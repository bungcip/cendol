/app/src/ast.rs:
    1|       |//! Abstract Syntax Tree (AST) for C11 compiler.
    2|       |//!
    3|       |//! This module provides the core AST data structures and APIs for representing
    4|       |//! C11 programs. The AST is designed as a flattened storage system for efficiency,
    5|       |//! with index-based references to child nodes and types.
    6|       |//!
    7|       |//! ## Architecture
    8|       |//!
    9|       |//! The AST is organized into focused submodules for better maintainability:
   10|       |//!
   11|       |//! - [`nodes`]: Node definitions, constructors, and builder patterns for AST nodes
   12|       |//! - [`types`]: Type system representation and utilities for semantic analysis
   13|       |//!
   14|       |//! ## Key Features
   15|       |//!
   16|       |//! - **Flattened Storage**: All AST nodes are stored in contiguous vectors with index-based references
   17|       |//! - **Interior Mutability**: Uses `Cell` for type annotations without requiring mutable AST access
   18|       |//! - **Builder Patterns**: Ergonomic constructors for complex AST nodes
   19|       |//! - **Type System**: Canonical types distinct from syntactic type specifiers
   20|       |//!
   21|       |
   22|       |use smallvec::SmallVec;
   23|       |use std::num::NonZeroU32;
   24|       |
   25|       |/// Represents an interned string using symbol_table crate.
   26|       |/// Alias for GlobalSymbol from symbol_table crate with global feature.
   27|       |pub type NameId = symbol_table::GlobalSymbol;
   28|       |
   29|       |use crate::semantic::{ImplicitConversion, QualType, ScopeId, SemanticInfo, SymbolRef, TypeRef, ValueCategory};
   30|       |pub use crate::source_manager::{SourceId, SourceLoc, SourceSpan};
   31|       |
   32|       |// Submodules
   33|       |// Submodules
   34|       |pub mod dumper;
   35|       |pub mod literal;
   36|       |pub mod nodes;
   37|       |pub mod parsed;
   38|       |pub mod parsed_types;
   39|       |
   40|       |// Re-export commonly used items for convenience
   41|       |pub use nodes::*;
   42|       |pub use parsed::*;
   43|       |pub use parsed_types::*;
   44|       |
   45|       |// Re-export operators that are used throughout the codebase
   46|       |pub use nodes::{BinaryOp, UnaryOp};
   47|       |
   48|       |/// The flattened AST storage.
   49|       |/// Contains all AST nodes, types, symbol entries in contiguous vectors.
   50|       |#[derive(Clone, Default)]
   51|       |pub struct Ast {
   52|       |    pub kinds: Vec<NodeKind>,
   53|       |    pub spans: Vec<SourceSpan>,
   54|       |    pub semantic_info: Option<SemanticInfo>, // Populated after type resolution
   55|       |}
   56|       |
   57|       |impl Ast {
   58|       |    /// Create a new empty AST
   59|    205|    pub fn new() -> Self {
   60|    205|        Ast::default()
   61|    205|    }
   62|       |
   63|       |    /// Add a node to the AST and return its reference
   64|  2.75k|    pub(crate) fn push_node(&mut self, kind: NodeKind, span: SourceSpan) -> NodeRef {
   65|  2.75k|        let index = self.kinds.len() as u32 + 1; // Start from 1 for NonZeroU32
   66|  2.75k|        self.kinds.push(kind);
   67|  2.75k|        self.spans.push(span);
   68|  2.75k|        NodeRef::new(index).expect("NodeRef overflow")
   69|  2.75k|    }
   70|       |
   71|       |    /// Add a dummy node to the AST and return its reference
   72|  1.84k|    pub(crate) fn push_dummy(&mut self, span: SourceSpan) -> NodeRef {
   73|  1.84k|        self.push_node(NodeKind::Dummy, span)
   74|  1.84k|    }
   75|       |
   76|       |    /// Get node kind by reference
   77|  8.17k|    pub fn get_kind(&self, node_ref: NodeRef) -> &NodeKind {
   78|  8.17k|        &self.kinds[node_ref.index()]
   79|  8.17k|    }
   80|       |
   81|       |    /// Get node span by reference
   82|    443|    pub fn get_span(&self, node_ref: NodeRef) -> SourceSpan {
   83|    443|        self.spans[node_ref.index()]
   84|    443|    }
   85|       |
   86|       |    /// get root node ref
   87|    235|    pub fn get_root(&self) -> NodeRef {
   88|    235|        NodeRef::ROOT
   89|    235|    }
   90|       |
   91|    321|    pub fn scope_of(&self, node_ref: NodeRef) -> ScopeId {
   92|    321|        match &self.kinds[node_ref.index()] {
   93|     92|            NodeKind::TranslationUnit(data) => data.scope_id,
   94|    110|            NodeKind::Function(data) => data.scope_id,
   95|      0|            NodeKind::FunctionDecl(data) => data.scope_id,
   96|    118|            NodeKind::CompoundStatement(data) => data.scope_id,
   97|      1|            NodeKind::For(data) => data.scope_id,
   98|      0|            _ => panic!("ICE: Node {:?} does not have a scope", self.get_kind(node_ref)),
   99|       |        }
  100|    321|    }
  101|       |
  102|       |    /// attach semantic info side table for AST (populated after type resolution)
  103|     92|    pub fn attach_semantic_info(&mut self, semantic_info: SemanticInfo) {
  104|     92|        self.semantic_info = Some(semantic_info);
  105|     92|    }
  106|       |}
  107|       |
  108|       |/// Node reference type for referencing child nodes.
  109|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
  110|       |pub struct NodeRef(NonZeroU32);
  111|       |
  112|       |impl NodeRef {
  113|       |    pub const ROOT: NodeRef = NodeRef(NonZeroU32::new(1).unwrap());
  114|       |
  115|  7.29k|    pub fn new(value: u32) -> Option<Self> {
  116|  7.29k|        NonZeroU32::new(value).map(Self)
  117|  7.29k|    }
  118|       |
  119|  20.4k|    pub fn get(self) -> u32 {
  120|  20.4k|        self.0.get()
  121|  20.4k|    }
  122|       |
  123|  14.3k|    pub fn index(self) -> usize {
  124|  14.3k|        (self.get() - 1) as usize
  125|  14.3k|    }
  126|       |
  127|       |    /// Create an iterator over a range of consecutive NodeRefs, starting from `self`.
  128|       |    #[inline]
  129|  1.81k|    pub fn range(self, len: impl Into<u32>) -> NodeRefRange {
  130|  1.81k|        NodeRefRange {
  131|  1.81k|            current: self.get(),
  132|  1.81k|            end: self.get() + len.into(),
  133|  1.81k|        }
  134|  1.81k|    }
  135|       |}
  136|       |
  137|       |/// An iterator over a contiguous range of `NodeRef`s.
  138|       |#[derive(Clone, Debug)]
  139|       |pub struct NodeRefRange {
  140|       |    current: u32,
  141|       |    end: u32,
  142|       |}
  143|       |
  144|       |impl Iterator for NodeRefRange {
  145|       |    type Item = NodeRef;
  146|       |
  147|       |    #[inline]
  148|  4.55k|    fn next(&mut self) -> Option<Self::Item> {
  149|  4.55k|        if self.current < self.end {
  150|  2.74k|            let node = NodeRef::new(self.current).expect("NodeRef overflow in range");
  151|  2.74k|            self.current += 1;
  152|  2.74k|            Some(node)
  153|       |        } else {
  154|  1.81k|            None
  155|       |        }
  156|  4.55k|    }
  157|       |
  158|       |    #[inline]
  159|     12|    fn size_hint(&self) -> (usize, Option<usize>) {
  160|     12|        let len = (self.end - self.current) as usize;
  161|     12|        (len, Some(len))
  162|     12|    }
  163|       |}
  164|       |
  165|       |impl ExactSizeIterator for NodeRefRange {}
  166|       |
  167|       |/// The primary AST node structure.
  168|       |/// Stored in the flattened Vec<Node>, with index-based references.
  169|       |/// Designed to be small and cache-friendly.
  170|       |#[derive(Debug, Clone)]
  171|       |pub struct Node {
  172|       |    pub kind: NodeKind,
  173|       |    pub span: SourceSpan,
  174|       |}
  175|       |
  176|       |impl Node {
  177|       |    /// Create a new node with the given kind and source span
  178|      0|    pub fn new(kind: NodeKind, span: SourceSpan) -> Self {
  179|      0|        Node { kind, span }
  180|      0|    }
  181|       |
  182|       |    // Note: Node no longer stores resolved type directly; resolved types & conversions
  183|       |    // are stored in semantic_info side table after type resolution completes.
  184|       |}
  185|       |
  186|       |impl Ast {
  187|       |    /// Get the resolved type for a node (reads from attached semantic_info)
  188|  1.34k|    pub fn get_resolved_type(&self, node_ref: NodeRef) -> Option<QualType> {
  189|  1.34k|        self.semantic_info.as_ref()?.types[node_ref.index()]
                                                 ^0
  190|  1.34k|    }
  191|       |
  192|       |    /// Get the value category for a node (reads from attached semantic_info)
  193|     66|    pub fn get_value_category(&self, node_ref: NodeRef) -> Option<ValueCategory> {
  194|     66|        self.semantic_info
  195|     66|            .as_ref()?
                                   ^0
  196|       |            .value_categories
  197|     66|            .get(node_ref.index())
  198|     66|            .copied()
  199|     66|    }
  200|       |
  201|       |    /// Get the conversions for a node (reads from attached semantic_info)
  202|      0|    pub fn get_conversions(&self, node_ref: NodeRef) -> Option<&SmallVec<[ImplicitConversion; 1]>> {
  203|      0|        self.semantic_info.as_ref()?.conversions.get(node_ref.index())
  204|      0|    }
  205|       |
  206|       |    /// Check if a node has only pointer decay conversion (optimization opportunity)
  207|      0|    pub fn has_only_pointer_decay(&self, node_ref: NodeRef) -> bool {
  208|      0|        if let Some(conversions) = self.get_conversions(node_ref) {
  209|      0|            conversions.len() == 1 && matches!(conversions[0], ImplicitConversion::PointerDecay { .. })
  210|       |        } else {
  211|      0|            false
  212|       |        }
  213|      0|    }
  214|       |}

/app/src/ast/dumper.rs:
    1|       |//! AST Dumper module
    2|       |//!
    3|       |//! This module handles AST dumping for debugging and visualization.
    4|       |
    5|       |use hashbrown::HashSet;
    6|       |
    7|       |use crate::ast::parsed::{ParsedAst, ParsedNodeKind};
    8|       |use crate::ast::{Ast, DesignatedInitializer, Designator, NodeKind};
    9|       |use crate::semantic::{ArraySizeType, BuiltinType, SymbolRef, SymbolTable, TypeKind, TypeRef, TypeRegistry};
   10|       |
   11|       |/// Dumper for AST
   12|       |pub struct AstDumper;
   13|       |
   14|       |impl AstDumper {
   15|       |    /// Dump parsed AST to stdout
   16|     12|    pub(crate) fn dump_parsed_ast(ast: &ParsedAst) {
   17|    159|        for (i, node) in ast.nodes.iter().enumerate() {
                                       ^12              ^12
   18|    159|            if matches!(node.kind, ParsedNodeKind::Dummy) {
                             ^155
   19|      4|                continue;
   20|    155|            }
   21|    155|            print!("{}: ", i + 1);
   22|    155|            Self::dump_parsed_node_kind(&node.kind, ast);
   23|       |        }
   24|     12|    }
   25|       |
   26|       |    /// Dump parser AST to stdout
   27|      3|    pub(crate) fn dump_parser(ast: &Ast, symbol_table: Option<&SymbolTable>) {
   28|     48|        for (i, kind) in ast.kinds.iter().enumerate() {
                                       ^3               ^3
   29|     48|            if matches!(kind, NodeKind::Dummy) {
   30|      0|                continue;
   31|     48|            }
   32|     48|            print!("{}: ", i + 1);
   33|     48|            Self::dump_parser_kind(kind, ast, symbol_table);
   34|       |        }
   35|      3|    }
   36|       |
   37|       |    /// Dump TypeRegistry information for used TypeRefs in the AST
   38|      2|    pub(crate) fn dump_type_registry(ast: &Ast, registry: &TypeRegistry) {
   39|       |        // Collect all TypeRefs used in the AST
   40|      2|        let mut used_type_refs = HashSet::new();
   41|       |
   42|     34|        for kind in &ast.kinds {
                          ^32
   43|     32|            Self::collect_type_refs_from_node(kind, &mut used_type_refs);
   44|     32|        }
   45|       |
   46|      2|        if used_type_refs.is_empty() {
   47|      0|            return;
   48|      2|        }
   49|       |
   50|       |        // Print header
   51|      2|        println!("\n=== TypeRegistry (Used TypeRefs) ===");
   52|       |
   53|       |        // Sort TypeRefs for consistent output
   54|      2|        let mut sorted_type_refs: Vec<_> = used_type_refs.into_iter().collect();
   55|     20|        sorted_type_refs.sort_by_key(|ty_ref| ty_ref.get());
                      ^2               ^2
   56|       |
   57|       |        // Dump each used TypeRef with user-friendly formatting
   58|     10|        for ty_ref in sorted_type_refs {
                          ^8
   59|      8|            let ty = registry.get(ty_ref);
   60|      8|            let formatted_type = Self::format_type_kind_user_friendly(&ty.kind, registry);
   61|      8|            println!("TypeRef({}): {}", ty_ref.base(), formatted_type);
   62|      8|        }
   63|      2|    }
   64|       |
   65|       |    /// Format TypeKind in a user-friendly way for TypeRegistry dump
   66|       |    #[allow(clippy::only_used_in_recursion)]
   67|     12|    fn format_type_kind_user_friendly(kind: &TypeKind, registry: &TypeRegistry) -> String {
   68|     12|        match kind {
   69|       |            // Basic types - use the existing dump format
   70|      7|            TypeKind::Builtin(b) => match b {
   71|      0|                BuiltinType::Void => "void".to_string(),
   72|      0|                BuiltinType::Bool => "_Bool".to_string(),
   73|      0|                BuiltinType::Char => "char".to_string(),
   74|      0|                BuiltinType::SChar => "signed char".to_string(),
   75|      0|                BuiltinType::UChar => "unsigned char".to_string(),
   76|      0|                BuiltinType::Short => "short".to_string(),
   77|      0|                BuiltinType::UShort => "unsigned short".to_string(),
   78|      5|                BuiltinType::Int => "int".to_string(),
   79|      0|                BuiltinType::UInt => "unsigned int".to_string(),
   80|      0|                BuiltinType::Long => "long".to_string(),
   81|      0|                BuiltinType::ULong => "unsigned long".to_string(),
   82|      0|                BuiltinType::LongLong => "long long".to_string(),
   83|      0|                BuiltinType::ULongLong => "unsigned long long".to_string(),
   84|      2|                BuiltinType::Float => "float".to_string(),
   85|      0|                BuiltinType::Double => "double".to_string(),
   86|      0|                BuiltinType::LongDouble => "long double".to_string(),
   87|      0|                BuiltinType::Signed => "signed".to_string(),
   88|       |            },
   89|      0|            TypeKind::Complex { .. } => "_Complex".to_string(),
   90|      0|            TypeKind::Error => "<error>".to_string(),
   91|       |
   92|       |            // Complex types - provide more detailed information
   93|      1|            TypeKind::Pointer { pointee } => {
   94|      1|                let current_type = registry.get(pointee.ty());
   95|      1|                format!(
   96|      1|                    "{}*",
   97|      1|                    Self::format_type_kind_user_friendly(&current_type.kind, registry)
   98|       |                )
   99|       |            }
  100|      1|            TypeKind::Array { element_type, size } => {
  101|      1|                let element_str = Self::format_type_kind_user_friendly(&registry.get(*element_type).kind, registry);
  102|      1|                match size {
  103|      1|                    ArraySizeType::Constant(len) => format!("{}[{}]", element_str, len),
  104|      0|                    ArraySizeType::Incomplete => format!("{}[]", element_str),
  105|      0|                    ArraySizeType::Variable(_) => "<VLA>".to_string(),
  106|      0|                    ArraySizeType::Star => format!("{}[*]", element_str),
  107|       |                }
  108|       |            }
  109|       |            TypeKind::Function {
  110|      2|                return_type,
  111|      2|                parameters,
  112|      2|                is_variadic,
  113|       |                ..
  114|       |            } => {
  115|      2|                let return_str = Self::format_type_kind_user_friendly(&registry.get(*return_type).kind, registry);
  116|      2|                let mut param_strs = Vec::new();
  117|      2|                for param in parameters {
                                  ^0
  118|      0|                    let param_str =
  119|      0|                        Self::format_type_kind_user_friendly(&registry.get(param.param_type.ty()).kind, registry);
  120|      0|                    param_strs.push(param_str);
  121|      0|                }
  122|      2|                let params = param_strs.join(", ");
  123|      2|                let variadic = if *is_variadic { ", ..." } else { "" };
                                                               ^0
  124|      2|                format!("{}({}{})", return_str, params, variadic)
  125|       |            }
  126|      1|            TypeKind::Record { tag, is_union, .. } => {
  127|      1|                let kind_str = if *is_union { "union" } else { "struct" };
                                                            ^0
  128|      1|                if let Some(tag_name) = tag {
  129|      1|                    format!("{} {}", kind_str, tag_name)
  130|       |                } else {
  131|      0|                    format!("{} (anonymous)", kind_str)
  132|       |                }
  133|       |            }
  134|      0|            TypeKind::Enum { tag, .. } => {
  135|      0|                if let Some(tag_name) = tag {
  136|      0|                    format!("enum {}", tag_name)
  137|       |                } else {
  138|      0|                    "enum (anonymous)".to_string()
  139|       |                }
  140|       |            }
  141|       |        }
  142|     12|    }
  143|       |
  144|       |    /// Collect TypeRefs from a NodeKind
  145|     32|    fn collect_type_refs_from_node(kind: &NodeKind, type_refs: &mut HashSet<TypeRef>) {
  146|     32|        match kind {
  147|      0|            NodeKind::Designator(_) => {}
  148|      2|            NodeKind::Function(data) => {
  149|      2|                type_refs.insert(data.ty);
  150|      2|            }
  151|      0|            NodeKind::Param(data) => {
  152|      0|                type_refs.insert(data.ty.ty());
  153|      0|            }
  154|      0|            NodeKind::FunctionDecl(func_decl) => {
  155|      0|                type_refs.insert(func_decl.ty);
  156|      0|            }
  157|      1|            NodeKind::RecordDecl(record_decl) => {
  158|      1|                type_refs.insert(record_decl.ty);
  159|      1|            }
  160|      2|            NodeKind::FieldDecl(field_decl) => {
  161|      2|                type_refs.insert(field_decl.ty.ty());
  162|      2|            }
  163|      0|            NodeKind::EnumDecl(enum_decl) => {
  164|      0|                type_refs.insert(enum_decl.ty);
  165|      0|            }
  166|      0|            NodeKind::EnumMember(_) => {}
  167|       |
  168|       |            // QualType usage (contains TypeRef)
  169|      1|            NodeKind::Cast(qual_type, _) => {
  170|      1|                type_refs.insert(qual_type.ty());
  171|      1|            }
  172|      0|            NodeKind::SizeOfType(qual_type) => {
  173|      0|                type_refs.insert(qual_type.ty());
  174|      0|            }
  175|      0|            NodeKind::AlignOf(qual_type) => {
  176|      0|                type_refs.insert(qual_type.ty());
  177|      0|            }
  178|      0|            NodeKind::CompoundLiteral(qual_type, _) => {
  179|      0|                type_refs.insert(qual_type.ty());
  180|      0|            }
  181|      0|            NodeKind::BuiltinVaArg(qual_type, _) => {
  182|      0|                type_refs.insert(qual_type.ty());
  183|      0|            }
  184|      0|            NodeKind::BuiltinVaStart(_, _) | NodeKind::BuiltinVaEnd(_) | NodeKind::BuiltinVaCopy(_, _) => {}
  185|      5|            NodeKind::VarDecl(var_decl) => {
  186|      5|                type_refs.insert(var_decl.ty.ty());
  187|      5|            }
  188|      0|            NodeKind::TypedefDecl(typedef_decl) => {
  189|      0|                type_refs.insert(typedef_decl.ty.ty());
  190|      0|            }
  191|      0|            NodeKind::GenericSelection(_) => {
  192|      0|                // GenericSelectionData doesn't contain TypeRefs directly.
  193|      0|            }
  194|      0|            NodeKind::GenericAssociation(ga) => {
  195|      0|                if let Some(qual_type) = ga.ty {
  196|      0|                    type_refs.insert(qual_type.ty());
  197|      0|                }
  198|       |            }
  199|       |
  200|       |            // Literal nodes - don't contain TypeRefs
  201|      9|            NodeKind::Literal(_) | NodeKind::Ident(_, _) => {
  202|      9|                // These don't contain TypeRefs
  203|      9|            }
  204|       |
  205|       |            // Statement types that don't directly contain TypeRefs
  206|       |            NodeKind::TranslationUnit(_)
  207|       |            | NodeKind::CompoundStatement(_)
  208|       |            | NodeKind::If(_)
  209|       |            | NodeKind::While(_)
  210|       |            | NodeKind::DoWhile(_, _)
  211|       |            | NodeKind::For(_)
  212|       |            | NodeKind::Return(_)
  213|       |            | NodeKind::Break
  214|       |            | NodeKind::Continue
  215|       |            | NodeKind::Goto(_, _)
  216|       |            | NodeKind::Label(_, _, _)
  217|       |            | NodeKind::Switch(_, _)
  218|       |            | NodeKind::Case(_, _)
  219|       |            | NodeKind::CaseRange(_, _, _)
  220|       |            | NodeKind::Default(_)
  221|       |            | NodeKind::ExpressionStatement(_)
  222|       |            | NodeKind::InitializerList(_)
  223|       |            | NodeKind::InitializerItem(_)
  224|       |            | NodeKind::StaticAssert(_, _)
  225|       |            | NodeKind::EnumConstant(_, _)
  226|      9|            | NodeKind::Dummy => {
  227|      9|                // These don't directly contain TypeRefs
  228|      9|            }
  229|       |
  230|       |            // GNU extensions
  231|      0|            NodeKind::GnuStatementExpression(_, _) => {
  232|      0|                // Doesn't directly contain TypeRef
  233|      0|            }
  234|       |
  235|       |            // Expression nodes with NodeRef children - types handled during traversal
  236|       |            NodeKind::FunctionCall(_)
  237|       |            | NodeKind::BinaryOp(_, _, _)
  238|       |            | NodeKind::UnaryOp(_, _)
  239|       |            | NodeKind::TernaryOp(_, _, _)
  240|       |            | NodeKind::PostIncrement(_)
  241|       |            | NodeKind::PostDecrement(_)
  242|       |            | NodeKind::Assignment(_, _, _)
  243|       |            | NodeKind::MemberAccess(_, _, _)
  244|       |            | NodeKind::IndexAccess(_, _)
  245|      3|            | NodeKind::SizeOfExpr(_) => {
  246|      3|                // These don't directly contain TypeRefs, they will be handled when we process child nodes
  247|      3|            }
  248|       |        }
  249|     32|    }
  250|       |
  251|       |    /// Get function name from symbol entry reference
  252|      4|    fn get_function_name(symbol_ref: SymbolRef, symbol_table: Option<&SymbolTable>) -> String {
  253|      4|        if let Some(table) = symbol_table {
  254|      4|            let entry = table.get_symbol(symbol_ref);
  255|      4|            return entry.name.to_string();
  256|      0|        }
  257|      0|        format!("func_{}", symbol_ref.get())
  258|      4|    }
  259|       |
  260|       |    /// Format a DesignatedInitializer for display
  261|      4|    fn format_designated_initializer(init: &DesignatedInitializer, ast: &Ast) -> String {
  262|      4|        let mut result = String::new();
  263|      4|        for designator_ref in init.designator_start.range(init.designator_len) {
  264|      4|            match ast.get_kind(designator_ref) {
  265|      4|                NodeKind::Designator(d) => match d {
  266|      2|                    Designator::FieldName(name) => {
  267|      2|                        result.push_str(&format!(".{}", name));
  268|      2|                    }
  269|      2|                    Designator::ArrayIndex(index) => {
  270|      2|                        result.push_str(&format!("[{}]", index.get()));
  271|      2|                    }
  272|      0|                    Designator::GnuArrayRange(start, end) => {
  273|      0|                        result.push_str(&format!("[{} ... {}]", start.get(), end.get()));
  274|      0|                    }
  275|       |                },
  276|      0|                _ => result.push_str("<invalid designator>"),
  277|       |            }
  278|       |        }
  279|       |
  280|      4|        if init.designator_len > 0 {
  281|      4|            result.push_str(" = ");
  282|      4|        }
                      ^0
  283|       |
  284|      4|        result.push_str(&init.initializer.get().to_string());
  285|      4|        result
  286|      4|    }
  287|       |
  288|       |    /// Dump a single parsed AST node kind
  289|    155|    fn dump_parsed_node_kind(kind: &ParsedNodeKind, _ast: &ParsedAst) {
  290|    155|        match kind {
  291|     41|            ParsedNodeKind::Literal(literal) => match literal {
  292|     28|                crate::ast::literal::Literal::Int { val, suffix } => {
  293|     28|                    println!("LiteralInt({:?}, {:?})", val, suffix)
  294|       |                }
  295|      2|                crate::ast::literal::Literal::Float(f) => println!("LiteralFloat({})", f),
  296|      8|                crate::ast::literal::Literal::String(s) => println!("LiteralString(\"{}\")", s),
  297|      3|                crate::ast::literal::Literal::Char(c) => println!("LiteralChar('{}')", *c as char),
  298|       |            },
  299|     21|            ParsedNodeKind::Ident(name) => println!("Ident({})", name),
  300|       |
  301|       |            // Expressions
  302|      2|            ParsedNodeKind::UnaryOp(op, node) => println!("UnaryOp({:?}, {})", op, node.get()),
  303|      6|            ParsedNodeKind::BinaryOp(op, l, r) => {
  304|      6|                println!("BinaryOp({:?}, {}, {})", op, l.get(), r.get())
  305|       |            }
  306|      0|            ParsedNodeKind::TernaryOp(c, t, e) => {
  307|      0|                println!("TernaryOp({}, {}, {})", c.get(), t.get(), e.get())
  308|       |            }
  309|      0|            ParsedNodeKind::GnuStatementExpression(stmt, expr) => {
  310|      0|                println!("GnuStatementExpression({}, {})", stmt.get(), expr.get())
  311|       |            }
  312|      2|            ParsedNodeKind::PostIncrement(node) => println!("PostIncrement({})", node.get()),
  313|      1|            ParsedNodeKind::PostDecrement(node) => println!("PostDecrement({})", node.get()),
  314|      0|            ParsedNodeKind::Assignment(op, l, r) => {
  315|      0|                println!("Assignment({:?}, {}, {})", op, l.get(), r.get())
  316|       |            }
  317|      7|            ParsedNodeKind::FunctionCall(callee, args) => {
  318|      8|                let args_str = args.iter().map(|a| a.get().to_string()).collect::<Vec<_>>().join(", ");
                                  ^7         ^7          ^7                           ^7                  ^7   ^7
  319|      7|                println!("FunctionCall(callee={}, args=[{}])", callee.get(), args_str)
  320|       |            }
  321|      0|            ParsedNodeKind::MemberAccess(obj, field, arrow) => println!(
  322|      0|                "MemberAccess({}, {}, {})",
  323|      0|                obj.get(),
  324|       |                field,
  325|      0|                if *arrow { "->" } else { "." }
  326|       |            ),
  327|      0|            ParsedNodeKind::IndexAccess(arr, idx) => {
  328|      0|                println!("IndexAccess({}, {})", arr.get(), idx.get())
  329|       |            }
  330|      0|            ParsedNodeKind::Cast(ty, expr) => println!("Cast({:?}, {})", ty, expr.get()),
  331|      0|            ParsedNodeKind::SizeOfExpr(expr) => println!("SizeOfExpr({})", expr.get()),
  332|      0|            ParsedNodeKind::SizeOfType(ty) => println!("SizeOfType({:?})", ty),
  333|      0|            ParsedNodeKind::AlignOf(ty) => println!("AlignOf({:?})", ty),
  334|      0|            ParsedNodeKind::CompoundLiteral(ty, init) => {
  335|      0|                println!("CompoundLiteral({:?}, {})", ty, init.get())
  336|       |            }
  337|      0|            ParsedNodeKind::BuiltinVaArg(ty, expr) => {
  338|      0|                println!("BuiltinVaArg({:?}, {})", ty, expr.get())
  339|       |            }
  340|      0|            ParsedNodeKind::BuiltinVaStart(ap, last) => {
  341|      0|                println!("BuiltinVaStart({}, {})", ap.get(), last.get())
  342|       |            }
  343|      0|            ParsedNodeKind::BuiltinVaEnd(ap) => {
  344|      0|                println!("BuiltinVaEnd({})", ap.get())
  345|       |            }
  346|      0|            ParsedNodeKind::BuiltinVaCopy(dst, src) => {
  347|      0|                println!("BuiltinVaCopy({}, {})", dst.get(), src.get())
  348|       |            }
  349|      0|            ParsedNodeKind::GenericSelection(ctrl, assocs) => {
  350|      0|                println!("GenericSelection({}, {:?})", ctrl.get(), assocs)
  351|       |            }
  352|       |
  353|       |            // Statements
  354|     11|            ParsedNodeKind::CompoundStatement(stmts) => {
  355|     23|                let stmts_str = stmts.iter().map(|s| s.get().to_string()).collect::<Vec<_>>().join(", ");
                                  ^11         ^11          ^11                          ^11                 ^11  ^11
  356|     11|                println!("CompoundStatement(stmts=[{}])", stmts_str)
  357|       |            }
  358|      2|            ParsedNodeKind::If(data) => println!("If({:?})", data),
  359|      1|            ParsedNodeKind::While(data) => println!("While({:?})", data),
  360|      1|            ParsedNodeKind::DoWhile(body, cond) => {
  361|      1|                println!("DoWhile(body={}, cond={})", body.get(), cond.get())
  362|       |            }
  363|      1|            ParsedNodeKind::For(data) => println!("For({:?})", data),
  364|      4|            ParsedNodeKind::Return(expr) => println!(
  365|      4|                "Return({})",
  366|      4|                expr.map(|e| e.get().to_string()).unwrap_or("void".to_string())
  367|       |            ),
  368|      2|            ParsedNodeKind::Break => println!("Break"),
  369|      0|            ParsedNodeKind::Continue => println!("Continue"),
  370|      0|            ParsedNodeKind::Goto(label) => println!("Goto({})", label),
  371|      0|            ParsedNodeKind::Label(label, stmt) => println!("Label({}, {})", label, stmt.get()),
  372|      1|            ParsedNodeKind::Switch(cond, body) => {
  373|      1|                println!("Switch({}, {})", cond.get(), body.get())
  374|       |            }
  375|      2|            ParsedNodeKind::Case(val, stmt) => println!("Case({}, {})", val.get(), stmt.get()),
  376|      0|            ParsedNodeKind::CaseRange(start, end, stmt) => {
  377|      0|                println!("CaseRange({}, {}, {})", start.get(), end.get(), stmt.get())
  378|       |            }
  379|      1|            ParsedNodeKind::Default(stmt) => println!("Default({})", stmt.get()),
  380|      9|            ParsedNodeKind::ExpressionStatement(expr) => println!(
  381|      9|                "ExpressionStatement({})",
  382|      9|                expr.map(|e| e.get().to_string()).unwrap_or("empty".to_string())
  383|       |            ),
  384|      0|            ParsedNodeKind::EmptyStatement => println!("EmptyStatement"),
  385|       |
  386|       |            // Declarations & Definitions
  387|     19|            ParsedNodeKind::Declaration(data) => println!("Declaration({:?})", data),
  388|      4|            ParsedNodeKind::FunctionDef(data) => println!("FunctionDef({:?})", data),
  389|      3|            ParsedNodeKind::EnumConstant(name, val) => println!(
  390|      3|                "EnumConstant({}, {})",
  391|       |                name,
  392|      3|                val.map(|v| v.get().to_string()).unwrap_or("auto".to_string())
                                          ^1      ^1
  393|       |            ),
  394|      0|            ParsedNodeKind::StaticAssert(cond, msg) => {
  395|      0|                println!("StaticAssert({}, \"{}\")", cond.get(), msg)
  396|       |            }
  397|       |
  398|       |            // Top Level
  399|     12|            ParsedNodeKind::TranslationUnit(decls) => {
  400|     19|                let decls_str = decls.iter().map(|d| d.get().to_string()).collect::<Vec<_>>().join(", ");
                                  ^12         ^12          ^12                          ^12                 ^12  ^12
  401|     12|                println!("TranslationUnit(decls=[{}])", decls_str)
  402|       |            }
  403|       |
  404|       |            // InitializerList
  405|      2|            ParsedNodeKind::InitializerList(inits) => println!("InitializerList({:?})", inits),
  406|       |
  407|      0|            ParsedNodeKind::Dummy => println!("Dummy"),
  408|       |        }
  409|    155|    }
  410|       |
  411|       |    /// Dump a single AST node kind
  412|     48|    fn dump_parser_kind(kind: &NodeKind, ast: &Ast, symbol_table: Option<&SymbolTable>) {
  413|     48|        match kind {
  414|      3|            NodeKind::TranslationUnit(tu_data) => {
  415|      3|                let start = tu_data.decl_start.get();
  416|      3|                if tu_data.decl_len > 0 {
  417|      3|                    let last = start + tu_data.decl_len as u32 - 1;
  418|      3|                    println!("TranslationUnit(decls={}..{}) (parser kind)", start, last);
  419|      3|                } else {
  420|      0|                    println!("TranslationUnit(decls=[]) (parser kind)");
  421|      0|                }
  422|       |            }
  423|     11|            NodeKind::Literal(literal) => match literal {
  424|     11|                crate::ast::literal::Literal::Int { val, suffix } => {
  425|     11|                    println!("LiteralInt({:?}, {:?})", val, suffix)
  426|       |                }
  427|      0|                crate::ast::literal::Literal::Float(f) => println!("LiteralFloat({})", f),
  428|      0|                crate::ast::literal::Literal::String(s) => println!("LiteralString({})", s),
  429|      0|                crate::ast::literal::Literal::Char(c) => println!("LiteralChar('{}')", *c as char),
  430|       |            },
  431|      3|            NodeKind::Ident(sym, _) => println!("Ident({})", sym),
  432|      0|            NodeKind::UnaryOp(op, operand) => println!("UnaryOp({:?}, {})", op, operand.get()),
  433|      1|            NodeKind::BinaryOp(op, left, right) => {
  434|      1|                println!("BinaryOp({:?}, {}, {})", op, left.get(), right.get())
  435|       |            }
  436|      0|            NodeKind::TernaryOp(cond, then, else_) => {
  437|      0|                println!("TernaryOp({}, {}, {})", cond.get(), then.get(), else_.get())
  438|       |            }
  439|      0|            NodeKind::PostIncrement(expr) => println!("PostIncrement({})", expr.get()),
  440|      0|            NodeKind::PostDecrement(expr) => println!("PostDecrement({})", expr.get()),
  441|      0|            NodeKind::Assignment(op, lhs, rhs) => {
  442|      0|                println!("Assignment({:?}, {}, {})", op, lhs.get(), rhs.get())
  443|       |            }
  444|      1|            NodeKind::FunctionCall(call_expr) => {
  445|      1|                let start = call_expr.arg_start.get();
  446|      1|                if call_expr.arg_len > 0 {
  447|      1|                    let last = start + call_expr.arg_len as u32 - 1;
  448|      1|                    println!(
  449|      1|                        "FunctionCall(callee={}, args={}..{})",
  450|      1|                        call_expr.callee.get(),
  451|      1|                        start,
  452|      1|                        last
  453|      1|                    );
  454|      1|                } else {
  455|      0|                    println!("FunctionCall(callee={}, args=[])", call_expr.callee.get());
  456|      0|                }
  457|       |            }
  458|       |
  459|      0|            NodeKind::MemberAccess(obj, field, is_arrow) => println!(
  460|      0|                "MemberAccess({}, {}, {})",
  461|      0|                obj.get(),
  462|       |                field,
  463|      0|                if *is_arrow { "->" } else { "." }
  464|       |            ),
  465|      0|            NodeKind::IndexAccess(array, index) => {
  466|      0|                println!("IndexAccess({}, {})", array.get(), index.get())
  467|       |            }
  468|      0|            NodeKind::Cast(ty, expr) => println!("Cast({}, {})", ty, expr.get()),
  469|      0|            NodeKind::SizeOfExpr(expr) => println!("SizeOfExpr({})", expr.get()),
  470|      0|            NodeKind::SizeOfType(ty) => println!("SizeOfType({})", ty),
  471|      0|            NodeKind::AlignOf(ty) => println!("AlignOf({})", ty),
  472|      0|            NodeKind::CompoundLiteral(ty, init) => {
  473|      0|                println!("CompoundLiteral({}, {})", ty, init.get())
  474|       |            }
  475|      0|            NodeKind::BuiltinVaArg(ty, expr) => {
  476|      0|                println!("BuiltinVaArg({}, {})", ty, expr.get())
  477|       |            }
  478|      0|            NodeKind::BuiltinVaStart(ap, last) => {
  479|      0|                println!("BuiltinVaStart({}, {})", ap.get(), last.get())
  480|       |            }
  481|      0|            NodeKind::BuiltinVaEnd(ap) => {
  482|      0|                println!("BuiltinVaEnd({})", ap.get())
  483|       |            }
  484|      0|            NodeKind::BuiltinVaCopy(dst, src) => {
  485|      0|                println!("BuiltinVaCopy({}, {})", dst.get(), src.get())
  486|       |            }
  487|       |
  488|      0|            NodeKind::GenericSelection(gs) => {
  489|      0|                let start = gs.assoc_start.get();
  490|      0|                if gs.assoc_len > 0 {
  491|      0|                    let last = start + gs.assoc_len as u32 - 1;
  492|      0|                    println!(
  493|      0|                        "GenericSelection(control={}, associations={}..{})",
  494|      0|                        gs.control.get(),
  495|      0|                        start,
  496|      0|                        last
  497|      0|                    );
  498|      0|                } else {
  499|      0|                    println!("GenericSelection(control={}, associations=[])", gs.control.get());
  500|      0|                }
  501|       |            }
  502|      0|            NodeKind::GenericAssociation(ga) => {
  503|      0|                println!(
  504|      0|                    "GenericAssociation(ty={:?}, result_expr={})",
  505|       |                    ga.ty,
  506|      0|                    ga.result_expr.get()
  507|       |                )
  508|       |            }
  509|      0|            NodeKind::GnuStatementExpression(compound_stmt, result_expr) => {
  510|      0|                println!("GnuStatementExpression({}, {})", compound_stmt.get(), result_expr.get())
  511|       |            }
  512|      4|            NodeKind::CompoundStatement(cs) => {
  513|      4|                let start = cs.stmt_start.get();
  514|      4|                if cs.stmt_len > 0 {
  515|      4|                    let last = start + cs.stmt_len as u32 - 1;
  516|      4|                    println!("CompoundStatement(stmts={}..{})", start, last);
  517|      4|                } else {
  518|      0|                    println!("CompoundStatement(stmts=[])");
  519|      0|                }
  520|       |            }
  521|      0|            NodeKind::If(if_stmt) => println!(
  522|      0|                "If(condition={}, then={}, else={})",
  523|      0|                if_stmt.condition.get(),
  524|      0|                if_stmt.then_branch.get(),
  525|      0|                if_stmt
  526|      0|                    .else_branch
  527|      0|                    .map(|r| r.get().to_string())
  528|      0|                    .unwrap_or("none".to_string())
  529|       |            ),
  530|      0|            NodeKind::While(while_stmt) => println!(
  531|      0|                "While(condition={}, body={})",
  532|      0|                while_stmt.condition.get(),
  533|      0|                while_stmt.body.get()
  534|       |            ),
  535|      0|            NodeKind::DoWhile(body, cond) => {
  536|      0|                println!("DoWhile(body={}, condition={})", body.get(), cond.get())
  537|       |            }
  538|      0|            NodeKind::For(for_stmt) => println!(
  539|      0|                "For(init={}, condition={}, increment={}, body={})",
  540|      0|                for_stmt.init.map(|r| r.get().to_string()).unwrap_or("none".to_string()),
  541|      0|                for_stmt
  542|      0|                    .condition
  543|      0|                    .map(|r| r.get().to_string())
  544|      0|                    .unwrap_or("none".to_string()),
  545|      0|                for_stmt
  546|      0|                    .increment
  547|      0|                    .map(|r| r.get().to_string())
  548|      0|                    .unwrap_or("none".to_string()),
  549|      0|                for_stmt.body.get()
  550|       |            ),
  551|      4|            NodeKind::Return(expr) => println!(
  552|      4|                "Return({})",
  553|      4|                expr.map(|r| r.get().to_string()).unwrap_or("void".to_string())
  554|       |            ),
  555|      0|            NodeKind::Break => println!("Break"),
  556|      0|            NodeKind::Continue => println!("Continue"),
  557|      0|            NodeKind::Goto(label, _) => println!("Goto({})", label),
  558|      0|            NodeKind::Label(label, stmt, _) => println!("Label({}, {})", label, stmt.get()),
  559|      0|            NodeKind::Switch(cond, body) => {
  560|      0|                println!("Switch(condition={}, body={})", cond.get(), body.get())
  561|       |            }
  562|      0|            NodeKind::Case(expr, stmt) => println!("Case({}, {})", expr.get(), stmt.get()),
  563|      0|            NodeKind::CaseRange(start, end, stmt) => {
  564|      0|                println!("CaseRange({}, {}, {})", start.get(), end.get(), stmt.get())
  565|       |            }
  566|      0|            NodeKind::Default(stmt) => println!("Default({})", stmt.get()),
  567|      0|            NodeKind::ExpressionStatement(expr) => println!(
  568|      0|                "ExpressionStatement({})",
  569|      0|                expr.map(|r| r.get().to_string()).unwrap_or("none".to_string())
  570|       |            ),
  571|       |
  572|       |            // Declaration and FunctionDef removed
  573|      4|            NodeKind::Function(data) => {
  574|      4|                let func_name = Self::get_function_name(data.symbol, symbol_table);
  575|      4|                let start = data.param_start.get();
  576|      4|                if data.param_len > 0 {
  577|      1|                    let last = start + data.param_len as u32 - 1;
  578|      1|                    println!(
  579|      1|                        "Function(name={}, symbol={:?}, ty={}, params={}..{}, body={})",
  580|      1|                        func_name,
  581|      1|                        data.symbol,
  582|      1|                        data.ty,
  583|      1|                        start,
  584|      1|                        last,
  585|      1|                        data.body.get()
  586|      1|                    );
  587|      3|                } else {
  588|      3|                    println!(
  589|      3|                        "Function(name={}, symbol={:?}, ty={}, params=[], body={})",
  590|      3|                        func_name,
  591|      3|                        data.symbol,
  592|      3|                        data.ty,
  593|      3|                        data.body.get()
  594|      3|                    );
  595|      3|                }
  596|       |            }
  597|      2|            NodeKind::Param(data) => {
  598|      2|                println!("Param(symbol={:?}, ty={:?})", data.symbol, data.ty)
  599|       |            }
  600|      0|            NodeKind::EnumConstant(name, value) => println!(
  601|      0|                "EnumConstant({}, {})",
  602|       |                name,
  603|      0|                value.map(|r| r.get().to_string()).unwrap_or("auto".to_string())
  604|       |            ),
  605|      0|            NodeKind::StaticAssert(cond, msg) => {
  606|      0|                println!("StaticAssert(condition={}, message={})", cond.get(), msg)
  607|       |            }
  608|      2|            NodeKind::VarDecl(var_decl) => {
  609|      2|                println!(
  610|      2|                    "VarDecl(name={}, ty={}, storage={:?})",
  611|       |                    var_decl.name, var_decl.ty, var_decl.storage
  612|       |                )
  613|       |            }
  614|      0|            NodeKind::FunctionDecl(func_decl) => {
  615|      0|                println!(
  616|      0|                    "FunctionDecl(name={}, ty={}, storage={:?})",
  617|       |                    func_decl.name,
  618|      0|                    func_decl.ty.get(),
  619|       |                    func_decl.storage
  620|       |                )
  621|       |            }
  622|      0|            NodeKind::TypedefDecl(typedef_decl) => {
  623|      0|                println!("TypedefDecl(name={}, ty={})", typedef_decl.name, typedef_decl.ty)
  624|       |            }
  625|      1|            NodeKind::RecordDecl(record_decl) => {
  626|      1|                let start = record_decl.member_start.get();
  627|      1|                if record_decl.member_len > 0 {
  628|      1|                    let last = start + record_decl.member_len as u32 - 1;
  629|      1|                    println!(
  630|      1|                        "RecordDecl(name={:?}, ty={}, is_union={}, members={}..{})",
  631|      1|                        record_decl.name,
  632|      1|                        record_decl.ty.get(),
  633|      1|                        record_decl.is_union,
  634|      1|                        start,
  635|      1|                        last
  636|      1|                    );
  637|      1|                } else {
  638|      0|                    println!(
  639|      0|                        "RecordDecl(name={:?}, ty={}, is_union={}, members=[])",
  640|      0|                        record_decl.name,
  641|      0|                        record_decl.ty.get(),
  642|      0|                        record_decl.is_union
  643|      0|                    );
  644|      0|                }
  645|       |            }
  646|      2|            NodeKind::FieldDecl(field_decl) => {
  647|      2|                println!("FieldDecl(name={:?}, ty={})", field_decl.name, field_decl.ty)
  648|       |            }
  649|      0|            NodeKind::EnumDecl(enum_decl) => {
  650|      0|                let start = enum_decl.member_start.get();
  651|      0|                if enum_decl.member_len > 0 {
  652|      0|                    let last = start + enum_decl.member_len as u32 - 1;
  653|      0|                    println!(
  654|      0|                        "EnumDecl(name={:?}, ty={}, members={}..{})",
  655|      0|                        enum_decl.name,
  656|      0|                        enum_decl.ty.get(),
  657|      0|                        start,
  658|      0|                        last
  659|      0|                    );
  660|      0|                } else {
  661|      0|                    println!(
  662|      0|                        "EnumDecl(name={:?}, ty={}, members=[])",
  663|      0|                        enum_decl.name,
  664|      0|                        enum_decl.ty.get()
  665|      0|                    );
  666|      0|                }
  667|       |            }
  668|      0|            NodeKind::EnumMember(enum_member) => {
  669|      0|                println!("EnumMember(name={}, value={})", enum_member.name, enum_member.value)
  670|       |            }
  671|      2|            NodeKind::InitializerList(list) => {
  672|      2|                let start = list.init_start.get();
  673|      2|                if list.init_len > 0 {
  674|      2|                    let last = start + list.init_len as u32 - 1;
  675|      2|                    println!("InitializerList(inits={}..{})", start, last);
  676|      2|                } else {
  677|      0|                    println!("InitializerList(inits=[])");
  678|      0|                }
  679|       |            }
  680|      4|            NodeKind::InitializerItem(init) => {
  681|      4|                println!("InitializerItem({})", Self::format_designated_initializer(init, ast))
  682|       |            }
  683|      4|            NodeKind::Designator(d) => match d {
  684|      2|                Designator::FieldName(name) => println!("Designator(.{})", name),
  685|      2|                Designator::ArrayIndex(idx) => println!("Designator([{}])", idx.get()),
  686|      0|                Designator::GnuArrayRange(start, end) => println!("Designator([{} ... {}])", start.get(), end.get()),
  687|       |            },
  688|      0|            NodeKind::Dummy => println!("DUMMY"),
  689|       |        }
  690|     48|    }
  691|       |}

/app/src/ast/nodes.rs:
    1|       |//! AST Node definitions, constructors, and builder patterns.
    2|       |//!
    3|       |//! This module contains the core AST node types, including the NodeKind enum
    4|       |//! and associated data structures. It provides constructors and builder patterns
    5|       |//! for creating complex AST nodes ergonomically.
    6|       |
    7|       |use serde::Serialize;
    8|       |
    9|       |use crate::semantic::TypeQualifiers;
   10|       |use crate::{
   11|       |    ast::{NameId, NodeRef, SymbolRef, TypeRef},
   12|       |    semantic::{QualType, ScopeId},
   13|       |};
   14|       |
   15|       |/// The core enum defining all possible AST node types for C11.
   16|       |/// Variants use NodeIndex for child references, enabling flattened storage.
   17|       |/// Maintained original structure for compatibility, but moved to this module.
   18|       |use crate::ast::literal::Literal;
   19|       |
   20|       |#[derive(Debug, Clone, Serialize)]
   21|       |pub enum NodeKind {
   22|       |    // --- Literals (Inline storage for common types) ---
   23|       |    Literal(Literal),
   24|       |
   25|       |    // --- Expressions ---
   26|       |    // Ident now includes a resolved SymbolRef after semantic analysis
   27|       |    Ident(NameId, SymbolRef),
   28|       |    UnaryOp(UnaryOp, NodeRef),
   29|       |    BinaryOp(BinaryOp, NodeRef, NodeRef),
   30|       |    TernaryOp(NodeRef, NodeRef, NodeRef),
   31|       |    GnuStatementExpression(
   32|       |        NodeRef, /* compound statement */
   33|       |        NodeRef, /* result expression */
   34|       |    ),
   35|       |
   36|       |    PostIncrement(NodeRef),
   37|       |    PostDecrement(NodeRef),
   38|       |
   39|       |    Assignment(BinaryOp, NodeRef /* lhs */, NodeRef /* rhs */),
   40|       |    FunctionCall(CallExpr),
   41|       |
   42|       |    MemberAccess(
   43|       |        NodeRef, /* object */
   44|       |        NameId,  /* field */
   45|       |        bool,    /* is_arrow */
   46|       |    ),
   47|       |    IndexAccess(NodeRef /* array */, NodeRef /* index */),
   48|       |
   49|       |    Cast(QualType, NodeRef),
   50|       |    BuiltinVaArg(QualType, NodeRef),
   51|       |    BuiltinVaStart(NodeRef, NodeRef),
   52|       |    BuiltinVaEnd(NodeRef),
   53|       |    BuiltinVaCopy(NodeRef, NodeRef),
   54|       |    SizeOfExpr(NodeRef),
   55|       |    SizeOfType(QualType),
   56|       |    AlignOf(QualType), // C11 _Alignof
   57|       |
   58|       |    CompoundLiteral(QualType, NodeRef),
   59|       |    GenericSelection(GenericSelectionData),
   60|       |    GenericAssociation(GenericAssociationData),
   61|       |
   62|       |    // --- Statements (Complex statements are separate structs) ---
   63|       |    CompoundStatement(CompoundStmtData),
   64|       |    If(IfStmt),
   65|       |    While(WhileStmt),
   66|       |    DoWhile(NodeRef /* body */, NodeRef /* condition */),
   67|       |    For(ForStmt),
   68|       |
   69|       |    Return(Option<NodeRef>),
   70|       |    Break,
   71|       |    Continue,
   72|       |    Goto(NameId, SymbolRef),                           // resolved symbol after semantic analysis
   73|       |    Label(NameId, NodeRef /* statement */, SymbolRef), // resolved symbol after semantic analysis
   74|       |
   75|       |    Switch(NodeRef /* condition */, NodeRef /* body statement */),
   76|       |    Case(NodeRef /* const_expr */, NodeRef /* statement */),
   77|       |    CaseRange(
   78|       |        NodeRef, /* start_expr */
   79|       |        NodeRef, /* end_expr */
   80|       |        NodeRef, /* statement */
   81|       |    ), // GNU Extension often supported
   82|       |    Default(NodeRef /* statement */),
   83|       |
   84|       |    ExpressionStatement(Option<NodeRef> /* expression */), // Expression followed by ';'
   85|       |
   86|       |    // --- Declarations & Definitions ---
   87|       |    // Removed Parser-only Declaration and FunctionDef variants.
   88|       |    // They are now lowered to semantic nodes immediately or exist only in ParsedAst.
   89|       |    EnumConstant(NameId, Option<NodeRef> /* value expr */),
   90|       |    StaticAssert(NodeRef /* condition */, NameId /* message */),
   91|       |
   92|       |    // --- Semantic Nodes (Type-Resolved) ---
   93|       |    // declarations of VarDecl/FunctionDecl/TypedefDecl/RecordDecl
   94|       |    VarDecl(VarDeclData),
   95|       |    FunctionDecl(FunctionDeclData),
   96|       |    TypedefDecl(TypedefDeclData),
   97|       |    RecordDecl(RecordDeclData),
   98|       |    FieldDecl(FieldDeclData),
   99|       |    EnumDecl(EnumDeclData),
  100|       |    EnumMember(EnumMemberData),
  101|       |    Function(FunctionData),
  102|       |    Param(ParamData),
  103|       |
  104|       |    // --- Top Level ---
  105|       |    TranslationUnit(TranslationUnitData),
  106|       |
  107|       |    // --- InitializerList ---
  108|       |    InitializerList(InitializerListData),
  109|       |    InitializerItem(DesignatedInitializer),
  110|       |    Designator(Designator),
  111|       |
  112|       |    // --- Dummy Node ---
  113|       |    Dummy,
  114|       |}
  115|       |
  116|       |impl NodeKind {
  117|  3.89k|    pub fn visit_children<F: FnMut(NodeRef)>(&self, mut f: F) {
  118|  3.89k|        match self {
  119|       |            NodeKind::Literal(_)
  120|       |            | NodeKind::Ident(..)
  121|       |            | NodeKind::SizeOfType(_)
  122|       |            | NodeKind::AlignOf(_)
  123|       |            | NodeKind::Break
  124|       |            | NodeKind::Continue
  125|       |            | NodeKind::Goto(..)
  126|       |            | NodeKind::TypedefDecl(_)
  127|       |            | NodeKind::FieldDecl(_)
  128|       |            | NodeKind::EnumMember(_)
  129|       |            | NodeKind::Param(_)
  130|  1.41k|            | NodeKind::Dummy => {}
  131|       |
  132|     71|            NodeKind::UnaryOp(_, child)
  133|      4|            | NodeKind::PostIncrement(child)
  134|      5|            | NodeKind::PostDecrement(child)
  135|    100|            | NodeKind::MemberAccess(child, ..)
  136|     15|            | NodeKind::Cast(_, child)
  137|      0|            | NodeKind::BuiltinVaArg(_, child)
  138|      0|            | NodeKind::BuiltinVaEnd(child)
  139|     24|            | NodeKind::SizeOfExpr(child)
  140|      0|            | NodeKind::CompoundLiteral(_, child)
  141|     12|            | NodeKind::Label(_, child, _)
  142|      0|            | NodeKind::Default(child)
  143|    251|            | NodeKind::StaticAssert(child, _) => f(*child),
                                                   ^20
  144|       |
  145|      0|            NodeKind::BuiltinVaStart(lhs, rhs)
  146|      0|            | NodeKind::BuiltinVaCopy(lhs, rhs)
  147|    154|            | NodeKind::BinaryOp(_, lhs, rhs)
  148|      0|            | NodeKind::GnuStatementExpression(lhs, rhs)
  149|    143|            | NodeKind::Assignment(_, lhs, rhs)
  150|     44|            | NodeKind::IndexAccess(lhs, rhs)
  151|      0|            | NodeKind::DoWhile(lhs, rhs)
  152|      1|            | NodeKind::Switch(lhs, rhs)
  153|    345|            | NodeKind::Case(lhs, rhs) => {
                                           ^3   ^3
  154|    345|                f(*lhs);
  155|    345|                f(*rhs);
  156|    345|            }
  157|       |
  158|      8|            NodeKind::TernaryOp(c1, c2, c3) | NodeKind::CaseRange(c1, c2, c3) => {
                                                                                ^0  ^0  ^0
  159|      8|                f(*c1);
  160|      8|                f(*c2);
  161|      8|                f(*c3);
  162|      8|            }
  163|       |
  164|     51|            NodeKind::FunctionCall(call) => {
  165|     51|                f(call.callee);
  166|     51|                for child in call.arg_start.range(call.arg_len) {
                                  ^32
  167|     32|                    f(child);
  168|     32|                }
  169|       |            }
  170|       |
  171|     11|            NodeKind::GenericSelection(gs) => {
  172|     11|                f(gs.control);
  173|     24|                for child in gs.assoc_start.range(gs.assoc_len) {
                                           ^11            ^11   ^11
  174|     24|                    f(child);
  175|     24|                }
  176|       |            }
  177|       |
  178|     24|            NodeKind::GenericAssociation(ga) => {
  179|     24|                f(ga.result_expr);
  180|     24|            }
  181|       |
  182|    314|            NodeKind::CompoundStatement(cs) => {
  183|    809|                for child in cs.stmt_start.range(cs.stmt_len) {
                                           ^314          ^314  ^314
  184|    809|                    f(child);
  185|    809|                }
  186|       |            }
  187|       |
  188|     78|            NodeKind::If(stmt) => {
  189|     78|                f(stmt.condition);
  190|     78|                f(stmt.then_branch);
  191|     78|                if let Some(else_branch) = stmt.else_branch {
                                          ^2
  192|      2|                    f(else_branch);
  193|     76|                }
  194|       |            }
  195|       |
  196|      2|            NodeKind::While(stmt) => {
  197|      2|                f(stmt.condition);
  198|      2|                f(stmt.body);
  199|      2|            }
  200|       |
  201|      2|            NodeKind::For(stmt) => {
  202|      2|                if let Some(init) = stmt.init {
                                          ^0
  203|      0|                    f(init);
  204|      2|                }
  205|      2|                if let Some(cond) = stmt.condition {
  206|      2|                    f(cond);
  207|      2|                }
                              ^0
  208|      2|                if let Some(inc) = stmt.increment {
                                          ^0
  209|      0|                    f(inc);
  210|      2|                }
  211|      2|                f(stmt.body);
  212|       |            }
  213|       |
  214|    334|            NodeKind::Return(expr) | NodeKind::ExpressionStatement(expr) | NodeKind::EnumConstant(_, expr) => {
                                                                                 ^189                              ^0
  215|    523|                if let Some(child) = expr {
                                          ^517
  216|    517|                    f(*child);
  217|    517|                }
                              ^6
  218|       |            }
  219|       |
  220|    312|            NodeKind::VarDecl(data) => {
  221|    312|                if let Some(init) = data.init {
                                          ^177
  222|    177|                    f(init);
  223|    177|                }
                              ^135
  224|       |            }
  225|       |
  226|     18|            NodeKind::FunctionDecl(data) => {
  227|     18|                if let Some(body) = data.body {
                                          ^0
  228|      0|                    f(body);
  229|     18|                }
  230|       |            }
  231|       |
  232|     33|            NodeKind::RecordDecl(data) => {
  233|     55|                for child in data.member_start.range(data.member_len) {
                                           ^33               ^33   ^33
  234|     55|                    f(child);
  235|     55|                }
  236|       |            }
  237|       |
  238|      6|            NodeKind::EnumDecl(data) => {
  239|     11|                for child in data.member_start.range(data.member_len) {
                                           ^6                ^6    ^6
  240|     11|                    f(child);
  241|     11|                }
  242|       |            }
  243|       |
  244|    187|            NodeKind::Function(data) => {
  245|    187|                for child in data.param_start.range(data.param_len) {
                                  ^14
  246|     14|                    f(child);
  247|     14|                }
  248|    187|                f(data.body);
  249|       |            }
  250|       |
  251|    181|            NodeKind::TranslationUnit(data) => {
  252|    322|                for child in data.decl_start.range(data.decl_len) {
                                           ^181            ^181  ^181
  253|    322|                    f(child);
  254|    322|                }
  255|       |            }
  256|       |
  257|     33|            NodeKind::InitializerList(data) => {
  258|     72|                for child in data.init_start.range(data.init_len) {
                                           ^33             ^33   ^33
  259|     72|                    f(child);
  260|     72|                }
  261|       |            }
  262|       |
  263|     72|            NodeKind::InitializerItem(item) => {
  264|     72|                for designator in item.designator_start.range(item.designator_len) {
                                  ^38
  265|     38|                    f(designator);
  266|     38|                }
  267|     72|                f(item.initializer);
  268|       |            }
  269|       |
  270|     38|            NodeKind::Designator(d) => match d {
  271|     19|                Designator::ArrayIndex(idx) => f(*idx),
  272|      0|                Designator::GnuArrayRange(start, end) => {
  273|      0|                    f(*start);
  274|      0|                    f(*end);
  275|      0|                }
  276|     19|                Designator::FieldName(_) => {}
  277|       |            },
  278|       |        }
  279|  3.89k|    }
  280|       |}
  281|       |
  282|       |// Structs for Large/Indirect Variants (to keep NodeKind size small and cache-friendly)
  283|       |// These are stored separately with index-based references.
  284|       |
  285|       |// Control flow statements
  286|       |#[derive(Debug, Clone, Copy, Serialize)]
  287|       |pub struct IfStmt {
  288|       |    pub condition: NodeRef,
  289|       |    pub then_branch: NodeRef,
  290|       |    pub else_branch: Option<NodeRef>,
  291|       |}
  292|       |
  293|       |#[derive(Debug, Clone, Copy, Serialize)]
  294|       |pub struct WhileStmt {
  295|       |    pub condition: NodeRef,
  296|       |    pub body: NodeRef,
  297|       |}
  298|       |
  299|       |#[derive(Debug, Clone, Copy, Serialize)]
  300|       |pub struct ForStmt {
  301|       |    pub init: Option<NodeRef>, // Can be Declaration or Expression
  302|       |    pub condition: Option<NodeRef>,
  303|       |    pub increment: Option<NodeRef>,
  304|       |    pub body: NodeRef,
  305|       |    pub scope_id: ScopeId,
  306|       |}
  307|       |
  308|       |// Semantic node data structures (type-resolved)
  309|       |#[derive(Debug, Clone, Copy, Serialize)]
  310|       |pub struct CompoundStmtData {
  311|       |    pub stmt_start: NodeRef,
  312|       |    pub stmt_len: u16,
  313|       |    pub scope_id: ScopeId,
  314|       |}
  315|       |
  316|       |#[derive(Debug, Clone, Copy, Serialize)]
  317|       |pub struct TranslationUnitData {
  318|       |    pub decl_start: NodeRef,
  319|       |    pub decl_len: u16,
  320|       |    pub scope_id: ScopeId,
  321|       |}
  322|       |
  323|       |#[derive(Debug, Clone, Copy, Serialize)]
  324|       |pub struct InitializerListData {
  325|       |    pub init_start: NodeRef,
  326|       |    pub init_len: u16,
  327|       |}
  328|       |
  329|       |#[derive(Debug, Clone, Serialize)]
  330|       |pub struct FunctionData {
  331|       |    pub symbol: SymbolRef,
  332|       |    pub ty: TypeRef, // function type, not the return type
  333|       |    pub is_noreturn: bool,
  334|       |    pub param_start: NodeRef,
  335|       |    pub param_len: u16,
  336|       |    pub body: NodeRef, // compound statement
  337|       |    pub scope_id: ScopeId,
  338|       |}
  339|       |
  340|       |#[derive(Debug, Clone, Serialize)]
  341|       |pub struct ParamData {
  342|       |    pub symbol: SymbolRef,
  343|       |    pub ty: QualType,
  344|       |}
  345|       |
  346|       |// Semantic node data structures (type-resolved)
  347|       |#[derive(Debug, Clone, Serialize)]
  348|       |pub struct VarDeclData {
  349|       |    pub name: NameId,
  350|       |    pub ty: QualType,
  351|       |    pub storage: Option<StorageClass>,
  352|       |    pub init: Option<NodeRef>,  // InitializerList or Expression
  353|       |    pub alignment: Option<u16>, // Max alignment in bytes
  354|       |}
  355|       |
  356|       |#[derive(Debug, Clone, Serialize)]
  357|       |pub struct FunctionDeclData {
  358|       |    pub name: NameId,
  359|       |    pub ty: TypeRef,
  360|       |    pub storage: Option<StorageClass>,
  361|       |    pub body: Option<NodeRef>,
  362|       |    pub scope_id: ScopeId,
  363|       |}
  364|       |
  365|       |#[derive(Debug, Clone, Serialize)]
  366|       |pub struct TypedefDeclData {
  367|       |    pub name: NameId,
  368|       |    pub ty: QualType,
  369|       |}
  370|       |
  371|       |#[derive(Debug, Clone, Serialize)]
  372|       |pub struct RecordDeclData {
  373|       |    pub name: Option<NameId>,
  374|       |    pub ty: TypeRef,
  375|       |    pub member_start: NodeRef,
  376|       |    /// index where FieldDecl located
  377|       |    pub member_len: u16,
  378|       |
  379|       |    pub is_union: bool,
  380|       |}
  381|       |
  382|       |#[derive(Debug, Clone, Serialize)]
  383|       |pub struct FieldDeclData {
  384|       |    pub name: Option<NameId>,
  385|       |    pub ty: QualType, // object type
  386|       |}
  387|       |
  388|       |#[derive(Debug, Clone, Serialize)]
  389|       |pub struct CallExpr {
  390|       |    pub callee: NodeRef,
  391|       |    pub arg_start: NodeRef, // index where CallArg located
  392|       |    pub arg_len: u16,
  393|       |}
  394|       |
  395|       |#[derive(Debug, Clone, Serialize)]
  396|       |pub struct EnumDeclData {
  397|       |    pub name: Option<NameId>,
  398|       |    pub ty: TypeRef,
  399|       |    pub member_start: NodeRef,
  400|       |    pub member_len: u16,
  401|       |}
  402|       |
  403|       |#[derive(Debug, Clone, Serialize)]
  404|       |pub struct EnumMemberData {
  405|       |    pub name: NameId,
  406|       |    pub value: i64,
  407|       |}
  408|       |
  409|       |#[derive(Debug, Clone, Copy, Serialize, PartialEq, Eq)]
  410|       |pub enum TypeQualifier {
  411|       |    Const,
  412|       |    Restrict,
  413|       |    Volatile,
  414|       |    Atomic,
  415|       |}
  416|       |
  417|       |// Storage classes
  418|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  419|       |#[repr(u8)]
  420|       |pub enum StorageClass {
  421|       |    Typedef,
  422|       |    Extern,
  423|       |    Static,
  424|       |    Auto,
  425|       |    Register,
  426|       |    ThreadLocal, // C11 _Thread_local
  427|       |}
  428|       |
  429|       |// Function specifiers
  430|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  431|       |#[repr(u8)]
  432|       |pub enum FunctionSpecifier {
  433|       |    Inline,
  434|       |    Noreturn, // C11 _Noreturn
  435|       |}
  436|       |
  437|       |// Unary Operators
  438|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  439|       |#[repr(u8)]
  440|       |pub enum UnaryOp {
  441|       |    Plus,
  442|       |    Minus,
  443|       |    Deref,
  444|       |    AddrOf,
  445|       |    BitNot,
  446|       |    LogicNot,
  447|       |    PreIncrement,
  448|       |    PreDecrement,
  449|       |}
  450|       |
  451|       |// Binary Operators (includes assignment types)
  452|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  453|       |#[repr(u8)]
  454|       |pub enum BinaryOp {
  455|       |    Add,
  456|       |    Sub,
  457|       |    Mul,
  458|       |    Div,
  459|       |    Mod,
  460|       |    BitAnd,
  461|       |    BitOr,
  462|       |    BitXor,
  463|       |    LShift,
  464|       |    RShift,
  465|       |    Equal,
  466|       |    NotEqual,
  467|       |    Less,
  468|       |    LessEqual,
  469|       |    Greater,
  470|       |    GreaterEqual,
  471|       |    LogicAnd,
  472|       |    LogicOr,
  473|       |    Comma,
  474|       |    Assign,
  475|       |    AssignAdd,
  476|       |    AssignSub,
  477|       |    AssignMul,
  478|       |    AssignDiv,
  479|       |    AssignMod,
  480|       |    AssignBitAnd,
  481|       |    AssignBitOr,
  482|       |    AssignBitXor,
  483|       |    AssignLShift,
  484|       |    AssignRShift,
  485|       |}
  486|       |
  487|       |impl BinaryOp {
  488|    746|    pub(crate) fn is_assignment(&self) -> bool {
  489|    431|        matches!(
  490|    746|            self,
  491|       |            BinaryOp::Assign
  492|       |                | BinaryOp::AssignAdd
  493|       |                | BinaryOp::AssignSub
  494|       |                | BinaryOp::AssignMul
  495|       |                | BinaryOp::AssignDiv
  496|       |                | BinaryOp::AssignMod
  497|       |                | BinaryOp::AssignBitAnd
  498|       |                | BinaryOp::AssignBitOr
  499|       |                | BinaryOp::AssignBitXor
  500|       |                | BinaryOp::AssignLShift
  501|       |                | BinaryOp::AssignRShift
  502|       |        )
  503|    746|    }
  504|       |
  505|    191|    pub fn without_assignment(&self) -> Option<BinaryOp> {
  506|    191|        match self {
  507|      6|            BinaryOp::AssignAdd => Some(BinaryOp::Add),
  508|      6|            BinaryOp::AssignSub => Some(BinaryOp::Sub),
  509|      2|            BinaryOp::AssignMul => Some(BinaryOp::Mul),
  510|      2|            BinaryOp::AssignDiv => Some(BinaryOp::Div),
  511|      2|            BinaryOp::AssignMod => Some(BinaryOp::Mod),
  512|      0|            BinaryOp::AssignBitAnd => Some(BinaryOp::BitAnd),
  513|      0|            BinaryOp::AssignBitOr => Some(BinaryOp::BitOr),
  514|      0|            BinaryOp::AssignBitXor => Some(BinaryOp::BitXor),
  515|      0|            BinaryOp::AssignLShift => Some(BinaryOp::LShift),
  516|      0|            BinaryOp::AssignRShift => Some(BinaryOp::RShift),
  517|    173|            _ => None,
  518|       |        }
  519|    191|    }
  520|       |}
  521|       |// Array sizes
  522|       |#[derive(Debug, Clone, Serialize)]
  523|       |pub enum ArraySize {
  524|       |    Expression {
  525|       |        expr: NodeRef,
  526|       |        qualifiers: TypeQualifiers,
  527|       |    },
  528|       |    Star {
  529|       |        qualifiers: TypeQualifiers,
  530|       |    }, // [*] VLA
  531|       |    Incomplete, // []
  532|       |    VlaSpecifier {
  533|       |        is_static: bool,
  534|       |        qualifiers: TypeQualifiers,
  535|       |        size: Option<NodeRef>,
  536|       |    }, // for VLA
  537|       |}
  538|       |
  539|       |#[derive(Debug, Clone, Copy, Serialize)]
  540|       |pub struct DesignatedInitializer {
  541|       |    pub designator_start: NodeRef,
  542|       |    pub designator_len: u16,
  543|       |    pub initializer: NodeRef,
  544|       |}
  545|       |
  546|       |#[derive(Debug, Clone, Serialize)]
  547|       |pub enum Designator {
  548|       |    FieldName(NameId),
  549|       |    ArrayIndex(NodeRef),             // Index expression
  550|       |    GnuArrayRange(NodeRef, NodeRef), // GCC extension: Range expression [start ... end]
  551|       |}
  552|       |
  553|       |#[derive(Debug, Clone, Serialize)]
  554|       |pub struct GenericSelectionData {
  555|       |    pub control: NodeRef,
  556|       |    pub assoc_start: NodeRef,
  557|       |    pub assoc_len: u16,
  558|       |}
  559|       |
  560|       |#[derive(Debug, Clone, Serialize)]
  561|       |pub struct GenericAssociationData {
  562|       |    pub ty: Option<QualType>, // None for 'default:'
  563|       |    pub result_expr: NodeRef,
  564|       |}

/app/src/ast/parsed.rs:
    1|       |use crate::{
    2|       |    ast::{BinaryOp, FunctionSpecifier, NameId, ParsedType, SourceSpan, StorageClass, TypeQualifier, UnaryOp},
    3|       |    semantic::TypeQualifiers,
    4|       |};
    5|       |use std::num::NonZeroU32;
    6|       |use thin_vec::ThinVec;
    7|       |
    8|       |use super::ParsedTypeArena;
    9|       |
   10|       |/// Node reference type for referencing child nodes in ParsedAst.
   11|       |pub type ParsedNodeRef = NonZeroU32;
   12|       |
   13|       |/// The parsed AST storage.
   14|       |/// Produced by the Parser. Purely syntactic.
   15|       |#[derive(Clone, Default)]
   16|       |pub struct ParsedAst {
   17|       |    pub nodes: Vec<ParsedNode>,
   18|       |    pub parsed_types: ParsedTypeArena,
   19|       |}
   20|       |
   21|       |impl ParsedAst {
   22|    466|    pub fn new() -> Self {
   23|    466|        ParsedAst::default()
   24|    466|    }
   25|       |
   26|  5.26k|    pub fn push_node(&mut self, node: ParsedNode) -> ParsedNodeRef {
   27|  5.26k|        let index = self.nodes.len() as u32 + 1;
   28|  5.26k|        self.nodes.push(node);
   29|  5.26k|        ParsedNodeRef::new(index).expect("ParsedNodeRef overflow")
   30|  5.26k|    }
   31|       |
   32|  7.71k|    pub fn get_node(&self, index: ParsedNodeRef) -> &ParsedNode {
   33|  7.71k|        &self.nodes[(index.get() - 1) as usize]
   34|  7.71k|    }
   35|       |
   36|  1.77k|    pub fn replace_node(&mut self, old_node_ref: ParsedNodeRef, new_node: ParsedNode) -> ParsedNodeRef {
   37|  1.77k|        let old_index = (old_node_ref.get() - 1) as usize;
   38|  1.77k|        self.nodes[old_index] = new_node;
   39|  1.77k|        old_node_ref
   40|  1.77k|    }
   41|       |
   42|    207|    pub fn get_root(&self) -> ParsedNodeRef {
   43|    207|        ParsedNodeRef::new(1).expect("Parsed AST empty")
   44|    207|    }
   45|       |}
   46|       |
   47|       |#[derive(Debug, Clone)]
   48|       |pub struct ParsedNode {
   49|       |    pub kind: ParsedNodeKind,
   50|       |    pub span: SourceSpan,
   51|       |}
   52|       |
   53|       |impl ParsedNode {
   54|  7.04k|    pub fn new(kind: ParsedNodeKind, span: SourceSpan) -> Self {
   55|  7.04k|        ParsedNode { kind, span }
   56|  7.04k|    }
   57|       |}
   58|       |
   59|       |#[derive(Debug, Clone)]
   60|       |pub enum ParsedNodeKind {
   61|       |    // --- Literals ---
   62|       |    Literal(crate::ast::literal::Literal),
   63|       |
   64|       |    // --- Expressions ---
   65|       |    Ident(NameId), // No symbol ref yet
   66|       |    UnaryOp(UnaryOp, ParsedNodeRef),
   67|       |    BinaryOp(BinaryOp, ParsedNodeRef, ParsedNodeRef),
   68|       |    TernaryOp(ParsedNodeRef, ParsedNodeRef, ParsedNodeRef),
   69|       |    GnuStatementExpression(ParsedNodeRef, ParsedNodeRef),
   70|       |
   71|       |    PostIncrement(ParsedNodeRef),
   72|       |    PostDecrement(ParsedNodeRef),
   73|       |
   74|       |    Assignment(BinaryOp, ParsedNodeRef, ParsedNodeRef),
   75|       |    FunctionCall(ParsedNodeRef, Vec<ParsedNodeRef>),
   76|       |    MemberAccess(ParsedNodeRef, NameId, bool),
   77|       |    IndexAccess(ParsedNodeRef, ParsedNodeRef),
   78|       |
   79|       |    Cast(ParsedType, ParsedNodeRef),
   80|       |    BuiltinVaArg(ParsedType, ParsedNodeRef),
   81|       |    BuiltinVaStart(ParsedNodeRef, ParsedNodeRef),
   82|       |    BuiltinVaEnd(ParsedNodeRef),
   83|       |    BuiltinVaCopy(ParsedNodeRef, ParsedNodeRef),
   84|       |    SizeOfExpr(ParsedNodeRef),
   85|       |    SizeOfType(ParsedType),
   86|       |    AlignOf(ParsedType),
   87|       |
   88|       |    CompoundLiteral(ParsedType, ParsedNodeRef),
   89|       |    GenericSelection(ParsedNodeRef, Vec<ParsedGenericAssociation>),
   90|       |
   91|       |    // --- Statements ---
   92|       |    CompoundStatement(Vec<ParsedNodeRef>),
   93|       |    If(ParsedIfStmt),
   94|       |    While(ParsedWhileStmt),
   95|       |    DoWhile(ParsedNodeRef, ParsedNodeRef),
   96|       |    For(ParsedForStmt),
   97|       |
   98|       |    Return(Option<ParsedNodeRef>),
   99|       |    Break,
  100|       |    Continue,
  101|       |    Goto(NameId),
  102|       |    Label(NameId, ParsedNodeRef),
  103|       |
  104|       |    Switch(ParsedNodeRef, ParsedNodeRef),
  105|       |    Case(ParsedNodeRef, ParsedNodeRef),
  106|       |    CaseRange(ParsedNodeRef, ParsedNodeRef, ParsedNodeRef),
  107|       |    Default(ParsedNodeRef),
  108|       |
  109|       |    ExpressionStatement(Option<ParsedNodeRef>),
  110|       |    EmptyStatement,
  111|       |
  112|       |    // --- Declarations & Definitions ---
  113|       |    Declaration(ParsedDeclarationData),
  114|       |    FunctionDef(ParsedFunctionDefData),
  115|       |    EnumConstant(NameId, Option<ParsedNodeRef>),
  116|       |    StaticAssert(ParsedNodeRef, NameId),
  117|       |
  118|       |    // --- Top Level ---
  119|       |    TranslationUnit(Vec<ParsedNodeRef>),
  120|       |
  121|       |    // --- InitializerList ---
  122|       |    InitializerList(Vec<ParsedDesignatedInitializer>),
  123|       |
  124|       |    // --- Dummy Node ---
  125|       |    Dummy,
  126|       |}
  127|       |
  128|       |#[derive(Debug, Clone)]
  129|       |pub struct ParsedIfStmt {
  130|       |    pub condition: ParsedNodeRef,
  131|       |    pub then_branch: ParsedNodeRef,
  132|       |    pub else_branch: Option<ParsedNodeRef>,
  133|       |}
  134|       |
  135|       |#[derive(Debug, Clone)]
  136|       |pub struct ParsedWhileStmt {
  137|       |    pub condition: ParsedNodeRef,
  138|       |    pub body: ParsedNodeRef,
  139|       |}
  140|       |
  141|       |#[derive(Debug, Clone)]
  142|       |pub struct ParsedForStmt {
  143|       |    pub init: Option<ParsedNodeRef>,
  144|       |    pub condition: Option<ParsedNodeRef>,
  145|       |    pub increment: Option<ParsedNodeRef>,
  146|       |    pub body: ParsedNodeRef,
  147|       |}
  148|       |
  149|       |#[derive(Debug, Clone)]
  150|       |pub struct ParsedInitDeclarator {
  151|       |    pub declarator: ParsedDeclarator,
  152|       |    pub initializer: Option<ParsedNodeRef>,
  153|       |    pub span: SourceSpan,
  154|       |}
  155|       |
  156|       |#[derive(Debug, Clone)]
  157|       |pub struct ParsedDeclarationData {
  158|       |    pub specifiers: ThinVec<ParsedDeclSpecifier>,
  159|       |    pub init_declarators: ThinVec<ParsedInitDeclarator>,
  160|       |}
  161|       |
  162|       |#[derive(Debug, Clone)]
  163|       |pub struct ParsedFunctionDefData {
  164|       |    pub specifiers: ThinVec<ParsedDeclSpecifier>,
  165|       |    pub declarator: Box<ParsedDeclarator>,
  166|       |    pub body: ParsedNodeRef,
  167|       |}
  168|       |
  169|       |// Declaration specifiers and related types
  170|       |#[derive(Debug, Clone)]
  171|       |pub enum ParsedDeclSpecifier {
  172|       |    StorageClass(StorageClass),
  173|       |    TypeQualifier(TypeQualifier),
  174|       |    FunctionSpecifier(FunctionSpecifier),
  175|       |    AlignmentSpecifier(ParsedAlignmentSpecifier),
  176|       |    TypeSpecifier(ParsedTypeSpecifier),
  177|       |    Attribute,
  178|       |}
  179|       |
  180|       |// Type specifiers
  181|       |#[derive(Debug, Clone)]
  182|       |pub enum ParsedTypeSpecifier {
  183|       |    Void,
  184|       |    Char,
  185|       |    Short,
  186|       |    Int,
  187|       |    Long,
  188|       |    LongLong,
  189|       |    Float,
  190|       |    Double,
  191|       |    LongDouble,
  192|       |    Signed,
  193|       |    Unsigned,
  194|       |    Bool,
  195|       |    Complex,
  196|       |    Atomic(ParsedType), // _Bool, _Complex, _Atomic
  197|       |    Record(
  198|       |        bool,                        /* is_union */
  199|       |        Option<NameId>,              /* tag */
  200|       |        Option<ParsedRecordDefData>, /* definition */
  201|       |    ),
  202|       |    Enum(
  203|       |        Option<NameId>,             /* tag */
  204|       |        Option<Vec<ParsedNodeRef>>, /* enumerators */
  205|       |    ),
  206|       |    TypedefName(NameId),
  207|       |}
  208|       |
  209|       |// Alignment specifiers
  210|       |#[derive(Debug, Clone)]
  211|       |pub enum ParsedAlignmentSpecifier {
  212|       |    Type(ParsedType),    // _Alignas(type-name)
  213|       |    Expr(ParsedNodeRef), // _Alignas(constant-expression)
  214|       |}
  215|       |
  216|       |// Declarators
  217|       |#[derive(Debug, Clone)]
  218|       |pub enum ParsedDeclarator {
  219|       |    Identifier(NameId, TypeQualifiers),                     // Base case: name (e.g., `x`)
  220|       |    Abstract,                                               // for abstract declarator
  221|       |    Pointer(TypeQualifiers, Option<Box<ParsedDeclarator>>), // e.g., `*`
  222|       |    Array(Box<ParsedDeclarator>, ParsedArraySize),          // e.g., `[10]`
  223|       |    Function {
  224|       |        inner: Box<ParsedDeclarator>,
  225|       |        params: ThinVec<ParsedParamData>,
  226|       |        is_variadic: bool,
  227|       |    }, // e.g., `(int x)`
  228|       |    AnonymousRecord(
  229|       |        bool,                           /* is_union */
  230|       |        ThinVec<ParsedDeclarationData>, /* members */
  231|       |    ), // C11 anonymous struct/union
  232|       |    BitField(Box<ParsedDeclarator>, ParsedNodeRef /* bit width expression */), // e.g., `x : 8`
  233|       |}
  234|       |
  235|       |impl ParsedDeclarator {}
  236|       |
  237|       |#[derive(Debug, Clone)]
  238|       |pub struct ParsedParamData {
  239|       |    pub specifiers: ThinVec<ParsedDeclSpecifier>,
  240|       |    pub declarator: Option<ParsedDeclarator>, // Optional name for abstract declarator
  241|       |    pub span: SourceSpan,
  242|       |}
  243|       |
  244|       |// Array sizes
  245|       |#[derive(Debug, Clone)]
  246|       |pub enum ParsedArraySize {
  247|       |    Expression {
  248|       |        expr: ParsedNodeRef,
  249|       |        qualifiers: TypeQualifiers,
  250|       |    },
  251|       |    Star {
  252|       |        qualifiers: TypeQualifiers,
  253|       |    }, // [*] VLA
  254|       |    Incomplete, // []
  255|       |    VlaSpecifier {
  256|       |        is_static: bool,
  257|       |        qualifiers: TypeQualifiers,
  258|       |        size: Option<ParsedNodeRef>,
  259|       |    }, // for VLA
  260|       |}
  261|       |
  262|       |// Record definitions
  263|       |#[derive(Debug, Clone)]
  264|       |pub struct ParsedGenericAssociation {
  265|       |    pub type_name: Option<ParsedType>, // None for 'default:'
  266|       |    pub result_expr: ParsedNodeRef,
  267|       |}
  268|       |
  269|       |#[derive(Debug, Clone)]
  270|       |pub struct ParsedRecordDefData {
  271|       |    pub tag: Option<NameId>,                         // None if anonymous
  272|       |    pub members: Option<Vec<ParsedDeclarationData>>, // Field declarations
  273|       |    pub is_union: bool,
  274|       |}
  275|       |
  276|       |#[derive(Debug, Clone)]
  277|       |pub struct ParsedDesignatedInitializer {
  278|       |    pub designation: Vec<ParsedDesignatedInitializerDesignator>,
  279|       |    pub initializer: ParsedNodeRef,
  280|       |}
  281|       |
  282|       |#[derive(Debug, Clone)]
  283|       |pub enum ParsedDesignatedInitializerDesignator {
  284|       |    FieldName(NameId),
  285|       |    ArrayIndex(ParsedNodeRef),
  286|       |    GnuArrayRange(ParsedNodeRef, ParsedNodeRef),
  287|       |}
  288|       |
  289|       |// Renaming alias for compatibility while refactoring
  290|       |pub type ParsedDesignator = ParsedDesignatedInitializerDesignator;

/app/src/ast/parsed_types.rs:
    1|       |//! Parsed type system for the Parser phase.
    2|       |//!
    3|       |//! This module defines the syntactic type representations used during parsing,
    4|       |//! distinct from the semantic type system used during analysis. These types
    5|       |//! are only relevant in the Parser phase and will be converted to semantic
    6|       |//! types during the SymbolResolver phase.
    7|       |
    8|       |use std::num::{NonZeroU16, NonZeroU32};
    9|       |
   10|       |use serde::Serialize;
   11|       |
   12|       |use crate::ast::parsed::{ParsedArraySize, ParsedTypeSpecifier};
   13|       |use crate::ast::{NameId, SourceSpan};
   14|       |use crate::semantic::TypeQualifiers;
   15|       |
   16|       |/// Type reference for parsed base types
   17|       |pub type ParsedBaseTypeRef = NonZeroU32;
   18|       |
   19|       |/// Type reference for parsed declarators
   20|       |pub type ParsedDeclRef = NonZeroU32;
   21|       |
   22|       |/// A parsed type that represents the syntactic structure of a type
   23|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
   24|       |pub struct ParsedType {
   25|       |    pub base: ParsedBaseTypeRef,   // NonZeroU32
   26|       |    pub declarator: ParsedDeclRef, // NonZeroU32
   27|       |    pub qualifiers: TypeQualifiers,
   28|       |}
   29|       |
   30|       |/// Range for struct members in the arena
   31|       |#[derive(Debug, Clone, Copy)]
   32|       |pub struct ParsedStructMemberRange {
   33|       |    pub start: u32,
   34|       |    pub len: u32,
   35|       |}
   36|       |
   37|       |/// Range for function parameters in the arena
   38|       |#[derive(Debug, Clone, Copy)]
   39|       |pub struct ParsedParamRange {
   40|       |    pub start: u32,
   41|       |    pub len: u32,
   42|       |}
   43|       |
   44|       |/// Range for enum values in the arena
   45|       |#[derive(Debug, Clone, Copy)]
   46|       |pub struct ParsedEnumRange {
   47|       |    pub start: u32,
   48|       |    pub len: u32,
   49|       |}
   50|       |
   51|       |/// Function parameter information
   52|       |#[derive(Debug, Clone)]
   53|       |pub struct ParsedFunctionParam {
   54|       |    pub name: Option<NameId>,
   55|       |    pub ty: ParsedType,
   56|       |    pub span: SourceSpan,
   57|       |}
   58|       |
   59|       |/// Parsed struct/union member information
   60|       |#[derive(Debug, Clone)]
   61|       |pub struct ParsedStructMember {
   62|       |    pub name: Option<NameId>,
   63|       |    pub ty: ParsedType,
   64|       |    pub bit_field_size: Option<NonZeroU16>,
   65|       |    pub span: SourceSpan,
   66|       |}
   67|       |
   68|       |/// Parsed enum constant information
   69|       |#[derive(Debug, Clone)]
   70|       |pub struct ParsedEnumConstant {
   71|       |    pub name: NameId,
   72|       |    pub value: Option<i64>, // None for now, resolved later
   73|       |    pub span: SourceSpan,
   74|       |}
   75|       |
   76|       |/// Function flags for declarators
   77|       |#[derive(Debug, Clone, Copy)]
   78|       |pub struct FunctionFlags {
   79|       |    pub is_variadic: bool,
   80|       |}
   81|       |
   82|       |/// Parsed base type node (the fundamental type specifier)
   83|       |#[derive(Clone, Debug)]
   84|       |pub enum ParsedBaseTypeNode {
   85|       |    Builtin(ParsedTypeSpecifier),
   86|       |
   87|       |    Record {
   88|       |        tag: Option<NameId>,
   89|       |        members: Option<ParsedStructMemberRange>, // index range
   90|       |        is_union: bool,
   91|       |    },
   92|       |
   93|       |    Enum {
   94|       |        tag: Option<NameId>,
   95|       |        enumerators: Option<ParsedEnumRange>,
   96|       |    },
   97|       |
   98|       |    Typedef(NameId),
   99|       |
  100|       |    Error,
  101|       |}
  102|       |
  103|       |/// Parsed declarator node (the declarator structure)
  104|       |#[derive(Debug, Clone)]
  105|       |pub enum ParsedDeclaratorNode {
  106|       |    Identifier {
  107|       |        name: Option<NameId>,
  108|       |    },
  109|       |
  110|       |    Pointer {
  111|       |        qualifiers: TypeQualifiers,
  112|       |        inner: ParsedDeclRef,
  113|       |    },
  114|       |
  115|       |    Array {
  116|       |        size: ParsedArraySize,
  117|       |        inner: ParsedDeclRef,
  118|       |    },
  119|       |
  120|       |    Function {
  121|       |        params: ParsedParamRange,
  122|       |        flags: FunctionFlags,
  123|       |        inner: ParsedDeclRef,
  124|       |    },
  125|       |}
  126|       |
  127|       |/// Arena for storing parsed type information
  128|       |/// This provides efficient allocation and referencing for parsed types
  129|       |#[derive(Clone, Debug, Default)]
  130|       |pub struct ParsedTypeArena {
  131|       |    base_types: Vec<ParsedBaseTypeNode>,
  132|       |    declarators: Vec<ParsedDeclaratorNode>,
  133|       |    params: Vec<ParsedFunctionParam>,
  134|       |    struct_members: Vec<ParsedStructMember>,
  135|       |    enum_constants: Vec<ParsedEnumConstant>,
  136|       |}
  137|       |
  138|       |impl ParsedTypeArena {
  139|       |    /// Allocate a new base type and return its reference
  140|     41|    pub(crate) fn alloc_base_type(&mut self, base_type: ParsedBaseTypeNode) -> ParsedBaseTypeRef {
  141|     41|        let index = self.base_types.len() as u32 + 1; // Start from 1 for NonZeroU32
  142|     41|        self.base_types.push(base_type);
  143|     41|        ParsedBaseTypeRef::new(index).expect("ParsedBaseTypeRef overflow")
  144|     41|    }
  145|       |
  146|       |    /// Allocate a new declarator and return its reference
  147|     53|    pub(crate) fn alloc_decl(&mut self, declarator: ParsedDeclaratorNode) -> ParsedDeclRef {
  148|     53|        let index = self.declarators.len() as u32 + 1; // Start from 1 for NonZeroU32
  149|     53|        self.declarators.push(declarator);
  150|     53|        ParsedDeclRef::new(index).expect("ParsedDeclRef overflow")
  151|     53|    }
  152|       |
  153|       |    /// Allocate function parameters and return the range
  154|      2|    pub(crate) fn alloc_params(&mut self, params: Vec<ParsedFunctionParam>) -> ParsedParamRange {
  155|      2|        let start = self.params.len() as u32;
  156|      2|        self.params.extend(params);
  157|      2|        let len = self.params.len() as u32 - start;
  158|      2|        ParsedParamRange { start, len }
  159|      2|    }
  160|       |
  161|       |    /// Allocate struct members and return the range
  162|      0|    pub(crate) fn alloc_struct_members(&mut self, members: Vec<ParsedStructMember>) -> ParsedStructMemberRange {
  163|      0|        let start = self.struct_members.len() as u32;
  164|      0|        self.struct_members.extend(members);
  165|      0|        let len = self.struct_members.len() as u32 - start;
  166|      0|        ParsedStructMemberRange { start, len }
  167|      0|    }
  168|       |
  169|       |    /// Allocate enum constants and return the range
  170|      1|    pub(crate) fn alloc_enum_constants(&mut self, enumerators: Vec<ParsedEnumConstant>) -> ParsedEnumRange {
  171|      1|        let start = self.enum_constants.len() as u32;
  172|      1|        self.enum_constants.extend(enumerators);
  173|      1|        let len = self.enum_constants.len() as u32 - start;
  174|      1|        ParsedEnumRange { start, len }
  175|      1|    }
  176|       |
  177|       |    /// Get a base type by reference
  178|     23|    pub(crate) fn get_base_type(&self, base_ref: ParsedBaseTypeRef) -> ParsedBaseTypeNode {
  179|     23|        let index = (base_ref.get() - 1) as usize;
  180|     23|        self.base_types[index].clone()
  181|     23|    }
  182|       |
  183|       |    /// Get a declarator by reference
  184|     29|    pub(crate) fn get_decl(&self, decl_ref: ParsedDeclRef) -> ParsedDeclaratorNode {
  185|     29|        let index = (decl_ref.get() - 1) as usize;
  186|     29|        self.declarators[index].clone()
  187|     29|    }
  188|       |
  189|       |    /// Get function parameters by range
  190|      1|    pub(crate) fn get_params(&self, range: ParsedParamRange) -> &[ParsedFunctionParam] {
  191|      1|        let start = range.start as usize;
  192|      1|        let end = start + range.len as usize;
  193|      1|        &self.params[start..end]
  194|      1|    }
  195|       |
  196|       |    /// Get struct members by range
  197|      0|    pub(crate) fn get_struct_members(&self, range: ParsedStructMemberRange) -> &[ParsedStructMember] {
  198|      0|        let start = range.start as usize;
  199|      0|        let end = start + range.len as usize;
  200|      0|        &self.struct_members[start..end]
  201|      0|    }
  202|       |
  203|       |    /// Get enum constants by range
  204|      1|    pub(crate) fn get_enum_constants(&self, range: ParsedEnumRange) -> &[ParsedEnumConstant] {
  205|      1|        let start = range.start as usize;
  206|      1|        let end = start + range.len as usize;
  207|      1|        &self.enum_constants[start..end]
  208|      1|    }
  209|       |}

/app/src/diagnostic.rs:
    1|       |use crate::ast::NameId;
    2|       |use crate::lexer::TokenKind;
    3|       |use crate::semantic::TypeRef;
    4|       |use crate::source_manager::{SourceManager, SourceSpan};
    5|       |use annotate_snippets::renderer::DecorStyle;
    6|       |use annotate_snippets::{AnnotationKind, Level, Renderer, Snippet};
    7|       |
    8|       |/// Diagnostic severity levels
    9|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
   10|       |pub enum DiagnosticLevel {
   11|       |    #[default]
   12|       |    Error,
   13|       |    Warning,
   14|       |    Note,
   15|       |}
   16|       |
   17|       |/// Individual diagnostic with rich context
   18|       |#[derive(Debug, Clone, Default)]
   19|       |pub struct Diagnostic {
   20|       |    pub level: DiagnosticLevel,
   21|       |    pub message: String,
   22|       |    pub span: SourceSpan,
   23|       |    pub code: Option<String>,     // Error code like "E001"
   24|       |    pub hints: Vec<String>,       // Suggestions for fixing
   25|       |    pub related: Vec<SourceSpan>, // Related locations
   26|       |}
   27|       |
   28|       |/// Parse errors
   29|       |#[derive(Debug, thiserror::Error)]
   30|       |pub enum ParseError {
   31|       |    #[error("Unexpected token: expected {expected_tokens}, found {found:?}")]
   32|       |    UnexpectedToken {
   33|       |        expected_tokens: String,
   34|       |        found: TokenKind,
   35|       |        span: SourceSpan,
   36|       |    },
   37|       |
   38|       |    #[error("Unexpected End of File")]
   39|       |    UnexpectedEof { span: SourceSpan },
   40|       |
   41|       |    #[error("Invalid unary operator")]
   42|       |    InvalidUnaryOperator { span: SourceSpan },
   43|       |
   44|       |    #[error("Declaration not allowed in this context")]
   45|       |    DeclarationNotAllowed { span: SourceSpan },
   46|       |
   47|       |    #[error("Parser exceeded maximum iteration limit - possible infinite loop")]
   48|       |    InfiniteLoop { span: SourceSpan },
   49|       |}
   50|       |
   51|       |impl ParseError {
   52|      2|    pub fn span(&self) -> SourceSpan {
   53|      2|        match self {
   54|      2|            ParseError::UnexpectedToken { span, .. } => *span,
   55|      0|            ParseError::UnexpectedEof { span } => *span,
   56|      0|            ParseError::InvalidUnaryOperator { span } => *span,
   57|      0|            ParseError::DeclarationNotAllowed { span } => *span,
   58|      0|            ParseError::InfiniteLoop { span } => *span,
   59|       |        }
   60|      2|    }
   61|       |}
   62|       |/// Diagnostic engine for collecting and reporting semantic errors and warnings
   63|       |pub struct DiagnosticEngine {
   64|       |    pub diagnostics: Vec<Diagnostic>,
   65|       |    pub warnings_as_errors: bool,
   66|       |    pub disable_all_warnings: bool,
   67|       |}
   68|       |
   69|       |impl Default for DiagnosticEngine {
   70|      0|    fn default() -> Self {
   71|      0|        Self::new()
   72|      0|    }
   73|       |}
   74|       |
   75|       |impl DiagnosticEngine {
   76|    190|    pub(crate) fn new() -> Self {
   77|    190|        DiagnosticEngine {
   78|    190|            diagnostics: Vec::new(),
   79|    190|            warnings_as_errors: false,
   80|    190|            disable_all_warnings: false,
   81|    190|        }
   82|    190|    }
   83|       |
   84|    611|    pub(crate) fn from_warnings(warnings: &[String]) -> Self {
   85|    611|        let warnings_as_errors = warnings.iter().any(|w| w == "error");
                                                                       ^0   ^0
   86|    611|        let disable_all_warnings = warnings.iter().any(|w| w == "no-warnings");
                                                                         ^0   ^0
   87|    611|        Self {
   88|    611|            diagnostics: Vec::new(),
   89|    611|            warnings_as_errors,
   90|    611|            disable_all_warnings,
   91|    611|        }
   92|    611|    }
   93|       |
   94|      0|    fn _report(&mut self, level: DiagnosticLevel, message: String, span: SourceSpan) {
   95|      0|        if level == DiagnosticLevel::Warning && self.disable_all_warnings {
   96|      0|            return;
   97|      0|        }
   98|       |
   99|      0|        let final_level = if level == DiagnosticLevel::Warning && self.warnings_as_errors {
  100|      0|            DiagnosticLevel::Error
  101|       |        } else {
  102|      0|            level
  103|       |        };
  104|       |
  105|      0|        self.diagnostics.push(Diagnostic {
  106|      0|            level: final_level,
  107|      0|            message,
  108|      0|            span,
  109|      0|            ..Default::default()
  110|      0|        });
  111|      0|    }
  112|       |
  113|       |    // pub(crate) fn report_note(&mut self, message: String, span: SourceSpan) {
  114|       |    //     self._report(DiagnosticLevel::Note, message, span);
  115|       |    // }
  116|       |
  117|     95|    pub(crate) fn report_diagnostic(&mut self, diagnostic: Diagnostic) {
  118|     95|        self.diagnostics.push(diagnostic);
  119|     95|    }
  120|       |
  121|  1.03k|    pub(crate) fn has_errors(&self) -> bool {
  122|  1.03k|        self.diagnostics.iter().any(|d| d.level == DiagnosticLevel::Error)
                                                      ^71        ^71
  123|  1.03k|    }
  124|       |
  125|    136|    pub(crate) fn diagnostics(&self) -> &[Diagnostic] {
  126|    136|        &self.diagnostics
  127|    136|    }
  128|       |
  129|     72|    pub(crate) fn report<T: IntoDiagnostic>(&mut self, error: T) {
  130|     83|        for diagnostic in error.into_diagnostic() {
                                        ^72   ^72
  131|     83|            self.report_diagnostic(diagnostic);
  132|     83|        }
  133|     72|    }
  134|       |}
  135|       |
  136|       |pub trait IntoDiagnostic {
  137|       |    fn into_diagnostic(self) -> Vec<Diagnostic>;
  138|       |}
  139|       |
  140|       |impl IntoDiagnostic for ParseError {
  141|      2|    fn into_diagnostic(self) -> Vec<Diagnostic> {
  142|      2|        vec![Diagnostic {
  143|      2|            level: DiagnosticLevel::Error,
  144|      2|            message: self.to_string(),
  145|      2|            span: self.span(),
  146|      2|            ..Default::default()
  147|      2|        }]
  148|      2|    }
  149|       |}
  150|       |
  151|       |impl IntoDiagnostic for SemanticError {
  152|     70|    fn into_diagnostic(self) -> Vec<Diagnostic> {
  153|     70|        let mut diagnostics = vec![Diagnostic {
  154|     70|            level: DiagnosticLevel::Error,
  155|     70|            message: self.to_string(),
  156|     70|            span: self.span(),
  157|     70|            ..Default::default()
  158|     70|        }];
  159|       |
  160|      4|        if let SemanticError::Redefinition { first_def, .. }
  161|     70|        | SemanticError::RedefinitionWithDifferentType { first_def, .. } = &self
                                                                       ^1
  162|      5|        {
  163|      5|            diagnostics.push(Diagnostic {
  164|      5|                level: DiagnosticLevel::Note,
  165|      5|                message: "previous definition is here".to_string(),
  166|      5|                span: *first_def,
  167|      5|                ..Default::default()
  168|      5|            });
  169|     65|        }
  170|       |
  171|     70|        if let SemanticError::ConflictingLinkage { first_def, .. } = &self {
                                                                 ^1
  172|      1|            diagnostics.push(Diagnostic {
  173|      1|                level: DiagnosticLevel::Note,
  174|      1|                message: "previous declaration is here".to_string(),
  175|      1|                span: *first_def,
  176|      1|                ..Default::default()
  177|      1|            });
  178|     69|        }
  179|       |
  180|     70|        if let SemanticError::DuplicateMember { first_def, .. } = &self {
                                                              ^3
  181|      3|            diagnostics.push(Diagnostic {
  182|      3|                level: DiagnosticLevel::Note,
  183|      3|                message: "previous declaration is here".to_string(),
  184|      3|                span: *first_def,
  185|      3|                ..Default::default()
  186|      3|            });
  187|     67|        }
  188|       |
  189|     70|        if let SemanticError::ConflictingTypes { first_def, .. } = &self {
                                                               ^2
  190|      2|            diagnostics.push(Diagnostic {
  191|      2|                level: DiagnosticLevel::Note,
  192|      2|                message: "previous declaration is here".to_string(),
  193|      2|                span: *first_def,
  194|      2|                ..Default::default()
  195|      2|            });
  196|     68|        }
  197|       |
  198|       |        // Handle warnings
  199|     70|        if matches!(self, SemanticError::IncompatiblePointerComparison { .. }) {
                         ^69
  200|      1|            diagnostics[0].level = DiagnosticLevel::Warning;
  201|     69|        }
  202|       |
  203|     70|        diagnostics
  204|     70|    }
  205|       |}
  206|       |/// Semantic errors
  207|       |#[derive(Debug, thiserror::Error)]
  208|       |pub enum SemanticError {
  209|       |    #[error("variable has incomplete type 'void'")]
  210|       |    VariableOfVoidType { span: SourceSpan },
  211|       |    #[error("called object type '{ty}' is not a function or function pointer")]
  212|       |    CalledNonFunctionType { ty: String, span: SourceSpan },
  213|       |    #[error("Undeclared identifier '{name}'")]
  214|       |    UndeclaredIdentifier { name: NameId, span: SourceSpan },
  215|       |    #[error("redefinition of '{name}'")]
  216|       |    Redefinition {
  217|       |        name: NameId,
  218|       |        first_def: SourceSpan,
  219|       |        span: SourceSpan,
  220|       |    },
  221|       |    #[error("redefinition of '{name}' with a different type")]
  222|       |    RedefinitionWithDifferentType {
  223|       |        name: NameId,
  224|       |        first_def: SourceSpan,
  225|       |        span: SourceSpan,
  226|       |    },
  227|       |    #[error("type mismatch: expected {expected}, found {found}")]
  228|       |    TypeMismatch {
  229|       |        expected: String,
  230|       |        found: String,
  231|       |        span: SourceSpan,
  232|       |    },
  233|       |    #[error("Expression is not assignable (not an lvalue)")]
  234|       |    NotAnLvalue { span: SourceSpan },
  235|       |    #[error("Invalid operands for binary operation: have '{left_ty}' and '{right_ty}'")]
  236|       |    InvalidBinaryOperands {
  237|       |        left_ty: String,
  238|       |        right_ty: String,
  239|       |        span: SourceSpan,
  240|       |    },
  241|       |    #[error("Invalid operand for unary operation: have '{ty}'")]
  242|       |    InvalidUnaryOperand { ty: String, span: SourceSpan },
  243|       |    #[error("Initializer element is not a compile-time constant")]
  244|       |    NonConstantInitializer { span: SourceSpan },
  245|       |    #[error("invalid initializer")]
  246|       |    InvalidInitializer { span: SourceSpan },
  247|       |    #[error("Invalid use of void type in expression")]
  248|       |    InvalidUseOfVoid { span: SourceSpan },
  249|       |    #[error("conflicting types for '{name}'")]
  250|       |    ConflictingTypes {
  251|       |        name: String,
  252|       |        span: SourceSpan,
  253|       |        first_def: SourceSpan,
  254|       |    },
  255|       |    #[error("void function '{name}' should not return a value")]
  256|       |    VoidReturnWithValue { name: String, span: SourceSpan },
  257|       |    #[error("non-void function '{name}' should return a value")]
  258|       |    NonVoidReturnWithoutValue { name: String, span: SourceSpan },
  259|       |
  260|       |    #[error("excess elements in {kind} initializer")]
  261|       |    ExcessElements { kind: String, span: SourceSpan },
  262|       |
  263|       |    #[error("Unsupported feature: {feature}")]
  264|       |    UnsupportedFeature { feature: String, span: SourceSpan },
  265|       |
  266|       |    #[error("size of array has non-positive value")]
  267|       |    InvalidArraySize { span: SourceSpan },
  268|       |
  269|       |    #[error("bit-field has non-positive width")]
  270|       |    InvalidBitfieldWidth { span: SourceSpan },
  271|       |
  272|       |    #[error("bit-field width is not a constant expression")]
  273|       |    NonConstantBitfieldWidth { span: SourceSpan },
  274|       |
  275|       |    #[error("bit-field type '{ty}' is invalid")]
  276|       |    InvalidBitfieldType { ty: String, span: SourceSpan },
  277|       |
  278|       |    // Errors related to declaration specifiers
  279|       |    #[error("conflicting storage class specifiers")]
  280|       |    ConflictingStorageClasses { span: SourceSpan },
  281|       |    #[error("conflicting linkage for '{name}'")]
  282|       |    ConflictingLinkage {
  283|       |        name: String,
  284|       |        span: SourceSpan,
  285|       |        first_def: SourceSpan,
  286|       |    },
  287|       |    #[error("cannot combine with previous '{prev}' declaration specifier")]
  288|       |    ConflictingTypeSpecifiers { prev: String, span: SourceSpan },
  289|       |    #[error("'{spec}' function specifier appears on non-function declaration")]
  290|       |    InvalidFunctionSpecifier { spec: String, span: SourceSpan },
  291|       |    #[error("duplicate member '{name}'")]
  292|       |    DuplicateMember {
  293|       |        name: NameId,
  294|       |        span: SourceSpan,
  295|       |        first_def: SourceSpan,
  296|       |    },
  297|       |    #[error("member reference base type '{ty}' is not a structure or union")]
  298|       |    MemberAccessOnNonRecord { ty: String, span: SourceSpan },
  299|       |    #[error("no member named '{name}' in '{ty}'")]
  300|       |    MemberNotFound { name: NameId, ty: String, span: SourceSpan },
  301|       |    #[error("expected a typedef name, found {found}")]
  302|       |    ExpectedTypedefName { found: String, span: SourceSpan },
  303|       |    #[error("missing type specifier in declaration")]
  304|       |    MissingTypeSpecifier { span: SourceSpan },
  305|       |    #[error("static assertion failed: {message}")]
  306|       |    StaticAssertFailed { message: String, span: SourceSpan },
  307|       |    #[error("expression in static assertion is not constant")]
  308|       |    StaticAssertNotConstant { span: SourceSpan },
  309|       |    #[error("recursive type definition")]
  310|       |    RecursiveType { ty: TypeRef },
  311|       |    #[error("Invalid application of 'sizeof' to an incomplete type")]
  312|       |    SizeOfIncompleteType { ty: TypeRef, span: SourceSpan },
  313|       |    #[error("Invalid application of 'sizeof' to a function type")]
  314|       |    SizeOfFunctionType { span: SourceSpan },
  315|       |    #[error("controlling expression type does not match any generic association")]
  316|       |    GenericNoMatch { span: SourceSpan },
  317|       |
  318|       |    #[error("requested alignment is not a positive power of 2")]
  319|       |    InvalidAlignment { value: i64, span: SourceSpan },
  320|       |
  321|       |    #[error("requested alignment is not a constant expression")]
  322|       |    NonConstantAlignment { span: SourceSpan },
  323|       |
  324|       |    #[error("cannot assign to read-only location")]
  325|       |    AssignmentToReadOnly { span: SourceSpan },
  326|       |
  327|       |    #[error("incomplete type '{ty}'")]
  328|       |    IncompleteType { ty: String, span: SourceSpan },
  329|       |
  330|       |    #[error("comparison of incompatible pointer types '{lhs}' and '{rhs}'")]
  331|       |    IncompatiblePointerComparison { lhs: String, rhs: String, span: SourceSpan },
  332|       |
  333|       |    #[error("'case' or 'default' label not in switch statement")]
  334|       |    CaseNotInSwitch { span: SourceSpan },
  335|       |
  336|       |    #[error("duplicate case value '{value}'")]
  337|       |    DuplicateCase { value: String, span: SourceSpan },
  338|       |
  339|       |    #[error("multiple default labels in one switch")]
  340|       |    MultipleDefaultLabels { span: SourceSpan },
  341|       |
  342|       |    #[error("flexible array member must be the last member of a structure")]
  343|       |    FlexibleArrayNotLast { span: SourceSpan },
  344|       |
  345|       |    #[error("flexible array member in otherwise empty structure")]
  346|       |    FlexibleArrayInEmptyStruct { span: SourceSpan },
  347|       |
  348|       |    #[error("restrict requires a pointer type")]
  349|       |    InvalidRestrict { span: SourceSpan },
  350|       |    #[error("function '{name}' declared '_Noreturn' should not return")]
  351|       |    NoreturnFunctionReturns { name: String, span: SourceSpan },
  352|       |    #[error("unreachable code")]
  353|       |    UnreachableCode { span: SourceSpan },
  354|       |}
  355|       |
  356|       |impl SemanticError {
  357|     70|    pub fn span(&self) -> SourceSpan {
  358|     70|        match self {
  359|      1|            SemanticError::VariableOfVoidType { span } => *span,
  360|      1|            SemanticError::CalledNonFunctionType { span, .. } => *span,
  361|      1|            SemanticError::InvalidRestrict { span } => *span,
  362|      1|            SemanticError::UndeclaredIdentifier { span, .. } => *span,
  363|      4|            SemanticError::Redefinition { span, .. } => *span,
  364|      1|            SemanticError::RedefinitionWithDifferentType { span, .. } => *span,
  365|      9|            SemanticError::TypeMismatch { span, .. } => *span,
  366|      9|            SemanticError::NotAnLvalue { span } => *span,
  367|      1|            SemanticError::InvalidBinaryOperands { span, .. } => *span,
  368|      1|            SemanticError::InvalidUnaryOperand { span, .. } => *span,
  369|      0|            SemanticError::NonConstantInitializer { span } => *span,
  370|      1|            SemanticError::InvalidInitializer { span } => *span,
  371|      0|            SemanticError::InvalidUseOfVoid { span } => *span,
  372|      2|            SemanticError::ConflictingTypes { span, .. } => *span,
  373|      1|            SemanticError::VoidReturnWithValue { span, .. } => *span,
  374|      0|            SemanticError::NonVoidReturnWithoutValue { span, .. } => *span,
  375|      1|            SemanticError::ExcessElements { span, .. } => *span,
  376|      0|            SemanticError::UnsupportedFeature { span, .. } => *span,
  377|      1|            SemanticError::InvalidArraySize { span } => *span,
  378|      0|            SemanticError::InvalidBitfieldWidth { span } => *span,
  379|      0|            SemanticError::NonConstantBitfieldWidth { span } => *span,
  380|      1|            SemanticError::InvalidBitfieldType { span, .. } => *span,
  381|      3|            SemanticError::ConflictingStorageClasses { span } => *span,
  382|      1|            SemanticError::ConflictingLinkage { span, .. } => *span,
  383|      0|            SemanticError::ConflictingTypeSpecifiers { span, .. } => *span,
  384|      0|            SemanticError::InvalidFunctionSpecifier { span, .. } => *span,
  385|      3|            SemanticError::DuplicateMember { span, .. } => *span,
  386|      0|            SemanticError::MemberAccessOnNonRecord { span, .. } => *span,
  387|      1|            SemanticError::MemberNotFound { span, .. } => *span,
  388|      0|            SemanticError::ExpectedTypedefName { span, .. } => *span,
  389|      0|            SemanticError::MissingTypeSpecifier { span } => *span,
  390|      2|            SemanticError::StaticAssertFailed { span, .. } => *span,
  391|      1|            SemanticError::StaticAssertNotConstant { span } => *span,
  392|       |            SemanticError::RecursiveType { .. } => {
  393|       |                // For recursive types, we don't have a specific span, so use a dummy span
  394|      1|                SourceSpan::dummy()
  395|       |            }
  396|      2|            SemanticError::SizeOfIncompleteType { span, .. } => *span,
  397|      1|            SemanticError::SizeOfFunctionType { span } => *span,
  398|      1|            SemanticError::GenericNoMatch { span } => *span,
  399|      2|            SemanticError::InvalidAlignment { span, .. } => *span,
  400|      0|            SemanticError::NonConstantAlignment { span } => *span,
  401|      8|            SemanticError::AssignmentToReadOnly { span } => *span,
  402|      2|            SemanticError::IncompleteType { span, .. } => *span,
  403|      1|            SemanticError::IncompatiblePointerComparison { span, .. } => *span,
  404|      1|            SemanticError::CaseNotInSwitch { span } => *span,
  405|      1|            SemanticError::DuplicateCase { span, .. } => *span,
  406|      0|            SemanticError::MultipleDefaultLabels { span } => *span,
  407|      1|            SemanticError::FlexibleArrayNotLast { span } => *span,
  408|      0|            SemanticError::FlexibleArrayInEmptyStruct { span } => *span,
  409|      2|            SemanticError::NoreturnFunctionReturns { span, .. } => *span,
  410|      0|            SemanticError::UnreachableCode { span } => *span,
  411|       |        }
  412|     70|    }
  413|       |}
  414|       |
  415|       |/// Configurable error formatter using annotate_snippets
  416|       |pub struct ErrorFormatter {
  417|       |    pub show_source: bool,
  418|       |    pub show_hints: bool,
  419|       |    pub use_colors: bool,
  420|       |    pub max_context: usize,
  421|       |}
  422|       |
  423|       |impl Default for ErrorFormatter {
  424|     13|    fn default() -> Self {
  425|     13|        ErrorFormatter {
  426|     13|            show_source: true,
  427|     13|            show_hints: true,
  428|     13|            use_colors: true,
  429|     13|            max_context: 3,
  430|     13|        }
  431|     13|    }
  432|       |}
  433|       |
  434|       |impl ErrorFormatter {
  435|      0|    fn format_location(&self, diag: &Diagnostic, source_manager: &SourceManager) -> String {
  436|      0|        let path = source_manager
  437|      0|            .get_file_info(diag.span.source_id())
  438|      0|            .map(|fi| fi.path.to_str().unwrap_or("<unknown>"))
  439|      0|            .unwrap_or("<unknown>");
  440|       |
  441|       |        // Get line and column information
  442|      0|        let line_col = source_manager.get_line_column(diag.span.start());
  443|      0|        if let Some((line, col)) = line_col {
  444|      0|            format!("{}:{}:{}", path, line, col)
  445|       |        } else {
  446|      0|            path.to_string()
  447|       |        }
  448|      0|    }
  449|       |
  450|      0|    fn level<'a>(&self, diag: &Diagnostic) -> Level<'a> {
  451|      0|        match diag.level {
  452|      0|            DiagnosticLevel::Error => Level::ERROR,
  453|      0|            DiagnosticLevel::Warning => Level::WARNING,
  454|      0|            DiagnosticLevel::Note => Level::NOTE,
  455|       |        }
  456|      0|    }
  457|       |
  458|      0|    fn create_snippet<'a>(
  459|      0|        &self,
  460|      0|        span: SourceSpan,
  461|      0|        message: &'a str,
  462|      0|        source_manager: &'a SourceManager,
  463|      0|    ) -> Snippet<'a, annotate_snippets::Annotation<'a>> {
  464|      0|        let source_buffer = source_manager.get_buffer(span.source_id());
  465|      0|        let source = std::str::from_utf8(source_buffer).unwrap_or("");
  466|      0|        let path = source_manager
  467|      0|            .get_file_info(span.source_id())
  468|      0|            .map(|fi| fi.path.to_str().unwrap_or("<unknown>"))
  469|      0|            .unwrap_or("<unknown>");
  470|       |
  471|      0|        let mut snippet = Snippet::source(source).line_start(1).path(path);
  472|       |
  473|      0|        let annotation_kind = AnnotationKind::Primary;
  474|       |
  475|      0|        snippet = snippet.annotation(
  476|      0|            annotation_kind
  477|      0|                .span(span.start().offset() as usize..span.end().offset() as usize)
  478|      0|                .label(message),
  479|       |        );
  480|       |
  481|      0|        snippet
  482|      0|    }
  483|       |
  484|       |    /// Format a single diagnostic with rich source code context
  485|      0|    fn format_diagnostic(&self, diag: &Diagnostic, source_manager: &SourceManager) -> String {
  486|      0|        let renderer = if self.use_colors {
  487|      0|            Renderer::styled().decor_style(DecorStyle::Unicode)
  488|       |        } else {
  489|      0|            Renderer::plain()
  490|       |        };
  491|       |
  492|       |        // If it's a built-in source ID (e.g. command line define), simple print
  493|      0|        if diag.span.is_source_id_builtin() {
  494|      0|            return format!("{}: {}", self.format_location(diag, source_manager), diag.message);
  495|      0|        }
  496|       |
  497|       |        // Primary error snippet
  498|      0|        let snippet = self.create_snippet(diag.span, &diag.message, source_manager);
  499|       |        // Use primary_title instead of title
  500|      0|        let mut group = self.level(diag).primary_title(&diag.message).element(snippet);
  501|       |
  502|      0|        for hint in &diag.hints {
  503|      0|            group = group.element(Level::HELP.message(hint));
  504|      0|        }
  505|       |
  506|       |        // Handle macro expansion history
  507|       |        // We must collect strings first to ensure they live long enough for the snippets
  508|      0|        let mut expansion_history = Vec::new();
  509|      0|        let mut current_id = diag.span.source_id();
  510|       |
  511|      0|        while let Some(file_info) = source_manager.get_file_info(current_id) {
  512|      0|            if let Some(include_loc) = file_info.include_loc {
  513|       |                // Determine if this is a macro expansion (virtual file) or an include
  514|      0|                let is_macro = file_info.path.to_str().is_some_and(|s| s.starts_with("<macro_"));
  515|      0|                let note_msg = if is_macro {
  516|      0|                    let macro_name = file_info
  517|      0|                        .path
  518|      0|                        .to_str()
  519|      0|                        .unwrap()
  520|      0|                        .trim_start_matches("<macro_")
  521|      0|                        .trim_end_matches('>');
  522|      0|                    format!("expanded from macro '{}'", macro_name)
  523|       |                } else {
  524|      0|                    "included from here".to_string()
  525|       |                };
  526|       |
  527|       |                // For visualization, use a 1-char span at the include/expansion location
  528|      0|                let exp_span = SourceSpan::new_with_length(include_loc.source_id(), include_loc.offset(), 1);
  529|      0|                expansion_history.push((exp_span, note_msg));
  530|       |
  531|      0|                current_id = include_loc.source_id();
  532|       |            } else {
  533|      0|                break;
  534|       |            }
  535|       |        }
  536|       |
  537|      0|        for (span, msg) in &expansion_history {
  538|      0|            let exp_snippet = self.create_snippet(*span, msg, source_manager);
  539|      0|            group = group.element(exp_snippet);
  540|      0|        }
  541|       |
  542|      0|        let report = &[group];
  543|      0|        renderer.render(report).to_string()
  544|      0|    }
  545|       |
  546|       |    /// Print all diagnostics to stderr
  547|     13|    pub fn print_diagnostics(&self, diagnostics: &[Diagnostic], source_manager: &SourceManager) {
  548|     13|        for diag in diagnostics {
                          ^0
  549|      0|            let formatted = self.format_diagnostic(diag, source_manager);
  550|      0|            eprintln!("{}", formatted);
  551|      0|        }
  552|     13|    }
  553|       |}

/app/src/driver/cli.rs:
    1|       |//! CLI parsing and configuration module
    2|       |//!
    3|       |//! This module handles command-line argument parsing using clap and
    4|       |//! provides configuration structures for the compiler driver.
    5|       |
    6|       |use clap::{Args, Parser as CliParser};
    7|       |use std::path::PathBuf;
    8|       |use target_lexicon::Triple;
    9|       |
   10|       |use crate::{
   11|       |    driver::artifact::CompilePhase,
   12|       |    lang_options::{CStandard, LangOptions},
   13|       |};
   14|       |
   15|       |/// CLI interface using clap
   16|       |#[derive(CliParser, Debug)]
   17|       |#[clap(name = "cendol", about = "C11 Compiler written in Rust", allow_hyphen_values = true)]
   18|       |pub struct Cli {
   19|       |    /// Input C source files
   20|       |    #[clap(value_parser, required = true)]
   21|       |    pub input_files: Vec<PathBuf>,
   22|       |
   23|       |    /// Output file for AST dump
   24|       |    #[clap(short, long, value_name = "FILE")]
   25|       |    pub output: Option<PathBuf>,
   26|       |
   27|       |    /// Enable verbose diagnostic output
   28|       |    #[clap(short, long)]
   29|       |    pub verbose: bool,
   30|       |
   31|       |    /// Dump AST after parser phase
   32|       |    #[clap(long)]
   33|       |    pub dump_ast_after_parser: bool,
   34|       |
   35|       |    /// Dump AST after semantic lowering phase
   36|       |    #[clap(long)]
   37|       |    pub dump_ast_after_semantic_lowering: bool,
   38|       |
   39|       |    /// Dump MIR (Mid-level Intermediate Representation) to console
   40|       |    #[clap(long)]
   41|       |    pub dump_mir: bool,
   42|       |
   43|       |    /// Dump Cranelift IR (Intermediate Representation) to console
   44|       |    #[clap(long)]
   45|       |    pub dump_cranelift: bool,
   46|       |
   47|       |    /// Preprocess only, output preprocessed source to stdout
   48|       |    #[clap(short = 'E')]
   49|       |    pub preprocess_only: bool,
   50|       |
   51|       |    /// Preprocessor options
   52|       |    #[clap(flatten)]
   53|       |    pub preprocessor: PreprocessorOptions,
   54|       |
   55|       |    /// Suppress line markers in preprocessor output
   56|       |    #[clap(short = 'P')]
   57|       |    pub suppress_line_markers: bool,
   58|       |
   59|       |    /// Retain comments in preprocessor output
   60|       |    #[clap(short = 'C', long = "retain-comments")]
   61|       |    pub retain_comments: bool,
   62|       |
   63|       |    /// Include search paths
   64|       |    #[clap(short = 'I', long = "include-path", value_name = "DIR", action = clap::ArgAction::Append)]
   65|       |    pub include_paths: Vec<PathBuf>,
   66|       |
   67|       |    /// Preprocessor macro definitions
   68|       |    #[clap(short = 'D', long = "define", value_name = "NAME[=VALUE]", action = clap::ArgAction::Append)]
   69|       |    pub defines: Vec<String>,
   70|       |
   71|       |    /// Compiler warnings
   72|       |    #[clap(short = 'W', action = clap::ArgAction::Append)]
   73|       |    pub warnings: Vec<String>,
   74|       |
   75|       |    /// Enable all warnings
   76|       |    #[clap(long = "Wall")]
   77|       |    pub wall: bool,
   78|       |
   79|       |    /// Set C language standard (e.g., c99, c11)
   80|       |    #[clap(long = "std", value_name = "STANDARD")]
   81|       |    pub c_standard: Option<CStandard>,
   82|       |
   83|       |    /// Target triple (e.g. x86_64-unknown-linux-gnu)
   84|       |    #[clap(long = "target", value_name = "TRIPLE")]
   85|       |    pub target: Option<String>,
   86|       |}
   87|       |
   88|       |#[derive(Args, Debug)]
   89|       |pub struct PreprocessorOptions {
   90|       |    /// Maximum include depth
   91|       |    #[clap(long, default_value = "100")]
   92|       |    pub max_include_depth: usize,
   93|       |}
   94|       |
   95|       |/// input file can be path to file or string buffer pair (filename, buffer)
   96|       |#[derive(Debug, Clone)]
   97|       |pub enum PathOrBuffer {
   98|       |    Path(PathBuf),
   99|       |    Buffer(String, Vec<u8>),
  100|       |}
  101|       |
  102|       |/// Configuration for compilation
  103|       |#[derive(Debug)]
  104|       |pub struct CompileConfig {
  105|       |    pub input_files: Vec<PathOrBuffer>,
  106|       |    pub output_path: Option<PathBuf>,
  107|       |    pub stop_after: CompilePhase,
  108|       |
  109|       |    pub verbose: bool,
  110|       |    pub preprocessor: crate::pp::PPConfig,
  111|       |    pub suppress_line_markers: bool,
  112|       |    pub include_paths: Vec<PathBuf>,
  113|       |    pub defines: Vec<(String, Option<String>)>, // NAME -> VALUE
  114|       |    pub warnings: Vec<String>,
  115|       |    pub lang_options: LangOptions,
  116|       |    pub target: Triple,
  117|       |}
  118|       |
  119|       |impl Default for CompileConfig {
  120|    611|    fn default() -> Self {
  121|    611|        Self {
  122|    611|            input_files: Vec::new(),
  123|    611|            output_path: None,
  124|    611|            stop_after: CompilePhase::EmitObject,
  125|    611|            verbose: false,
  126|    611|            preprocessor: crate::pp::PPConfig::default(),
  127|    611|            suppress_line_markers: false,
  128|    611|            include_paths: Vec::new(),
  129|    611|            defines: Vec::new(),
  130|    611|            warnings: Vec::new(),
  131|    611|            lang_options: LangOptions::default(),
  132|    611|            target: Triple::host(),
  133|    611|        }
  134|    611|    }
  135|       |}
  136|       |
  137|       |impl CompileConfig {
  138|       |    /// Create a new CompileConfig from a string of source code
  139|       |    /// it used by tests infrastructure
  140|       |    #[cfg(test)]
  141|    602|    pub(crate) fn from_virtual_file(source: String, stop_after: CompilePhase) -> Self {
  142|    602|        let filename = "example.c";
  143|    602|        let source = source.into_bytes();
  144|       |
  145|    602|        Self {
  146|    602|            input_files: vec![PathOrBuffer::Buffer(filename.to_string(), source)],
  147|    602|            stop_after,
  148|    602|            target: Triple::host(),
  149|    602|            ..Default::default()
  150|    602|        }
  151|    602|    }
  152|       |}
  153|       |
  154|       |impl Cli {
  155|       |    /// Validate input files and check for option-like filenames
  156|      0|    fn validate_input_files(&self) -> Result<(), String> {
  157|      0|        for input_file in &self.input_files {
  158|      0|            let file_name = input_file.to_string_lossy();
  159|      0|            if file_name.starts_with('-') {
  160|      0|                return Err(format!("File '{}' not found: No such file or directory", file_name)
  161|      0|                    + "\n"
  162|      0|                    + "If this is meant to be a command-line option, place it before the filename.\n"
  163|      0|                    + &format!(
  164|      0|                        "Example: {} -o output_file",
  165|      0|                        std::env::args().next().unwrap_or("cendol".to_string())
  166|      0|                    ));
  167|      0|            }
  168|       |        }
  169|      0|        Ok(())
  170|      0|    }
  171|       |
  172|       |    /// Convert CLI arguments into compilation configuration
  173|      0|    pub fn into_config(self) -> Result<CompileConfig, String> {
  174|       |        // Validate input files first
  175|      0|        self.validate_input_files()?;
  176|       |
  177|       |        // Parse defines
  178|      0|        let defines = self
  179|      0|            .defines
  180|      0|            .iter()
  181|      0|            .map(|def| {
  182|      0|                if let Some(eq_pos) = def.find('=') {
  183|      0|                    let name = def[..eq_pos].to_string();
  184|      0|                    let value = Some(def[eq_pos + 1..].to_string());
  185|      0|                    (name, value)
  186|       |                } else {
  187|      0|                    (def.clone(), None)
  188|       |                }
  189|      0|            })
  190|      0|            .collect();
  191|       |
  192|       |        // Handle -Wall flag by adding "all" to warnings if -Wall is specified
  193|      0|        let mut warnings = self.warnings;
  194|      0|        if self.wall {
  195|      0|            warnings.push("all".to_string());
  196|      0|        }
  197|       |
  198|       |        // Build language options
  199|       |
  200|      0|        let lang_options = LangOptions {
  201|      0|            c_standard: self.c_standard,
  202|      0|        };
  203|       |
  204|       |        // Build preprocessor configuration with include paths
  205|      0|        let mut system_include_paths = Vec::new();
  206|       |
  207|       |        // Add user-specified include paths as system include paths
  208|      0|        for path in &self.include_paths {
  209|      0|            system_include_paths.push(path.clone());
  210|      0|        }
  211|       |
  212|       |        // Add default system include paths
  213|      0|        system_include_paths.push(PathBuf::from("/usr/include"));
  214|       |
  215|       |        // Add architecture-specific include paths
  216|      0|        let arch_paths = [
  217|      0|            "/usr/include/x86_64-linux-gnu",
  218|      0|            "/usr/include/x86_64-linux-gnu/c++/13",
  219|      0|            "/usr/include/c++/13",
  220|      0|        ];
  221|       |
  222|      0|        for arch_path in &arch_paths {
  223|      0|            let path = PathBuf::from(arch_path);
  224|      0|            if path.exists() {
  225|      0|                system_include_paths.push(path);
  226|      0|            }
  227|       |        }
  228|       |
  229|      0|        let stop_after = if self.preprocess_only {
  230|      0|            CompilePhase::Preprocess
  231|      0|        } else if self.dump_ast_after_parser {
  232|      0|            CompilePhase::Parse
  233|      0|        } else if self.dump_ast_after_semantic_lowering {
  234|      0|            CompilePhase::SemanticLowering
  235|      0|        } else if self.dump_mir {
  236|      0|            CompilePhase::Mir
  237|      0|        } else if self.dump_cranelift {
  238|      0|            CompilePhase::Cranelift
  239|       |        } else {
  240|      0|            CompilePhase::EmitObject
  241|       |        };
  242|       |
  243|      0|        let target_triple = if let Some(t) = self.target {
  244|      0|            t.parse::<Triple>()
  245|      0|                .map_err(|e| format!("Invalid target triple: {}", e))?
  246|       |        } else {
  247|      0|            Triple::host()
  248|       |        };
  249|       |
  250|      0|        Ok(CompileConfig {
  251|      0|            input_files: self.input_files.into_iter().map(PathOrBuffer::Path).collect(),
  252|      0|            output_path: self.output,
  253|      0|            stop_after,
  254|      0|            verbose: self.verbose,
  255|      0|            preprocessor: crate::pp::PPConfig {
  256|      0|                max_include_depth: self.preprocessor.max_include_depth,
  257|      0|                system_include_paths,
  258|      0|                target: target_triple.clone(),
  259|      0|                ..Default::default()
  260|      0|            },
  261|      0|            suppress_line_markers: self.suppress_line_markers,
  262|      0|            include_paths: self.include_paths,
  263|      0|            defines,
  264|      0|            warnings,
  265|      0|            lang_options,
  266|      0|            target: target_triple,
  267|      0|        })
  268|      0|    }
  269|       |}

/app/src/driver/compiler.rs:
    1|       |//! Core compilation pipeline orchestration module
    2|       |//!
    3|       |//! This module contains the main compiler driver that orchestrates
    4|       |//! the compilation pipeline including preprocessing, lexing, parsing,
    5|       |//! semantic analysis, and output generation.
    6|       |
    7|       |use indexmap::IndexMap;
    8|       |
    9|       |use crate::ast::dumper::AstDumper;
   10|       |use crate::ast::{Ast, NodeKind, NodeRef, ParsedAst, SourceId};
   11|       |use crate::diagnostic::{Diagnostic, DiagnosticEngine, DiagnosticLevel};
   12|       |use crate::driver::cli::PathOrBuffer;
   13|       |use crate::lexer::{Lexer, Token};
   14|       |use crate::mir::codegen::{ClifOutput, EmitKind, MirToCraneliftLowerer};
   15|       |use crate::mir::validation::MirValidator;
   16|       |
   17|       |use super::artifact::{CompileArtifact, CompilePhase, PipelineOutputs};
   18|       |use crate::mir::MirProgram;
   19|       |use crate::mir::dumper::{MirDumpConfig, MirDumper};
   20|       |use crate::parser::Parser;
   21|       |use crate::pp::{PPToken, Preprocessor};
   22|       |use crate::semantic::{AstToMirLowerer, SymbolTable, TypeRegistry};
   23|       |use crate::source_manager::SourceManager;
   24|       |
   25|       |use super::cli::CompileConfig;
   26|       |use super::output::OutputHandler;
   27|       |
   28|       |/// Main compiler driver
   29|       |pub struct CompilerDriver {
   30|       |    config: CompileConfig,
   31|       |    diagnostics: DiagnosticEngine,
   32|       |    pub(crate) source_manager: SourceManager,
   33|       |    output_handler: OutputHandler,
   34|       |}
   35|       |
   36|       |impl CompilerDriver {
   37|       |    /// Create a new compiler driver from CLI arguments
   38|      0|    pub fn new(cli: super::cli::Cli) -> Result<Self, String> {
   39|      0|        let config = cli.into_config()?;
   40|      0|        Ok(Self::from_config(config))
   41|      0|    }
   42|       |
   43|       |    /// Create a new compiler driver from configuration
   44|    611|    pub(crate) fn from_config(config: CompileConfig) -> Self {
   45|    611|        let diagnostics = DiagnosticEngine::from_warnings(&config.warnings);
   46|    611|        CompilerDriver {
   47|    611|            diagnostics,
   48|    611|            source_manager: SourceManager::new(),
   49|    611|            output_handler: OutputHandler::new(),
   50|    611|            config,
   51|    611|        }
   52|    611|    }
   53|       |
   54|    611|    pub(crate) fn run_pipeline(&mut self, stop_after: CompilePhase) -> Result<PipelineOutputs, PipelineError> {
   55|    611|        let mut outputs = PipelineOutputs { units: IndexMap::new() };
   56|       |
   57|       |        // Process each input file
   58|    611|        let input_files = std::mem::take(&mut self.config.input_files);
   59|  1.14k|        for input_file in input_files {
                          ^611
   60|    611|            let source_id = match input_file {
   61|      0|                PathOrBuffer::Path(path) => match self.source_manager.add_file_from_path(&path, None) {
   62|      0|                    Ok(id) => id,
   63|      0|                    Err(e) => return Err(PipelineError::IoError(e)),
   64|       |                },
   65|    611|                PathOrBuffer::Buffer(path, buffer) => self.source_manager.add_buffer(buffer, &path, None),
   66|       |            };
   67|       |
   68|    611|            let unit_output = self.run_translation_unit(source_id, stop_after)?;
                              ^534                                                          ^77
   69|    534|            outputs.units.insert(source_id, unit_output);
   70|       |        }
   71|       |
   72|    534|        Ok(outputs)
   73|    611|    }
   74|       |
   75|    611|    fn run_translation_unit(
   76|    611|        &mut self,
   77|    611|        source_id: SourceId,
   78|    611|        stop_after: CompilePhase,
   79|    611|    ) -> Result<CompileArtifact, PipelineError> {
   80|    611|        let mut out = CompileArtifact::default();
   81|       |
   82|       |        // Preprocessing phase
   83|    611|        let pp_tokens = self.run_preprocessor(source_id)?;
                                                                      ^0
   84|    611|        if stop_after == CompilePhase::Preprocess {
   85|      0|            out.preprocessed = Some(pp_tokens);
   86|      0|            return Ok(out);
   87|    611|        }
   88|       |
   89|       |        // Lexing phase
   90|    611|        let tokens = self.run_lexer(&pp_tokens)?;
                                                             ^0
   91|    611|        if stop_after == CompilePhase::Lex {
   92|    242|            out.lexed = Some(tokens);
   93|    242|            return Ok(out);
   94|    369|        }
   95|       |
   96|       |        // parsing phase
   97|    369|        let parsed_ast = self.run_parser(&tokens)?;
                                                               ^0
   98|    369|        if stop_after == CompilePhase::Parse {
   99|    156|            out.parsed_ast = Some(parsed_ast);
  100|    156|            return Ok(out);
  101|    213|        }
  102|       |
  103|       |        // semantic lowering (Symbol Resolution & AST Construction)
  104|    213|        let (ast, symbol_table, registry) = self.run_semantic_lowering(parsed_ast)?;
                           ^189 ^189          ^189                                              ^24
  105|    189|        if stop_after == CompilePhase::SemanticLowering {
  106|     44|            out.ast = Some(ast);
  107|     44|            out.type_registry = Some(registry);
  108|     44|            out.symbol_table = Some(symbol_table);
  109|     44|            return Ok(out);
  110|    145|        }
  111|       |
  112|       |        // semantic analyzer & MIR generation phase
  113|    145|        let sema_output = self.run_semantic_analyzer(ast, symbol_table, registry)?;
                          ^100                                                                 ^45
  114|    100|        if stop_after == CompilePhase::Mir {
  115|     70|            out.sema_output = Some(sema_output);
  116|     70|            return Ok(out);
  117|     30|        }
  118|       |
  119|       |        // Cranelift code generation phase
  120|     30|        let emit_kind = if stop_after == CompilePhase::Cranelift {
  121|      9|            EmitKind::Clif
  122|       |        } else {
  123|     21|            EmitKind::Object
  124|       |        };
  125|     30|        let cl_output = self.run_codegen(sema_output, emit_kind)?;
                                                                              ^0
  126|       |
  127|     30|        match cl_output {
  128|      9|            ClifOutput::ClifDump(dump) => {
  129|      9|                out.clif_dump = Some(dump);
  130|      9|            }
  131|     21|            ClifOutput::ObjectFile(obj) => {
  132|     21|                out.object_file = Some(obj);
  133|     21|            }
  134|       |        }
  135|       |
  136|     30|        Ok(out)
  137|    611|    }
  138|       |
  139|    611|    fn run_preprocessor(&mut self, source_id: SourceId) -> Result<Vec<PPToken>, PipelineError> {
  140|    611|        let mut preprocessor = Preprocessor::new(
  141|    611|            &mut self.source_manager,
  142|    611|            &mut self.diagnostics,
  143|    611|            &self.config.preprocessor,
  144|       |        );
  145|       |
  146|       |        // Preprocessor is dropped here, releasing the borrow on diagnostics
  147|    611|        match preprocessor.process(source_id, &self.config.preprocessor) {
  148|    611|            Ok(t) => Ok(t),
  149|      0|            Err(e) => {
  150|       |                // Report the specific preprocessor error
  151|      0|                self.diagnostics.report_diagnostic(e.into());
  152|      0|                Err(PipelineError::Fatal)
  153|       |            }
  154|       |        }
  155|    611|    }
  156|       |
  157|    606|    fn run_lexer(&mut self, pp_tokens: &[PPToken]) -> Result<Vec<Token>, PipelineError> {
  158|    606|        let tokens = {
  159|    606|            let mut lexer = Lexer::new(pp_tokens);
  160|    606|            lexer.tokenize_all()
  161|       |        };
  162|       |
  163|       |        // Check for lexing errors and stop if any
  164|    606|        self.check_diagnostics_and_return_if_error()?;
                                                                  ^0
  165|       |
  166|    606|        Ok(tokens)
  167|    606|    }
  168|       |
  169|    363|    fn run_parser(&mut self, tokens: &[Token]) -> Result<ParsedAst, PipelineError> {
  170|       |        // Parsing phase
  171|    363|        let mut parsed_ast = ParsedAst::new();
  172|    363|        let mut parser = Parser::new(tokens, &mut parsed_ast, &mut self.diagnostics);
  173|    363|        match parser.parse_translation_unit() {
  174|    363|            Ok(_) => Ok(parsed_ast),
  175|      0|            Err(e) => {
  176|      0|                self.diagnostics.report(e);
  177|      0|                Err(PipelineError::Fatal)
  178|       |            }
  179|       |        }
  180|    363|    }
  181|       |
  182|    205|    fn run_semantic_lowering(
  183|    205|        &mut self,
  184|    205|        parsed_ast: ParsedAst,
  185|    205|    ) -> Result<(Ast, SymbolTable, TypeRegistry), PipelineError> {
  186|    205|        let mut symbol_table = SymbolTable::new();
  187|       |        // Use the target triple from configuration to initialize TypeRegistry
  188|    205|        let mut registry = TypeRegistry::new(self.config.target.clone());
  189|    205|        let mut ast = Ast::new();
  190|       |
  191|       |        use crate::semantic::lowering::run_semantic_lowering;
  192|    205|        run_semantic_lowering(
  193|    205|            &parsed_ast,
  194|    205|            &mut ast,
  195|    205|            &mut self.diagnostics,
  196|    205|            &mut symbol_table,
  197|    205|            &mut registry,
  198|       |        );
  199|       |
  200|    205|        self.check_diagnostics_and_return_if_error()?;
                                                                  ^24
  201|       |
  202|       |        // Validate that parsing-only node kinds have been lowered (actually they shouldn't exist in Ast now)
  203|       |        // But for safety/debugging:
  204|       |        #[cfg(debug_assertions)]
  205|  2.82k|        for kind in &ast.kinds {
                          ^2.64k
  206|     95|            match kind {
  207|     95|                NodeKind::BinaryOp(op, ..) if op.is_assignment() => {
                                                                             ^0
  208|      0|                    panic!(
  209|      0|                        "ICE: NodeKind::BinaryOp with assignment operator {:?}, use NodeKind::Assignment instead",
  210|       |                        op
  211|       |                    );
  212|       |                }
  213|     83|                NodeKind::Assignment(op, ..) if !op.is_assignment() => {
                                                                                ^0
  214|      0|                    panic!(
  215|      0|                        "ICE: NodeKind::Assignment with non-assignment operator {:?}, use NodeKind::BinaryOp instead",
  216|       |                        op
  217|       |                    );
  218|       |                }
  219|       |                // Check if any legacy variants slipped in (NodeKind shouldn't have them anymore so compile error if we match them)
  220|  2.64k|                _ => {}
  221|       |            }
  222|       |        }
  223|       |
  224|       |        #[cfg(debug_assertions)]
  225|  2.64k|        for (i, kind) in ast.kinds.iter().enumerate() {
                                       ^181             ^181
  226|  2.64k|            let parent_idx = i + 1;
  227|  2.64k|            kind.visit_children(|child| {
                                                      ^2.42k
  228|  2.42k|                let child_idx = child.get() as usize;
  229|  2.42k|                if child_idx <= parent_idx {
  230|      0|                    panic!(
  231|      0|                        "ICE: AST invariant violation: parent index ({}) >= child index ({}) for node {:?}",
  232|       |                        parent_idx, child_idx, kind
  233|       |                    );
  234|  2.42k|                }
  235|  2.42k|            });
  236|       |        }
  237|       |
  238|    181|        Ok((ast, symbol_table, registry))
  239|    205|    }
  240|       |
  241|    137|    fn run_semantic_analyzer(
  242|    137|        &mut self,
  243|    137|        mut ast: Ast,
  244|    137|        symbol_table: SymbolTable,
  245|    137|        mut registry: TypeRegistry,
  246|    137|    ) -> Result<MirProgram, PipelineError> {
  247|       |        use crate::semantic::analyzer::run_semantic_analyzer;
  248|    137|        let semantic_info = run_semantic_analyzer(&ast, &mut self.diagnostics, &symbol_table, &mut registry);
  249|    137|        self.check_diagnostics_and_return_if_error()?;
                                                                  ^45
  250|       |
  251|       |        // Attach semantic info to AST (like scope_map)
  252|     92|        ast.attach_semantic_info(semantic_info);
  253|       |
  254|       |        // invariant validations
  255|       |        // all expression must have resolved_type set
  256|  1.75k|        for (i, kind) in ast.kinds.iter().enumerate() {
                                       ^92              ^92
  257|  1.75k|            let node_ref = NodeRef::new((i as u32) + 1).unwrap();
  258|    208|            match kind {
  259|    208|                NodeKind::Ident(name, ..) if ast.get_resolved_type(node_ref).is_none() => {
                                                                                                   ^0
  260|      0|                    let span = ast.get_span(node_ref);
  261|      0|                    panic!(
  262|      0|                        "ICE: ident '{}' still not have resolved type: {:?}",
  263|       |                        name,
  264|      0|                        self.source_manager.get_line_column(span.start())
  265|       |                    );
  266|       |                }
  267|  1.75k|                _ => {}
  268|       |            }
  269|       |        }
  270|       |
  271|     92|        let mut sema = AstToMirLowerer::new(&ast, &symbol_table, &mut registry);
  272|     92|        let sema_output = sema.lower_module_complete();
  273|     92|        self.check_diagnostics_and_return_if_error()?;
                                                                  ^0
  274|       |
  275|     92|        Ok(sema_output)
  276|    137|    }
  277|       |
  278|     22|    fn run_codegen(&mut self, sema_output: MirProgram, emit_kind: EmitKind) -> Result<ClifOutput, PipelineError> {
  279|       |        // Validate MIR before code generation
  280|     22|        log::debug!("Running MIR validation");
                                  ^0
  281|     22|        let mut validator = MirValidator::new();
  282|     22|        if let Err(errors) = validator.validate(&sema_output) {
                                 ^0
  283|      0|            panic!("MIR validation failed: {:?}", errors);
  284|     22|        }
  285|       |
  286|       |        // Use MIR codegen instead of AST codegen
  287|     22|        let mir_codegen = MirToCraneliftLowerer::new(sema_output);
  288|     22|        match mir_codegen.compile_module(emit_kind) {
  289|     22|            Ok(output) => Ok(output),
  290|      0|            Err(e) => {
  291|      0|                self.diagnostics.report_diagnostic(Diagnostic {
  292|      0|                    level: DiagnosticLevel::Error,
  293|      0|                    message: e.to_string(),
  294|      0|                    ..Default::default()
  295|      0|                });
  296|      0|                Err(PipelineError::Fatal)
  297|       |            }
  298|       |        }
  299|     22|    }
  300|       |
  301|       |    /// Check if there are any diagnostics errors and return PipelineError::Fatal if there are
  302|  1.03k|    fn check_diagnostics_and_return_if_error(&self) -> Result<(), PipelineError> {
  303|  1.03k|        if self.diagnostics.has_errors() {
  304|     69|            Err(PipelineError::Fatal)
  305|       |        } else {
  306|    970|            Ok(())
  307|       |        }
  308|  1.03k|    }
  309|       |
  310|       |    /// Run the compilation process for all input files
  311|       |    /// this function handles the full pipeline from source to executable
  312|       |    /// and emit diagnostics if any error occurs
  313|     13|    pub fn run(&mut self) -> Result<(), DriverError> {
  314|     13|        let result = self.run_pipeline(self.config.stop_after);
  315|     13|        match result {
  316|     13|            Ok(outputs) => {
  317|     13|                self.print_diagnostics();
  318|     13|                let mut object_files_to_link = Vec::new();
  319|       |                // We need to keep the temp files alive until the linking process is complete
  320|     13|                let mut temp_files = Vec::new();
  321|       |
  322|       |                // Process outputs if needed
  323|     26|                for (_source_id, artifact) in outputs.units {
                                   ^13         ^13
  324|     13|                    if let Some(object_file) = artifact.object_file {
  325|       |                        // Write the object file to a temporary file
  326|     13|                        let mut temp_file = tempfile::Builder::new()
  327|     13|                            .suffix(".o")
  328|     13|                            .tempfile()
  329|     13|                            .map_err(|e| DriverError::IoError(format!("Failed to create temp file: {}", e)))?;
                                                                            ^0      ^0                                    ^0
  330|       |
  331|       |                        use std::io::Write;
  332|     13|                        temp_file
  333|     13|                            .write_all(&object_file)
  334|     13|                            .map_err(|e| DriverError::IoError(format!("Failed to write object file: {}", e)))?;
                                                                            ^0      ^0                                     ^0
  335|       |
  336|     13|                        object_files_to_link.push(temp_file.path().to_path_buf());
  337|     13|                        temp_files.push(temp_file);
  338|      0|                    } else if let Some(clif_dump) = artifact.clif_dump {
  339|      0|                        // Output Cranelift IR dump to console
  340|      0|                        println!("{}", clif_dump);
  341|      0|                    } else if let Some(sema_output) = artifact.sema_output {
  342|       |                        // Output MIR dump to console
  343|      0|                        let dump_config = MirDumpConfig { include_header: true };
  344|       |
  345|      0|                        let dumper = MirDumper::new(&sema_output, &dump_config);
  346|      0|                        match dumper.generate_mir_dump() {
  347|      0|                            Ok(mir_dump) => {
  348|      0|                                println!("{}", mir_dump);
  349|      0|                            }
  350|      0|                            Err(_e) => {
  351|      0|                                self.print_diagnostics();
  352|      0|                                return Err(DriverError::CompilationFailed);
  353|       |                            }
  354|       |                        }
  355|      0|                    } else if let Some(ast) = artifact.ast {
  356|      0|                        AstDumper::dump_parser(&ast, artifact.symbol_table.as_ref());
  357|      0|                        if let Some(registry) = artifact.type_registry {
  358|      0|                            AstDumper::dump_type_registry(&ast, &registry);
  359|      0|                        }
  360|      0|                    } else if let Some(parsed_ast) = artifact.parsed_ast {
  361|      0|                        AstDumper::dump_parsed_ast(&parsed_ast);
  362|      0|                    } else if let Some(preprocessed) = artifact.preprocessed {
  363|      0|                        self.output_handler.dump_preprocessed_output(
  364|      0|                            &preprocessed,
  365|      0|                            self.config.suppress_line_markers,
  366|      0|                            &self.source_manager,
  367|      0|                        )?;
  368|      0|                    }
  369|       |                }
  370|       |
  371|       |                // Link if we have object files
  372|     13|                if !object_files_to_link.is_empty() {
  373|       |                    // Determine the output path
  374|     13|                    let output_path = if let Some(output_path) = &self.config.output_path {
                                                                ^9
  375|      9|                        output_path.clone()
  376|       |                    } else {
  377|       |                        // Default to a.out if no output path is specified
  378|      4|                        "a.out".into()
  379|       |                    };
  380|       |
  381|       |                    // Link the object file into an executable using clang
  382|     13|                    let status = std::process::Command::new("clang")
  383|     13|                        .args(&object_files_to_link)
  384|     13|                        .arg("-lm")
  385|     13|                        .arg("-o")
  386|     13|                        .arg(&output_path)
  387|     13|                        .status()
  388|     13|                        .map_err(|e| DriverError::IoError(format!("Failed to execute clang for linking: {}", e)))?;
                                                                        ^0      ^0                                             ^0
  389|       |
  390|     13|                    if !status.success() {
  391|      0|                        return Err(DriverError::CompilationFailed);
  392|     13|                    }
  393|       |
  394|       |                    // Set executable permissions on the output file
  395|       |                    use std::os::unix::fs::PermissionsExt;
  396|     13|                    if let Ok(metadata) = std::fs::metadata(&output_path) {
  397|     13|                        let mut permissions = metadata.permissions();
  398|     13|                        permissions.set_mode(0o755); // rwxr-xr-x
  399|     13|                        if let Err(e) = std::fs::set_permissions(&output_path, permissions) {
                                                 ^0
  400|      0|                            eprintln!("Warning: Failed to set executable permissions: {}", e);
  401|     13|                        }
  402|      0|                    }
  403|      0|                }
  404|       |            }
  405|      0|            Err(e) => match e {
  406|      0|                PipelineError::IoError(io_err) => {
  407|      0|                    let message = format!("I/O Error: {}", io_err);
  408|      0|                    return Err(DriverError::IoError(message));
  409|       |                }
  410|       |                PipelineError::Fatal => {
  411|      0|                    self.print_diagnostics();
  412|      0|                    return Err(DriverError::CompilationFailed);
  413|       |                }
  414|       |            },
  415|       |        }
  416|       |
  417|     13|        Ok(())
  418|     13|    }
  419|       |
  420|       |    /// Get diagnostics for testing
  421|       |    #[cfg(test)]
  422|     68|    pub(crate) fn get_diagnostics(&self) -> Vec<Diagnostic> {
  423|     68|        self.diagnostics.diagnostics().to_vec()
  424|     68|    }
  425|       |
  426|      0|    pub fn has_errors(&self) -> bool {
  427|      0|        self.diagnostics.has_errors()
  428|      0|    }
  429|       |
  430|       |    /// Print accumulated diagnostics without returning an error
  431|     13|    pub fn print_diagnostics(&self) {
  432|     13|        let formatter = crate::diagnostic::ErrorFormatter::default();
  433|     13|        formatter.print_diagnostics(self.diagnostics.diagnostics(), &self.source_manager);
  434|     13|    }
  435|       |}
  436|       |
  437|       |/// Error types for the compiler driver
  438|       |#[derive(Debug, thiserror::Error)]
  439|       |pub enum DriverError {
  440|       |    #[error("I/O error: {0}")]
  441|       |    IoError(String),
  442|       |
  443|       |    #[error("Compilation failed due to errors")]
  444|       |    CompilationFailed,
  445|       |}
  446|       |
  447|       |/// Error that will stop the compilation pipeline
  448|       |#[derive(Debug)]
  449|       |pub enum PipelineError {
  450|       |    Fatal,
  451|       |    IoError(std::io::Error),
  452|       |}

/app/src/driver/output.rs:
    1|       |//! Output formatting and file writing module
    2|       |//!
    3|       |//! This module handles various output formats including preprocessed source,
    4|       |//! parser AST dumps, and HTML AST dumps.
    5|       |
    6|       |use crate::pp::PPToken;
    7|       |use crate::source_manager::SourceManager;
    8|       |
    9|       |use super::compiler::DriverError;
   10|       |
   11|       |/// Handler for various output formats
   12|       |pub(crate) struct OutputHandler;
   13|       |
   14|       |impl Default for OutputHandler {
   15|      0|    fn default() -> Self {
   16|      0|        Self::new()
   17|      0|    }
   18|       |}
   19|       |
   20|       |impl OutputHandler {
   21|       |    /// Create a new output handler
   22|    614|    pub(crate) fn new() -> Self {
   23|    614|        OutputHandler
   24|    614|    }
   25|       |
   26|       |    /// Dump preprocessed output to stdout
   27|      3|    pub(crate) fn dump_preprocessed_output(
   28|      3|        &self,
   29|      3|        pp_tokens: &[PPToken],
   30|      3|        suppress_line_markers: bool,
   31|      3|        source_manager: &SourceManager,
   32|      3|    ) -> Result<(), DriverError> {
   33|      3|        if pp_tokens.is_empty() {
   34|      0|            return Ok(());
   35|      3|        }
   36|       |
   37|       |        // Get the source buffer for the first token
   38|      3|        let first_token = &pp_tokens[0];
   39|       |
   40|       |        // Initial heuristic: try to find the first non-macro-expanded token
   41|       |        // to establish the "current file" context. This prevents line markers
   42|       |        // generally being emitted for the file itself if it starts with a macro.
   43|      3|        let mut current_file_id = first_token.location.source_id();
   44|      3|        for token in pp_tokens {
   45|      3|            if !token.flags.contains(crate::pp::PPTokenFlags::MACRO_EXPANDED) {
   46|      3|                current_file_id = token.location.source_id();
   47|      3|                break;
   48|      0|            }
   49|       |        }
   50|      3|        let mut current_buffer = source_manager.get_buffer(current_file_id);
   51|      3|        let mut last_pos = 0u32;
   52|      3|        let mut last_was_macro_expanded = false;
   53|       |
   54|     22|        for token in pp_tokens {
                          ^19
   55|     19|            if token.kind == crate::pp::PPTokenKind::Eof {
   56|      0|                break;
   57|     19|            }
   58|       |
   59|       |            // Handle macro-expanded tokens (Level A: use canonical spelling)
   60|     19|            if token.flags.contains(crate::pp::PPTokenFlags::MACRO_EXPANDED) {
   61|       |                // Heuristic: if we are entering a macro expansion (previous was not macro),
   62|       |                // and there was whitespace at the current position in the source, print a space.
   63|       |                // This preserves separation like "return FOO" -> "return 123".
   64|      2|                if !last_was_macro_expanded {
   65|       |                    // Check if char at last_pos is whitespace
   66|      2|                    if let Some(&byte) = current_buffer.get(last_pos as usize)
   67|      2|                        && (byte as char).is_whitespace()
   68|      2|                    {
   69|      2|                        print!(" ");
   70|      2|                    }
                                  ^0
   71|      0|                } else {
   72|      0|                    // Add space between consecutive macro-expanded tokens (linearization)
   73|      0|                    print!(" ");
   74|      0|                }
   75|       |
   76|       |                // For macro-expanded tokens, just print the canonical spelling
   77|       |                // No whitespace reconstruction for Level A - these tokens don't have
   78|       |                // meaningful source locations for whitespace calculation
   79|      2|                print!("{}", token.get_text());
   80|      2|                last_was_macro_expanded = true;
   81|       |                // Don't update last_pos for macro-expanded tokens
   82|      2|                continue;
   83|     17|            }
   84|       |
   85|       |            // Check for file transitions and emit line markers
   86|     17|            if token.location.source_id() != current_file_id {
   87|       |                // Emit line marker for file transition (unless suppressed)
   88|      0|                if !suppress_line_markers
   89|      0|                    && let Some(file_info) = source_manager.get_file_info(token.location.source_id())
   90|       |                {
   91|      0|                    let line = source_manager
   92|      0|                        .get_line_column(token.location)
   93|      0|                        .map(|(l, _)| l)
   94|      0|                        .unwrap_or(1);
   95|      0|                    let filename = file_info
   96|      0|                        .path
   97|      0|                        .file_name()
   98|      0|                        .and_then(|n| n.to_str())
   99|      0|                        .unwrap_or("<unknown>");
  100|       |
  101|       |                    // Ensure we start on a new line
  102|      0|                    println!();
  103|      0|                    println!("# {} \"{}\" 1", line, filename);
  104|      0|                }
  105|       |
  106|      0|                current_file_id = token.location.source_id();
  107|      0|                current_buffer = source_manager.get_buffer(current_file_id);
  108|      0|                last_pos = token.location.offset();
  109|     17|            }
  110|       |
  111|     17|            let token_start = token.location.offset();
  112|     17|            let token_end = token_start + token.length as u32;
  113|       |
  114|       |            // Print all bytes between last_pos and token_start (whitespace, comments)
  115|     17|            if token_start > last_pos {
  116|     14|                let slice = &current_buffer[last_pos as usize..token_start as usize];
  117|       |                // Convert to string, assuming UTF-8 (preprocessor should ensure this)
  118|     14|                if let Ok(text) = std::str::from_utf8(slice) {
  119|       |                    // Only print slices that are all whitespace to avoid printing directive text
  120|     22|                    if text.chars().all(|c| c.is_whitespace()) {
                                     ^14          ^14
  121|     10|                        print!("{}", text);
  122|     10|                    }
                                  ^4
  123|      0|                }
  124|      3|            }
  125|       |
  126|       |            // Print the token's raw bytes from source
  127|     17|            let token_slice = token.get_raw_slice(current_buffer);
  128|     17|            if let Ok(text) = std::str::from_utf8(token_slice) {
  129|     17|                print!("{}", text);
  130|     17|            }
                          ^0
  131|       |
  132|     17|            last_pos = token_end;
  133|     17|            last_was_macro_expanded = false;
  134|       |        }
  135|       |
  136|      3|        println!();
  137|      3|        Ok(())
  138|      3|    }
  139|       |}

/app/src/lang_options.rs:
    1|       |/// supported C standards
    2|       |#[derive(Copy, Clone, Debug, PartialEq, Eq)]
    3|       |pub enum CStandard {
    4|       |    C89,
    5|       |    C99,
    6|       |    C11,
    7|       |}
    8|       |
    9|       |impl From<&str> for CStandard {
   10|      0|    fn from(s: &str) -> Self {
   11|      0|        match s {
   12|      0|            "c89" | "c90" => CStandard::C89,
   13|      0|            "c99" => CStandard::C99,
   14|      0|            "c11" => CStandard::C11,
   15|      0|            _ => CStandard::C11, // default to C11
   16|       |        }
   17|      0|    }
   18|       |}
   19|       |
   20|       |/// Language options affecting compilation behavior
   21|       |#[derive(Copy, Clone, Debug, Default)]
   22|       |pub struct LangOptions {
   23|       |    pub c_standard: Option<CStandard>, // C standard version (e.g., "c99", "c11")
   24|       |}
   25|       |
   26|       |impl LangOptions {
   27|     18|    pub fn c11() -> Self {
   28|     18|        LangOptions {
   29|     18|            c_standard: Some(CStandard::C11),
   30|     18|        }
   31|     18|    }
   32|       |
   33|       |    /// Check if C11 standard is enabled
   34|    731|    pub fn is_c11(&self) -> bool {
   35|    713|        matches!(self.c_standard, Some(CStandard::C11))
                               ^18
   36|    731|    }
   37|       |}
   38|       |
   39|       |#[cfg(test)]
   40|       |mod tests {
   41|       |    use super::*;
   42|       |
   43|       |    #[test]
   44|     18|    fn test_lang_options_c11() {
   45|     18|        let options = LangOptions::c11();
   46|     18|        assert!(options.is_c11());
   47|     18|        assert_eq!(options.c_standard, Some(CStandard::C11));
   48|     18|    }
   49|       |
   50|       |    #[test]
   51|     18|    fn test_lang_options_default() {
   52|     18|        let options = LangOptions::default();
   53|     18|        assert!(!options.is_c11());
   54|     18|        assert_eq!(options.c_standard, None);
   55|     18|    }
   56|       |}

/app/src/lexer.rs:
    1|       |use crate::intern::StringId;
    2|       |use crate::pp::{PPToken, PPTokenKind};
    3|       |use crate::source_manager::SourceSpan;
    4|       |
    5|       |use serde::Serialize;
    6|       |/// C11 token kinds for the lexical analyzer
    7|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
    8|       |pub enum TokenKind {
    9|       |    // === LITERALS ===
   10|       |    IntegerConstant(i64),    // Parsed integer literal value
   11|       |    FloatConstant(f64),      // Parsed float literal value
   12|       |    CharacterConstant(u8),   // Byte value of character constant
   13|       |    StringLiteral(StringId), // Interned string literal
   14|       |
   15|       |    // === IDENTIFIERS ===
   16|       |    Identifier(StringId), // Interned identifier
   17|       |
   18|       |    // === KEYWORDS ===
   19|       |    // Storage class specifiers
   20|       |    Auto,
   21|       |    Extern,
   22|       |    Register,
   23|       |    Static,
   24|       |    ThreadLocal,
   25|       |
   26|       |    // Type qualifiers
   27|       |    Const,
   28|       |    Restrict,
   29|       |    Volatile,
   30|       |    Atomic,
   31|       |
   32|       |    // Type specifiers
   33|       |    Bool,
   34|       |    Char,
   35|       |    Double,
   36|       |    Float,
   37|       |    Int,
   38|       |    Long,
   39|       |    Short,
   40|       |    Signed,
   41|       |    Unsigned,
   42|       |    Void,
   43|       |    Complex,
   44|       |
   45|       |    // Complex type specifiers
   46|       |    Struct,
   47|       |    Union,
   48|       |    Enum,
   49|       |
   50|       |    // Control flow
   51|       |    Break,
   52|       |    Case,
   53|       |    Continue,
   54|       |    Default,
   55|       |    Do,
   56|       |    Else,
   57|       |    For,
   58|       |    Goto,
   59|       |    If,
   60|       |    Return,
   61|       |    Switch,
   62|       |    While,
   63|       |
   64|       |    // Other keywords
   65|       |    Alignas,
   66|       |    Alignof,
   67|       |    Generic,
   68|       |    Inline,
   69|       |    Noreturn,
   70|       |    Pragma,
   71|       |    Sizeof,
   72|       |    StaticAssert,
   73|       |    Typedef,
   74|       |    Attribute,
   75|       |    BuiltinVaArg,
   76|       |    BuiltinVaStart,
   77|       |    BuiltinVaEnd,
   78|       |    BuiltinVaCopy,
   79|       |
   80|       |    // === OPERATORS ===
   81|       |    // Arithmetic operators
   82|       |    Plus,
   83|       |    Minus,
   84|       |    Star,
   85|       |    Slash,
   86|       |    Percent,
   87|       |    Increment,
   88|       |    Decrement,
   89|       |
   90|       |    // Bitwise operators
   91|       |    And,
   92|       |    Or,
   93|       |    Xor,
   94|       |    Not,
   95|       |    Tilde,
   96|       |    LeftShift,
   97|       |    RightShift,
   98|       |
   99|       |    // Comparison operators
  100|       |    Less,
  101|       |    Greater,
  102|       |    LessEqual,
  103|       |    GreaterEqual,
  104|       |    Equal,
  105|       |    NotEqual,
  106|       |
  107|       |    // Assignment operators
  108|       |    Assign,
  109|       |    PlusAssign,
  110|       |    MinusAssign,
  111|       |    StarAssign,
  112|       |    DivAssign,
  113|       |    ModAssign,
  114|       |    AndAssign,
  115|       |    OrAssign,
  116|       |    XorAssign,
  117|       |    LeftShiftAssign,
  118|       |    RightShiftAssign,
  119|       |
  120|       |    // Logical operators
  121|       |    LogicAnd,
  122|       |    LogicOr,
  123|       |
  124|       |    // Member access
  125|       |    Arrow,
  126|       |    Dot,
  127|       |
  128|       |    // Ternary operator
  129|       |    Question,
  130|       |    Colon,
  131|       |
  132|       |    // === PUNCTUATION ===
  133|       |    Comma,
  134|       |    Semicolon,
  135|       |    Ellipsis,
  136|       |
  137|       |    // Brackets and parentheses
  138|       |    LeftParen,
  139|       |    RightParen,
  140|       |    LeftBracket,
  141|       |    RightBracket,
  142|       |    LeftBrace,
  143|       |    RightBrace,
  144|       |
  145|       |    // === SPECIAL TOKENS ===
  146|       |    EndOfFile,
  147|       |    Unknown,
  148|       |}
  149|       |
  150|       |impl TokenKind {
  151|       |    /// Check if the token is a storage class specifier
  152|    892|    pub(crate) fn is_storage_class_specifier(&self) -> bool {
  153|    891|        matches!(
  154|    892|            self,
  155|       |            TokenKind::Typedef
  156|       |                | TokenKind::Extern
  157|       |                | TokenKind::Static
  158|       |                | TokenKind::ThreadLocal
  159|       |                | TokenKind::Auto
  160|       |                | TokenKind::Register
  161|       |        )
  162|    892|    }
  163|       |
  164|       |    /// Check if the token is a type specifier
  165|    891|    pub(crate) fn is_type_specifier(&self) -> bool {
  166|    601|        matches!(
  167|    891|            self,
  168|       |            TokenKind::Void
  169|       |                | TokenKind::Char
  170|       |                | TokenKind::Short
  171|       |                | TokenKind::Int
  172|       |                | TokenKind::Long
  173|       |                | TokenKind::Float
  174|       |                | TokenKind::Double
  175|       |                | TokenKind::Signed
  176|       |                | TokenKind::Unsigned
  177|       |                | TokenKind::Bool
  178|       |                | TokenKind::Complex
  179|       |                | TokenKind::Atomic
  180|       |                | TokenKind::Struct
  181|       |                | TokenKind::Union
  182|       |                | TokenKind::Enum
  183|       |        )
  184|    891|    }
  185|       |
  186|       |    /// Check if the token is a type qualifier
  187|    601|    pub(crate) fn is_type_qualifier(&self) -> bool {
  188|    588|        matches!(
  189|    601|            self,
  190|       |            TokenKind::Const | TokenKind::Restrict | TokenKind::Volatile | TokenKind::Atomic
  191|       |        )
  192|    601|    }
  193|       |
  194|       |    /// Check if the token is a function specifier
  195|    588|    pub(crate) fn is_function_specifier(&self) -> bool {
  196|    588|        matches!(self, TokenKind::Inline | TokenKind::Noreturn)
  197|    588|    }
  198|       |
  199|       |    /// Check if the token is an alignment specifier
  200|    588|    pub(crate) fn is_alignment_specifier(&self) -> bool {
  201|    588|        matches!(self, TokenKind::Alignas)
  202|    588|    }
  203|       |
  204|       |    /// Check if the token can start a declaration specifier
  205|    892|    pub(crate) fn is_declaration_specifier_start(&self) -> bool {
  206|    892|        self.is_storage_class_specifier()
  207|    891|            || self.is_type_specifier()
  208|    601|            || self.is_type_qualifier()
  209|    588|            || self.is_function_specifier()
  210|    588|            || self.is_alignment_specifier()
  211|    588|            || matches!(self, TokenKind::Attribute)
  212|    892|    }
  213|       |
  214|       |    /// Check if the token can start a declaration (including typedefs)
  215|    886|    pub(crate) fn is_declaration_start(&self, is_typedef: bool) -> bool {
  216|    886|        if self.is_declaration_specifier_start() || *self == TokenKind::StaticAssert {
                                                                  ^583
  217|    306|            return true;
  218|    580|        }
  219|       |
  220|    580|        if let TokenKind::Identifier(_) = self {
  221|    193|            return is_typedef;
  222|    387|        }
  223|       |
  224|    387|        false
  225|    886|    }
  226|       |}
  227|       |
  228|       |/// Token with source span for the parser
  229|       |#[derive(Debug, Clone, Copy, PartialEq)]
  230|       |pub struct Token {
  231|       |    pub kind: TokenKind,
  232|       |    pub span: SourceSpan,
  233|       |}
  234|       |
  235|       |/// Classify a preprocessor punctuation token into a lexical token.
  236|       |///
  237|       |///  Bolt: Optimized with a `match` statement.
  238|       |/// This is significantly faster than the previous `HashMap` implementation because
  239|       |/// the Rust compiler can optimize it into a perfect hash table or a more direct
  240|       |/// jump table, avoiding the overhead of runtime hashing and lookups.
  241|  5.59k|fn classify_punctuation(pp_token_kind: PPTokenKind) -> TokenKind {
  242|  5.59k|    match pp_token_kind {
  243|       |        // Arithmetic operators
  244|     41|        PPTokenKind::Plus => TokenKind::Plus,
  245|     23|        PPTokenKind::Minus => TokenKind::Minus,
  246|    175|        PPTokenKind::Star => TokenKind::Star,
  247|      2|        PPTokenKind::Slash => TokenKind::Slash,
  248|      3|        PPTokenKind::Percent => TokenKind::Percent,
  249|     35|        PPTokenKind::Increment => TokenKind::Increment,
  250|     20|        PPTokenKind::Decrement => TokenKind::Decrement,
  251|       |
  252|       |        // Bitwise operators
  253|     55|        PPTokenKind::And => TokenKind::And,
  254|      1|        PPTokenKind::Or => TokenKind::Or,
  255|      1|        PPTokenKind::Xor => TokenKind::Xor,
  256|      5|        PPTokenKind::Not => TokenKind::Not,
  257|      3|        PPTokenKind::Tilde => TokenKind::Tilde,
  258|      1|        PPTokenKind::LeftShift => TokenKind::LeftShift,
  259|      1|        PPTokenKind::RightShift => TokenKind::RightShift,
  260|       |
  261|       |        // Comparison operators
  262|     50|        PPTokenKind::Less => TokenKind::Less,
  263|     33|        PPTokenKind::Greater => TokenKind::Greater,
  264|      2|        PPTokenKind::LessEqual => TokenKind::LessEqual,
  265|      2|        PPTokenKind::GreaterEqual => TokenKind::GreaterEqual,
  266|     10|        PPTokenKind::Equal => TokenKind::Equal,
  267|     35|        PPTokenKind::NotEqual => TokenKind::NotEqual,
  268|       |
  269|       |        // Assignment operators
  270|    537|        PPTokenKind::Assign => TokenKind::Assign,
  271|      4|        PPTokenKind::PlusAssign => TokenKind::PlusAssign,
  272|      4|        PPTokenKind::MinusAssign => TokenKind::MinusAssign,
  273|      2|        PPTokenKind::StarAssign => TokenKind::StarAssign,
  274|      2|        PPTokenKind::DivAssign => TokenKind::DivAssign,
  275|      2|        PPTokenKind::ModAssign => TokenKind::ModAssign,
  276|      1|        PPTokenKind::AndAssign => TokenKind::AndAssign,
  277|      1|        PPTokenKind::OrAssign => TokenKind::OrAssign,
  278|      1|        PPTokenKind::XorAssign => TokenKind::XorAssign,
  279|      1|        PPTokenKind::LeftShiftAssign => TokenKind::LeftShiftAssign,
  280|      1|        PPTokenKind::RightShiftAssign => TokenKind::RightShiftAssign,
  281|       |
  282|       |        // Logical operators
  283|      2|        PPTokenKind::LogicAnd => TokenKind::LogicAnd,
  284|      7|        PPTokenKind::LogicOr => TokenKind::LogicOr,
  285|       |
  286|       |        // Member access
  287|     16|        PPTokenKind::Arrow => TokenKind::Arrow,
  288|     64|        PPTokenKind::Dot => TokenKind::Dot,
  289|       |
  290|       |        // Ternary operator
  291|      7|        PPTokenKind::Question => TokenKind::Question,
  292|     94|        PPTokenKind::Colon => TokenKind::Colon,
  293|       |
  294|       |        // Punctuation
  295|    277|        PPTokenKind::Comma => TokenKind::Comma,
  296|  1.32k|        PPTokenKind::Semicolon => TokenKind::Semicolon,
  297|     14|        PPTokenKind::Ellipsis => TokenKind::Ellipsis,
  298|       |
  299|       |        // Brackets and parentheses
  300|    675|        PPTokenKind::LeftParen => TokenKind::LeftParen,
  301|    675|        PPTokenKind::RightParen => TokenKind::RightParen,
  302|    160|        PPTokenKind::LeftBracket => TokenKind::LeftBracket,
  303|    160|        PPTokenKind::RightBracket => TokenKind::RightBracket,
  304|    534|        PPTokenKind::LeftBrace => TokenKind::LeftBrace,
  305|    532|        PPTokenKind::RightBrace => TokenKind::RightBrace,
  306|       |
  307|       |        // Tokens that don't map directly to a parser token
  308|      0|        PPTokenKind::Hash | PPTokenKind::HashHash => TokenKind::Unknown,
  309|       |
  310|       |        // Non-punctuation tokens are not handled by this function
  311|      1|        _ => TokenKind::Unknown,
  312|       |    }
  313|  5.59k|}
  314|       |
  315|       |/// Check if a symbol represents a C11 keyword.
  316|       |///
  317|       |///  Bolt: Optimized with a pre-initialized `HashMap`.
  318|       |/// This is significantly faster than the previous match-based implementation, which
  319|       |/// required converting the `StringId` to a `&str` for every lookup. This version
  320|       |// pre-interns all keywords and stores them in a lazily-initialized `HashMap`.
  321|       |/// Subsequent lookups use the `StringId` directly, resulting in a much faster
  322|       |/// integer comparison instead of a string comparison.
  323|  3.83k|pub(crate) fn is_keyword(symbol: StringId) -> Option<TokenKind> {
  324|  3.83k|    keyword_map().get(&symbol).copied()
  325|  3.83k|}
  326|       |
  327|  3.83k|fn keyword_map() -> &'static hashbrown::HashMap<StringId, TokenKind> {
  328|       |    static KEYWORDS: std::sync::OnceLock<hashbrown::HashMap<StringId, TokenKind>> = std::sync::OnceLock::new();
  329|  3.83k|    KEYWORDS.get_or_init(|| {
                                          ^18
  330|     18|        let mut m = hashbrown::HashMap::new();
  331|     18|        m.insert(StringId::new("auto"), TokenKind::Auto);
  332|     18|        m.insert(StringId::new("break"), TokenKind::Break);
  333|     18|        m.insert(StringId::new("case"), TokenKind::Case);
  334|     18|        m.insert(StringId::new("char"), TokenKind::Char);
  335|     18|        m.insert(StringId::new("const"), TokenKind::Const);
  336|     18|        m.insert(StringId::new("continue"), TokenKind::Continue);
  337|     18|        m.insert(StringId::new("default"), TokenKind::Default);
  338|     18|        m.insert(StringId::new("do"), TokenKind::Do);
  339|     18|        m.insert(StringId::new("double"), TokenKind::Double);
  340|     18|        m.insert(StringId::new("else"), TokenKind::Else);
  341|     18|        m.insert(StringId::new("enum"), TokenKind::Enum);
  342|     18|        m.insert(StringId::new("extern"), TokenKind::Extern);
  343|     18|        m.insert(StringId::new("float"), TokenKind::Float);
  344|     18|        m.insert(StringId::new("for"), TokenKind::For);
  345|     18|        m.insert(StringId::new("goto"), TokenKind::Goto);
  346|     18|        m.insert(StringId::new("if"), TokenKind::If);
  347|     18|        m.insert(StringId::new("inline"), TokenKind::Inline);
  348|     18|        m.insert(StringId::new("int"), TokenKind::Int);
  349|     18|        m.insert(StringId::new("long"), TokenKind::Long);
  350|     18|        m.insert(StringId::new("register"), TokenKind::Register);
  351|     18|        m.insert(StringId::new("restrict"), TokenKind::Restrict);
  352|     18|        m.insert(StringId::new("return"), TokenKind::Return);
  353|     18|        m.insert(StringId::new("short"), TokenKind::Short);
  354|     18|        m.insert(StringId::new("signed"), TokenKind::Signed);
  355|     18|        m.insert(StringId::new("sizeof"), TokenKind::Sizeof);
  356|     18|        m.insert(StringId::new("static"), TokenKind::Static);
  357|     18|        m.insert(StringId::new("struct"), TokenKind::Struct);
  358|     18|        m.insert(StringId::new("switch"), TokenKind::Switch);
  359|     18|        m.insert(StringId::new("typedef"), TokenKind::Typedef);
  360|     18|        m.insert(StringId::new("union"), TokenKind::Union);
  361|     18|        m.insert(StringId::new("unsigned"), TokenKind::Unsigned);
  362|     18|        m.insert(StringId::new("void"), TokenKind::Void);
  363|     18|        m.insert(StringId::new("volatile"), TokenKind::Volatile);
  364|     18|        m.insert(StringId::new("while"), TokenKind::While);
  365|     18|        m.insert(StringId::new("_Alignas"), TokenKind::Alignas);
  366|     18|        m.insert(StringId::new("_Alignof"), TokenKind::Alignof);
  367|     18|        m.insert(StringId::new("_Atomic"), TokenKind::Atomic);
  368|     18|        m.insert(StringId::new("_Bool"), TokenKind::Bool);
  369|     18|        m.insert(StringId::new("_Complex"), TokenKind::Complex);
  370|     18|        m.insert(StringId::new("_Generic"), TokenKind::Generic);
  371|     18|        m.insert(StringId::new("_Noreturn"), TokenKind::Noreturn);
  372|     18|        m.insert(StringId::new("_Pragma"), TokenKind::Pragma);
  373|     18|        m.insert(StringId::new("_Static_assert"), TokenKind::StaticAssert);
  374|     18|        m.insert(StringId::new("_Thread_local"), TokenKind::ThreadLocal);
  375|     18|        m.insert(StringId::new("__attribute__"), TokenKind::Attribute);
  376|     18|        m.insert(StringId::new("__attribute"), TokenKind::Attribute);
  377|     18|        m.insert(StringId::new("__builtin_va_arg"), TokenKind::BuiltinVaArg);
  378|     18|        m.insert(StringId::new("__builtin_va_start"), TokenKind::BuiltinVaStart);
  379|     18|        m.insert(StringId::new("__builtin_va_end"), TokenKind::BuiltinVaEnd);
  380|     18|        m.insert(StringId::new("__builtin_va_copy"), TokenKind::BuiltinVaCopy);
  381|     18|        m
  382|     18|    })
  383|  3.83k|}
  384|       |
  385|       |/// Lexer state machine
  386|       |pub struct Lexer<'src> {
  387|       |    // Current position in token stream
  388|       |    tokens: &'src [PPToken],
  389|       |    // current_index: usize,
  390|       |}
  391|       |
  392|       |impl<'src> Lexer<'src> {
  393|       |    /// Create a new lexer with the given preprocessor token stream
  394|    606|    pub fn new(tokens: &'src [PPToken]) -> Self {
  395|    606|        Lexer {
  396|    606|            tokens,
  397|    606|            // current_index: 0,
  398|    606|        }
  399|    606|    }
  400|       |
  401|       |    /// Parse C11 integer literal syntax
  402|       |    ///
  403|       |    ///  Bolt: Optimized integer parsing.
  404|       |    /// This implementation is faster than the previous version. It first uses the
  405|       |    /// existing optimized `strip_integer_suffix` function, then replaces the multi-step
  406|       |    /// `extract_digits_and_base` and `parse_integer_value` (which used slower
  407|       |    /// general-purpose parsing functions) with a single, direct parsing loop.
  408|       |    /// This avoids intermediate allocations and improves performance by using
  409|       |    /// checked arithmetic directly on the string's characters.
  410|  1.09k|    fn parse_c11_integer_literal(&self, text: StringId) -> Result<i64, ()> {
  411|  1.09k|        let text_str = text.as_str();
  412|       |
  413|       |        // Use the existing, optimized suffix stripper to get the numeric part.
  414|  1.09k|        let number_part = Self::strip_integer_suffix(text_str);
  415|       |
  416|       |        // Handle the case where the number is just "0" after stripping suffix.
  417|  1.09k|        if number_part == "0" {
  418|    245|            return Ok(0);
  419|    849|        }
  420|       |
  421|    849|        let mut base = 10;
  422|    849|        let mut digits_to_parse = number_part;
  423|       |
  424|       |        // Determine base and strip prefix from the numeric part.
  425|    849|        if number_part.starts_with("0x") || number_part.starts_with("0X") {
                                                          ^837        ^837
  426|     12|            base = 16;
  427|     12|            digits_to_parse = &number_part[2..];
  428|    837|        } else if let Some(stripped) = number_part.strip_prefix('0') {
                                         ^8
  429|      8|            base = 8;
  430|      8|            digits_to_parse = stripped;
  431|    829|        }
  432|       |        // else base is 10 and we parse the whole `number_part`.
  433|       |
  434|       |        // If after stripping prefixes the string is empty, it's an error.
  435|    849|        if digits_to_parse.is_empty() {
  436|      0|            return Err(());
  437|    849|        }
  438|       |
  439|    849|        let mut result: u64 = 0;
  440|  1.12k|        for c in digits_to_parse.chars() {
                               ^849            ^849
  441|       |            // `to_digit` will return None for invalid characters in the given base
  442|       |            // (e.g., '9' in octal), which correctly propagates the error.
  443|  1.12k|            let digit = c.to_digit(base).ok_or(())?;
                              ^1.08k                            ^44
  444|       |
  445|       |            // Use checked arithmetic to prevent overflow, replicating .parse() behavior.
  446|  1.08k|            result = result.checked_mul(base as u64).ok_or(())?;
                                                                            ^0
  447|  1.08k|            result = result.checked_add(digit as u64).ok_or(())?;
                                                                             ^0
  448|       |        }
  449|       |
  450|    805|        Ok(result as i64)
  451|  1.09k|    }
  452|       |
  453|       |    /// Strip integer literal suffix (u, l, ll, ul, ull, etc.)
  454|  1.09k|    fn strip_integer_suffix(text: &str) -> &str {
  455|       |        //  Bolt: Optimized suffix stripping.
  456|       |        // This implementation is faster than the previous version, which used multiple
  457|       |        // string slices and `eq_ignore_ascii_case` calls. By working with bytes directly
  458|       |        // and using `matches!` for character comparisons, we avoid the overhead of
  459|       |        // slicing and function calls in the common cases, resulting in a small but
  460|       |        // measurable performance improvement for parsing integer literals.
  461|  1.09k|        let bytes = text.as_bytes();
  462|  1.09k|        let len = bytes.len();
  463|       |
  464|  1.09k|        if len == 0 {
  465|      0|            return text;
  466|  1.09k|        }
  467|       |
  468|       |        // Check for the longest suffixes first (3 characters: "ull", "llu").
  469|  1.09k|        if len >= 3 {
  470|     80|            let last3 = (
  471|     80|                bytes[len - 3].to_ascii_lowercase(),
  472|     80|                bytes[len - 2].to_ascii_lowercase(),
  473|     80|                bytes[len - 1].to_ascii_lowercase(),
  474|     80|            );
  475|     80|            if matches!(last3, (b'u', b'l', b'l') | (b'l', b'l', b'u')) {
                             ^71
  476|      9|                return &text[..len - 3];
  477|     71|            }
  478|  1.01k|        }
  479|       |
  480|       |        // Check for 2-character suffixes ("ul", "lu", "ll").
  481|  1.08k|        if len >= 2 {
  482|    204|            let last2 = (bytes[len - 2].to_ascii_lowercase(), bytes[len - 1].to_ascii_lowercase());
  483|    204|            if matches!(last2, (b'u', b'l') | (b'l', b'u') | (b'l', b'l')) {
                             ^191
  484|     13|                return &text[..len - 2];
  485|    191|            }
  486|    881|        }
  487|       |
  488|       |        // Check for 1-character suffixes ("u", "l").
  489|  1.07k|        if len >= 1 {
  490|  1.07k|            let last1 = bytes[len - 1].to_ascii_lowercase();
  491|  1.07k|            if matches!(last1, b'u' | b'l') {
                             ^1.06k
  492|      8|                return &text[..len - 1];
  493|  1.06k|            }
  494|      0|        }
  495|       |
  496|       |        // No suffix found.
  497|  1.06k|        text
  498|  1.09k|    }
  499|       |
  500|       |    /// Classify a preprocessor token into a lexical token
  501|  11.2k|    fn classify_token(&self, pptoken: &PPToken) -> TokenKind {
  502|  11.2k|        match pptoken.kind {
  503|  3.79k|            PPTokenKind::Identifier(symbol) => {
  504|       |                // Check if it's a keyword
  505|  3.79k|                is_keyword(symbol).unwrap_or(TokenKind::Identifier(symbol))
  506|       |            }
  507|    133|            PPTokenKind::StringLiteral(symbol) => {
  508|       |                // Strip quotes from string literal
  509|    133|                if let Some(content) = Self::extract_string_content(&symbol) {
  510|    133|                    let unescaped = Self::unescape_string(content);
  511|    133|                    TokenKind::StringLiteral(StringId::new(unescaped))
  512|       |                } else {
  513|      0|                    TokenKind::StringLiteral(symbol)
  514|       |                }
  515|       |            }
  516|     55|            PPTokenKind::CharLiteral(codepoint, _) => TokenKind::CharacterConstant(codepoint),
  517|  1.09k|            PPTokenKind::Number(value) => {
  518|       |                // Try to parse as integer first, then float, then unknown
  519|  1.09k|                if let Ok(int_val) = self.parse_c11_integer_literal(value) {
                                        ^1.05k
  520|  1.05k|                    TokenKind::IntegerConstant(int_val)
  521|     44|                } else if let Ok(float_val) = self.parse_c11_float_literal(value) {
  522|     44|                    TokenKind::FloatConstant(float_val)
  523|       |                } else {
  524|      0|                    TokenKind::Unknown // Could not parse as integer or float
  525|       |                }
  526|       |            }
  527|    605|            PPTokenKind::Eof => TokenKind::EndOfFile,
  528|      0|            PPTokenKind::Eod => TokenKind::Unknown,
  529|       |            // Handle punctuation tokens using the optimized match-based function
  530|  5.59k|            pptoken_kind => classify_punctuation(pptoken_kind),
  531|       |        }
  532|  11.2k|    }
  533|       |
  534|       |    /// Get all tokens from the stream
  535|    606|    pub fn tokenize_all(&mut self) -> Vec<Token> {
  536|    606|        let mut tokens = Vec::new();
  537|    606|        let mut current_token_iter = self.tokens.iter().peekable();
  538|       |
  539|  11.2k|        while let Some(pptoken) = current_token_iter.next() {
  540|  11.2k|            if let PPTokenKind::StringLiteral(symbol) = pptoken.kind {
                                                            ^139
  541|       |                //  Bolt: Optimized string literal handling.
  542|       |                // This introduces a fast path for single string literals, which are the
  543|       |                // most common case. By peeking ahead, we avoid the overhead of the
  544|       |                // two-pass concatenation logic unless it's actually needed. This
  545|       |                // reduces overhead and improves lexer performance.
  546|       |
  547|       |                // --- Fast path for single string literals ---
  548|    133|                if !matches!(
  549|    139|                    current_token_iter.peek(),
  550|       |                    Some(PPToken {
  551|       |                        kind: PPTokenKind::StringLiteral(_),
  552|       |                        ..
  553|       |                    })
  554|       |                ) {
  555|    133|                    tokens.push(Token {
  556|    133|                        kind: self.classify_token(pptoken), // Handles quote stripping
  557|    133|                        span: SourceSpan::new_with_length(
  558|    133|                            pptoken.location.source_id(),
  559|    133|                            pptoken.location.offset(),
  560|    133|                            pptoken.length as u32,
  561|    133|                        ),
  562|    133|                    });
  563|    133|                    continue;
  564|      6|                }
  565|       |
  566|       |                // --- Slow path: Concatenate adjacent string literals ---
  567|      6|                let start_span = SourceSpan::new_with_length(
  568|      6|                    pptoken.location.source_id(),
  569|      6|                    pptoken.location.offset(),
  570|      6|                    pptoken.length as u32,
  571|       |                );
  572|      6|                let mut final_span = start_span;
  573|       |
  574|       |                // --- Phase 1: Calculate total size and find last span ---
  575|      6|                let mut total_size = Self::extract_string_content(&symbol).unwrap_or("").len();
  576|      6|                let mut adjacent_literals = 0;
  577|      6|                let next_token_idx = self.tokens.len() - current_token_iter.len();
  578|       |
  579|     15|                while let Some(next_pptoken) = self.tokens.get(next_token_idx + adjacent_literals) {
  580|     15|                    if let PPTokenKind::StringLiteral(next_symbol) = next_pptoken.kind {
                                                                    ^9
  581|      9|                        total_size += Self::extract_string_content(&next_symbol).unwrap_or("").len();
  582|      9|                        final_span = SourceSpan::new_with_length(
  583|      9|                            next_pptoken.location.source_id(),
  584|      9|                            next_pptoken.location.offset(),
  585|      9|                            next_pptoken.length as u32,
  586|      9|                        );
  587|      9|                        adjacent_literals += 1;
  588|      9|                    } else {
  589|      6|                        break;
  590|       |                    }
  591|       |                }
  592|       |
  593|       |                // --- Phase 2: Allocate and append ---
  594|      6|                let mut content = String::with_capacity(total_size);
  595|      6|                if let Some(s_content) = Self::extract_string_content(&symbol) {
  596|      6|                    content.push_str(&Self::unescape_string(s_content));
  597|      6|                }
                              ^0
  598|       |
  599|      6|                for _ in 0..adjacent_literals {
  600|      9|                    let consumed_pptoken = current_token_iter.next().unwrap();
  601|      9|                    if let PPTokenKind::StringLiteral(next_symbol) = consumed_pptoken.kind
  602|      9|                        && let Some(s_content) = Self::extract_string_content(&next_symbol)
  603|      9|                    {
  604|      9|                        content.push_str(&Self::unescape_string(s_content));
  605|      9|                    }
                                  ^0
  606|       |                }
  607|       |
  608|      6|                tokens.push(Token {
  609|      6|                    kind: TokenKind::StringLiteral(StringId::new(content)),
  610|      6|                    span: start_span.merge(final_span),
  611|      6|                });
  612|      6|                continue;
  613|  11.1k|            }
  614|       |
  615|       |            // For all other tokens, process normally
  616|  11.1k|            let token = Token {
  617|  11.1k|                kind: self.classify_token(pptoken),
  618|  11.1k|                span: SourceSpan::new_with_length(
  619|  11.1k|                    pptoken.location.source_id(),
  620|  11.1k|                    pptoken.location.offset(),
  621|  11.1k|                    pptoken.length as u32,
  622|  11.1k|                ),
  623|  11.1k|            };
  624|       |
  625|  11.1k|            let is_eof = matches!(token.kind, TokenKind::EndOfFile);
                                       ^10.5k
  626|  11.1k|            tokens.push(token);
  627|  11.1k|            if is_eof {
  628|    606|                break;
  629|  10.5k|            }
  630|       |        }
  631|       |
  632|    606|        tokens
  633|    606|    }
  634|       |
  635|       |    /// Parse C11 floating-point literal syntax
  636|     44|    fn parse_c11_float_literal(&self, text: StringId) -> Result<f64, ()> {
  637|     44|        let text_str = text.as_str();
  638|       |
  639|       |        // C11 floating-point literal format:
  640|       |        // [digits][.digits][e|E[+|-]digits][f|F|l|L]
  641|       |        // or [digits][e|E[+|-]digits][f|F|l|L]
  642|       |        // or 0[xX][hexdigits][.hexdigits][p|P[+|-]digits][f|F|l|L]
  643|       |
  644|       |        //  Bolt: Optimized suffix stripping.
  645|       |        // This is faster than chaining `ends_with` calls. By checking the last byte
  646|       |        // directly, we avoid multiple string traversals and improve performance for
  647|       |        // parsing floating-point literals.
  648|     44|        let text_without_suffix = if !text_str.is_empty() {
  649|     44|            match text_str.as_bytes()[text_str.len() - 1] {
  650|      2|                b'f' | b'F' | b'l' | b'L' => &text_str[..text_str.len() - 1],
  651|     42|                _ => text_str,
  652|       |            }
  653|       |        } else {
  654|      0|            text_str
  655|       |        };
  656|       |
  657|       |        // Handle hexadecimal floating-point literals (C99/C11)
  658|     44|        if text_str.starts_with("0x") || text_str.starts_with("0X") {
                                                       ^43      ^43
  659|      1|            self.parse_hex_float_literal(text_without_suffix)
  660|       |        } else {
  661|       |            // Use Rust's built-in parsing for decimal floats
  662|     43|            match text_without_suffix.parse::<f64>() {
  663|     43|                Ok(val) => Ok(val),
  664|       |                Err(_) => {
  665|       |                    // Invalid float, treat as unknown
  666|      0|                    Err(())
  667|       |                }
  668|       |            }
  669|       |        }
  670|     44|    }
  671|       |
  672|       |    /// Parse hexadecimal floating-point literal (C99/C11)
  673|      1|    fn parse_hex_float_literal(&self, text: &str) -> Result<f64, ()> {
  674|       |        // Format: 0[xX][hexdigits][.hexdigits][pP[+|-]digits][fFlL]
  675|       |        // Example: 0x1.2p3, 0x1p-5f, 0x.8p10L
  676|       |
  677|      1|        let mut chars = text.chars().peekable();
  678|      1|        let mut result = 0.0f64;
  679|      1|        let mut exponent = 0i32;
  680|      1|        let mut seen_dot = false;
  681|      1|        let mut fraction_digits = 0;
  682|       |
  683|       |        // Skip "0x" or "0X"
  684|      1|        chars.next(); // '0'
  685|      1|        chars.next(); // 'x' or 'X'
  686|       |
  687|       |        // Parse hexadecimal digits before decimal point
  688|      2|        while let Some(&c) = chars.peek() {
  689|      2|            if c.is_ascii_hexdigit() {
  690|      1|                let digit = c.to_digit(16).unwrap() as f64;
  691|      1|                result = result * 16.0 + digit;
  692|      1|                chars.next();
  693|      1|            } else if c == '.' && !seen_dot {
  694|      1|                seen_dot = true;
  695|      1|                chars.next();
  696|      1|                break;
  697|      0|            } else if c == 'p' || c == 'P' {
  698|      0|                break;
  699|       |            } else {
  700|      0|                return Err(());
  701|       |            }
  702|       |        }
  703|       |
  704|       |        // Parse hexadecimal digits after decimal point
  705|      1|        if seen_dot {
  706|      2|            while let Some(&c) = chars.peek() {
  707|      2|                if c.is_ascii_hexdigit() {
  708|      1|                    let digit = c.to_digit(16).unwrap() as f64;
  709|      1|                    result = result * 16.0 + digit;
  710|      1|                    fraction_digits += 1;
  711|      1|                    chars.next();
  712|      1|                } else if c == 'p' || c == 'P' {
                                                    ^0
  713|      1|                    break;
  714|       |                } else {
  715|      0|                    return Err(());
  716|       |                }
  717|       |            }
  718|      0|        }
  719|       |
  720|       |        // Parse binary exponent
  721|      1|        if let Some(&c) = chars.peek()
  722|      1|            && (c == 'p' || c == 'P')
                                          ^0
  723|       |        {
  724|      1|            chars.next(); // consume 'p' or 'P'
  725|       |
  726|       |            // Parse optional sign
  727|      1|            let mut exp_negative = false;
  728|      1|            if let Some(&sign) = chars.peek() {
  729|      1|                if sign == '+' {
  730|      0|                    chars.next();
  731|      1|                } else if sign == '-' {
  732|      0|                    exp_negative = true;
  733|      0|                    chars.next();
  734|      1|                }
  735|      0|            }
  736|       |
  737|       |            // Parse exponent digits safely without string allocation
  738|      1|            let mut exp_val = 0i32;
  739|      1|            let mut exp_digits = 0;
  740|      2|            while let Some(&c) = chars.peek() {
                                          ^1
  741|      1|                if let Some(digit) = c.to_digit(10) {
  742|       |                    // Use checked arithmetic to prevent overflow, replicating .parse() behavior.
  743|      1|                    exp_val = match exp_val.checked_mul(10).and_then(|v| v.checked_add(digit as i32)) {
  744|      1|                        Some(val) => val,
  745|      0|                        None => return Err(()), // Overflow
  746|       |                    };
  747|      1|                    exp_digits += 1;
  748|      1|                    chars.next();
  749|       |                } else {
  750|      0|                    break;
  751|       |                }
  752|       |            }
  753|       |
  754|      1|            if exp_digits == 0 {
  755|      0|                return Err(());
  756|      1|            }
  757|       |
  758|      1|            exponent = if exp_negative { -exp_val } else { exp_val };
                                                       ^0
  759|      0|        }
  760|       |
  761|       |        // Apply fractional adjustment
  762|      1|        if fraction_digits > 0 {
  763|      1|            result /= 16.0f64.powi(fraction_digits);
  764|      1|        }
                      ^0
  765|       |
  766|       |        // Apply binary exponent
  767|      1|        if exponent != 0 {
  768|      1|            result *= 2.0f64.powi(exponent);
  769|      1|        }
                      ^0
  770|       |
  771|      1|        Ok(result)
  772|      1|    }
  773|       |
  774|       |    /// Extract content from a string literal symbol, removing quotes
  775|    163|    fn extract_string_content(symbol: &StringId) -> Option<&str> {
  776|    163|        let s = symbol.as_str();
  777|    163|        if s.starts_with('"') && s.ends_with('"') && s.len() >= 2 {
  778|    163|            Some(&s[1..s.len() - 1])
  779|       |        } else {
  780|      0|            None
  781|       |        }
  782|    163|    }
  783|       |
  784|       |    /// Unescape C11 string literal content
  785|    148|    fn unescape_string(s: &str) -> String {
  786|       |        //  Bolt: Fast path for strings with no escape sequences.
  787|       |        // This avoids allocating a new string and iterating over it when no
  788|       |        // unescaping is necessary. It makes the common case of simple strings
  789|       |        // much faster.
  790|    148|        if !s.contains('\\') {
  791|    144|            return s.to_string();
  792|      4|        }
  793|       |
  794|      4|        let mut result = String::with_capacity(s.len());
  795|      4|        let mut chars = s.chars().peekable();
  796|       |
  797|     44|        while let Some(c) = chars.next() {
                                     ^40
  798|     40|            if c == '\\' {
  799|      4|                match chars.peek() {
  800|      4|                    Some('n') => {
  801|      4|                        chars.next();
  802|      4|                        result.push('\n');
  803|      4|                    }
  804|      0|                    Some('t') => {
  805|      0|                        chars.next();
  806|      0|                        result.push('\t');
  807|      0|                    }
  808|      0|                    Some('r') => {
  809|      0|                        chars.next();
  810|      0|                        result.push('\r');
  811|      0|                    }
  812|      0|                    Some('b') => {
  813|      0|                        chars.next();
  814|      0|                        result.push('\u{0008}');
  815|      0|                    } // Backspace
  816|      0|                    Some('f') => {
  817|      0|                        chars.next();
  818|      0|                        result.push('\u{000C}');
  819|      0|                    } // Form feed
  820|      0|                    Some('v') => {
  821|      0|                        chars.next();
  822|      0|                        result.push('\u{000B}');
  823|      0|                    } // Vertical tab
  824|      0|                    Some('a') => {
  825|      0|                        chars.next();
  826|      0|                        result.push('\u{0007}');
  827|      0|                    } // Alert
  828|      0|                    Some('\\') => {
  829|      0|                        chars.next();
  830|      0|                        result.push('\\');
  831|      0|                    }
  832|      0|                    Some('\'') => {
  833|      0|                        chars.next();
  834|      0|                        result.push('\'');
  835|      0|                    }
  836|      0|                    Some('"') => {
  837|      0|                        chars.next();
  838|      0|                        result.push('"');
  839|      0|                    }
  840|      0|                    Some('?') => {
  841|      0|                        chars.next();
  842|      0|                        result.push('?');
  843|      0|                    }
  844|       |                    Some('x') => {
  845|       |                        // Hex escape
  846|      0|                        chars.next(); // consume 'x'
  847|      0|                        let mut val: u64 = 0;
  848|      0|                        let mut has_digits = false;
  849|      0|                        while let Some(&ch) = chars.peek() {
  850|      0|                            if let Some(digit) = ch.to_digit(16) {
  851|      0|                                // Prevent overflow
  852|      0|                                val = val.saturating_mul(16).saturating_add(digit as u64);
  853|      0|                                has_digits = true;
  854|      0|                                chars.next();
  855|      0|                            } else {
  856|      0|                                break;
  857|       |                            }
  858|       |                        }
  859|      0|                        if has_digits {
  860|       |                            // Limit to valid Unicode scalar value range since we must produce a String
  861|      0|                            let char_val = if val > 0x10FFFF {
  862|      0|                                0xFFFD // Replacement character
  863|       |                            } else {
  864|      0|                                val as u32
  865|       |                            };
  866|       |
  867|      0|                            if let Some(c) = std::char::from_u32(char_val) {
  868|      0|                                result.push(c);
  869|      0|                            } else {
  870|      0|                                // Fallback for invalid unicode scalars (e.g. surrogates)
  871|      0|                                result.push(std::char::REPLACEMENT_CHARACTER);
  872|      0|                            }
  873|      0|                        } else {
  874|      0|                            // \x with no digits is technically undefined/error.
  875|      0|                            // Keep \x
  876|      0|                            result.push('x');
  877|      0|                        }
  878|       |                    }
  879|      0|                    Some(c) if c.is_digit(8) => {
  880|       |                        // Octal escape
  881|       |                        // Up to 3 digits
  882|      0|                        let mut val = 0u32;
  883|      0|                        for _ in 0..3 {
  884|      0|                            if let Some(&ch) = chars.peek() {
  885|      0|                                if let Some(digit) = ch.to_digit(8) {
  886|      0|                                    val = val * 8 + digit;
  887|      0|                                    chars.next();
  888|      0|                                } else {
  889|      0|                                    break;
  890|       |                                }
  891|       |                            } else {
  892|      0|                                break;
  893|       |                            }
  894|       |                        }
  895|      0|                        if let Some(c) = std::char::from_u32(val) {
  896|      0|                            result.push(c);
  897|      0|                        } else {
  898|      0|                            result.push(std::char::REPLACEMENT_CHARACTER);
  899|      0|                        }
  900|       |                    }
  901|      0|                    Some(c) => {
  902|      0|                        // Unknown escape, keep char (standard says undefined)
  903|      0|                        // GCC emits just the char.
  904|      0|                        result.push(*c);
  905|      0|                        chars.next();
  906|      0|                    }
  907|      0|                    None => {
  908|      0|                        // Trailing backslash
  909|      0|                        result.push('\\');
  910|      0|                    }
  911|       |                }
  912|     36|            } else {
  913|     36|                result.push(c);
  914|     36|            }
  915|       |        }
  916|      4|        result
  917|    148|    }
  918|       |}

/app/src/main.rs:
    1|       |use cendol::driver::{Cli, CompilerDriver, DriverError};
    2|       |use clap::Parser;
    3|       |
    4|      0|fn main() {
    5|      0|    env_logger::init();
    6|      0|    let cli = Cli::parse();
    7|       |
    8|      0|    match CompilerDriver::new(cli) {
    9|      0|        Ok(mut driver) => {
   10|      0|            match driver.run() {
   11|      0|                Ok(_) => std::process::exit(0),
   12|      0|                Err(e) => {
   13|      0|                    match e {
   14|      0|                        DriverError::IoError(e) => eprintln!("I/O error: {:?}", e),
   15|      0|                        DriverError::CompilationFailed => (), // diagnostic already printed by driver.run()
   16|       |                    };
   17|      0|                    std::process::exit(1);
   18|       |                }
   19|       |            }
   20|       |        }
   21|      0|        Err(e) => {
   22|      0|            eprintln!("Failed to initialize compiler: {}", e);
   23|      0|            std::process::exit(1);
   24|       |        }
   25|       |    }
   26|       |}

/app/src/mir.rs:
    1|       |//! Mid-level Intermediate Representation (MIR) for C11 compiler.
    2|       |//!
    3|       |//! This module provides the MIR data structures and APIs for representing
    4|       |//! C11 programs after semantic analysis. The MIR is designed to be:
    5|       |//! - Typed: All entities have explicit types
    6|       |//! - Explicit: All C semantics are made explicit
    7|       |//! - Cranelift-friendly: Easy to lower to Cranelift IR
    8|       |//! - Non-SSA: Uses basic blocks with explicit control flow
    9|       |
   10|       |use hashbrown::HashMap;
   11|       |use serde::Serialize;
   12|       |use std::fmt;
   13|       |use std::num::NonZeroU32;
   14|       |
   15|       |use crate::ast::NameId;
   16|       |
   17|       |pub mod codegen;
   18|       |pub mod dumper;
   19|       |pub mod validation;
   20|       |
   21|       |/// Unique identifier for MIR global variables
   22|       |pub type GlobalId = NonZeroU32;
   23|       |
   24|       |/// Unique identifier for MIR modules
   25|       |pub type MirModuleId = NonZeroU32;
   26|       |
   27|       |/// Unique identifier for MIR functions
   28|       |pub type MirFunctionId = NonZeroU32;
   29|       |
   30|       |/// Unique identifier for MIR blocks
   31|       |pub type MirBlockId = NonZeroU32;
   32|       |
   33|       |/// Unique identifier for MIR statements
   34|       |pub type MirStmtId = NonZeroU32;
   35|       |
   36|       |/// Unique identifier for MIR locals
   37|       |pub type LocalId = NonZeroU32;
   38|       |
   39|       |/// Unique identifier for MIR types
   40|       |pub type TypeId = NonZeroU32;
   41|       |
   42|       |/// Unique identifier for MIR constant values
   43|       |pub type ConstValueId = NonZeroU32;
   44|       |
   45|       |/// Function kind - distinguishes between defined and extern functions
   46|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
   47|       |pub enum MirFunctionKind {
   48|       |    Defined,
   49|       |    Extern,
   50|       |}
   51|       |
   52|       |/// MIR Module - Top-level container for MIR
   53|       |#[derive(Debug, Clone, PartialEq, Serialize)]
   54|       |pub struct MirModule {
   55|       |    pub id: MirModuleId,
   56|       |    pub functions: Vec<MirFunctionId>,
   57|       |    pub globals: Vec<GlobalId>,
   58|       |    pub types: Vec<MirType>,
   59|       |    pub constants: Vec<ConstValue>,
   60|       |    pub pointer_width: u8, // Width of a pointer in bytes (e.g., 4 or 8)
   61|       |}
   62|       |
   63|       |impl MirModule {
   64|    190|    pub fn new(id: MirModuleId) -> Self {
   65|    190|        Self {
   66|    190|            id,
   67|    190|            functions: Vec::new(),
   68|    190|            globals: Vec::new(),
   69|    190|            types: Vec::new(),
   70|    190|            constants: Vec::new(),
   71|    190|            pointer_width: 8, // Default to 64-bit pointers
   72|    190|        }
   73|    190|    }
   74|       |}
   75|       |
   76|       |/// MIR Function - Represents a C function in MIR
   77|       |#[derive(Debug, Clone, PartialEq, Serialize)]
   78|       |pub struct MirFunction {
   79|       |    pub id: MirFunctionId,
   80|       |    pub name: NameId,
   81|       |    pub return_type: TypeId,
   82|       |    pub params: Vec<LocalId>,
   83|       |
   84|       |    pub kind: MirFunctionKind,
   85|       |    pub is_variadic: bool, // Track if this function is variadic
   86|       |
   87|       |    // Only valid if kind is Defined
   88|       |    pub locals: Vec<LocalId>,
   89|       |    pub blocks: Vec<MirBlockId>,
   90|       |    pub entry_block: Option<MirBlockId>,
   91|       |}
   92|       |
   93|       |impl MirFunction {
   94|    116|    pub fn new_defined(id: MirFunctionId, name: NameId, return_type: TypeId) -> Self {
   95|    116|        Self {
   96|    116|            id,
   97|    116|            name,
   98|    116|            return_type,
   99|    116|            params: Vec::new(),
  100|    116|            kind: MirFunctionKind::Defined,
  101|    116|            is_variadic: false,
  102|    116|            locals: Vec::new(),
  103|    116|            blocks: Vec::new(),
  104|    116|            entry_block: None,
  105|    116|        }
  106|    116|    }
  107|       |
  108|      5|    pub fn new_extern(id: MirFunctionId, name: NameId, return_type: TypeId) -> Self {
  109|      5|        Self {
  110|      5|            id,
  111|      5|            name,
  112|      5|            return_type,
  113|      5|            params: Vec::new(),
  114|      5|            kind: MirFunctionKind::Extern,
  115|      5|            is_variadic: false,
  116|      5|            locals: Vec::new(),
  117|      5|            blocks: Vec::new(),
  118|      5|            entry_block: None,
  119|      5|        }
  120|      5|    }
  121|       |}
  122|       |
  123|       |/// MIR Block - Basic block with statements and terminator
  124|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  125|       |pub struct MirBlock {
  126|       |    pub id: MirBlockId,
  127|       |    pub statements: Vec<MirStmtId>,
  128|       |    pub terminator: Terminator,
  129|       |}
  130|       |
  131|       |impl MirBlock {
  132|    277|    pub fn new(id: MirBlockId) -> Self {
  133|    277|        Self {
  134|    277|            id,
  135|    277|            statements: Vec::new(),
  136|    277|            terminator: Terminator::Unreachable,
  137|    277|        }
  138|    277|    }
  139|       |}
  140|       |
  141|       |/// MIR Statement - Individual operations within a block
  142|       |/// Only contains side-effect operations, no control flow
  143|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  144|       |pub enum MirStmt {
  145|       |    Assign(Place, Rvalue),
  146|       |    Store(Operand, Place),
  147|       |    // Function calls - dest is None if void or result is ignored
  148|       |    Call {
  149|       |        target: CallTarget,
  150|       |        args: Vec<Operand>,
  151|       |        dest: Option<Place>,
  152|       |    },
  153|       |    // Memory operations
  154|       |    Alloc(Place, TypeId),
  155|       |    Dealloc(Operand),
  156|       |    BuiltinVaStart(Place, Operand),
  157|       |    BuiltinVaEnd(Place),
  158|       |    BuiltinVaCopy(Place, Place),
  159|       |}
  160|       |
  161|       |/// Terminator - Control flow terminators for basic blocks
  162|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  163|       |pub enum Terminator {
  164|       |    Goto(MirBlockId),
  165|       |    If(Operand, MirBlockId, MirBlockId),
  166|       |    Return(Option<Operand>),
  167|       |    Unreachable,
  168|       |}
  169|       |
  170|       |/// Place - Represents a storage location (local variable or memory)
  171|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  172|       |pub enum Place {
  173|       |    Local(LocalId),
  174|       |    Deref(Box<Operand>),
  175|       |    Global(GlobalId),
  176|       |    // Aggregate access
  177|       |    StructField(Box<Place>, /* struct index */ usize),
  178|       |    ArrayIndex(Box<Place>, Box<Operand>),
  179|       |}
  180|       |
  181|       |/// Operand - Represents values used in MIR operations
  182|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  183|       |pub enum Operand {
  184|       |    Copy(Box<Place>),
  185|       |    Constant(ConstValueId),
  186|       |    // Address operations
  187|       |    AddressOf(Box<Place>),
  188|       |    // Type conversion
  189|       |    Cast(TypeId, Box<Operand>),
  190|       |}
  191|       |
  192|       |/// Rvalue - Right-hand side values in assignments
  193|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  194|       |pub enum Rvalue {
  195|       |    Use(Operand),
  196|       |    BinaryIntOp(BinaryIntOp, Operand, Operand),
  197|       |    BinaryFloatOp(BinaryFloatOp, Operand, Operand),
  198|       |    UnaryIntOp(UnaryIntOp, Operand),
  199|       |    UnaryFloatOp(UnaryFloatOp, Operand),
  200|       |    Cast(TypeId, Operand),
  201|       |    PtrAdd(Operand, Operand),
  202|       |    PtrSub(Operand, Operand),
  203|       |    PtrDiff(Operand, Operand),
  204|       |    // Aggregate construction
  205|       |    StructLiteral(Vec<(usize, Operand)>),
  206|       |    ArrayLiteral(Vec<Operand>),
  207|       |    // Memory operations
  208|       |    Load(Operand),
  209|       |    BuiltinVaArg(Place, TypeId),
  210|       |}
  211|       |
  212|       |/// Call target - represents how a function is called
  213|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  214|       |pub enum CallTarget {
  215|       |    Direct(MirFunctionId), // Direct call to a known function
  216|       |    Indirect(Operand),     // Indirect call via function pointer
  217|       |}
  218|       |
  219|       |/// Integer binary operations
  220|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  221|       |#[repr(u8)]
  222|       |pub enum BinaryIntOp {
  223|       |    Add,
  224|       |    Sub,
  225|       |    Mul,
  226|       |    Div,
  227|       |    Mod,
  228|       |    BitAnd,
  229|       |    BitOr,
  230|       |    BitXor,
  231|       |    LShift,
  232|       |    RShift,
  233|       |    Eq,
  234|       |    Ne,
  235|       |    Lt,
  236|       |    Le,
  237|       |    Gt,
  238|       |    Ge,
  239|       |}
  240|       |
  241|       |/// Floating-point binary operations
  242|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  243|       |#[repr(u8)]
  244|       |pub enum BinaryFloatOp {
  245|       |    Add,
  246|       |    Sub,
  247|       |    Mul,
  248|       |    Div,
  249|       |    Eq,
  250|       |    Ne,
  251|       |    Lt,
  252|       |    Le,
  253|       |    Gt,
  254|       |    Ge,
  255|       |}
  256|       |
  257|       |/// Integer unary operations
  258|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  259|       |#[repr(u8)]
  260|       |pub enum UnaryIntOp {
  261|       |    Neg,
  262|       |    BitwiseNot,
  263|       |    LogicalNot,
  264|       |}
  265|       |
  266|       |/// Floating-point unary operations
  267|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  268|       |#[repr(u8)]
  269|       |pub enum UnaryFloatOp {
  270|       |    Neg,
  271|       |}
  272|       |
  273|       |/// Type - MIR type system
  274|       |// - All Struct/Union have a stable NameId
  275|       |// - No anonymous record types exist in MIR
  276|       |// - No anonymous members exist in MIR
  277|       |// - Field names are unique within a record
  278|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  279|       |pub enum MirType {
  280|       |    Void,
  281|       |    Bool,
  282|       |
  283|       |    I8,
  284|       |    I16,
  285|       |    I32,
  286|       |    I64,
  287|       |    U8,
  288|       |    U16,
  289|       |    U32,
  290|       |    U64,
  291|       |    F32,
  292|       |    F64,
  293|       |    Pointer {
  294|       |        pointee: TypeId,
  295|       |    },
  296|       |    Array {
  297|       |        element: TypeId,
  298|       |        size: usize,
  299|       |        layout: MirArrayLayout,
  300|       |    },
  301|       |    Function {
  302|       |        return_type: TypeId,
  303|       |        params: Vec<TypeId>,
  304|       |        is_variadic: bool,
  305|       |    },
  306|       |    Record {
  307|       |        name: NameId,
  308|       |        field_types: Vec<TypeId>,
  309|       |        field_names: Vec<NameId>,
  310|       |        is_union: bool,
  311|       |        layout: MirRecordLayout,
  312|       |    },
  313|       |}
  314|       |impl MirType {
  315|    180|    pub fn is_signed(&self) -> bool {
  316|    180|        matches!(self, MirType::I8 | MirType::I16 | MirType::I32 | MirType::I64)
                      ^54
  317|    180|    }
  318|       |
  319|      8|    pub fn is_pointer(&self) -> bool {
  320|      8|        matches!(self, MirType::Pointer { .. })
                      ^0
  321|      8|    }
  322|       |
  323|     65|    pub fn is_float(&self) -> bool {
  324|     65|        matches!(self, MirType::F32 | MirType::F64)
  325|     65|    }
  326|       |
  327|    300|    pub fn is_aggregate(&self) -> bool {
  328|    300|        matches!(self, MirType::Record { .. } | MirType::Array { .. })
                      ^298
  329|    300|    }
  330|       |
  331|     42|    pub fn is_int(&self) -> bool {
  332|      0|        matches!(
  333|     42|            self,
  334|       |            MirType::I8
  335|       |                | MirType::I16
  336|       |                | MirType::I32
  337|       |                | MirType::I64
  338|       |                | MirType::U8
  339|       |                | MirType::U16
  340|       |                | MirType::U32
  341|       |                | MirType::U64
  342|       |                | MirType::Bool
  343|       |        )
  344|     42|    }
  345|       |
  346|     24|    pub fn width(&self) -> u32 {
  347|     24|        match self {
  348|      0|            MirType::I8 | MirType::U8 | MirType::Bool => 8,
  349|      0|            MirType::I16 | MirType::U16 => 16,
  350|     12|            MirType::I32 | MirType::U32 | MirType::F32 => 32,
  351|     12|            MirType::I64 | MirType::U64 | MirType::F64 => 64,
  352|      0|            MirType::Pointer { .. } => 64, // Assume 64-bit pointers
  353|      0|            _ => 0,                        // Others have no intrinsic "width" in this context
  354|       |        }
  355|     24|    }
  356|       |}
  357|       |
  358|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  359|       |pub struct MirRecordLayout {
  360|       |    pub size: u16,
  361|       |    pub alignment: u16,
  362|       |    pub field_offsets: Vec<u16>,
  363|       |}
  364|       |
  365|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
  366|       |pub struct MirArrayLayout {
  367|       |    pub size: u16,
  368|       |    pub align: u16,
  369|       |    pub stride: u16,
  370|       |}
  371|       |
  372|       |/// Constant Value Kind - discriminant for ConstValue
  373|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  374|       |pub enum ConstValueKind {
  375|       |    Int(i64),
  376|       |    Float(f64),
  377|       |    Bool(bool),
  378|       |    Null, // pointer null
  379|       |    Zero, // memset / padding / zero-init
  380|       |    // Aggregate constants
  381|       |    StructLiteral(Vec<(usize, ConstValueId)>),
  382|       |    ArrayLiteral(Vec<ConstValueId>),
  383|       |    // Address constants
  384|       |    GlobalAddress(GlobalId),
  385|       |    FunctionAddress(MirFunctionId),
  386|       |}
  387|       |
  388|       |/// Constant Value - Literal values in MIR
  389|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  390|       |pub struct ConstValue {
  391|       |    pub ty: TypeId,
  392|       |    pub kind: ConstValueKind,
  393|       |}
  394|       |
  395|       |/// Local - Represents a local variable or parameter
  396|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
  397|       |pub struct Local {
  398|       |    pub id: LocalId,
  399|       |    pub name: Option<NameId>,
  400|       |    pub type_id: TypeId,
  401|       |    pub is_param: bool,
  402|       |    pub alignment: Option<u32>, // Alignment in bytes
  403|       |}
  404|       |
  405|       |impl Local {
  406|    202|    pub fn new(id: LocalId, name: Option<NameId>, type_id: TypeId, is_param: bool) -> Self {
  407|    202|        Self {
  408|    202|            id,
  409|    202|            name,
  410|    202|            type_id,
  411|    202|            is_param,
  412|    202|            alignment: None,
  413|    202|        }
  414|    202|    }
  415|       |}
  416|       |
  417|       |/// Global - Represents a global variable
  418|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
  419|       |pub struct Global {
  420|       |    pub id: GlobalId,
  421|       |    pub name: NameId,
  422|       |    pub type_id: TypeId,
  423|       |    pub is_constant: bool,
  424|       |    pub initial_value: Option<ConstValueId>,
  425|       |    pub alignment: Option<u32>, // Max alignment in bytes
  426|       |}
  427|       |
  428|       |impl Global {
  429|     38|    pub fn new(id: GlobalId, name: NameId, type_id: TypeId, is_constant: bool) -> Self {
  430|     38|        Self {
  431|     38|            id,
  432|     38|            name,
  433|     38|            type_id,
  434|     38|            is_constant,
  435|     38|            initial_value: None,
  436|     38|            alignment: None,
  437|     38|        }
  438|     38|    }
  439|       |}
  440|       |
  441|       |/// MIR Builder - Builds MIR from AST
  442|       |pub(crate) struct MirBuilder {
  443|       |    module: MirModule,
  444|       |    current_function: Option<MirFunctionId>,
  445|       |    current_block: Option<MirBlockId>,
  446|       |    next_local_id: u32,
  447|       |    next_block_id: u32,
  448|       |    next_stmt_id: u32,
  449|       |    next_global_id: u32,
  450|       |    next_type_id: u32,
  451|       |    next_const_id: u32,
  452|       |    anonymous_global_counter: u32,
  453|       |    // State tracking
  454|       |    functions: HashMap<MirFunctionId, MirFunction>,
  455|       |    blocks: HashMap<MirBlockId, MirBlock>,
  456|       |    locals: HashMap<LocalId, Local>,
  457|       |    globals: HashMap<GlobalId, Global>,
  458|       |    types: HashMap<TypeId, MirType>,
  459|       |    constants: HashMap<ConstValueId, ConstValue>,
  460|       |    // Statement storage with ID mapping
  461|       |    statements: HashMap<MirStmtId, MirStmt>,
  462|       |}
  463|       |
  464|       |/// Complete semantic analysis output containing the full MIR program representation
  465|       |/// Includes all functions, blocks, instructions, and type definitions.
  466|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  467|       |pub struct MirProgram {
  468|       |    pub module: MirModule,
  469|       |    pub functions: HashMap<MirFunctionId, MirFunction>,
  470|       |    pub blocks: HashMap<MirBlockId, MirBlock>,
  471|       |    pub locals: HashMap<LocalId, Local>,
  472|       |    pub globals: HashMap<GlobalId, Global>,
  473|       |    pub types: HashMap<TypeId, MirType>,
  474|       |    pub constants: HashMap<ConstValueId, ConstValue>,
  475|       |    pub statements: HashMap<MirStmtId, MirStmt>,
  476|       |    pub pointer_width: u8,
  477|       |}
  478|       |
  479|       |impl MirProgram {
  480|       |    /// get type or panic if not found
  481|    851|    pub(crate) fn get_type(&self, id: TypeId) -> &MirType {
  482|    851|        match self.types.get(&id) {
  483|    851|            Some(id) => id,
  484|      0|            None => panic!("ICE: Type ID {id} not found"),
  485|       |        }
  486|    851|    }
  487|    445|    pub(crate) fn get_local(&self, id: LocalId) -> &Local {
  488|    445|        match self.locals.get(&id) {
  489|    445|            Some(id) => id,
  490|      0|            None => panic!("ICE: Local ID {id} not found"),
  491|       |        }
  492|    445|    }
  493|     29|    pub(crate) fn get_function(&self, id: MirFunctionId) -> &MirFunction {
  494|     29|        match self.functions.get(&id) {
  495|     29|            Some(id) => id,
  496|      0|            None => panic!("ICE: Function ID {id} not found"),
  497|       |        }
  498|     29|    }
  499|     37|    pub(crate) fn get_global(&self, id: GlobalId) -> &Global {
  500|     37|        match self.globals.get(&id) {
  501|     37|            Some(id) => id,
  502|      0|            None => panic!("ICE: Global ID {id} not found"),
  503|       |        }
  504|     37|    }
  505|       |}
  506|       |
  507|       |impl MirBuilder {
  508|    190|    pub(crate) fn new(module_id: MirModuleId, pointer_width: u8) -> Self {
  509|    190|        let mut module = MirModule::new(module_id);
  510|    190|        module.pointer_width = pointer_width;
  511|    190|        Self {
  512|    190|            module,
  513|    190|            current_function: None,
  514|    190|            current_block: None,
  515|    190|            next_local_id: 1,
  516|    190|            next_block_id: 1,
  517|    190|            next_stmt_id: 1,
  518|    190|            next_global_id: 1,
  519|    190|            next_type_id: 1,
  520|    190|            next_const_id: 1,
  521|    190|            anonymous_global_counter: 0,
  522|    190|            functions: HashMap::new(),
  523|    190|            blocks: HashMap::new(),
  524|    190|            locals: HashMap::new(),
  525|    190|            globals: HashMap::new(),
  526|    190|            types: HashMap::new(),
  527|    190|            constants: HashMap::new(),
  528|    190|            statements: HashMap::new(),
  529|    190|        }
  530|    190|    }
  531|       |
  532|       |    /// Create a new local variable
  533|    202|    pub(crate) fn create_local(&mut self, name: Option<NameId>, type_id: TypeId, is_param: bool) -> LocalId {
  534|    202|        let local_id = LocalId::new(self.next_local_id).unwrap();
  535|    202|        self.next_local_id += 1;
  536|       |
  537|    202|        let local = Local::new(local_id, name, type_id, is_param);
  538|    202|        self.locals.insert(local_id, local);
  539|       |
  540|    202|        if let Some(func_id) = self.current_function
                                  ^191
  541|    191|            && let Some(func) = self.functions.get_mut(&func_id)
  542|       |        {
  543|    191|            if is_param {
  544|      0|                func.params.push(local_id);
  545|    191|            } else {
  546|    191|                func.locals.push(local_id);
  547|    191|            }
  548|     11|        }
  549|       |
  550|    202|        local_id
  551|    202|    }
  552|       |
  553|      0|    pub(crate) fn set_local_alignment(&mut self, local_id: LocalId, alignment: u32) {
  554|      0|        if let Some(local) = self.locals.get_mut(&local_id) {
  555|      0|            local.alignment = Some(alignment);
  556|      0|        }
  557|      0|    }
  558|       |
  559|       |    /// Create a new basic block
  560|    277|    pub(crate) fn create_block(&mut self) -> MirBlockId {
  561|    277|        let func_id = self.current_function.expect("no current function");
  562|    277|        let func = self.functions.get(&func_id).unwrap();
  563|       |
  564|    277|        assert!(
  565|    277|            matches!(func.kind, MirFunctionKind::Defined),
                          ^0
  566|      0|            "cannot create blocks for extern function"
  567|       |        );
  568|       |
  569|    277|        let block_id = MirBlockId::new(self.next_block_id).unwrap();
  570|    277|        self.next_block_id += 1;
  571|       |
  572|    277|        let block = MirBlock::new(block_id);
  573|    277|        self.blocks.insert(block_id, block);
  574|       |
  575|    277|        if let Some(func) = self.functions.get_mut(&func_id) {
  576|    277|            func.blocks.push(block_id);
  577|    277|        }
                      ^0
  578|       |
  579|    277|        block_id
  580|    277|    }
  581|       |
  582|       |    /// Add a statement to the current block
  583|    241|    pub(crate) fn add_statement(&mut self, stmt: MirStmt) -> MirStmtId {
  584|    241|        let stmt_id = MirStmtId::new(self.next_stmt_id).unwrap();
  585|    241|        self.next_stmt_id += 1;
  586|       |
  587|       |        // Store statement in the HashMap
  588|    241|        self.statements.insert(stmt_id, stmt.clone());
  589|       |
  590|    241|        if let Some(block_id) = self.current_block
  591|    241|            && let Some(block) = self.blocks.get_mut(&block_id)
  592|    241|        {
  593|    241|            block.statements.push(stmt_id);
  594|    241|        }
                      ^0
  595|       |
  596|    241|        stmt_id
  597|    241|    }
  598|       |
  599|       |    /// Set the terminator for the current block
  600|    272|    pub(crate) fn set_terminator(&mut self, terminator: Terminator) {
  601|    272|        if let Some(block_id) = self.current_block
  602|    272|            && let Some(block) = self.blocks.get_mut(&block_id)
  603|    272|        {
  604|    272|            block.terminator = terminator;
  605|    272|        }
                      ^0
  606|    272|    }
  607|       |
  608|       |    /// Set the current block
  609|    277|    pub(crate) fn set_current_block(&mut self, block_id: MirBlockId) {
  610|    277|        self.current_block = Some(block_id);
  611|    277|    }
  612|       |
  613|       |    /// Check if the current block has a non-unreachable terminator
  614|       |    /// Since terminators always exist, this checks if the terminator is meaningful
  615|       |    /// (i.e., not just the default Unreachable terminator)
  616|    540|    pub(crate) fn current_block_has_terminator(&self) -> bool {
  617|    540|        if let Some(block_id) = self.current_block
  618|    540|            && let Some(block) = self.blocks.get(&block_id)
  619|       |        {
  620|    540|            return !matches!(block.terminator, Terminator::Unreachable);
                                  ^45
  621|      0|        }
  622|      0|        false
  623|    540|    }
  624|       |
  625|       |    /// Declare a function (extern - no body)
  626|      5|    pub(crate) fn declare_function(
  627|      5|        &mut self,
  628|      5|        name: NameId,
  629|      5|        param_types: Vec<TypeId>,
  630|      5|        return_type: TypeId,
  631|      5|        is_variadic: bool,
  632|      5|    ) -> MirFunctionId {
  633|      5|        let func_id = MirFunctionId::new(self.module.functions.len() as u32 + 1).unwrap();
  634|      5|        let mut func = MirFunction::new_extern(func_id, name, return_type);
  635|      5|        func.is_variadic = is_variadic;
  636|       |
  637|       |        // Create locals for each parameter
  638|      6|        for (i, &param_type) in param_types.iter().enumerate() {
                                              ^5                 ^5
  639|      6|            let param_name = Some(NameId::new(format!("param{}", i)));
  640|      6|            let local_id = self.create_local(param_name, param_type, true);
  641|      6|            func.params.push(local_id);
  642|      6|        }
  643|       |
  644|      5|        self.functions.insert(func_id, func);
  645|      5|        self.module.functions.push(func_id);
  646|       |
  647|      5|        func_id
  648|      5|    }
  649|       |
  650|       |    /// Define a function (has body)
  651|    116|    pub(crate) fn define_function(
  652|    116|        &mut self,
  653|    116|        name: NameId,
  654|    116|        param_types: Vec<TypeId>,
  655|    116|        return_type: TypeId,
  656|    116|        is_variadic: bool,
  657|    116|    ) -> MirFunctionId {
  658|    116|        let func_id = MirFunctionId::new(self.module.functions.len() as u32 + 1).unwrap();
  659|    116|        let mut func = MirFunction::new_defined(func_id, name, return_type);
  660|    116|        func.is_variadic = is_variadic;
  661|       |
  662|       |        // Create locals for each parameter
  663|    116|        for (i, &param_type) in param_types.iter().enumerate() {
                           ^5  ^5
  664|      5|            let param_name = Some(NameId::new(format!("param{}", i)));
  665|      5|            let local_id = self.create_local(param_name, param_type, true);
  666|      5|            func.params.push(local_id);
  667|      5|        }
  668|       |
  669|    116|        self.functions.insert(func_id, func);
  670|    116|        self.module.functions.push(func_id);
  671|       |
  672|    116|        func_id
  673|    116|    }
  674|       |
  675|       |    /// Set current function
  676|    116|    pub(crate) fn set_current_function(&mut self, func_id: MirFunctionId) {
  677|    116|        self.current_function = Some(func_id);
  678|    116|        if let Some(func) = self.functions.get(&func_id)
  679|    116|            && let Some(entry_block) = func.entry_block
                                      ^0
  680|      0|        {
  681|      0|            self.current_block = Some(entry_block);
  682|    116|        }
  683|    116|    }
  684|       |
  685|       |    /// Create a new global variable with initial value
  686|     38|    pub(crate) fn create_global_with_init(
  687|     38|        &mut self,
  688|     38|        name: NameId,
  689|     38|        type_id: TypeId,
  690|     38|        is_constant: bool,
  691|     38|        initial_value: Option<ConstValueId>,
  692|     38|    ) -> GlobalId {
  693|     38|        let global_id = GlobalId::new(self.next_global_id).unwrap();
  694|     38|        self.next_global_id += 1;
  695|       |
  696|     38|        let mut global = Global::new(global_id, name, type_id, is_constant);
  697|     38|        global.initial_value = initial_value;
  698|     38|        self.globals.insert(global_id, global);
  699|     38|        self.module.globals.push(global_id);
  700|       |
  701|     38|        global_id
  702|     38|    }
  703|       |
  704|      2|    pub(crate) fn set_global_initializer(&mut self, global_id: GlobalId, init_id: ConstValueId) {
  705|      2|        if let Some(global) = self.globals.get_mut(&global_id) {
  706|      2|            global.initial_value = Some(init_id);
  707|      2|        }
                      ^0
  708|      2|    }
  709|       |
  710|      0|    pub(crate) fn set_global_alignment(&mut self, global_id: GlobalId, alignment: u32) {
  711|      0|        if let Some(global) = self.globals.get_mut(&global_id) {
  712|      0|            global.alignment = Some(alignment);
  713|      0|        }
  714|      0|    }
  715|       |
  716|       |    /// Add a type to the module with interning
  717|    325|    pub(crate) fn add_type(&mut self, mir_type: MirType) -> TypeId {
  718|       |        // Check if type already exists (type interning)
  719|  1.08k|        for (existing_id, existing_type) in &self.types {
                           ^804         ^804
  720|    804|            if existing_type == &mir_type {
  721|     49|                return *existing_id;
  722|    755|            }
  723|       |        }
  724|       |
  725|       |        // Type doesn't exist, create new one
  726|    276|        let type_id = TypeId::new(self.next_type_id).unwrap();
  727|    276|        self.next_type_id += 1;
  728|       |
  729|    276|        self.types.insert(type_id, mir_type.clone());
  730|    276|        self.module.types.push(mir_type);
  731|       |
  732|    276|        type_id
  733|    325|    }
  734|       |
  735|       |    /// Update an existing type previously inserted with `add_type`.
  736|       |    /// This replaces the type entry in both the internal map and the module vector.
  737|     34|    pub(crate) fn update_type(&mut self, type_id: TypeId, mir_type: MirType) {
  738|     34|        self.types.insert(type_id, mir_type.clone());
  739|     34|        let idx = (type_id.get() - 1) as usize;
  740|     34|        if idx < self.module.types.len() {
  741|     34|            self.module.types[idx] = mir_type;
  742|     34|        }
                      ^0
  743|     34|    }
  744|       |
  745|    126|    pub(crate) fn get_type(&self, type_id: TypeId) -> &MirType {
  746|    126|        self.types.get(&type_id).expect("Type ID not found in MirBuilder")
  747|    126|    }
  748|       |
  749|       |    /// Create a constant value
  750|    537|    pub(crate) fn create_constant(&mut self, ty: TypeId, kind: ConstValueKind) -> ConstValueId {
  751|    537|        let const_id = ConstValueId::new(self.next_const_id).unwrap();
  752|    537|        self.next_const_id += 1;
  753|       |
  754|    537|        let value = ConstValue { ty, kind };
  755|    537|        self.constants.insert(const_id, value.clone());
  756|    537|        self.module.constants.push(value);
  757|       |
  758|    537|        const_id
  759|    537|    }
  760|       |
  761|       |    /// Consumes the builder and returns all the generated MIR components.
  762|       |    /// This is the preferred way to get the final MIR, as it avoids cloning.
  763|     98|    pub(crate) fn consume(self) -> MirProgram {
  764|     98|        let pointer_width = self.module.pointer_width;
  765|     98|        MirProgram {
  766|     98|            module: self.module,
  767|     98|            functions: self.functions,
  768|     98|            blocks: self.blocks,
  769|     98|            locals: self.locals,
  770|     98|            globals: self.globals,
  771|     98|            types: self.types,
  772|     98|            constants: self.constants,
  773|     98|            statements: self.statements,
  774|     98|            pointer_width,
  775|     98|        }
  776|     98|    }
  777|       |
  778|       |    /// Get all functions for validation
  779|    520|    pub(crate) fn get_functions(&self) -> &HashMap<MirFunctionId, MirFunction> {
  780|    520|        &self.functions
  781|    520|    }
  782|       |
  783|       |    /// Get all constants for validation
  784|    388|    pub(crate) fn get_constants(&self) -> &HashMap<ConstValueId, ConstValue> {
  785|    388|        &self.constants
  786|    388|    }
  787|       |
  788|     13|    pub(crate) fn get_globals(&self) -> &HashMap<GlobalId, Global> {
  789|     13|        &self.globals
  790|     13|    }
  791|       |
  792|     83|    pub(crate) fn get_locals(&self) -> &HashMap<LocalId, Local> {
  793|     83|        &self.locals
  794|     83|    }
  795|       |
  796|       |    /// Set the entry block for a function
  797|    116|    pub(crate) fn set_function_entry_block(&mut self, func_id: MirFunctionId, block_id: MirBlockId) {
  798|    116|        if let Some(func) = self.functions.get_mut(&func_id) {
  799|    116|            assert!(matches!(func.kind, MirFunctionKind::Defined));
                                  ^0
  800|    116|            func.entry_block = Some(block_id);
  801|      0|        }
  802|    116|    }
  803|       |
  804|      8|    pub(crate) fn get_next_anonymous_global_name(&mut self) -> NameId {
  805|      8|        let name = format!(".L.str{}", self.anonymous_global_counter);
  806|      8|        self.anonymous_global_counter += 1;
  807|      8|        NameId::new(name)
  808|      8|    }
  809|       |}
  810|       |
  811|       |/// Display implementations for debugging
  812|       |impl fmt::Display for MirModule {
  813|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  814|      0|        writeln!(f, "MirModule(id: {})", self.id.get())?;
  815|      0|        writeln!(f, "  Functions: {:?}", self.functions)?;
  816|      0|        writeln!(f, "  Globals: {:?}", self.globals)?;
  817|      0|        writeln!(f, "  Types: {:?}", self.types)?;
  818|      0|        writeln!(f, "  Constants: {:?}", self.constants)?;
  819|      0|        Ok(())
  820|      0|    }
  821|       |}
  822|       |
  823|       |impl fmt::Display for MirFunction {
  824|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  825|      0|        writeln!(
  826|      0|            f,
  827|      0|            "MirFunction(id: {}, name: {}, kind: {:?}, is_variadic: {})",
  828|      0|            self.id.get(),
  829|       |            self.name,
  830|       |            self.kind,
  831|       |            self.is_variadic
  832|      0|        )?;
  833|      0|        writeln!(f, "  Return type: {:?}", self.return_type)?;
  834|      0|        writeln!(f, "  Params: {:?}", self.params)?;
  835|      0|        writeln!(f, "  Locals: {:?}", self.locals)?;
  836|      0|        writeln!(f, "  Blocks: {:?}", self.blocks)?;
  837|      0|        if let Some(entry_block) = self.entry_block {
  838|      0|            writeln!(f, "  Entry block: {:?}", entry_block)?;
  839|       |        } else {
  840|      0|            writeln!(f, "  Entry block: None")?;
  841|       |        }
  842|      0|        Ok(())
  843|      0|    }
  844|       |}
  845|       |
  846|       |impl fmt::Display for MirBlock {
  847|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  848|      0|        writeln!(f, "MirBlock(id: {})", self.id.get())?;
  849|      0|        writeln!(f, "  Statements: {:?}", self.statements)?;
  850|      0|        writeln!(f, "  Terminator: {:?}", self.terminator)?;
  851|      0|        Ok(())
  852|      0|    }
  853|       |}
  854|       |
  855|       |impl fmt::Display for MirStmt {
  856|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  857|      0|        match self {
  858|      0|            MirStmt::Assign(place, operand) => write!(f, "Assign({:?}, {:?})", place, operand),
  859|      0|            MirStmt::Store(operand, place) => write!(f, "Store({:?}, {:?})", operand, place),
  860|      0|            MirStmt::Call { target, args, dest } => {
  861|      0|                write!(f, "Call {{ target: {:?}, args: {:?}, dest: {:?} }}", target, args, dest)
  862|       |            }
  863|      0|            MirStmt::Alloc(place, type_id) => write!(f, "Alloc({:?}, {})", place, type_id.get()),
  864|      0|            MirStmt::Dealloc(operand) => write!(f, "Dealloc({:?})", operand),
  865|      0|            MirStmt::BuiltinVaStart(ap, last) => write!(f, "BuiltinVaStart({:?}, {:?})", ap, last),
  866|      0|            MirStmt::BuiltinVaEnd(ap) => write!(f, "BuiltinVaEnd({:?})", ap),
  867|      0|            MirStmt::BuiltinVaCopy(dst, src) => write!(f, "BuiltinVaCopy({:?}, {:?})", dst, src),
  868|       |        }
  869|      0|    }
  870|       |}
  871|       |
  872|       |impl fmt::Display for Terminator {
  873|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  874|      0|        match self {
  875|      0|            Terminator::Goto(block) => write!(f, "Goto({})", block.get()),
  876|      0|            Terminator::If(cond, then_block, else_block) => {
  877|      0|                write!(f, "If({:?}, {}, {})", cond, then_block.get(), else_block.get())
  878|       |            }
  879|      0|            Terminator::Return(operand) => write!(f, "Return({:?})", operand),
  880|      0|            Terminator::Unreachable => write!(f, "Unreachable"),
  881|       |        }
  882|      0|    }
  883|       |}
  884|       |
  885|       |impl fmt::Display for Place {
  886|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  887|      0|        match self {
  888|      0|            Place::Local(local) => write!(f, "Local({})", local.get()),
  889|      0|            Place::Deref(operand) => write!(f, "Deref({:?})", operand),
  890|      0|            Place::Global(global) => write!(f, "Global({})", global.get()),
  891|      0|            Place::StructField(place, field_idx) => write!(f, "StructField({:?}, {})", place, field_idx),
  892|      0|            Place::ArrayIndex(place, index) => write!(f, "ArrayIndex({:?}, {:?})", place, index),
  893|       |        }
  894|      0|    }
  895|       |}
  896|       |
  897|       |impl fmt::Display for Operand {
  898|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  899|      0|        match self {
  900|      0|            Operand::Copy(place) => write!(f, "Copy({:?})", place),
  901|      0|            Operand::Constant(const_id) => write!(f, "Constant({})", const_id.get()),
  902|      0|            Operand::AddressOf(place) => write!(f, "AddressOf({:?})", place),
  903|      0|            Operand::Cast(type_id, operand) => write!(f, "Cast({}, {:?})", type_id.get(), operand),
  904|       |        }
  905|      0|    }
  906|       |}
  907|       |
  908|       |impl fmt::Display for Rvalue {
  909|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  910|      0|        match self {
  911|      0|            Rvalue::Use(operand) => write!(f, "Use({:?})", operand),
  912|      0|            Rvalue::BinaryIntOp(op, left, right) => write!(f, "BinaryIntOp({}, {:?}, {:?})", op, left, right),
  913|      0|            Rvalue::BinaryFloatOp(op, left, right) => write!(f, "BinaryFloatOp({}, {:?}, {:?})", op, left, right),
  914|      0|            Rvalue::UnaryIntOp(op, operand) => write!(f, "UnaryIntOp({}, {:?})", op, operand),
  915|      0|            Rvalue::UnaryFloatOp(op, operand) => write!(f, "UnaryFloatOp({}, {:?})", op, operand),
  916|      0|            Rvalue::Cast(type_id, operand) => write!(f, "Cast({}, {:?})", type_id.get(), operand),
  917|      0|            Rvalue::PtrAdd(base, offset) => write!(f, "PtrAdd({:?}, {:?})", base, offset),
  918|      0|            Rvalue::PtrSub(base, offset) => write!(f, "PtrSub({:?}, {:?})", base, offset),
  919|      0|            Rvalue::PtrDiff(left, right) => write!(f, "PtrDiff({:?}, {:?})", left, right),
  920|      0|            Rvalue::StructLiteral(fields) => write!(f, "StructLiteral({:?})", fields),
  921|      0|            Rvalue::ArrayLiteral(elements) => write!(f, "ArrayLiteral({:?})", elements),
  922|      0|            Rvalue::Load(operand) => write!(f, "Load({:?})", operand),
  923|      0|            Rvalue::BuiltinVaArg(ap, ty) => write!(f, "BuiltinVaArg({:?}, {})", ap, ty.get()),
  924|       |        }
  925|      0|    }
  926|       |}
  927|       |
  928|       |impl fmt::Display for BinaryIntOp {
  929|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  930|      0|        match self {
  931|      0|            BinaryIntOp::Add => write!(f, "+"),
  932|      0|            BinaryIntOp::Sub => write!(f, "-"),
  933|      0|            BinaryIntOp::Mul => write!(f, "*"),
  934|      0|            BinaryIntOp::Div => write!(f, "/"),
  935|      0|            BinaryIntOp::Mod => write!(f, "%"),
  936|      0|            BinaryIntOp::BitAnd => write!(f, "&"),
  937|      0|            BinaryIntOp::BitOr => write!(f, "|"),
  938|      0|            BinaryIntOp::BitXor => write!(f, "^"),
  939|      0|            BinaryIntOp::LShift => write!(f, "<<"),
  940|      0|            BinaryIntOp::RShift => write!(f, ">>"),
  941|      0|            BinaryIntOp::Eq => write!(f, "=="),
  942|      0|            BinaryIntOp::Ne => write!(f, "!="),
  943|      0|            BinaryIntOp::Lt => write!(f, "<"),
  944|      0|            BinaryIntOp::Le => write!(f, "<="),
  945|      0|            BinaryIntOp::Gt => write!(f, ">"),
  946|      0|            BinaryIntOp::Ge => write!(f, ">="),
  947|       |        }
  948|      0|    }
  949|       |}
  950|       |
  951|       |impl fmt::Display for BinaryFloatOp {
  952|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  953|      0|        match self {
  954|      0|            BinaryFloatOp::Add => write!(f, "+"),
  955|      0|            BinaryFloatOp::Sub => write!(f, "-"),
  956|      0|            BinaryFloatOp::Mul => write!(f, "*"),
  957|      0|            BinaryFloatOp::Div => write!(f, "/"),
  958|      0|            BinaryFloatOp::Eq => write!(f, "=="),
  959|      0|            BinaryFloatOp::Ne => write!(f, "!="),
  960|      0|            BinaryFloatOp::Lt => write!(f, "<"),
  961|      0|            BinaryFloatOp::Le => write!(f, "<="),
  962|      0|            BinaryFloatOp::Gt => write!(f, ">"),
  963|      0|            BinaryFloatOp::Ge => write!(f, ">="),
  964|       |        }
  965|      0|    }
  966|       |}
  967|       |
  968|       |impl fmt::Display for UnaryIntOp {
  969|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  970|      0|        match self {
  971|      0|            UnaryIntOp::Neg => write!(f, "-"),
  972|      0|            UnaryIntOp::BitwiseNot => write!(f, "~"),
  973|      0|            UnaryIntOp::LogicalNot => write!(f, "!"),
  974|       |        }
  975|      0|    }
  976|       |}
  977|       |
  978|       |impl fmt::Display for UnaryFloatOp {
  979|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  980|      0|        match self {
  981|      0|            UnaryFloatOp::Neg => write!(f, "-"),
  982|       |        }
  983|      0|    }
  984|       |}
  985|       |
  986|       |impl fmt::Display for MirType {
  987|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  988|      0|        match self {
  989|      0|            MirType::Void => write!(f, "void"),
  990|      0|            MirType::Bool => write!(f, "bool"),
  991|       |
  992|      0|            MirType::I8 => write!(f, "i8"),
  993|      0|            MirType::I16 => write!(f, "i16"),
  994|      0|            MirType::I32 => write!(f, "i32"),
  995|      0|            MirType::I64 => write!(f, "i64"),
  996|      0|            MirType::U8 => write!(f, "u8"),
  997|      0|            MirType::U16 => write!(f, "u16"),
  998|      0|            MirType::U32 => write!(f, "u32"),
  999|      0|            MirType::U64 => write!(f, "u64"),
 1000|      0|            MirType::F32 => write!(f, "f32"),
 1001|      0|            MirType::F64 => write!(f, "f64"),
 1002|      0|            MirType::Pointer { pointee } => write!(f, "*{}", pointee.get()),
 1003|      0|            MirType::Array { element, size, .. } => write!(f, "[{}]{}", size, element.get()),
 1004|       |            MirType::Function {
 1005|      0|                return_type,
 1006|      0|                params,
 1007|      0|                is_variadic,
 1008|       |            } => {
 1009|      0|                if *is_variadic {
 1010|      0|                    write!(f, "fn({:?}, ...) -> {}", params, return_type.get())
 1011|       |                } else {
 1012|      0|                    write!(f, "fn({:?}) -> {}", params, return_type.get())
 1013|       |                }
 1014|       |            }
 1015|       |            MirType::Record {
 1016|      0|                name,
 1017|      0|                field_types,
 1018|      0|                field_names,
 1019|      0|                is_union,
 1020|       |                ..
 1021|       |            } => {
 1022|      0|                let kind = if *is_union { "union" } else { "struct" };
 1023|      0|                let fields_str = field_names
 1024|      0|                    .iter()
 1025|      0|                    .zip(field_types.iter())
 1026|      0|                    .map(|(name, ty)| format!("{}: {}", name, ty.get()))
 1027|      0|                    .collect::<Vec<_>>()
 1028|      0|                    .join(", ");
 1029|      0|                write!(f, "{} {} {{ {} }}", kind, name, fields_str)
 1030|       |            }
 1031|       |        }
 1032|      0|    }
 1033|       |}
 1034|       |
 1035|       |impl fmt::Display for ConstValueKind {
 1036|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1037|      0|        match self {
 1038|      0|            ConstValueKind::Int(val) => write!(f, "{}", val),
 1039|      0|            ConstValueKind::Float(val) => write!(f, "{}", val),
 1040|      0|            ConstValueKind::Bool(val) => write!(f, "{}", val),
 1041|      0|            ConstValueKind::Null => write!(f, "null"),
 1042|      0|            ConstValueKind::Zero => write!(f, "zeroinit"),
 1043|      0|            ConstValueKind::StructLiteral(fields) => write!(f, "StructLiteral({:?})", fields),
 1044|      0|            ConstValueKind::ArrayLiteral(elements) => write!(f, "ArrayLiteral({:?})", elements),
 1045|      0|            ConstValueKind::GlobalAddress(global_id) => write!(f, "GlobalAddress({})", global_id.get()),
 1046|      0|            ConstValueKind::FunctionAddress(func_id) => write!(f, "FunctionAddress({})", func_id.get()),
 1047|       |        }
 1048|      0|    }
 1049|       |}
 1050|       |
 1051|       |impl fmt::Display for ConstValue {
 1052|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1053|      0|        write!(f, "{} (ty: {})", self.kind, self.ty.get())
 1054|      0|    }
 1055|       |}
 1056|       |
 1057|       |impl fmt::Display for CallTarget {
 1058|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1059|      0|        match self {
 1060|      0|            CallTarget::Direct(func_id) => write!(f, "Direct({})", func_id.get()),
 1061|      0|            CallTarget::Indirect(operand) => write!(f, "Indirect({:?})", operand),
 1062|       |        }
 1063|      0|    }
 1064|       |}
 1065|       |
 1066|       |impl fmt::Display for Local {
 1067|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1068|      0|        write!(
 1069|      0|            f,
 1070|      0|            "Local(id: {}, name: {:?}, type: {}, is_param: {})",
 1071|      0|            self.id.get(),
 1072|       |            self.name,
 1073|      0|            self.type_id.get(),
 1074|       |            self.is_param
 1075|       |        )
 1076|      0|    }
 1077|       |}
 1078|       |
 1079|       |impl fmt::Display for Global {
 1080|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1081|      0|        write!(
 1082|      0|            f,
 1083|      0|            "Global(id: {}, name: {}, type: {}, is_constant: {})",
 1084|      0|            self.id.get(),
 1085|       |            self.name,
 1086|      0|            self.type_id.get(),
 1087|       |            self.is_constant
 1088|       |        )
 1089|      0|    }
 1090|       |}

/app/src/mir/codegen.rs:
    1|       |//! MIR to Cranelift IR lowering module
    2|       |//!
    3|       |//! This module provides the mechanical translation from MIR to Cranelift IR.
    4|       |//! The translation follows these rules:
    5|       |//! - No C logic
    6|       |//! - Assume MIR is valid
    7|       |
    8|       |use crate::mir::MirProgram;
    9|       |use crate::mir::{
   10|       |    BinaryFloatOp, BinaryIntOp, CallTarget, ConstValueId, ConstValueKind, GlobalId, LocalId, MirBlockId, MirFunction,
   11|       |    MirFunctionId, MirFunctionKind, MirStmt, MirType, Operand, Place, Rvalue, Terminator, TypeId, UnaryFloatOp,
   12|       |    UnaryIntOp,
   13|       |};
   14|       |use cranelift::codegen::ir::{BlockArg, Inst, StackSlot, StackSlotData, StackSlotKind};
   15|       |use cranelift::prelude::{
   16|       |    AbiParam, Block, Configurable, FloatCC, FunctionBuilderContext, InstBuilder, IntCC, MemFlags, Signature, Type,
   17|       |    Value, types,
   18|       |};
   19|       |use cranelift_frontend::FunctionBuilder;
   20|       |use cranelift_module::{DataDescription, DataId, FuncId, Linkage, Module};
   21|       |use cranelift_object::{ObjectBuilder, ObjectModule};
   22|       |use hashbrown::HashMap;
   23|       |use hashbrown::HashSet;
   24|       |use target_lexicon::Triple;
   25|       |
   26|       |/// emitted from codegen
   27|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   28|       |pub enum EmitKind {
   29|       |    Object,
   30|       |    Clif,
   31|       |}
   32|       |
   33|       |pub enum ClifOutput {
   34|       |    ObjectFile(Vec<u8>),
   35|       |    ClifDump(String),
   36|       |}
   37|       |
   38|       |/// Helper function to convert MIR type to Cranelift type
   39|       |/// Returns None for void types, as they don't have a representation in Cranelift
   40|    476|fn convert_type(mir_type: &MirType) -> Option<Type> {
   41|    476|    match mir_type {
   42|      6|        MirType::Void => None,
   43|     27|        MirType::Bool => Some(types::I8), // Booleans as i8 (standard C)
   44|       |
   45|     18|        MirType::I8 | MirType::U8 => Some(types::I8),
   46|     10|        MirType::I16 | MirType::U16 => Some(types::I16),
   47|    336|        MirType::I32 | MirType::U32 => Some(types::I32),
   48|     42|        MirType::I64 | MirType::U64 => Some(types::I64),
   49|      0|        MirType::F32 => Some(types::F32),
   50|      2|        MirType::F64 => Some(types::F64),
   51|     31|        MirType::Pointer { .. } => Some(types::I64), // Pointers are 64-bit on most modern systems
   52|       |
   53|      3|        MirType::Array { .. } | MirType::Record { .. } => None,
   54|      1|        MirType::Function { .. } => Some(types::I64), // Function pointers
   55|       |    }
   56|    476|}
   57|       |
   58|       |/// Helper function to convert MIR function kind to Cranelift linkage
   59|     59|fn convert_linkage(kind: MirFunctionKind) -> Linkage {
   60|     59|    match kind {
   61|      1|        MirFunctionKind::Extern => Linkage::Import,
   62|     58|        MirFunctionKind::Defined => Linkage::Export,
   63|       |    }
   64|     59|}
   65|       |
   66|       |/// Helper function to get the size of a MIR type in bytes
   67|    122|pub(crate) fn mir_type_size(mir_type: &MirType, mir: &MirProgram) -> Result<u32, String> {
   68|    122|    match mir_type {
   69|     32|        MirType::I8 | MirType::U8 => Ok(1),
   70|      2|        MirType::I16 | MirType::U16 => Ok(2),
   71|     61|        MirType::I32 | MirType::U32 => Ok(4),
   72|      3|        MirType::I64 | MirType::U64 => Ok(8),
   73|      0|        MirType::F32 => Ok(4),
   74|      0|        MirType::F64 => Ok(8),
   75|       |
   76|     10|        MirType::Pointer { .. } => Ok(mir.pointer_width as u32),
   77|      3|        MirType::Array { layout, .. } => Ok(layout.size as u32),
   78|      4|        MirType::Record { layout, .. } => Ok(layout.size as u32),
   79|      7|        MirType::Bool => Ok(1),
   80|      0|        MirType::Void => Ok(0),
   81|       |        // For other complex types, let's have a default, though this should be comprehensive.
   82|      0|        _ => Ok(4), // Default size for other types
   83|       |    }
   84|    122|}
   85|       |
   86|       |/// Context for constant emission
   87|       |pub(crate) struct EmitContext<'a> {
   88|       |    pub mir: &'a MirProgram,
   89|       |    pub func_id_map: &'a HashMap<MirFunctionId, FuncId>,
   90|       |    pub data_id_map: &'a HashMap<GlobalId, DataId>,
   91|       |}
   92|       |
   93|       |/// Context for emitting function bodies
   94|       |pub(crate) struct BodyEmitContext<'a, 'b> {
   95|       |    pub builder: &'a mut FunctionBuilder<'b>,
   96|       |    pub mir: &'a MirProgram,
   97|       |    pub stack_slots: &'a HashMap<LocalId, StackSlot>,
   98|       |    pub module: &'a mut ObjectModule,
   99|       |    pub clif_blocks: &'a HashMap<MirBlockId, Block>,
  100|       |    pub worklist: &'a mut Vec<MirBlockId>,
  101|       |    pub return_type: Option<Type>,
  102|       |    pub va_spill_slot: Option<StackSlot>,
  103|       |    pub func: &'a MirFunction,
  104|       |    pub func_id_map: &'a HashMap<MirFunctionId, FuncId>,
  105|       |}
  106|       |
  107|       |/// Helper to emit integer constants
  108|     35|fn emit_const_int(val: i64, layout: &MirType, output: &mut Vec<u8>) -> Result<(), String> {
  109|     35|    match layout {
  110|     30|        MirType::I8 | MirType::U8 => {
  111|     30|            let bytes = (val as i8).to_le_bytes();
  112|     30|            output.extend_from_slice(&bytes);
  113|     30|        }
  114|      0|        MirType::I16 | MirType::U16 => {
  115|      0|            let bytes = (val as i16).to_le_bytes();
  116|      0|            output.extend_from_slice(&bytes);
  117|      0|        }
  118|      5|        MirType::I32 | MirType::U32 => {
  119|      5|            let bytes = (val as i32).to_le_bytes();
  120|      5|            output.extend_from_slice(&bytes);
  121|      5|        }
  122|      0|        MirType::I64 | MirType::U64 => {
  123|      0|            let bytes = val.to_le_bytes();
  124|      0|            output.extend_from_slice(&bytes);
  125|      0|        }
  126|       |        MirType::Bool => {
  127|      0|            let byte = if val != 0 { 1u8 } else { 0u8 };
  128|      0|            output.push(byte);
  129|       |        }
  130|      0|        MirType::Pointer { .. } => {
  131|      0|            let bytes = (val).to_le_bytes();
  132|      0|            output.extend_from_slice(&bytes);
  133|      0|        }
  134|      0|        _ => {
  135|      0|            let bytes = (val as i32).to_le_bytes();
  136|      0|            output.extend_from_slice(&bytes);
  137|      0|        }
  138|       |    }
  139|     35|    Ok(())
  140|     35|}
  141|       |
  142|       |/// Helper to emit float constants
  143|      0|fn emit_const_float(val: f64, ty: &MirType, output: &mut Vec<u8>) -> Result<(), String> {
  144|      0|    match ty {
  145|      0|        MirType::F32 => {
  146|      0|            let bytes = (val as f32).to_bits().to_le_bytes();
  147|      0|            output.extend_from_slice(&bytes);
  148|      0|        }
  149|      0|        MirType::F64 => {
  150|      0|            let bytes = val.to_bits().to_le_bytes();
  151|      0|            output.extend_from_slice(&bytes);
  152|      0|        }
  153|      0|        _ => {
  154|      0|            let bytes = val.to_bits().to_le_bytes();
  155|      0|            output.extend_from_slice(&bytes);
  156|      0|        }
  157|       |    }
  158|      0|    Ok(())
  159|      0|}
  160|       |
  161|       |/// Helper to emit struct constants
  162|      1|fn emit_const_struct(
  163|      1|    fields: &[(usize, ConstValueId)],
  164|      1|    ty: &MirType,
  165|      1|    output: &mut Vec<u8>,
  166|      1|    ctx: &EmitContext,
  167|      1|    mut module: Option<&mut ObjectModule>,
  168|      1|    mut data_description: Option<&mut DataDescription>,
  169|      1|    base_offset: u32,
  170|      1|) -> Result<(), String> {
  171|      1|    match ty {
  172|       |        MirType::Record {
  173|      1|            layout: record_layout,
  174|       |            field_types: _,
  175|       |            ..
  176|       |        } => {
  177|       |            // Initialize the entire struct with zeros
  178|      1|            let struct_size = record_layout.size as usize;
  179|      1|            let mut struct_bytes = vec![0u8; struct_size];
  180|       |
  181|       |            // Emit each field at its proper offset
  182|      3|            for (field_index, field_const_id) in fields {
                               ^2           ^2
  183|      2|                if *field_index < record_layout.field_offsets.len() {
  184|      2|                    let field_offset = record_layout.field_offsets[*field_index] as usize;
  185|       |
  186|      2|                    let mut field_bytes = Vec::new();
  187|      2|                    emit_const(
  188|      2|                        *field_const_id,
  189|      2|                        &mut field_bytes,
  190|      2|                        ctx,
  191|      2|                        reborrow_module(&mut module),
  192|      2|                        reborrow_data_description(&mut data_description),
  193|      2|                        base_offset + field_offset as u32,
  194|      0|                    )?;
  195|       |
  196|       |                    // Copy the field bytes into the struct buffer
  197|      2|                    if field_offset + field_bytes.len() <= struct_size {
  198|      2|                        struct_bytes[field_offset..field_offset + field_bytes.len()].copy_from_slice(&field_bytes);
  199|      2|                    } else {
  200|      0|                        return Err(format!(
  201|      0|                            "Field emission overflow: offset {} + size {} > struct size {}",
  202|      0|                            field_offset,
  203|      0|                            field_bytes.len(),
  204|      0|                            struct_size
  205|      0|                        ));
  206|       |                    }
  207|      0|                }
  208|       |            }
  209|      1|            output.extend_from_slice(&struct_bytes);
  210|      1|            Ok(())
  211|       |        }
  212|      0|        _ => Err("StructLiteral with non-record type".to_string()),
  213|       |    }
  214|      1|}
  215|       |
  216|       |/// Helper to emit array constants
  217|      8|fn emit_const_array(
  218|      8|    elements: &[ConstValueId],
  219|      8|    ty: &MirType,
  220|      8|    output: &mut Vec<u8>,
  221|      8|    ctx: &EmitContext,
  222|      8|    mut module: Option<&mut ObjectModule>,
  223|      8|    mut data_description: Option<&mut DataDescription>,
  224|      8|    base_offset: u32,
  225|      8|) -> Result<(), String> {
  226|      8|    match ty {
  227|       |        MirType::Array {
  228|      8|            element,
  229|      8|            size,
  230|      8|            layout: array_layout,
  231|       |        } => {
  232|       |            // Emit each element according to the array layout
  233|     34|            for (i, element_const_id) in elements.iter().enumerate() {
                                                       ^8       ^8     ^8
  234|     34|                if i >= *size {
  235|      0|                    break; // Don't emit more elements than the array size
  236|     34|                }
  237|       |
  238|     34|                let element_type = ctx.mir.get_type(*element);
  239|     34|                let element_size = mir_type_size(element_type, ctx.mir)? as usize;
                                                                                     ^0
  240|       |
  241|       |                // Calculate offset for this element
  242|     34|                let element_offset = (i * array_layout.stride as usize) as u32;
  243|       |
  244|     34|                emit_const(
  245|     34|                    *element_const_id,
  246|     34|                    output,
  247|     34|                    ctx,
  248|     34|                    reborrow_module(&mut module),
  249|     34|                    reborrow_data_description(&mut data_description),
  250|     34|                    base_offset + element_offset,
  251|      0|                )?;
  252|       |
  253|       |                // Add padding if needed for stride > element size
  254|     34|                if array_layout.stride as usize > element_size {
  255|      0|                    let padding = array_layout.stride as usize - element_size;
  256|      0|                    output.extend_from_slice(&vec![0u8; padding]);
  257|     34|                }
  258|       |            }
  259|       |
  260|       |            // Fill remaining space with zeros if array is partially initialized
  261|      8|            let emitted_size = elements.len() * array_layout.stride as usize;
  262|      8|            if emitted_size < array_layout.size as usize {
  263|      0|                let remaining = array_layout.size as usize - emitted_size;
  264|      0|                output.extend_from_slice(&vec![0u8; remaining]);
  265|      8|            }
  266|      8|            Ok(())
  267|       |        }
  268|      0|        _ => Err("ArrayLiteral with non-array type".to_string()),
  269|       |    }
  270|      8|}
  271|       |
  272|       |/// Emit a constant value to the output buffer based on its type layout
  273|     48|pub(crate) fn emit_const(
  274|     48|    const_id: ConstValueId,
  275|     48|    output: &mut Vec<u8>,
  276|     48|    ctx: &EmitContext,
  277|     48|    mut module: Option<&mut ObjectModule>,
  278|     48|    mut data_description: Option<&mut DataDescription>,
  279|     48|    offset: u32,
  280|     48|) -> Result<(), String> {
  281|     48|    let const_value = ctx
  282|     48|        .mir
  283|     48|        .constants
  284|     48|        .get(&const_id)
  285|     48|        .ok_or_else(|| format!("Constant ID {} not found", const_id.get()))?;
                                     ^0      ^0                          ^0       ^0     ^0
  286|       |
  287|     48|    let ty = ctx.mir.get_type(const_value.ty);
  288|       |
  289|     48|    match &const_value.kind {
  290|     35|        ConstValueKind::Int(val) => emit_const_int(*val, ty, output),
  291|      0|        ConstValueKind::Float(val) => emit_const_float(*val, ty, output),
  292|      0|        ConstValueKind::Bool(val) => {
  293|      0|            let byte = if *val { 1u8 } else { 0u8 };
  294|      0|            output.push(byte);
  295|      0|            Ok(())
  296|       |        }
  297|       |        ConstValueKind::Null => {
  298|       |            // Emit null as all zeros (pointer-sized)
  299|      0|            let null_bytes = 0i64.to_le_bytes();
  300|      0|            output.extend_from_slice(&null_bytes);
  301|      0|            Ok(())
  302|       |        }
  303|       |        ConstValueKind::Zero => {
  304|       |            // Emit zeros for the entire type size
  305|      1|            let size = mir_type_size(ty, ctx.mir)? as usize;
                                                               ^0
  306|      1|            output.extend_from_slice(&vec![0u8; size]);
  307|      1|            Ok(())
  308|       |        }
  309|      2|        ConstValueKind::GlobalAddress(global_id) => {
  310|       |            // Handle Global Relocation
  311|      2|            if let (Some(dd), Some(mod_obj)) = (&mut data_description, &mut module) {
  312|      2|                if let Some(&data_id) = ctx.data_id_map.get(global_id) {
  313|      2|                    let global_val = mod_obj.declare_data_in_data(data_id, dd);
  314|      2|                    dd.write_data_addr(offset, global_val, 0);
  315|      2|                } else {
  316|      0|                    return Err(format!(
  317|      0|                        "Global ID {} not found in map during relocation",
  318|      0|                        global_id.get()
  319|      0|                    ));
  320|       |                }
  321|      0|            }
  322|       |
  323|       |            // Emit zero placeholder
  324|      2|            let addr_bytes = 0i64.to_le_bytes();
  325|      2|            output.extend_from_slice(&addr_bytes);
  326|      2|            Ok(())
  327|       |        }
  328|      1|        ConstValueKind::FunctionAddress(func_id) => {
  329|       |            // Handle Function Relocation
  330|      1|            if let (Some(dd), Some(mod_obj)) = (&mut data_description, &mut module) {
  331|      1|                if let Some(&clif_func_id) = ctx.func_id_map.get(func_id) {
  332|      1|                    let func_ref = mod_obj.declare_func_in_data(clif_func_id, dd);
  333|      1|                    dd.write_function_addr(offset, func_ref);
  334|      1|                } else {
  335|      0|                    println!(
  336|      0|                        "Warning: Function ID {} not found in map during relocation. Maps available: {:?}",
  337|      0|                        func_id.get(),
  338|      0|                        ctx.func_id_map.keys()
  339|      0|                    );
  340|      0|                }
  341|      0|            }
  342|       |
  343|       |            // Emit zero placeholder
  344|      1|            let addr_bytes = 0i64.to_le_bytes();
  345|      1|            output.extend_from_slice(&addr_bytes);
  346|      1|            Ok(())
  347|       |        }
  348|      1|        ConstValueKind::StructLiteral(fields) => {
  349|      1|            emit_const_struct(fields, ty, output, ctx, module, data_description, offset)
  350|       |        }
  351|      8|        ConstValueKind::ArrayLiteral(elements) => {
  352|      8|            emit_const_array(elements, ty, output, ctx, module, data_description, offset)
  353|       |        }
  354|       |    }
  355|     48|}
  356|       |
  357|     36|fn reborrow_module<'b>(m: &'b mut Option<&mut ObjectModule>) -> Option<&'b mut ObjectModule> {
  358|     36|    m.as_mut().map(|inner| &mut **inner)
  359|     36|}
  360|       |
  361|     36|fn reborrow_data_description<'b>(dd: &'b mut Option<&mut DataDescription>) -> Option<&'b mut DataDescription> {
  362|     36|    dd.as_mut().map(|inner| &mut **inner)
  363|     36|}
  364|       |
  365|       |/// Helper to prepare a function signature for a call
  366|      2|fn prepare_call_signature(
  367|      2|    call_conv: cranelift::codegen::isa::CallConv,
  368|      2|    return_type_id: TypeId,
  369|      2|    param_types: &[TypeId],
  370|      2|    args: &[Operand],
  371|      2|    mir: &MirProgram,
  372|      2|    is_variadic: bool,
  373|      2|) -> Signature {
  374|      2|    let mut sig = Signature::new(call_conv);
  375|       |
  376|       |    // Return type
  377|      2|    let return_mir_type = mir.get_type(return_type_id);
  378|      2|    let return_type_opt = match convert_type(return_mir_type) {
  379|      2|        Some(t) => Some(t),
  380|      0|        None if return_mir_type.is_aggregate() => Some(types::I64),
  381|      0|        None => None,
  382|       |    };
  383|      2|    if let Some(ret_type) = return_type_opt {
  384|      2|        sig.returns.push(AbiParam::new(ret_type));
  385|      2|    }
                  ^0
  386|       |
  387|       |    // Fixed parameters
  388|      4|    for &param_type_id in param_types {
                       ^2
  389|      2|        let mir_type = mir.get_type(param_type_id);
  390|      2|        let param_type = match convert_type(mir_type) {
  391|      2|            Some(t) => t,
  392|      0|            None if mir_type.is_aggregate() => types::I64,
  393|      0|            None => types::I32, // Should not happen for valid MIR
  394|       |        };
  395|      2|        sig.params.push(AbiParam::new(param_type));
  396|       |    }
  397|       |
  398|       |    // Variadic arguments (if any) - structs are expanded to multiple I64 slots
  399|      2|    for arg in args.iter().skip(param_types.len()) {
  400|      2|        let arg_type_id = get_operand_type_id(arg, mir).ok();
  401|      2|        if let Some(type_id) = arg_type_id {
  402|      2|            let mir_type = mir.get_type(type_id);
  403|      2|            if mir_type.is_aggregate() {
  404|       |                // For structs/arrays, calculate how many I64 slots we need
  405|      0|                let size = mir_type_size(mir_type, mir).unwrap_or(8);
  406|      0|                let num_slots = size.div_ceil(8) as usize; // Round up to nearest 8 bytes
  407|      0|                for _ in 0..num_slots {
  408|      0|                    sig.params.push(AbiParam::new(types::I64));
  409|      0|                }
  410|      0|                continue;
  411|      2|            }
  412|      0|        }
  413|      2|        let mut arg_type = get_operand_clif_type(arg, mir).unwrap_or(types::I32);
  414|       |        // Normalized Variadic Signature hack: promote variadic GPR args to i64
  415|      2|        if is_variadic && arg_type.is_int() && arg_type.bits() < 64 {
  416|      2|            arg_type = types::I64;
  417|      2|        }
                      ^0
  418|      2|        sig.params.push(AbiParam::new(arg_type));
  419|       |    }
  420|       |
  421|       |    // Normalized Variadic Signature hack: Ensure at least 16 slots for variadic functions
  422|       |    // This matches the 16-slot spill area in setup_signature
  423|      2|    if is_variadic {
  424|      1|        let current_gpr_count = sig.params.len();
  425|      1|        let total_variadic_slots = 16;
  426|      1|        if current_gpr_count < total_variadic_slots {
  427|     13|            for _ in 0..(total_variadic_slots - current_gpr_count) {
                                      ^1
  428|     13|                sig.params.push(AbiParam::new(types::I64));
  429|     13|            }
  430|      0|        }
  431|      1|    }
  432|       |
  433|      2|    sig
  434|      2|}
  435|       |
  436|       |/// Helper to resolve arguments for a call, handling variadic struct expansion if needed
  437|      2|fn resolve_call_args(
  438|      2|    args: &[Operand],
  439|      2|    fixed_param_count: usize,
  440|      2|    sig: &Signature,
  441|      2|    ctx: &mut BodyEmitContext,
  442|      2|    is_variadic: bool,
  443|      2|) -> Result<Vec<Value>, String> {
  444|      2|    let mut arg_values = Vec::new();
  445|      2|    let mut sig_idx = 0;
  446|       |
  447|      4|    for (arg_idx, arg) in args.iter().enumerate() {
                                        ^2   ^2     ^2
  448|      4|        if sig_idx >= sig.params.len() {
  449|      0|            break;
  450|      4|        }
  451|       |
  452|      4|        let param_type = sig.params[sig_idx].value_type;
  453|       |
  454|       |        // Check if this is a variadic struct argument that needs expansion
  455|      4|        if is_variadic
  456|      3|            && arg_idx >= fixed_param_count
  457|      2|            && let Ok(type_id) = get_operand_type_id(arg, ctx.mir)
  458|       |        {
  459|      2|            let mir_type = ctx.mir.get_type(type_id);
  460|      2|            if mir_type.is_aggregate() {
  461|       |                // Get the struct address
  462|      0|                let struct_addr = resolve_operand(arg, ctx, types::I64)?;
  463|       |
  464|       |                // Calculate how many I64 slots this struct needs
  465|      0|                let size = mir_type_size(mir_type, ctx.mir).unwrap_or(8);
  466|      0|                let num_slots = size.div_ceil(8) as usize;
  467|       |
  468|       |                // Load each I64 chunk from the struct
  469|      0|                for slot in 0..num_slots {
  470|      0|                    if sig_idx < sig.params.len() {
  471|      0|                        let offset = (slot * 8) as i32;
  472|      0|                        let value = ctx.builder.ins().load(types::I64, MemFlags::new(), struct_addr, offset);
  473|      0|                        arg_values.push(value);
  474|      0|                        sig_idx += 1;
  475|      0|                    }
  476|       |                }
  477|      0|                continue;
  478|      2|            }
  479|      2|        }
  480|       |
  481|       |        // Non-struct argument (or fixed param)
  482|      4|        match resolve_operand(arg, ctx, param_type) {
  483|      4|            Ok(value) => arg_values.push(value),
  484|      0|            Err(e) => return Err(format!("Failed to resolve function argument: {}", e)),
  485|       |        }
  486|      4|        sig_idx += 1;
  487|       |    }
  488|       |
  489|       |    // Padding for remaining signature params (variadic slot padding SysV x86_64 hack)
  490|     15|    while sig_idx < sig.params.len() {
  491|     13|        let param_type = sig.params[sig_idx].value_type;
  492|     13|        arg_values.push(ctx.builder.ins().iconst(param_type, 0i64));
  493|     13|        sig_idx += 1;
  494|     13|    }
  495|       |
  496|      2|    Ok(arg_values)
  497|      2|}
  498|       |
  499|       |/// Helper to get the result of a call, or a zero constant if it has no return value
  500|      2|fn get_call_result(builder: &mut FunctionBuilder, call_inst: Inst, expected_type: Type) -> Value {
  501|      2|    let results = builder.inst_results(call_inst);
  502|      2|    if results.is_empty() {
  503|      0|        builder.ins().iconst(expected_type, 0i64)
  504|       |    } else {
  505|      2|        results[0]
  506|       |    }
  507|      2|}
  508|       |
  509|      2|fn emit_function_call_impl(
  510|      2|    call_target: &CallTarget,
  511|      2|    args: &[Operand],
  512|      2|    expected_type: Type,
  513|      2|    ctx: &mut BodyEmitContext,
  514|      2|) -> Result<Value, String> {
  515|       |    // 1. Determine function properties and callee address if indirect/variadic
  516|      2|    let (return_type_id, param_types, is_variadic, name_linkage, target_addr) = match call_target {
  517|      0|        CallTarget::Direct(func_id) => {
  518|      0|            let func = ctx.mir.get_function(*func_id);
  519|      0|            let param_types: Vec<TypeId> = func.params.iter().map(|&p| ctx.mir.get_local(p).type_id).collect();
  520|      0|            (
  521|      0|                func.return_type,
  522|      0|                param_types,
  523|      0|                func.is_variadic,
  524|      0|                Some((func.name.as_str(), convert_linkage(func.kind))),
  525|      0|                None,
  526|      0|            )
  527|       |        }
  528|      2|        CallTarget::Indirect(func_operand) => {
  529|      2|            let func_ptr_type_id = get_operand_type_id(func_operand, ctx.mir)
  530|      2|                .map_err(|e| format!("Failed to get function pointer type: {}", e))?;
                                           ^0      ^0                                            ^0
  531|      2|            let func_ptr_type = ctx.mir.get_type(func_ptr_type_id);
  532|       |
  533|      2|            let ((return_type_id, param_types), is_function_type, is_variadic_call) = match func_ptr_type {
  534|      2|                MirType::Pointer { pointee } => match ctx.mir.get_type(*pointee) {
  535|       |                    MirType::Function {
  536|      2|                        return_type,
  537|      2|                        params,
  538|      2|                        is_variadic,
  539|      2|                    } => ((*return_type, params.clone()), false, *is_variadic),
  540|      0|                    _ => return Err("Indirect call operand points to non-function type".to_string()),
  541|       |                },
  542|       |                MirType::Function {
  543|      0|                    return_type,
  544|      0|                    params,
  545|      0|                    is_variadic,
  546|      0|                } => ((*return_type, params.clone()), true, *is_variadic),
  547|      0|                _ => return Err("Indirect call operand is not a pointer".to_string()),
  548|       |            };
  549|       |
  550|      2|            let callee_val = if is_function_type {
  551|      0|                match func_operand {
  552|      0|                    Operand::Copy(place) => resolve_place_to_addr(place, ctx)?,
  553|      0|                    _ => resolve_operand(func_operand, ctx, types::I64)?,
  554|       |                }
  555|       |            } else {
  556|      2|                resolve_operand(func_operand, ctx, types::I64)?
                                                                            ^0
  557|       |            };
  558|       |
  559|      2|            (return_type_id, param_types, is_variadic_call, None, Some(callee_val))
  560|       |        }
  561|       |    };
  562|       |
  563|       |    // 2. Prepare call site signature and resolve arguments
  564|      2|    let sig = prepare_call_signature(
  565|      2|        ctx.builder.func.signature.call_conv,
  566|      2|        return_type_id,
  567|      2|        &param_types,
  568|      2|        args,
  569|      2|        ctx.mir,
  570|      2|        is_variadic,
  571|       |    );
  572|       |
  573|      2|    let arg_values = resolve_call_args(args, param_types.len(), &sig, ctx, is_variadic)?;
                                                                                                     ^0
  574|       |
  575|       |    // 3. Emit the call
  576|      2|    let call_inst = if is_variadic {
  577|      1|        if let Some((name, linkage)) = name_linkage {
                                   ^0    ^0
  578|       |            // Variadic direct calls must be indirect to use the custom signature
  579|      0|            let canonical_sig = prepare_call_signature(
  580|      0|                ctx.builder.func.signature.call_conv,
  581|      0|                return_type_id,
  582|      0|                &param_types,
  583|      0|                &[],
  584|      0|                ctx.mir,
  585|      0|                is_variadic,
  586|       |            );
  587|      0|            let decl = ctx
  588|      0|                .module
  589|      0|                .declare_function(name, linkage, &canonical_sig)
  590|      0|                .map_err(|e| format!("Failed to declare variadic function {}: {:?}", name, e))?;
  591|      0|            let func_ref = ctx.module.declare_func_in_func(decl, ctx.builder.func);
  592|      0|            let addr = ctx.builder.ins().func_addr(types::I64, func_ref);
  593|      0|            let sig_ref = ctx.builder.import_signature(sig);
  594|      0|            ctx.builder.ins().call_indirect(sig_ref, addr, &arg_values)
  595|      1|        } else if let Some(addr) = target_addr {
  596|      1|            let sig_ref = ctx.builder.import_signature(sig);
  597|      1|            ctx.builder.ins().call_indirect(sig_ref, addr, &arg_values)
  598|       |        } else {
  599|      0|            return Err("Variadic call without target".to_string());
  600|       |        }
  601|      1|    } else if let Some(addr) = target_addr {
  602|      1|        let sig_ref = ctx.builder.import_signature(sig);
  603|      1|        ctx.builder.ins().call_indirect(sig_ref, addr, &arg_values)
  604|       |    } else {
  605|       |        // Direct non-variadic call
  606|      0|        let (name, linkage) = name_linkage.unwrap();
  607|      0|        let decl = ctx
  608|      0|            .module
  609|      0|            .declare_function(name, linkage, &sig)
  610|      0|            .map_err(|e| format!("Failed to declare function {}: {:?}", name, e))?;
  611|      0|        let func_ref = ctx.module.declare_func_in_func(decl, ctx.builder.func);
  612|      0|        ctx.builder.ins().call(func_ref, &arg_values)
  613|       |    };
  614|       |
  615|      2|    Ok(get_call_result(ctx.builder, call_inst, expected_type))
  616|      2|}
  617|       |
  618|       |/// Helper function to convert boolean to integer (0 or 1)
  619|     31|fn emit_bool_to_int(val: Value, target_type: Type, builder: &mut FunctionBuilder) -> Value {
  620|     31|    let one = builder.ins().iconst(target_type, 1);
  621|     31|    let zero = builder.ins().iconst(target_type, 0i64);
  622|     31|    builder.ins().select(val, one, zero)
  623|     31|}
  624|       |
  625|       |/// Helper function to emit a memcpy call
  626|      0|fn emit_memcpy(
  627|      0|    dest: Value,
  628|      0|    src: Value,
  629|      0|    size: i64,
  630|      0|    builder: &mut FunctionBuilder,
  631|      0|    module: &mut ObjectModule,
  632|      0|) -> Result<(), String> {
  633|      0|    let mut sig = Signature::new(builder.func.signature.call_conv);
  634|      0|    sig.params.push(AbiParam::new(types::I64)); // dest
  635|      0|    sig.params.push(AbiParam::new(types::I64)); // src
  636|      0|    sig.params.push(AbiParam::new(types::I64)); // size
  637|      0|    sig.returns.push(AbiParam::new(types::I64)); // returns dest (ignored)
  638|       |
  639|      0|    let callee = module
  640|      0|        .declare_function("memcpy", Linkage::Import, &sig)
  641|      0|        .map_err(|e| format!("Failed to declare memcpy: {:?}", e))?;
  642|      0|    let local_callee = module.declare_func_in_func(callee, builder.func);
  643|       |
  644|      0|    let size_val = builder.ins().iconst(types::I64, size);
  645|      0|    builder.ins().call(local_callee, &[dest, src, size_val]);
  646|      0|    Ok(())
  647|      0|}
  648|       |
  649|       |/// Helper function to emit a type conversion in Cranelift
  650|    233|fn emit_type_conversion(val: Value, from: Type, to: Type, is_signed: bool, builder: &mut FunctionBuilder) -> Value {
  651|    233|    if from == to {
  652|    194|        return val;
  653|     39|    }
  654|       |
  655|       |    // Float to Float
  656|     39|    if from.is_float() && to.is_float() {
                                        ^2 ^2
  657|      0|        let from_width = from.bits();
  658|      0|        let to_width = to.bits();
  659|      0|        if from_width < to_width {
  660|      0|            return builder.ins().fpromote(to, val);
  661|      0|        } else if from_width > to_width {
  662|      0|            return builder.ins().fdemote(to, val);
  663|       |        } else {
  664|      0|            return val;
  665|       |        }
  666|     39|    }
  667|       |
  668|       |    // Integer to Float
  669|     39|    if from.is_int() && to.is_float() {
                                      ^37^37
  670|      0|        return if is_signed {
  671|      0|            builder.ins().fcvt_from_sint(to, val)
  672|       |        } else {
  673|      0|            builder.ins().fcvt_from_uint(to, val)
  674|       |        };
  675|     39|    }
  676|       |
  677|       |    // Float to Integer
  678|     39|    if from.is_float() && to.is_int() {
                                        ^2 ^2
  679|      2|        let to_width = to.bits();
  680|      2|        if to_width < 32 {
  681|       |            // Cranelift x64 backend doesn't support fcvt_to_sint/uint for < 32-bit targets
  682|       |            // Convert to I32 first, then reduce
  683|      2|            let intermediate = if is_signed {
  684|      2|                builder.ins().fcvt_to_sint(types::I32, val)
  685|       |            } else {
  686|      0|                builder.ins().fcvt_to_uint(types::I32, val)
  687|       |            };
  688|      2|            return builder.ins().ireduce(to, intermediate);
  689|      0|        }
  690|       |
  691|      0|        return if is_signed {
  692|      0|            builder.ins().fcvt_to_sint(to, val)
  693|       |        } else {
  694|      0|            builder.ins().fcvt_to_uint(to, val)
  695|       |        };
  696|     37|    }
  697|       |
  698|       |    // General Integer/Pointer/Bool conversions (Extension/Reduction/Bitcast)
  699|     37|    let from_width = from.bits();
  700|     37|    let to_width = to.bits();
  701|       |
  702|     37|    if from_width < to_width {
  703|       |        // Extension
  704|     33|        if is_signed {
  705|     25|            builder.ins().sextend(to, val)
  706|       |        } else {
  707|      8|            builder.ins().uextend(to, val)
  708|       |        }
  709|      4|    } else if from_width > to_width {
  710|       |        // Reduction
  711|      4|        builder.ins().ireduce(to, val)
  712|       |    } else {
  713|       |        // Same width, diff types (e.g. I64 <-> F64 bitcast, or I32 <-> F32 bitcast, or Pointer types)
  714|       |        // Note: Float bitcasts usually handled above if involving floats, but check standard bitcast rules.
  715|       |        // Actually bitcast works for any same-sized types.
  716|      0|        builder.ins().bitcast(to, MemFlags::new(), val)
  717|       |    }
  718|    233|}
  719|       |
  720|       |/// Helper function to resolve a MIR operand to a Cranelift value
  721|    309|fn resolve_operand(operand: &Operand, ctx: &mut BodyEmitContext, expected_type: Type) -> Result<Value, String> {
  722|    309|    match operand {
  723|    141|        Operand::Constant(const_id) => {
  724|    141|            let const_value = ctx.mir.constants.get(const_id).expect("constant id not found");
  725|    141|            match &const_value.kind {
  726|    136|                ConstValueKind::Int(val) => Ok(ctx.builder.ins().iconst(expected_type, *val)),
  727|      2|                ConstValueKind::Float(val) => {
  728|       |                    // Use the appropriate float constant based on expected type
  729|      2|                    if expected_type == types::F64 {
  730|      2|                        Ok(ctx.builder.ins().f64const(*val))
  731|       |                    } else {
  732|      0|                        Ok(ctx.builder.ins().f32const(*val as f32))
  733|       |                    }
  734|       |                }
  735|      0|                ConstValueKind::Bool(val) => {
  736|      0|                    let int_val = if *val { 1 } else { 0 };
  737|      0|                    Ok(ctx.builder.ins().iconst(expected_type, int_val))
  738|       |                }
  739|      0|                ConstValueKind::Null => Ok(ctx.builder.ins().iconst(expected_type, 0i64)),
  740|      1|                ConstValueKind::GlobalAddress(global_id) => {
  741|       |                    // Get the global variable and return its address
  742|       |                    // This handles the array-to-pointer decay for string literals
  743|      1|                    let global = ctx.mir.get_global(*global_id);
  744|      1|                    let global_val = ctx
  745|      1|                        .module
  746|      1|                        .declare_data(global.name.as_str(), Linkage::Export, true, false)
  747|      1|                        .map_err(|e| format!("Failed to declare global data: {:?}", e))?;
                                                   ^0      ^0                                        ^0
  748|      1|                    let local_id = ctx.module.declare_data_in_func(global_val, ctx.builder.func);
  749|       |                    // Global addresses are always pointer-sized (i64)
  750|      1|                    let addr = ctx.builder.ins().global_value(types::I64, local_id);
  751|      1|                    Ok(emit_type_conversion(
  752|      1|                        addr,
  753|      1|                        types::I64,
  754|      1|                        expected_type,
  755|      1|                        false,
  756|      1|                        ctx.builder,
  757|      1|                    ))
  758|       |                }
  759|      2|                ConstValueKind::FunctionAddress(func_id) => {
  760|      2|                    if let Some(&clif_func_id) = ctx.func_id_map.get(func_id) {
  761|      2|                        let func_ref = ctx.module.declare_func_in_func(clif_func_id, ctx.builder.func);
  762|      2|                        let addr = ctx.builder.ins().func_addr(types::I64, func_ref);
  763|      2|                        Ok(emit_type_conversion(
  764|      2|                            addr,
  765|      2|                            types::I64,
  766|      2|                            expected_type,
  767|      2|                            false,
  768|      2|                            ctx.builder,
  769|      2|                        ))
  770|       |                    } else {
  771|      0|                        Err(format!("Function ID {} not found in map", func_id.get()))
  772|       |                    }
  773|       |                }
  774|      0|                _ => Ok(ctx.builder.ins().iconst(expected_type, 0i64)),
  775|       |            }
  776|       |        }
  777|    100|        Operand::Copy(place) => {
  778|       |            // Determine the correct type from the place itself
  779|    100|            let place_type_id = get_place_type_id(place, ctx.mir);
  780|    100|            let place_type = ctx.mir.get_type(place_type_id);
  781|       |
  782|    100|            if place_type.is_aggregate() {
  783|       |                // For aggregate types, resolving the operand value means getting its address
  784|      0|                let addr = resolve_place_to_addr(place, ctx)?;
  785|      0|                return Ok(emit_type_conversion(
  786|      0|                    addr,
  787|      0|                    types::I64,
  788|      0|                    expected_type,
  789|      0|                    false,
  790|      0|                    ctx.builder,
  791|      0|                ));
  792|    100|            }
  793|       |
  794|    100|            let place_clif_type =
  795|    100|                convert_type(place_type).ok_or_else(|| format!("Unsupported place type: {:?}", place_type))?;
                                                                     ^0      ^0                                          ^0
  796|       |
  797|    100|            let val = resolve_place(place, ctx, place_clif_type)?;
                                                                              ^0
  798|    100|            Ok(emit_type_conversion(
  799|    100|                val,
  800|    100|                place_clif_type,
  801|    100|                expected_type,
  802|    100|                place_type.is_signed(),
  803|    100|                ctx.builder,
  804|    100|            ))
  805|       |        }
  806|     62|        Operand::Cast(type_id, inner_operand) => {
  807|     62|            let inner_type = get_operand_clif_type(inner_operand, ctx.mir)?;
                                                                                        ^0
  808|     62|            let inner_val = resolve_operand(inner_operand, ctx, inner_type)?;
                                                                                         ^0
  809|       |
  810|     62|            let mir_type = ctx.mir.get_type(*type_id);
  811|     62|            let target_type = convert_type(mir_type).unwrap_or(types::I32);
  812|       |
  813|     62|            let converted = emit_type_conversion(
  814|     62|                inner_val,
  815|     62|                inner_type,
  816|     62|                target_type,
  817|     62|                is_operand_signed(inner_operand, ctx.mir),
  818|     62|                ctx.builder,
  819|       |            );
  820|     62|            Ok(emit_type_conversion(
  821|     62|                converted,
  822|     62|                target_type,
  823|     62|                expected_type,
  824|     62|                mir_type.is_signed(),
  825|     62|                ctx.builder,
  826|     62|            ))
  827|       |        }
  828|      6|        Operand::AddressOf(place) => {
  829|       |            // The value of an AddressOf operand is the address of the place.
  830|      6|            let addr = resolve_place_to_addr(place, ctx)?;
                                                                      ^0
  831|      6|            Ok(emit_type_conversion(
  832|      6|                addr,
  833|      6|                types::I64,
  834|      6|                expected_type,
  835|      6|                false,
  836|      6|                ctx.builder,
  837|      6|            ))
  838|       |        }
  839|       |    }
  840|    309|}
  841|       |
  842|       |/// Helper function to resolve a MIR place to a Cranelift value
  843|    100|fn resolve_place(place: &Place, ctx: &mut BodyEmitContext, expected_type: Type) -> Result<Value, String> {
  844|    100|    match place {
  845|     83|        Place::Local(local_id) => {
  846|       |            // A local place is resolved by loading from its stack slot
  847|     83|            if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
  848|     83|                Ok(ctx.builder.ins().stack_load(expected_type, *stack_slot, 0))
  849|       |            } else {
  850|      0|                Err(format!("Stack slot not found for local {}", local_id.get()))
  851|       |            }
  852|       |        }
  853|      0|        Place::Global(_global_id) => {
  854|       |            // First, get the memory address of the global.
  855|      0|            let addr = resolve_place_to_addr(place, ctx)?;
  856|       |
  857|       |            // Then, load the value from that address.
  858|      0|            Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
  859|       |        }
  860|      0|        Place::Deref(operand) => {
  861|       |            // The address is the value of the operand, so we load from that value
  862|      0|            let addr = resolve_operand(operand, ctx, types::I64)?;
  863|      0|            Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
  864|       |        }
  865|      7|        Place::StructField(base_place, field_index) => {
  866|       |            // Get the address of the struct field
  867|      7|            let addr = resolve_place_to_addr(&Place::StructField(base_place.clone(), *field_index), ctx)?;
                                                                                                                      ^0
  868|      7|            Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
  869|       |        }
  870|     10|        Place::ArrayIndex(base_place, index_operand) => {
  871|       |            // Get the address of the array element
  872|     10|            let addr = resolve_place_to_addr(&Place::ArrayIndex(base_place.clone(), index_operand.clone()), ctx)?;
                                                                                                                              ^0
  873|     10|            Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
  874|       |        }
  875|       |    }
  876|    100|}
  877|       |
  878|       |/// Helper function to get the Cranelift Type of an operand
  879|    145|fn get_operand_clif_type(operand: &Operand, mir: &MirProgram) -> Result<Type, String> {
  880|    145|    match operand {
  881|     53|        Operand::Constant(const_id) => {
  882|     53|            let const_value = mir.constants.get(const_id).expect("constant id not found");
  883|     53|            let mir_type = mir.get_type(const_value.ty);
  884|       |
  885|       |            // If we have a specific type for the constant, use that to determine the Cranelift type
  886|     53|            if let Some(clif_type) = convert_type(mir_type) {
                                      ^52
  887|     52|                return Ok(clif_type);
  888|      1|            }
  889|       |
  890|       |            // Fallback to kind-based determination if type is not convertible (e.g., struct/array)
  891|      1|            match &const_value.kind {
  892|       |                // Integer literals in MIR are typically used in integer-sized contexts
  893|       |                // Default to I32 so common small integer constants (like `4`) match i32
  894|       |                // places instead of being treated as 64-bit immediates.
  895|      0|                ConstValueKind::Int(_) => Ok(types::I32),
  896|      0|                ConstValueKind::Float(_) => Ok(types::F64),
  897|      0|                ConstValueKind::Bool(_) => Ok(types::I32),
  898|       |                // Null/Zero/Global addresses are pointer-sized
  899|      1|                ConstValueKind::Null | ConstValueKind::Zero | ConstValueKind::GlobalAddress(_) => Ok(types::I64),
  900|      0|                ConstValueKind::FunctionAddress(_) => Ok(types::I64),
  901|      0|                ConstValueKind::StructLiteral(_) => Ok(types::I32),
  902|      0|                ConstValueKind::ArrayLiteral(_) => Ok(types::I32),
  903|       |            }
  904|       |        }
  905|     44|        Operand::Copy(place) => {
  906|     44|            let place_type_id = get_place_type_id(place, mir);
  907|     44|            let place_type = mir.get_type(place_type_id);
  908|     44|            if place_type.is_aggregate() {
  909|      0|                return Ok(types::I64);
  910|     44|            }
  911|     44|            convert_type(place_type).ok_or_else(|| format!("Unsupported place type: {:?}", place_type))
                                                                 ^0      ^0
  912|       |        }
  913|     46|        Operand::Cast(type_id, _) => {
  914|     46|            let mir_type = mir.get_type(*type_id);
  915|     46|            if mir_type.is_aggregate() {
  916|      0|                return Ok(types::I64);
  917|     46|            }
  918|     46|            Ok(convert_type(mir_type).unwrap_or(types::I32))
  919|       |        }
  920|      2|        Operand::AddressOf(_) => Ok(types::I64), // AddressOf always returns a pointer
  921|       |    }
  922|    145|}
  923|       |
  924|       |/// Helper function to check if a MIR type is signed
  925|     64|fn is_operand_signed(operand: &Operand, mir: &MirProgram) -> bool {
  926|     64|    match operand {
  927|     17|        Operand::Copy(place) => mir.get_type(get_place_type_id(place, mir)).is_signed(),
  928|      1|        Operand::Cast(type_id, _) => mir.get_type(*type_id).is_signed(),
  929|     46|        Operand::Constant(_const_id) => true,
  930|      0|        _ => false,
  931|       |    }
  932|     64|}
  933|       |
  934|       |/// Helper function to get the TypeId of an operand
  935|     18|fn get_operand_type_id(operand: &Operand, mir: &MirProgram) -> Result<TypeId, String> {
  936|     18|    match operand {
  937|      4|        Operand::Constant(const_id) => {
  938|      4|            let const_value = mir.constants.get(const_id).expect("constant id not found");
  939|      4|            Ok(const_value.ty)
  940|       |        }
  941|     14|        Operand::Copy(place) => Ok(get_place_type_id(place, mir)),
  942|      0|        Operand::Cast(type_id, _) => Ok(*type_id),
  943|      0|        Operand::AddressOf(place) => {
  944|       |            // AddressOf returns a pointer to the place's type.
  945|       |            // We need to find or create this pointer type in MIR.
  946|       |            // Actually, for PtrAdd scaling, we only care about the base type of the pointer.
  947|      0|            let place_type_id = get_place_type_id(place, mir);
  948|       |            // We need the TypeId for ptr<place_type_id>
  949|       |            // Let's see if we can find it in the type table.
  950|      0|            for (id, ty) in &mir.types {
  951|      0|                if let MirType::Pointer { pointee } = ty
  952|      0|                    && *pointee == place_type_id
  953|       |                {
  954|      0|                    return Ok(*id);
  955|      0|                }
  956|       |            }
  957|      0|            Err("Pointer type not found in MIR types".to_string())
  958|       |        }
  959|       |    }
  960|     18|}
  961|       |
  962|       |/// Helper function to get the TypeId of a place
  963|    440|fn get_place_type_id(place: &Place, mir: &MirProgram) -> TypeId {
  964|    440|    match place {
  965|    354|        Place::Local(local_id) => mir.get_local(*local_id).type_id,
  966|     28|        Place::Global(global_id) => mir.get_global(*global_id).type_id,
  967|     10|        Place::Deref(operand) => {
  968|       |            // To get the type of a dereference, we need the type of the operand,
  969|       |            // which should be a pointer. The resulting type is the pointee.
  970|     10|            let operand_type_id = get_operand_type_id(operand, mir).unwrap();
  971|     10|            let operand_type = mir.get_type(operand_type_id);
  972|     10|            match operand_type {
  973|     10|                MirType::Pointer { pointee } => *pointee,
  974|      0|                _ => panic!("Cannot determine type for deref operand"),
  975|       |            }
  976|       |        }
  977|     24|        Place::StructField(base_place, field_index) => {
  978|     24|            let base_type_id = get_place_type_id(base_place, mir);
  979|     24|            let base_type = mir.get_type(base_type_id);
  980|     24|            match base_type {
  981|     24|                MirType::Record { field_types, .. } => field_types.get(*field_index).copied().unwrap(),
  982|      0|                MirType::Pointer { pointee } => {
  983|      0|                    let pointee_type = mir.get_type(*pointee);
  984|      0|                    if let MirType::Record { field_types, .. } = pointee_type {
  985|      0|                        field_types.get(*field_index).copied().unwrap()
  986|       |                    } else {
  987|      0|                        panic!("Base of StructField is not a struct type")
  988|       |                    }
  989|       |                }
  990|      0|                _ => panic!("Base of StructField is not a struct type"),
  991|       |            }
  992|       |        }
  993|     24|        Place::ArrayIndex(base_place, _) => {
  994|     24|            let base_type_id = get_place_type_id(base_place, mir);
  995|     24|            let base_type = mir.get_type(base_type_id);
  996|     24|            match base_type {
  997|     24|                MirType::Array { element, .. } => *element,
  998|      0|                MirType::Pointer { pointee } => *pointee,
  999|      0|                _ => panic!("Base of ArrayIndex is not an array or pointer"),
 1000|       |            }
 1001|       |        }
 1002|       |    }
 1003|    440|}
 1004|       |
 1005|       |/// Helper function to resolve a MIR place to a memory address
 1006|     57|fn resolve_place_to_addr(place: &Place, ctx: &mut BodyEmitContext) -> Result<Value, String> {
 1007|     57|    match place {
 1008|     19|        Place::Local(local_id) => {
 1009|     19|            if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
 1010|     19|                Ok(ctx.builder.ins().stack_addr(types::I64, *stack_slot, 0))
 1011|       |            } else {
 1012|      0|                Err(format!("Stack slot not found for local {}", local_id.get()))
 1013|       |            }
 1014|       |        }
 1015|      8|        Place::Global(global_id) => {
 1016|      8|            let global = ctx.mir.get_global(*global_id);
 1017|      8|            let linkage = if global.initial_value.is_some() {
 1018|      8|                Linkage::Export
 1019|       |            } else {
 1020|      0|                Linkage::Import
 1021|       |            };
 1022|       |
 1023|      8|            let global_val = ctx
 1024|      8|                .module
 1025|      8|                .declare_data(global.name.as_str(), linkage, true, false)
 1026|      8|                .map_err(|e| format!("Failed to declare global data: {:?}", e))?;
                                           ^0      ^0                                        ^0
 1027|      8|            let local_id = ctx.module.declare_data_in_func(global_val, ctx.builder.func);
 1028|       |            // Use I64 for addresses
 1029|      8|            Ok(ctx.builder.ins().global_value(types::I64, local_id))
 1030|       |        }
 1031|      4|        Place::Deref(operand) => {
 1032|       |            // The address is the value of the operand itself (which should be a pointer).
 1033|      4|            resolve_operand(operand, ctx, types::I64)
 1034|       |        }
 1035|     12|        Place::StructField(base_place, field_index) => {
 1036|       |            // Get the base address of the struct
 1037|     12|            let base_addr = resolve_place_to_addr(base_place, ctx)?;
                                                                                ^0
 1038|       |
 1039|       |            // We need to find the type of the base_place to get the pre-computed field offset
 1040|     12|            let base_place_type_id = get_place_type_id(base_place, ctx.mir);
 1041|     12|            let base_type = ctx.mir.get_type(base_place_type_id);
 1042|       |
 1043|     12|            let (field_offset, is_pointer) = match base_type {
 1044|     12|                MirType::Record { layout, .. } => {
 1045|     12|                    let offset = layout
 1046|     12|                        .field_offsets
 1047|     12|                        .get(*field_index)
 1048|     12|                        .copied()
 1049|     12|                        .ok_or_else(|| format!("Field index {} out of bounds", field_index))?;
                                                     ^0      ^0                                           ^0
 1050|     12|                    (offset, false)
 1051|       |                }
 1052|      0|                MirType::Pointer { pointee } => {
 1053|      0|                    let pointee_type = ctx.mir.get_type(*pointee);
 1054|      0|                    if let MirType::Record { layout, .. } = pointee_type {
 1055|      0|                        let offset = layout
 1056|      0|                            .field_offsets
 1057|      0|                            .get(*field_index)
 1058|      0|                            .copied()
 1059|      0|                            .ok_or_else(|| format!("Field index {} out of bounds", field_index))?;
 1060|      0|                        (offset, true)
 1061|       |                    } else {
 1062|      0|                        return Err("Base of StructField is not a struct type".to_string());
 1063|       |                    }
 1064|       |                }
 1065|      0|                _ => return Err("Base of StructField is not a struct type".to_string()),
 1066|       |            };
 1067|       |
 1068|     12|            let final_addr = if is_pointer {
 1069|       |                // If the base is a pointer, we need to load the address it points to first
 1070|      0|                ctx.builder.ins().load(types::I64, MemFlags::new(), base_addr, 0)
 1071|       |            } else {
 1072|     12|                base_addr
 1073|       |            };
 1074|       |
 1075|     12|            let offset_val = ctx.builder.ins().iconst(types::I64, field_offset as i64);
 1076|     12|            Ok(ctx.builder.ins().iadd(final_addr, offset_val))
 1077|       |        }
 1078|     14|        Place::ArrayIndex(base_place, index_operand) => {
 1079|       |            // Get the base address of the array/pointer
 1080|     14|            let base_addr = resolve_place_to_addr(base_place, ctx)?;
                                                                                ^0
 1081|       |
 1082|       |            // Resolve the index operand to a value
 1083|     14|            let index_val = resolve_operand(index_operand, ctx, types::I64)?;
                                                                                         ^0
 1084|       |
 1085|       |            // Determine the element size using pre-computed layout information
 1086|     14|            let base_place_type_id = get_place_type_id(base_place, ctx.mir);
 1087|     14|            let base_type = ctx.mir.get_type(base_place_type_id);
 1088|       |
 1089|       |            // If the base is a pointer, we must load the pointer value from the base address
 1090|       |            // before adding the element offset. For arrays, the base address is already
 1091|       |            // the address of the first element.
 1092|     14|            let (element_size, final_base_addr) = match base_type {
 1093|     14|                MirType::Array { layout, .. } => (layout.stride as u32, base_addr),
 1094|      0|                MirType::Pointer { pointee } => {
 1095|      0|                    let pointee_type = ctx.mir.get_type(*pointee);
 1096|      0|                    let size = mir_type_size(pointee_type, ctx.mir)?;
 1097|      0|                    let loaded_ptr = ctx.builder.ins().load(types::I64, MemFlags::new(), base_addr, 0);
 1098|      0|                    (size, loaded_ptr)
 1099|       |                }
 1100|      0|                _ => return Err("Base of ArrayIndex is not an array or pointer".to_string()),
 1101|       |            };
 1102|       |
 1103|     14|            let element_size_val = ctx.builder.ins().iconst(types::I64, element_size as i64);
 1104|     14|            let offset = ctx.builder.ins().imul(index_val, element_size_val);
 1105|       |
 1106|     14|            Ok(ctx.builder.ins().iadd(final_base_addr, offset))
 1107|       |        }
 1108|       |    }
 1109|     57|}
 1110|       |/// Helper to lower a single MIR statement
 1111|    101|fn lower_statement(stmt: &MirStmt, ctx: &mut BodyEmitContext) -> Result<(), String> {
 1112|    101|    match stmt {
 1113|     95|        MirStmt::Assign(place, rvalue) => {
 1114|     95|            let place_type_id = get_place_type_id(place, ctx.mir);
 1115|     95|            let place_mir_type = ctx.mir.get_type(place_type_id);
 1116|     95|            let expected_type = match convert_type(place_mir_type) {
 1117|     93|                Some(t) => t,
 1118|      2|                None if place_mir_type.is_aggregate() => types::I64,
 1119|      0|                None => return Err("Cannot assign to void type".to_string()),
 1120|       |            };
 1121|       |
 1122|       |            // Process the rvalue to get a Cranelift value first
 1123|     95|            let rvalue_result = match rvalue {
                              ^93
 1124|     49|                Rvalue::Use(operand) => resolve_operand(operand, ctx, expected_type),
 1125|      0|                Rvalue::Cast(type_id, operand) => {
 1126|      0|                    let inner_clif_type = get_operand_clif_type(operand, ctx.mir)?;
 1127|      0|                    let inner_val = resolve_operand(operand, ctx, inner_clif_type)?;
 1128|       |
 1129|      0|                    let target_mir_type = ctx.mir.get_type(*type_id);
 1130|      0|                    let target_clif_type =
 1131|      0|                        convert_type(target_mir_type).ok_or_else(|| "Cannot cast to void type".to_string())?;
 1132|       |
 1133|      0|                    let converted = emit_type_conversion(
 1134|      0|                        inner_val,
 1135|      0|                        inner_clif_type,
 1136|      0|                        target_clif_type,
 1137|      0|                        is_operand_signed(operand, ctx.mir),
 1138|      0|                        ctx.builder,
 1139|       |                    );
 1140|       |
 1141|      0|                    Ok(emit_type_conversion(
 1142|      0|                        converted,
 1143|      0|                        target_clif_type,
 1144|      0|                        expected_type,
 1145|      0|                        target_mir_type.is_signed(),
 1146|      0|                        ctx.builder,
 1147|      0|                    ))
 1148|       |                }
 1149|      3|                Rvalue::UnaryIntOp(op, operand) => {
 1150|      3|                    let operand_clif_type = get_operand_clif_type(operand, ctx.mir)?;
                                                                                                 ^0
 1151|      3|                    let val = resolve_operand(operand, ctx, operand_clif_type)?;
                                                                                            ^0
 1152|       |
 1153|      3|                    match op {
 1154|      0|                        UnaryIntOp::Neg => Ok(ctx.builder.ins().ineg(val)),
 1155|      0|                        UnaryIntOp::BitwiseNot => Ok(ctx.builder.ins().bnot(val)),
 1156|       |                        UnaryIntOp::LogicalNot => {
 1157|      3|                            let zero = ctx.builder.ins().iconst(operand_clif_type, 0i64);
 1158|      3|                            let is_zero = ctx.builder.ins().icmp(IntCC::Equal, val, zero);
 1159|      3|                            Ok(emit_bool_to_int(is_zero, expected_type, ctx.builder))
 1160|       |                        }
 1161|       |                    }
 1162|       |                }
 1163|      0|                Rvalue::UnaryFloatOp(op, operand) => {
 1164|      0|                    let operand_clif_type = get_operand_clif_type(operand, ctx.mir)?;
 1165|      0|                    let val = resolve_operand(operand, ctx, operand_clif_type)?;
 1166|       |
 1167|      0|                    match op {
 1168|      0|                        UnaryFloatOp::Neg => Ok(ctx.builder.ins().fneg(val)),
 1169|       |                    }
 1170|       |                }
 1171|      1|                Rvalue::PtrAdd(base, offset) => {
 1172|      1|                    let base_type_id = get_operand_type_id(base, ctx.mir)?;
                                                                                       ^0
 1173|      1|                    let base_type = ctx.mir.get_type(base_type_id);
 1174|      1|                    let MirType::Pointer { pointee } = base_type else {
 1175|      0|                        return Err("PtrAdd base is not a pointer type".to_string());
 1176|       |                    };
 1177|       |
 1178|      1|                    let pointee_type = ctx.mir.get_type(*pointee);
 1179|      1|                    let pointee_size = mir_type_size(pointee_type, ctx.mir)?;
                                                                                         ^0
 1180|       |
 1181|      1|                    let base_val = resolve_operand(base, ctx, types::I64)?;
                                                                                       ^0
 1182|      1|                    let offset_val = resolve_operand(offset, ctx, types::I64)?;
                                                                                           ^0
 1183|       |
 1184|      1|                    let scaled_offset = if pointee_size > 1 {
 1185|      1|                        let size_val = ctx.builder.ins().iconst(types::I64, pointee_size as i64);
 1186|      1|                        ctx.builder.ins().imul(offset_val, size_val)
 1187|       |                    } else {
 1188|      0|                        offset_val
 1189|       |                    };
 1190|       |
 1191|      1|                    Ok(ctx.builder.ins().iadd(base_val, scaled_offset))
 1192|       |                }
 1193|      1|                Rvalue::PtrSub(base, offset) => {
 1194|      1|                    let base_type_id = get_operand_type_id(base, ctx.mir)?;
                                                                                       ^0
 1195|      1|                    let base_type = ctx.mir.get_type(base_type_id);
 1196|      1|                    let MirType::Pointer { pointee } = base_type else {
 1197|      0|                        return Err("PtrSub base is not a pointer type".to_string());
 1198|       |                    };
 1199|       |
 1200|      1|                    let pointee_type = ctx.mir.get_type(*pointee);
 1201|      1|                    let pointee_size = mir_type_size(pointee_type, ctx.mir)?;
                                                                                         ^0
 1202|       |
 1203|      1|                    let base_val = resolve_operand(base, ctx, types::I64)?;
                                                                                       ^0
 1204|      1|                    let offset_val = resolve_operand(offset, ctx, types::I64)?;
                                                                                           ^0
 1205|       |
 1206|      1|                    let scaled_offset = if pointee_size > 1 {
 1207|      1|                        let size_val = ctx.builder.ins().iconst(types::I64, pointee_size as i64);
 1208|      1|                        ctx.builder.ins().imul(offset_val, size_val)
 1209|       |                    } else {
 1210|      0|                        offset_val
 1211|       |                    };
 1212|       |
 1213|      1|                    Ok(ctx.builder.ins().isub(base_val, scaled_offset))
 1214|       |                }
 1215|      0|                Rvalue::PtrDiff(left, right) => {
 1216|      0|                    let left_type_id = get_operand_type_id(left, ctx.mir)?;
 1217|      0|                    let left_type = ctx.mir.get_type(left_type_id);
 1218|      0|                    let pointee_size = if let MirType::Pointer { pointee } = left_type {
 1219|      0|                        let pointee_type = ctx.mir.get_type(*pointee);
 1220|      0|                        mir_type_size(pointee_type, ctx.mir)?
 1221|       |                    } else {
 1222|      0|                        return Err("PtrDiff left operand is not a pointer type".to_string());
 1223|       |                    };
 1224|       |
 1225|      0|                    let left_val = resolve_operand(left, ctx, types::I64)?;
 1226|      0|                    let right_val = resolve_operand(right, ctx, types::I64)?;
 1227|       |
 1228|      0|                    let diff = ctx.builder.ins().isub(left_val, right_val);
 1229|      0|                    if pointee_size > 1 {
 1230|      0|                        let size_val = ctx.builder.ins().iconst(types::I64, pointee_size as i64);
 1231|      0|                        Ok(ctx.builder.ins().sdiv(diff, size_val))
 1232|       |                    } else {
 1233|      0|                        Ok(diff)
 1234|       |                    }
 1235|       |                }
 1236|      0|                Rvalue::Load(operand) => {
 1237|      0|                    let addr = resolve_operand(operand, ctx, types::I64)?;
 1238|      0|                    Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
 1239|       |                }
 1240|       |
 1241|     39|                Rvalue::BinaryIntOp(op, left_operand, right_operand) => {
 1242|     39|                    let left_clif_type = get_operand_clif_type(left_operand, ctx.mir)
 1243|     39|                        .map_err(|e| format!("Failed to get left operand type: {}", e))?;
                                                   ^0      ^0                                        ^0
 1244|     39|                    let right_clif_type = get_operand_clif_type(right_operand, ctx.mir)
 1245|     39|                        .map_err(|e| format!("Failed to get right operand type: {}", e))?;
                                                   ^0      ^0                                         ^0
 1246|       |
 1247|       |                    // For Add/Sub operations on Pointers, we treat them as I64
 1248|     39|                    let (final_left_type, final_right_type) = match op {
 1249|       |                        BinaryIntOp::Add | BinaryIntOp::Sub => {
 1250|      7|                            if left_clif_type == types::I64 && right_clif_type == types::I32 {
                                                                             ^1
 1251|       |                                // Pointer + int constant
 1252|      0|                                (types::I64, types::I64)
 1253|      7|                            } else if left_clif_type == types::I32 && right_clif_type == types::I64 {
                                                                                    ^6
 1254|       |                                // int constant + pointer
 1255|      0|                                (types::I64, types::I64)
 1256|       |                            } else {
 1257|      7|                                (left_clif_type, right_clif_type)
 1258|       |                            }
 1259|       |                        }
 1260|     32|                        _ => (left_clif_type, right_clif_type),
 1261|       |                    };
 1262|       |
 1263|     39|                    let left_val = resolve_operand(left_operand, ctx, final_left_type)?;
                                                                                                    ^0
 1264|     39|                    let right_val = resolve_operand(right_operand, ctx, final_right_type)?;
                                                                                                       ^0
 1265|       |
 1266|     39|                    let result_val = match op {
 1267|      3|                        BinaryIntOp::Add => ctx.builder.ins().iadd(left_val, right_val),
 1268|      4|                        BinaryIntOp::Sub => ctx.builder.ins().isub(left_val, right_val),
 1269|      2|                        BinaryIntOp::Mul => ctx.builder.ins().imul(left_val, right_val),
 1270|       |                        BinaryIntOp::Div => {
 1271|      1|                            if is_operand_signed(left_operand, ctx.mir) {
 1272|      1|                                ctx.builder.ins().sdiv(left_val, right_val)
 1273|       |                            } else {
 1274|      0|                                ctx.builder.ins().udiv(left_val, right_val)
 1275|       |                            }
 1276|       |                        }
 1277|       |                        BinaryIntOp::Mod => {
 1278|      1|                            if is_operand_signed(left_operand, ctx.mir) {
 1279|      1|                                ctx.builder.ins().srem(left_val, right_val)
 1280|       |                            } else {
 1281|      0|                                ctx.builder.ins().urem(left_val, right_val)
 1282|       |                            }
 1283|       |                        }
 1284|      0|                        BinaryIntOp::BitAnd => ctx.builder.ins().band(left_val, right_val),
 1285|      0|                        BinaryIntOp::BitOr => ctx.builder.ins().bor(left_val, right_val),
 1286|      0|                        BinaryIntOp::BitXor => ctx.builder.ins().bxor(left_val, right_val),
 1287|      0|                        BinaryIntOp::LShift => ctx.builder.ins().ishl(left_val, right_val),
 1288|       |                        BinaryIntOp::RShift => {
 1289|      0|                            if is_operand_signed(left_operand, ctx.mir) {
 1290|      0|                                ctx.builder.ins().sshr(left_val, right_val)
 1291|       |                            } else {
 1292|      0|                                ctx.builder.ins().ushr(left_val, right_val)
 1293|       |                            }
 1294|       |                        }
 1295|       |                        BinaryIntOp::Eq => {
 1296|      2|                            let cond = ctx.builder.ins().icmp(IntCC::Equal, left_val, right_val);
 1297|      2|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1298|       |                        }
 1299|       |                        BinaryIntOp::Ne => {
 1300|     26|                            let cond = ctx.builder.ins().icmp(IntCC::NotEqual, left_val, right_val);
 1301|     26|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1302|       |                        }
 1303|       |                        BinaryIntOp::Lt => {
 1304|      0|                            let cond = if is_operand_signed(left_operand, ctx.mir) {
 1305|      0|                                ctx.builder.ins().icmp(IntCC::SignedLessThan, left_val, right_val)
 1306|       |                            } else {
 1307|      0|                                ctx.builder.ins().icmp(IntCC::UnsignedLessThan, left_val, right_val)
 1308|       |                            };
 1309|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1310|       |                        }
 1311|       |                        BinaryIntOp::Le => {
 1312|      0|                            let cond = if is_operand_signed(left_operand, ctx.mir) {
 1313|      0|                                ctx.builder
 1314|      0|                                    .ins()
 1315|      0|                                    .icmp(IntCC::SignedLessThanOrEqual, left_val, right_val)
 1316|       |                            } else {
 1317|      0|                                ctx.builder
 1318|      0|                                    .ins()
 1319|      0|                                    .icmp(IntCC::UnsignedLessThanOrEqual, left_val, right_val)
 1320|       |                            };
 1321|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1322|       |                        }
 1323|       |                        BinaryIntOp::Gt => {
 1324|      0|                            let cond = if is_operand_signed(left_operand, ctx.mir) {
 1325|      0|                                ctx.builder.ins().icmp(IntCC::SignedGreaterThan, left_val, right_val)
 1326|       |                            } else {
 1327|      0|                                ctx.builder.ins().icmp(IntCC::UnsignedGreaterThan, left_val, right_val)
 1328|       |                            };
 1329|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1330|       |                        }
 1331|       |                        BinaryIntOp::Ge => {
 1332|      0|                            let cond = if is_operand_signed(left_operand, ctx.mir) {
 1333|      0|                                ctx.builder
 1334|      0|                                    .ins()
 1335|      0|                                    .icmp(IntCC::SignedGreaterThanOrEqual, left_val, right_val)
 1336|       |                            } else {
 1337|      0|                                ctx.builder
 1338|      0|                                    .ins()
 1339|      0|                                    .icmp(IntCC::UnsignedGreaterThanOrEqual, left_val, right_val)
 1340|       |                            };
 1341|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1342|       |                        }
 1343|       |                    };
 1344|     39|                    Ok(result_val)
 1345|       |                }
 1346|      0|                Rvalue::BinaryFloatOp(op, left_operand, right_operand) => {
 1347|      0|                    let left_cranelift_type = get_operand_clif_type(left_operand, ctx.mir)
 1348|      0|                        .map_err(|e| format!("Failed to get left operand type: {}", e))?;
 1349|      0|                    let right_cranelift_type = get_operand_clif_type(right_operand, ctx.mir)
 1350|      0|                        .map_err(|e| format!("Failed to get right operand type: {}", e))?;
 1351|       |
 1352|      0|                    let left_val = resolve_operand(left_operand, ctx, left_cranelift_type)?;
 1353|      0|                    let right_val = resolve_operand(right_operand, ctx, right_cranelift_type)?;
 1354|       |
 1355|      0|                    let result_val = match op {
 1356|      0|                        BinaryFloatOp::Add => ctx.builder.ins().fadd(left_val, right_val),
 1357|      0|                        BinaryFloatOp::Sub => ctx.builder.ins().fsub(left_val, right_val),
 1358|      0|                        BinaryFloatOp::Mul => ctx.builder.ins().fmul(left_val, right_val),
 1359|      0|                        BinaryFloatOp::Div => ctx.builder.ins().fdiv(left_val, right_val),
 1360|       |                        BinaryFloatOp::Eq => {
 1361|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::Equal, left_val, right_val);
 1362|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1363|       |                        }
 1364|       |                        BinaryFloatOp::Ne => {
 1365|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::NotEqual, left_val, right_val);
 1366|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1367|       |                        }
 1368|       |                        BinaryFloatOp::Lt => {
 1369|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::LessThan, left_val, right_val);
 1370|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1371|       |                        }
 1372|       |                        BinaryFloatOp::Le => {
 1373|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::LessThanOrEqual, left_val, right_val);
 1374|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1375|       |                        }
 1376|       |                        BinaryFloatOp::Gt => {
 1377|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::GreaterThan, left_val, right_val);
 1378|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1379|       |                        }
 1380|       |                        BinaryFloatOp::Ge => {
 1381|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::GreaterThanOrEqual, left_val, right_val);
 1382|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1383|       |                        }
 1384|       |                    };
 1385|      0|                    Ok(result_val)
 1386|       |                }
 1387|      0|                Rvalue::BuiltinVaArg(ap, type_id) => {
 1388|       |                    // X86_64 SysV va_arg implementation
 1389|       |                    // va_list is struct { gp_offset, fp_offset, overflow_arg_area, reg_save_area }
 1390|       |                    // For GP types: if gp_offset < 48, fetch from reg_save_area + gp_offset
 1391|       |                    //               else fetch from overflow_arg_area
 1392|       |
 1393|      0|                    let ap_addr = resolve_place_to_addr(ap, ctx)?;
 1394|       |
 1395|       |                    // Load fields from va_list
 1396|      0|                    let gp_offset = ctx.builder.ins().load(types::I32, MemFlags::new(), ap_addr, 0);
 1397|      0|                    let fp_offset = ctx.builder.ins().load(types::I32, MemFlags::new(), ap_addr, 4);
 1398|      0|                    let overflow_area = ctx.builder.ins().load(types::I64, MemFlags::new(), ap_addr, 8);
 1399|      0|                    let reg_save_area = ctx.builder.ins().load(types::I64, MemFlags::new(), ap_addr, 16);
 1400|       |
 1401|      0|                    let mir_type = ctx.mir.get_type(*type_id);
 1402|      0|                    let cl_type = convert_type(mir_type).unwrap_or(types::I64);
 1403|       |
 1404|      0|                    let is_float = mir_type.is_float();
 1405|       |
 1406|      0|                    let result = if !is_float {
 1407|       |                        // Integer/Pointer argument
 1408|      0|                        let can_use_reg = ctx.builder.ins().icmp_imm(IntCC::SignedLessThan, gp_offset, 48);
 1409|      0|                        let overflow_block = ctx.builder.create_block();
 1410|      0|                        let reg_block = ctx.builder.create_block();
 1411|      0|                        let join_block = ctx.builder.create_block();
 1412|       |
 1413|       |                        // Add block parameters to join_block for the result and updated va_list
 1414|      0|                        ctx.builder.append_block_param(join_block, cl_type);
 1415|      0|                        ctx.builder.append_block_param(join_block, types::I32); // updated gp_offset
 1416|       |
 1417|      0|                        ctx.builder.ins().brif(can_use_reg, reg_block, &[], overflow_block, &[]);
 1418|       |
 1419|       |                        // Reg path
 1420|      0|                        ctx.builder.switch_to_block(reg_block);
 1421|      0|                        ctx.builder.seal_block(reg_block);
 1422|      0|                        let offset_64 = ctx.builder.ins().uextend(types::I64, gp_offset);
 1423|      0|                        let addr = ctx.builder.ins().iadd(reg_save_area, offset_64);
 1424|      0|                        let val = ctx.builder.ins().load(cl_type, MemFlags::new(), addr, 0);
 1425|      0|                        let next_gp = ctx.builder.ins().iadd_imm(gp_offset, 8);
 1426|      0|                        ctx.builder
 1427|      0|                            .ins()
 1428|      0|                            .jump(join_block, &[BlockArg::Value(val), BlockArg::Value(next_gp)]);
 1429|       |
 1430|       |                        // Overflow path
 1431|      0|                        ctx.builder.switch_to_block(overflow_block);
 1432|      0|                        ctx.builder.seal_block(overflow_block);
 1433|      0|                        let val = ctx.builder.ins().load(cl_type, MemFlags::new(), overflow_area, 0);
 1434|      0|                        let next_overflow = ctx.builder.ins().iadd_imm(overflow_area, 8);
 1435|      0|                        ctx.builder.ins().store(MemFlags::new(), next_overflow, ap_addr, 8);
 1436|      0|                        ctx.builder
 1437|      0|                            .ins()
 1438|      0|                            .jump(join_block, &[BlockArg::Value(val), BlockArg::Value(gp_offset)]); // gp_offset unchanged
 1439|       |
 1440|       |                        // Join path
 1441|      0|                        ctx.builder.switch_to_block(join_block);
 1442|      0|                        ctx.builder.seal_block(join_block);
 1443|      0|                        let final_val = ctx.builder.block_params(join_block)[0];
 1444|      0|                        let final_gp = ctx.builder.block_params(join_block)[1];
 1445|      0|                        ctx.builder.ins().store(MemFlags::new(), final_gp, ap_addr, 0);
 1446|      0|                        final_val
 1447|       |                    } else {
 1448|       |                        // Floating point argument
 1449|      0|                        let can_use_reg = ctx.builder.ins().icmp_imm(IntCC::SignedLessThan, fp_offset, 176);
 1450|      0|                        let overflow_block = ctx.builder.create_block();
 1451|      0|                        let reg_block = ctx.builder.create_block();
 1452|      0|                        let join_block = ctx.builder.create_block();
 1453|       |
 1454|      0|                        ctx.builder.append_block_param(join_block, cl_type);
 1455|      0|                        ctx.builder.append_block_param(join_block, types::I32); // updated fp_offset
 1456|       |
 1457|      0|                        ctx.builder.ins().brif(can_use_reg, reg_block, &[], overflow_block, &[]);
 1458|       |
 1459|       |                        // Reg path
 1460|      0|                        ctx.builder.switch_to_block(reg_block);
 1461|      0|                        ctx.builder.seal_block(reg_block);
 1462|      0|                        let offset_64 = ctx.builder.ins().uextend(types::I64, fp_offset);
 1463|      0|                        let addr = ctx.builder.ins().iadd(reg_save_area, offset_64);
 1464|      0|                        let val = ctx.builder.ins().load(cl_type, MemFlags::new(), addr, 0);
 1465|      0|                        let next_fp = ctx.builder.ins().iadd_imm(fp_offset, 16);
 1466|      0|                        ctx.builder
 1467|      0|                            .ins()
 1468|      0|                            .jump(join_block, &[BlockArg::Value(val), BlockArg::Value(next_fp)]);
 1469|       |
 1470|       |                        // Overflow path
 1471|      0|                        ctx.builder.switch_to_block(overflow_block);
 1472|      0|                        ctx.builder.seal_block(overflow_block);
 1473|      0|                        let val = ctx.builder.ins().load(cl_type, MemFlags::new(), overflow_area, 0);
 1474|      0|                        let next_overflow = ctx.builder.ins().iadd_imm(overflow_area, 8);
 1475|      0|                        ctx.builder.ins().store(MemFlags::new(), next_overflow, ap_addr, 8);
 1476|      0|                        ctx.builder
 1477|      0|                            .ins()
 1478|      0|                            .jump(join_block, &[BlockArg::Value(val), BlockArg::Value(fp_offset)]);
 1479|       |
 1480|       |                        // Join path
 1481|      0|                        ctx.builder.switch_to_block(join_block);
 1482|      0|                        ctx.builder.seal_block(join_block);
 1483|      0|                        let final_val = ctx.builder.block_params(join_block)[0];
 1484|      0|                        let final_fp = ctx.builder.block_params(join_block)[1];
 1485|      0|                        ctx.builder.ins().store(MemFlags::new(), final_fp, ap_addr, 4);
 1486|      0|                        final_val
 1487|       |                    };
 1488|      0|                    Ok(result)
 1489|       |                }
 1490|      1|                Rvalue::ArrayLiteral(elements) => {
 1491|      1|                    let dest_addr = resolve_place_to_addr(place, ctx)?;
                                                                                   ^0
 1492|      1|                    let MirType::Array { element, layout, .. } = place_mir_type else {
 1493|      0|                        return Err("ArrayLiteral with non-array type".to_string());
 1494|       |                    };
 1495|      1|                    let element_mir_type = ctx.mir.get_type(*element);
 1496|      1|                    let element_clif_type = convert_type(element_mir_type);
 1497|      1|                    let stride = layout.stride as i64;
 1498|       |
 1499|      2|                    for (i, element_op) in elements.iter().enumerate() {
                                                         ^1              ^1
 1500|      2|                        let offset = i as i64 * stride;
 1501|      2|                        let element_dest_addr = if offset == 0 {
 1502|      1|                            dest_addr
 1503|       |                        } else {
 1504|      1|                            ctx.builder.ins().iadd_imm(dest_addr, offset)
 1505|       |                        };
 1506|       |
 1507|      2|                        if element_mir_type.is_aggregate() {
 1508|      0|                            let src_addr = resolve_operand(element_op, ctx, types::I64)?;
 1509|      0|                            let size = mir_type_size(element_mir_type, ctx.mir)? as i64;
 1510|      0|                            emit_memcpy(element_dest_addr, src_addr, size, ctx.builder, ctx.module)?;
 1511|       |                        } else {
 1512|      2|                            let val = resolve_operand(element_op, ctx, element_clif_type.unwrap())?;
                                                                                                                ^0
 1513|      2|                            ctx.builder.ins().store(MemFlags::new(), val, element_dest_addr, 0);
 1514|       |                        }
 1515|       |                    }
 1516|      1|                    return Ok(());
 1517|       |                }
 1518|      1|                Rvalue::StructLiteral(fields) => {
 1519|      1|                    let dest_addr = resolve_place_to_addr(place, ctx)?;
                                                                                   ^0
 1520|       |                    let MirType::Record {
 1521|      1|                        layout, field_types, ..
 1522|      1|                    } = place_mir_type
 1523|       |                    else {
 1524|      0|                        return Err("StructLiteral with non-record type".to_string());
 1525|       |                    };
 1526|       |
 1527|      2|                    for (field_idx, element_op) in fields.iter() {
                                                                 ^1     ^1
 1528|      2|                        let offset = layout.field_offsets[*field_idx] as i64;
 1529|      2|                        let field_dest_addr = if offset == 0 {
 1530|      1|                            dest_addr
 1531|       |                        } else {
 1532|      1|                            ctx.builder.ins().iadd_imm(dest_addr, offset)
 1533|       |                        };
 1534|       |
 1535|      2|                        let field_mir_type = ctx.mir.get_type(field_types[*field_idx]);
 1536|      2|                        if field_mir_type.is_aggregate() {
 1537|      0|                            let src_addr = resolve_operand(element_op, ctx, types::I64)?;
 1538|      0|                            let size = mir_type_size(field_mir_type, ctx.mir)? as i64;
 1539|      0|                            emit_memcpy(field_dest_addr, src_addr, size, ctx.builder, ctx.module)?;
 1540|       |                        } else {
 1541|      2|                            let field_clif_type = convert_type(field_mir_type).unwrap();
 1542|      2|                            let val = resolve_operand(element_op, ctx, field_clif_type)?;
                                                                                                     ^0
 1543|      2|                            ctx.builder.ins().store(MemFlags::new(), val, field_dest_addr, 0);
 1544|       |                        }
 1545|       |                    }
 1546|      1|                    return Ok(());
 1547|       |                }
 1548|       |            };
 1549|       |
 1550|       |            // Now, assign the resolved value to the place
 1551|     93|            if let Ok(value) = rvalue_result {
 1552|     93|                let place_type_id = get_place_type_id(place, ctx.mir);
 1553|     93|                let mir_type = ctx.mir.get_type(place_type_id);
 1554|       |
 1555|     93|                if mir_type.is_aggregate() {
 1556|      0|                    let dest_addr = resolve_place_to_addr(place, ctx)?;
 1557|      0|                    let size = mir_type_size(mir_type, ctx.mir)? as i64;
 1558|      0|                    emit_memcpy(dest_addr, value, size, ctx.builder, ctx.module)?;
 1559|       |                } else {
 1560|     93|                    match place {
 1561|     88|                        Place::Local(local_id) => {
 1562|       |                            // Check if this local has a stack slot (non-void types)
 1563|     88|                            if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
 1564|     88|                                ctx.builder.ins().stack_store(value, *stack_slot, 0);
 1565|     88|                            } else {
 1566|      0|                                // This local doesn't have a stack slot (likely a void type)
 1567|      0|                                // or it's optimized out. In MIR, we assume it's valid to ignore.
 1568|      0|                            }
 1569|       |                        }
 1570|       |                        _ => {
 1571|       |                            // This covers StructField, ArrayIndex, Deref, and Global assignments
 1572|      5|                            match resolve_place_to_addr(place, ctx) {
 1573|      5|                                Ok(addr) => {
 1574|      5|                                    ctx.builder.ins().store(MemFlags::new(), value, addr, 0);
 1575|      5|                                }
 1576|      0|                                Err(e) => return Err(format!("Failed to resolve place address: {}", e)),
 1577|       |                            }
 1578|       |                        }
 1579|       |                    }
 1580|       |                }
 1581|       |            } else {
 1582|      0|                return Err(format!("Failed to resolve rvalue: {:?}", rvalue_result.err()));
 1583|       |            }
 1584|     93|            Ok(())
 1585|       |        }
 1586|       |
 1587|      2|        MirStmt::Store(operand, place) => {
 1588|       |            // We need to determine the correct type for the operand
 1589|      2|            let place_type_id = get_place_type_id(place, ctx.mir);
 1590|      2|            let place_type = ctx.mir.get_type(place_type_id);
 1591|      2|            let cranelift_type = convert_type(place_type).ok_or_else(|| "Cannot store to a void type".to_string())?;
                                                                                      ^0                            ^0          ^0
 1592|       |
 1593|      2|            let value = resolve_operand(operand, ctx, cranelift_type)?;
                                                                                   ^0
 1594|       |
 1595|       |            // Now, store the value into the place
 1596|      2|            match place {
 1597|      1|                Place::Local(local_id) => {
 1598|      1|                    let stack_slot = ctx
 1599|      1|                        .stack_slots
 1600|      1|                        .get(local_id)
 1601|      1|                        .ok_or_else(|| format!("Stack slot not found for local {}", local_id.get()))?;
                                                     ^0      ^0                                   ^0       ^0     ^0
 1602|      1|                    ctx.builder.ins().stack_store(value, *stack_slot, 0);
 1603|       |                }
 1604|       |                _ => {
 1605|       |                    // For other places, resolve to an address and store
 1606|      1|                    let addr = resolve_place_to_addr(place, ctx)?;
                                                                              ^0
 1607|      1|                    ctx.builder.ins().store(MemFlags::new(), value, addr, 0);
 1608|       |                }
 1609|       |            }
 1610|      2|            Ok(())
 1611|       |        }
 1612|      2|        MirStmt::Call { target, args, dest } => {
 1613|      2|            if let Some(dest_place) = dest {
                                      ^1
 1614|       |                // Call with destination - need to store the result
 1615|      1|                let dest_type_id = get_place_type_id(dest_place, ctx.mir);
 1616|      1|                let dest_mir_type = ctx.mir.get_type(dest_type_id);
 1617|      1|                let expected_type = match convert_type(dest_mir_type) {
 1618|      1|                    Some(t) => t,
 1619|      0|                    None if dest_mir_type.is_aggregate() => types::I64,
 1620|      0|                    None => return Err("Cannot assign to void type".to_string()),
 1621|       |                };
 1622|      1|                let result = emit_function_call_impl(target, args, expected_type, ctx)?;
                                                                                                    ^0
 1623|       |
 1624|       |                // Store the result in the destination place
 1625|      1|                let dest_mir_type = ctx.mir.get_type(dest_type_id);
 1626|      1|                if dest_mir_type.is_aggregate() {
 1627|       |                    // For aggregate types, result is an address, memcpy to dest
 1628|      0|                    let dest_addr = resolve_place_to_addr(dest_place, ctx)?;
 1629|      0|                    let size = mir_type_size(dest_mir_type, ctx.mir)? as i64;
 1630|      0|                    emit_memcpy(dest_addr, result, size, ctx.builder, ctx.module)?;
 1631|       |                } else {
 1632|      1|                    match dest_place {
 1633|      1|                        Place::Local(local_id) => {
 1634|      1|                            if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
 1635|      1|                                ctx.builder.ins().stack_store(result, *stack_slot, 0);
 1636|      1|                            }
                                          ^0
 1637|       |                        }
 1638|       |                        _ => {
 1639|      0|                            let addr = resolve_place_to_addr(dest_place, ctx)?;
 1640|      0|                            ctx.builder.ins().store(MemFlags::new(), result, addr, 0);
 1641|       |                        }
 1642|       |                    }
 1643|       |                }
 1644|       |            } else {
 1645|       |                // Call without destination - ignore return value (side-effect only)
 1646|      1|                let _ = emit_function_call_impl(target, args, types::I32, ctx)?;
                                                                                            ^0
 1647|       |            }
 1648|      2|            Ok(())
 1649|       |        }
 1650|       |
 1651|      1|        MirStmt::Alloc(place, type_id) => {
 1652|       |            // Get the size of the type to be allocated
 1653|      1|            let alloc_type = ctx.mir.get_type(*type_id);
 1654|      1|            let size = mir_type_size(alloc_type, ctx.mir)?;
                                                                       ^0
 1655|       |
 1656|       |            // Define the `malloc` function signature (size_t -> void*)
 1657|       |            // In Cranelift, this would be (i64) -> i64 for a 64-bit target
 1658|      1|            let mut malloc_sig = Signature::new(ctx.builder.func.signature.call_conv);
 1659|      1|            malloc_sig.params.push(AbiParam::new(types::I64));
 1660|      1|            malloc_sig.returns.push(AbiParam::new(types::I64));
 1661|       |
 1662|       |            // Declare `malloc` if not already declared
 1663|      1|            let malloc_func = ctx
 1664|      1|                .module
 1665|      1|                .declare_function("malloc", Linkage::Import, &malloc_sig)
 1666|      1|                .map_err(|e| format!("Failed to declare malloc: {:?}", e))?;
                                           ^0      ^0                                   ^0
 1667|      1|            let local_malloc = ctx.module.declare_func_in_func(malloc_func, ctx.builder.func);
 1668|       |
 1669|       |            // Call `malloc` with the calculated size
 1670|      1|            let size_val = ctx.builder.ins().iconst(types::I64, size as i64);
 1671|      1|            let call_inst = ctx.builder.ins().call(local_malloc, &[size_val]);
 1672|      1|            let alloc_ptr = ctx.builder.inst_results(call_inst)[0];
 1673|       |
 1674|       |            // Store the returned pointer into the destination place
 1675|      1|            match place {
 1676|      1|                Place::Local(local_id) => {
 1677|      1|                    if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
 1678|      1|                        ctx.builder.ins().stack_store(alloc_ptr, *stack_slot, 0);
 1679|      1|                    } else {
 1680|      0|                        eprintln!("Warning: Stack slot not found for local {}", local_id.get());
 1681|      0|                    }
 1682|       |                }
 1683|       |                _ => {
 1684|      0|                    let addr = resolve_place_to_addr(place, ctx)?;
 1685|      0|                    ctx.builder.ins().store(MemFlags::new(), alloc_ptr, addr, 0);
 1686|       |                }
 1687|       |            }
 1688|      1|            Ok(())
 1689|       |        }
 1690|       |
 1691|      1|        MirStmt::Dealloc(operand) => {
 1692|       |            // Resolve the operand to get the pointer to be freed
 1693|      1|            let ptr_val = resolve_operand(operand, ctx, types::I64)?;
                                                                                 ^0
 1694|       |
 1695|       |            // Define the `free` function signature (void* -> void)
 1696|      1|            let mut free_sig = Signature::new(ctx.builder.func.signature.call_conv);
 1697|      1|            free_sig.params.push(AbiParam::new(types::I64));
 1698|       |
 1699|       |            // Declare `free` if not already declared
 1700|      1|            let free_func = ctx
 1701|      1|                .module
 1702|      1|                .declare_function("free", Linkage::Import, &free_sig)
 1703|      1|                .map_err(|e| format!("Failed to declare free: {:?}", e))?;
                                           ^0      ^0                                 ^0
 1704|      1|            let local_free = ctx.module.declare_func_in_func(free_func, ctx.builder.func);
 1705|       |
 1706|       |            // Call `free` with the pointer
 1707|      1|            ctx.builder.ins().call(local_free, &[ptr_val]);
 1708|      1|            Ok(())
 1709|       |        }
 1710|       |
 1711|      0|        MirStmt::BuiltinVaStart(ap, _) => {
 1712|       |            // X86_64 SysV va_start implementation
 1713|       |            // Initialize va_list { gp_offset, fp_offset, overflow_arg_area, reg_save_area }
 1714|       |            // We use a 16-slot (128-byte) spill area to capture all variadic args.
 1715|       |            // gp_offset starts after fixed params, and we use 128 as the threshold.
 1716|       |
 1717|      0|            let ap_addr = resolve_place_to_addr(ap, ctx)?;
 1718|       |
 1719|       |            // Calculate gp_offset: fixed_params * 8 (each GP register is 8 bytes)
 1720|      0|            let fixed_param_count = ctx.func.params.len() as i32;
 1721|      0|            let gp_offset_val = ctx.builder.ins().iconst(types::I32, (fixed_param_count * 8) as i64);
 1722|      0|            ctx.builder.ins().store(MemFlags::new(), gp_offset_val, ap_addr, 0);
 1723|       |
 1724|       |            // fp_offset: starts after GP regs (6 regs * 8 = 48 bytes)
 1725|       |            // But SysV X86_64 uses 48-176 for floating point regs.
 1726|       |            // Since we don't distinguish GPR/FPR in simplify, let's just set it to 48.
 1727|      0|            let fp_offset_val = ctx.builder.ins().iconst(types::I32, 48i64);
 1728|      0|            ctx.builder.ins().store(MemFlags::new(), fp_offset_val, ap_addr, 4);
 1729|       |
 1730|       |            // overflow_arg_area: points to the stack after the 16 spill slots
 1731|       |            // But currently we don't support stack-passed args in simplify.
 1732|       |            // Let's just point it to the end of the spill area.
 1733|      0|            if let Some(spill_slot) = ctx.va_spill_slot {
 1734|      0|                let spill_addr = ctx.builder.ins().stack_addr(types::I64, spill_slot, 0);
 1735|      0|                let overflow_addr = ctx.builder.ins().iadd_imm(spill_addr, 128);
 1736|      0|                ctx.builder.ins().store(MemFlags::new(), overflow_addr, ap_addr, 8);
 1737|      0|
 1738|      0|                // reg_save_area: points to the start of the spill area
 1739|      0|                ctx.builder.ins().store(MemFlags::new(), spill_addr, ap_addr, 16);
 1740|      0|            }
 1741|       |
 1742|      0|            Ok(())
 1743|       |        }
 1744|      0|        MirStmt::BuiltinVaEnd(_ap) => {
 1745|       |            // BuiltinVaEnd is a no-op
 1746|      0|            Ok(())
 1747|       |        }
 1748|      0|        MirStmt::BuiltinVaCopy(dst, src) => {
 1749|      0|            let dst_addr = resolve_place_to_addr(dst, ctx)?;
 1750|      0|            let src_addr = resolve_place_to_addr(src, ctx)?;
 1751|       |
 1752|       |            // Copy all 24 bytes of the va_list struct
 1753|       |            // gp_offset (4 bytes)
 1754|      0|            let gp = ctx.builder.ins().load(types::I32, MemFlags::new(), src_addr, 0);
 1755|      0|            ctx.builder.ins().store(MemFlags::new(), gp, dst_addr, 0);
 1756|       |            // fp_offset (4 bytes)
 1757|      0|            let fp = ctx.builder.ins().load(types::I32, MemFlags::new(), src_addr, 4);
 1758|      0|            ctx.builder.ins().store(MemFlags::new(), fp, dst_addr, 4);
 1759|       |            // overflow_arg_area (8 bytes)
 1760|      0|            let overflow = ctx.builder.ins().load(types::I64, MemFlags::new(), src_addr, 8);
 1761|      0|            ctx.builder.ins().store(MemFlags::new(), overflow, dst_addr, 8);
 1762|       |            // reg_save_area (8 bytes)
 1763|      0|            let reg = ctx.builder.ins().load(types::I64, MemFlags::new(), src_addr, 16);
 1764|      0|            ctx.builder.ins().store(MemFlags::new(), reg, dst_addr, 16);
 1765|       |
 1766|      0|            Ok(())
 1767|       |        }
 1768|       |    }
 1769|    101|}
 1770|       |
 1771|       |/// Helper to lower a terminator
 1772|    121|fn lower_terminator(terminator: &Terminator, ctx: &mut BodyEmitContext) -> Result<(), String> {
 1773|    121|    match terminator {
 1774|     36|        Terminator::Goto(target) => {
 1775|     36|            let target_cl_block = ctx
 1776|     36|                .clif_blocks
 1777|     36|                .get(target)
 1778|     36|                .ok_or_else(|| format!("Target block {} not found", target.get()))?;
                                             ^0      ^0                           ^0     ^0     ^0
 1779|     36|            ctx.builder.ins().jump(*target_cl_block, &[]);
 1780|     36|            ctx.worklist.push(*target);
 1781|       |        }
 1782|       |
 1783|     32|        Terminator::If(cond, then_bb, else_bb) => {
 1784|     32|            let cond_val = resolve_operand(cond, ctx, types::I32)?;
                                                                               ^0
 1785|       |
 1786|     32|            let then_cl_block = ctx
 1787|     32|                .clif_blocks
 1788|     32|                .get(then_bb)
 1789|     32|                .ok_or_else(|| format!("'Then' block {} not found", then_bb.get()))?;
                                             ^0      ^0                           ^0      ^0     ^0
 1790|     32|            let else_cl_block = ctx
 1791|     32|                .clif_blocks
 1792|     32|                .get(else_bb)
 1793|     32|                .ok_or_else(|| format!("'Else' block {} not found", else_bb.get()))?;
                                             ^0      ^0                           ^0      ^0     ^0
 1794|       |
 1795|     32|            ctx.builder
 1796|     32|                .ins()
 1797|     32|                .brif(cond_val, *then_cl_block, &[], *else_cl_block, &[]);
 1798|       |
 1799|     32|            ctx.worklist.push(*then_bb);
 1800|     32|            ctx.worklist.push(*else_bb);
 1801|       |        }
 1802|       |
 1803|     53|        Terminator::Return(opt) => {
 1804|     53|            if let Some(operand) = opt {
                                      ^50
 1805|     50|                if let Some(ret_type) = ctx.return_type {
 1806|     50|                    let return_value = resolve_operand(operand, ctx, ret_type)?;
                                                                                            ^0
 1807|     50|                    ctx.builder.ins().return_(&[return_value]);
 1808|       |                } else {
 1809|      0|                    return Err("Returning a value from a void function".to_string());
 1810|       |                }
 1811|      3|            } else {
 1812|      3|                ctx.builder.ins().return_(&[]);
 1813|      3|            }
 1814|       |        }
 1815|       |
 1816|       |        Terminator::Unreachable => {
 1817|       |            // For unreachable, default to appropriate return based on function type
 1818|      0|            if let Some(ret_type) = ctx.return_type {
 1819|      0|                let return_value = ctx.builder.ins().iconst(ret_type, 0i64);
 1820|      0|                ctx.builder.ins().return_(&[return_value]);
 1821|      0|            } else {
 1822|      0|                // Void function
 1823|      0|                ctx.builder.ins().return_(&[]);
 1824|      0|            }
 1825|       |        }
 1826|       |    }
 1827|    121|    Ok(())
 1828|    121|}
 1829|       |
 1830|     59|fn setup_signature(
 1831|     59|    func: &MirFunction,
 1832|     59|    mir: &MirProgram,
 1833|     59|    func_ctx: &mut Signature,
 1834|     59|) -> Result<(Option<Type>, Vec<Type>), String> {
 1835|       |    // Set up function signature using the actual return type from MIR
 1836|     59|    func_ctx.params.clear();
 1837|       |
 1838|       |    // Get the return type from MIR and convert to Cranelift type
 1839|     59|    let return_mir_type = mir.get_type(func.return_type);
 1840|     59|    let return_type_opt = match convert_type(return_mir_type) {
 1841|     53|        Some(t) => Some(t),
 1842|      6|        None if return_mir_type.is_aggregate() => Some(types::I64),
                                                           ^0   ^0
 1843|      6|        None => None, // Void
 1844|       |    };
 1845|       |
 1846|       |    // Add parameters from MIR function signature
 1847|     59|    let mut param_types = Vec::new();
 1848|     66|    for &param_id in &func.params {
                       ^7
 1849|      7|        let param_local = mir.get_local(param_id);
 1850|      7|        let mir_type = mir.get_type(param_local.type_id);
 1851|      7|        let param_type = match convert_type(mir_type) {
 1852|      7|            Some(t) => t,
 1853|      0|            None if mir_type.is_aggregate() => types::I64,
 1854|      0|            None => return Err(format!("Unsupported parameter type for local {}", param_id.get())),
 1855|       |        };
 1856|      7|        func_ctx.params.push(AbiParam::new(param_type));
 1857|      7|        param_types.push(param_type);
 1858|       |    }
 1859|       |
 1860|     59|    if func.is_variadic {
 1861|       |        // Add 16 total I64 parameters to capture variadic arguments (6 GPRs + 10 stack slots)
 1862|       |        // This allows variadic functions to receive many struct args that expand to multiple I64s
 1863|      2|        let fixed_params_count = func.params.len();
 1864|      2|        let total_variadic_slots = 16; // Support up to 16 I64 slots for variadic args
 1865|      2|        if fixed_params_count < total_variadic_slots {
 1866|     30|            for _ in 0..(total_variadic_slots - fixed_params_count) {
                                      ^2
 1867|     30|                func_ctx.params.push(AbiParam::new(types::I64));
 1868|     30|            }
 1869|      0|        }
 1870|     57|    }
 1871|       |
 1872|       |    // Only add return parameter if the function has a non-void return type
 1873|     59|    if let Some(return_type) = return_type_opt {
                              ^53
 1874|     53|        func_ctx.returns.push(AbiParam::new(return_type));
 1875|     53|    }
                  ^6
 1876|       |
 1877|     59|    Ok((return_type_opt, param_types))
 1878|     59|}
 1879|       |
 1880|     29|fn allocate_stack_slots(
 1881|     29|    func: &MirFunction,
 1882|     29|    mir: &MirProgram,
 1883|     29|    builder: &mut FunctionBuilder,
 1884|     29|    clif_stack_slots: &mut HashMap<LocalId, StackSlot>,
 1885|     29|) -> Result<(), String> {
 1886|     29|    clif_stack_slots.clear(); // Clear for each function
 1887|       |
 1888|       |    // Combine locals and params for slot allocation
 1889|     29|    let all_locals: Vec<LocalId> = func.locals.iter().chain(func.params.iter()).cloned().collect();
 1890|       |
 1891|    113|    for &local_id in &all_locals {
                       ^84
 1892|     84|        let local = mir.get_local(local_id);
 1893|     84|        let local_type = mir.get_type(local.type_id);
 1894|     84|        let size = mir_type_size(local_type, mir)?;
                                                               ^0
 1895|       |
 1896|       |        // Don't allocate space for zero-sized types
 1897|     84|        if size > 0 {
 1898|     84|            let slot = builder.create_sized_stack_slot(StackSlotData::new(StackSlotKind::ExplicitSlot, size, 0));
 1899|     84|            clif_stack_slots.insert(local_id, slot);
 1900|     84|        }
                      ^0
 1901|       |    }
 1902|     29|    Ok(())
 1903|     29|}
 1904|       |
 1905|     29|fn finalize_function_processing(
 1906|     29|    func: &MirFunction,
 1907|     29|    module: &mut ObjectModule,
 1908|     29|    func_ctx: &mut cranelift::codegen::Context,
 1909|     29|    emit_kind: EmitKind,
 1910|     29|    compiled_functions: &mut HashMap<String, String>,
 1911|     29|) -> Result<(), String> {
 1912|       |    // Now declare and define the function
 1913|     29|    let linkage = convert_linkage(func.kind);
 1914|       |
 1915|     29|    let id = module
 1916|     29|        .declare_function(func.name.as_str(), linkage, &func_ctx.func.signature)
 1917|     29|        .map_err(|e| format!("Failed to declare function {}: {:?}", func.name, e))?;
                                   ^0      ^0                                                   ^0
 1918|       |
 1919|       |    // Only define the function body if it's a defined function (not extern)
 1920|     29|    if matches!(func.kind, MirFunctionKind::Defined) {
                     ^0
 1921|     29|        module
 1922|     29|            .define_function(id, func_ctx)
 1923|     29|            .map_err(|e| format!("Failed to define function {}: {:?}", func.name, e))?;
                                       ^0      ^0                                                  ^0
 1924|      0|    }
 1925|       |
 1926|     29|    if emit_kind == EmitKind::Clif {
 1927|     16|        // Store the function IR string for dumping
 1928|     16|        let func_ir = func_ctx.func.to_string();
 1929|     16|        compiled_functions.insert(func.name.to_string(), func_ir);
 1930|     16|    }
                  ^13
 1931|       |
 1932|     29|    Ok(())
 1933|     29|}
 1934|       |
 1935|       |/// MIR to Cranelift IR Lowerer
 1936|       |pub(crate) struct MirToCraneliftLowerer {
 1937|       |    builder_context: FunctionBuilderContext,
 1938|       |    module: ObjectModule,
 1939|       |    mir: MirProgram, // NOTE: need better nama
 1940|       |    clif_stack_slots: HashMap<LocalId, StackSlot>,
 1941|       |    // Store compiled functions for dumping
 1942|       |    compiled_functions: HashMap<String, String>,
 1943|       |
 1944|       |    emit_kind: EmitKind,
 1945|       |
 1946|       |    // Mappings for relocations
 1947|       |    func_id_map: HashMap<MirFunctionId, FuncId>,
 1948|       |    data_id_map: HashMap<GlobalId, DataId>,
 1949|       |
 1950|       |    // Variadic spill area for the current function
 1951|       |    va_spill_slot: Option<StackSlot>,
 1952|       |}
 1953|       |
 1954|       |/// NOTE: we use panic!() to ICE because codegen rely on correct MIR, so if we give invalid MIR, then problem is in previous phase
 1955|       |impl MirToCraneliftLowerer {
 1956|     27|    pub(crate) fn new(mir: MirProgram) -> Self {
 1957|     27|        let triple = Triple::host();
 1958|     27|        let mut flag_builder = cranelift::prelude::settings::builder();
 1959|     27|        flag_builder.set("is_pic", "true").unwrap();
 1960|     27|        let builder = ObjectBuilder::new(
 1961|     27|            cranelift::prelude::isa::lookup(triple)
 1962|     27|                .unwrap()
 1963|     27|                .finish(cranelift::prelude::settings::Flags::new(flag_builder))
 1964|     27|                .unwrap(),
 1965|       |            "main",
 1966|     27|            cranelift_module::default_libcall_names(),
 1967|       |        )
 1968|     27|        .unwrap();
 1969|     27|        let module = ObjectModule::new(builder);
 1970|       |
 1971|     27|        Self {
 1972|     27|            builder_context: FunctionBuilderContext::new(),
 1973|     27|            // ctx: module.make_context(),
 1974|     27|            module,
 1975|     27|            mir,
 1976|     27|            clif_stack_slots: HashMap::new(),
 1977|     27|            compiled_functions: HashMap::new(),
 1978|     27|            emit_kind: EmitKind::Object,
 1979|     27|            func_id_map: HashMap::new(),
 1980|     27|            data_id_map: HashMap::new(),
 1981|     27|            va_spill_slot: None,
 1982|     27|        }
 1983|     27|    }
 1984|       |
 1985|     27|    pub(crate) fn compile_module(mut self, emit_kind: EmitKind) -> Result<ClifOutput, String> {
 1986|     27|        self.emit_kind = emit_kind;
 1987|       |
 1988|       |        // Pass 1: Declare all global variables
 1989|     38|        for (global_id, global) in &self.mir.globals {
                           ^11        ^11
 1990|     11|            let linkage = if global.initial_value.is_some() {
 1991|     11|                Linkage::Export
 1992|       |            } else {
 1993|      0|                Linkage::Import
 1994|       |            };
 1995|       |
 1996|     11|            let data_id = self
 1997|     11|                .module
 1998|     11|                .declare_data(global.name.as_str(), linkage, true, false)
 1999|     11|                .map_err(|e| format!("Failed to declare global data: {:?}", e))?;
                                           ^0      ^0                                        ^0
 2000|       |
 2001|     11|            self.data_id_map.insert(*global_id, data_id);
 2002|       |        }
 2003|       |
 2004|       |        // Pass 2: Declare all functions
 2005|     57|        for (func_id, func) in &self.mir.functions {
                           ^30      ^30
 2006|     30|            let linkage = convert_linkage(func.kind);
 2007|       |
 2008|       |            // Calculate signature for declaration
 2009|     30|            let mut sig = self.module.make_signature();
 2010|     30|            setup_signature(func, &self.mir, &mut sig)?;
                                                                    ^0
 2011|       |
 2012|     30|            let clif_func_id = self
 2013|     30|                .module
 2014|     30|                .declare_function(func.name.as_str(), linkage, &sig)
 2015|     30|                .map_err(|e| format!("Failed to declare function {}: {:?}", func.name, e))?;
                                           ^0      ^0                                                   ^0
 2016|       |
 2017|     30|            self.func_id_map.insert(*func_id, clif_func_id);
 2018|       |        }
 2019|       |
 2020|       |        // Pass 3: Define Global Variables (with relocations)
 2021|     38|        for (global_id, global) in &self.mir.globals {
                           ^11        ^11
 2022|     11|            if let Some(const_id) = global.initial_value {
 2023|     11|                let data_id = *self.data_id_map.get(global_id).unwrap();
 2024|     11|                let mut data_description = DataDescription::new();
 2025|     11|                let mut initial_value_bytes = Vec::new();
 2026|       |                // Enable relocations by passing data_description and maps
 2027|     11|                let ctx = EmitContext {
 2028|     11|                    mir: &self.mir,
 2029|     11|                    func_id_map: &self.func_id_map,
 2030|     11|                    data_id_map: &self.data_id_map,
 2031|     11|                };
 2032|     11|                emit_const(
 2033|     11|                    const_id,
 2034|     11|                    &mut initial_value_bytes,
 2035|     11|                    &ctx,
 2036|     11|                    Some(&mut self.module),
 2037|     11|                    Some(&mut data_description),
 2038|       |                    0,
 2039|      0|                )?;
 2040|       |
 2041|     11|                data_description.define(initial_value_bytes.into_boxed_slice());
 2042|       |
 2043|     11|                self.module
 2044|     11|                    .define_data(data_id, &data_description)
 2045|     11|                    .map_err(|e| format!("Failed to define global data: {:?}", e))?;
                                               ^0      ^0                                       ^0
 2046|      0|            }
 2047|       |        }
 2048|       |
 2049|       |        // Pass 4: Define Functions (Lower bodies)
 2050|       |        // We can't iterate on `&self.mir.module.functions` directly because `lower_function`
 2051|       |        // needs a mutable borrow of `self`. Instead, we iterate by index to avoid cloning the
 2052|       |        // function list, which would cause a heap allocation.
 2053|     30|        for i in 0..self.mir.module.functions.len() {
                                  ^27                       ^27
 2054|     30|            let func_id = self.mir.module.functions[i];
 2055|       |            // Only lower functions that are defined (have bodies)
 2056|     30|            if let Some(func) = self.mir.functions.get(&func_id)
 2057|     30|                && matches!(func.kind, MirFunctionKind::Defined)
                                 ^1
 2058|       |            {
 2059|     29|                self.lower_function(func_id)?;
                                                          ^0
 2060|      1|            }
 2061|       |        }
 2062|       |
 2063|       |        // Finalize and return the compiled code
 2064|     27|        let product = self.module.finish();
 2065|     27|        let code = product
 2066|     27|            .object
 2067|     27|            .write()
 2068|     27|            .map_err(|e| format!("Failed to write object file: {:?}", e))?;
                                       ^0      ^0                                      ^0
 2069|       |
 2070|     27|        if emit_kind == EmitKind::Object {
 2071|     13|            Ok(ClifOutput::ObjectFile(code))
 2072|       |        } else {
 2073|       |            // For Clif dump, concatenate all function IRs
 2074|     14|            let mut clif_dump = String::new();
 2075|     30|            for (func_name, func_ir) in &self.compiled_functions {
                               ^16        ^16
 2076|     16|                clif_dump.push_str(&format!("; Function: {}\n", func_name));
 2077|     16|                clif_dump.push_str(func_ir);
 2078|     16|                clif_dump.push_str("\n\n");
 2079|     16|            }
 2080|     14|            Ok(ClifOutput::ClifDump(clif_dump))
 2081|       |        }
 2082|     27|    }
 2083|       |
 2084|       |    /// Lower a MIR function to Cranelift IR using 3-phase algorithm
 2085|     29|    fn lower_function(&mut self, func_id: MirFunctionId) -> Result<(), String> {
 2086|     29|        let func = self.mir.get_function(func_id);
 2087|       |        // Create a fresh context for this function
 2088|     29|        let mut func_ctx = self.module.make_context();
 2089|       |
 2090|     29|        let (return_type_opt, param_types) = setup_signature(func, &self.mir, &mut func_ctx.func.signature)?;
                                                                                                                         ^0
 2091|       |
 2092|       |        // Create a function builder with the fresh context
 2093|     29|        let mut builder = FunctionBuilder::new(&mut func_ctx.func, &mut self.builder_context);
 2094|       |
 2095|     29|        allocate_stack_slots(func, &self.mir, &mut builder, &mut self.clif_stack_slots)?;
                                                                                                     ^0
 2096|       |
 2097|       |        // PHASE 1  Create all Cranelift blocks first (no instructions)
 2098|     29|        let mut clif_blocks = HashMap::new();
 2099|       |
 2100|    150|        for &block_id in &func.blocks {
                           ^121
 2101|    121|            clif_blocks.insert(block_id, builder.create_block());
 2102|    121|        }
 2103|       |
 2104|       |        // PHASE 2  Lower block content (without sealing)
 2105|     29|        let mut va_spill_slot = None;
 2106|       |
 2107|       |        // Use worklist algorithm for proper traversal
 2108|     29|        let mut worklist = vec![func.entry_block.expect("Defined function must have entry block")];
 2109|     29|        let mut visited = HashSet::new();
 2110|       |
 2111|    158|        while let Some(current_block_id) = worklist.pop() {
                                     ^129
 2112|    129|            if visited.contains(&current_block_id) {
 2113|      8|                continue;
 2114|    121|            }
 2115|    121|            visited.insert(current_block_id);
 2116|       |
 2117|    121|            let clif_block = clif_blocks
 2118|    121|                .get(&current_block_id)
 2119|    121|                .ok_or_else(|| format!("Block {} not found in mapping", current_block_id.get()))?;
                                             ^0      ^0                               ^0               ^0     ^0
 2120|    121|            builder.switch_to_block(*clif_block);
 2121|       |
 2122|       |            // Setup entry block parameters
 2123|    121|            if Some(current_block_id) == func.entry_block {
 2124|       |                // Step 1: Add ALL block parameters first (fixed params)
 2125|     32|                for &param_type in &param_types {
                                   ^3
 2126|      3|                    builder.append_block_param(*clif_block, param_type);
 2127|      3|                }
 2128|       |
 2129|       |                // Step 2: Add variadic block parameters if needed (still before any instructions)
 2130|     29|                if func.is_variadic {
 2131|      1|                    let fixed_param_count = func.params.len();
 2132|      1|                    let total_variadic_slots = 16; // Must match setup_signature
 2133|      1|                    if fixed_param_count < total_variadic_slots {
 2134|      1|                        let extra_count = total_variadic_slots - fixed_param_count;
 2135|     15|                        for _ in 0..extra_count {
                                                  ^1
 2136|     15|                            builder.append_block_param(*clif_block, types::I64);
 2137|     15|                        }
 2138|      0|                    }
 2139|     28|                }
 2140|       |
 2141|       |                // Step 3: NOW emit instructions - store fixed params to stack slots
 2142|     29|                let param_values: Vec<Value> = builder.block_params(*clif_block).to_vec();
 2143|       |
 2144|     29|                for (next_param_idx, &param_id) in func.params.iter().enumerate() {
                                   ^3               ^3
 2145|      3|                    let param_value = param_values[next_param_idx];
 2146|      3|                    if let Some(stack_slot) = self.clif_stack_slots.get(&param_id) {
 2147|      3|                        builder.ins().stack_store(param_value, *stack_slot, 0);
 2148|      3|                    }
                                  ^0
 2149|       |                }
 2150|       |
 2151|       |                // Step 4: Handle variadic spill area - save all 16 slots
 2152|     29|                if func.is_variadic {
 2153|      1|                    let total_slots = 16;
 2154|      1|                    let spill_size = total_slots * 8; // 128 bytes for 16 I64 slots
 2155|      1|                    let spill_slot = builder.create_sized_stack_slot(StackSlotData::new(
 2156|      1|                        StackSlotKind::ExplicitSlot,
 2157|      1|                        spill_size as u32,
 2158|       |                        0,
 2159|       |                    ));
 2160|      1|                    let all_param_values = builder.block_params(*clif_block).to_vec();
 2161|     16|                    for (i, val) in all_param_values
 2162|      1|                        .iter()
 2163|      1|                        .enumerate()
 2164|      1|                        .take(total_slots.min(all_param_values.len()))
 2165|     16|                    {
 2166|     16|                        builder.ins().stack_store(*val, spill_slot, (i * 8) as i32);
 2167|     16|                    }
 2168|      1|                    va_spill_slot = Some(spill_slot);
 2169|     28|                }
 2170|     92|            }
 2171|       |
 2172|       |            // Get the MIR block
 2173|    121|            let mir_block = self
 2174|    121|                .mir
 2175|    121|                .blocks
 2176|    121|                .get(&current_block_id)
 2177|    121|                .ok_or_else(|| format!("Block {} not found in MIR", current_block_id.get()))?;
                                             ^0      ^0                           ^0               ^0     ^0
 2178|       |
 2179|       |            // ========================================================================
 2180|       |            // SECTION 1: Process statements within this block
 2181|       |            // ========================================================================
 2182|    121|            let statements_to_process: Vec<MirStmt> = mir_block
 2183|    121|                .statements
 2184|    121|                .iter()
 2185|    121|                .filter_map(|&stmt_id| self.mir.statements.get(&stmt_id).cloned())
                                                     ^101                ^101^101      ^101
 2186|    121|                .collect();
 2187|       |
 2188|    121|            let mut ctx = BodyEmitContext {
 2189|    121|                builder: &mut builder,
 2190|    121|                mir: &self.mir,
 2191|    121|                stack_slots: &self.clif_stack_slots,
 2192|    121|                module: &mut self.module,
 2193|    121|                va_spill_slot,
 2194|    121|                func,
 2195|    121|                clif_blocks: &clif_blocks,
 2196|    121|                worklist: &mut worklist,
 2197|    121|                return_type: return_type_opt,
 2198|    121|                func_id_map: &self.func_id_map,
 2199|    121|            };
 2200|       |
 2201|       |            // Process statements
 2202|    222|            for stmt in &statements_to_process {
                              ^101
 2203|    101|                lower_statement(stmt, &mut ctx)?;
                                                             ^0
 2204|       |            }
 2205|       |
 2206|       |            // ========================================================================
 2207|       |            // SECTION 2: Process terminator (control flow)
 2208|       |            // ========================================================================
 2209|    121|            lower_terminator(&mir_block.terminator, &mut ctx)?;
                                                                           ^0
 2210|       |
 2211|    121|            va_spill_slot = ctx.va_spill_slot;
 2212|       |        }
 2213|       |
 2214|       |        // PHASE 3  Seal blocks with correct order
 2215|    150|        for &mir_block_id in &func.blocks {
                           ^121
 2216|    121|            let cl_block = clif_blocks.get(&mir_block_id).expect("Block not found in mapping");
 2217|    121|            builder.seal_block(*cl_block);
 2218|    121|        }
 2219|       |
 2220|       |        // Finalize the function
 2221|     29|        builder.finalize();
 2222|     29|        self.va_spill_slot = va_spill_slot;
 2223|       |
 2224|     29|        finalize_function_processing(
 2225|     29|            func,
 2226|     29|            &mut self.module,
 2227|     29|            &mut func_ctx,
 2228|     29|            self.emit_kind,
 2229|     29|            &mut self.compiled_functions,
 2230|      0|        )?;
 2231|       |
 2232|     29|        Ok(())
 2233|     29|    }
 2234|       |}

/app/src/mir/dumper.rs:
    1|       |//! MIR (Mid-level Intermediate Representation) Dumper
    2|       |//!
    3|       |//! This module provides functionality to dump MIR in a human-readable format
    4|       |//! following the C11 compiler's specific conventions:
    5|       |//! - Local variables: %0, %1, %tmp3
    6|       |//! - Global variables: @g_var
    7|       |//! - Basic blocks: bb0, bb1
    8|       |//! - Constants: const 42, const null
    9|       |//! - Types: i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, ptr<T>
   10|       |
   11|       |use std::fmt::Write;
   12|       |
   13|       |use super::{
   14|       |    BinaryFloatOp, BinaryIntOp, CallTarget, ConstValueId, ConstValueKind, Global, GlobalId, LocalId, MirBlock,
   15|       |    MirBlockId, MirFunction, MirFunctionId, MirFunctionKind, MirStmt, MirType, Operand, Place, Rvalue, Terminator,
   16|       |    TypeId, UnaryFloatOp, UnaryIntOp,
   17|       |};
   18|       |use crate::mir::MirProgram;
   19|       |
   20|       |/// Configuration for MIR dump output
   21|       |#[derive(Debug, Clone)]
   22|       |pub struct MirDumpConfig {
   23|       |    pub include_header: bool,
   24|       |}
   25|       |
   26|       |impl Default for MirDumpConfig {
   27|      0|    fn default() -> Self {
   28|      0|        MirDumpConfig { include_header: true }
   29|      0|    }
   30|       |}
   31|       |
   32|       |/// Main MIR dumper that generates human-readable MIR output
   33|       |pub struct MirDumper<'a> {
   34|       |    sema_output: &'a MirProgram,
   35|       |    config: &'a MirDumpConfig,
   36|       |}
   37|       |
   38|       |impl<'a> MirDumper<'a> {
   39|       |    /// Create a new MIR dumper
   40|     42|    pub fn new(sema_output: &'a MirProgram, config: &'a MirDumpConfig) -> Self {
   41|     42|        Self { sema_output, config }
   42|     42|    }
   43|       |
   44|       |    /// Generate the complete MIR dump
   45|     42|    pub fn generate_mir_dump(&self) -> Result<String, std::fmt::Error> {
   46|     42|        let mut output = String::new();
   47|       |
   48|       |        // Dump module header
   49|     42|        if self.config.include_header {
   50|      0|            writeln!(output, "; MIR Dump for Module {}", self.sema_output.module.id.get())?;
   51|      0|            writeln!(output, "; Generated by Cendol C11 Compiler")?;
   52|      0|            writeln!(output)?;
   53|     42|        }
   54|       |
   55|       |        // Dump type definitions
   56|     42|        self.dump_types(&mut output)?;
                                                  ^0
   57|     42|        writeln!(output)?;
                                      ^0
   58|       |
   59|       |        // Dump global variables first
   60|     42|        if !self.sema_output.module.globals.is_empty() {
   61|     46|            for &global_id in &self.sema_output.module.globals {
                               ^25
   62|     25|                if let Some(global) = self.sema_output.globals.get(&global_id) {
   63|     25|                    self.dump_global(&mut output, global)?;
                                                                       ^0
   64|     25|                    writeln!(output)?;
                                                  ^0
   65|      0|                }
   66|       |            }
   67|     21|            writeln!(output)?;
                                          ^0
   68|     21|        }
   69|       |
   70|       |        // Dump all functions
   71|    105|        for &func_id in &self.sema_output.module.functions {
                           ^63
   72|     63|            if let Some(func) = self.sema_output.functions.get(&func_id) {
   73|     63|                self.dump_function(&mut output, func)?;
                                                                   ^0
   74|     63|                writeln!(output)?;
                                              ^0
   75|      0|            }
   76|       |        }
   77|       |
   78|     42|        Ok(output)
   79|     42|    }
   80|       |
   81|       |    /// Dump a single function
   82|     63|    fn dump_function(&self, output: &mut String, func: &MirFunction) -> Result<(), std::fmt::Error> {
   83|       |        // Function signature
   84|     63|        let return_type = self.type_to_string(func.return_type);
   85|     63|        let fn_keyword = match func.kind {
   86|      4|            MirFunctionKind::Extern => "extern fn",
   87|     59|            MirFunctionKind::Defined => "fn",
   88|       |        };
   89|     63|        write!(output, "{} {}(", fn_keyword, func.name)?;
                                                                     ^0
   90|       |
   91|       |        // Dump parameters
   92|     63|        for (i, &param_id) in func.params.iter().enumerate() {
                           ^7  ^7
   93|      7|            if i > 0 {
   94|      1|                write!(output, ", ")?;
                                                  ^0
   95|      6|            }
   96|      7|            if let Some(param) = self.sema_output.locals.get(&param_id) {
   97|      7|                let param_type = self.type_to_string(param.type_id);
   98|      7|                let param_name = param.name.as_ref().map_or("%unnamed".to_string(), |s| s.to_string());
   99|      7|                write!(output, "%{}: {}", param_name, param_type)?;
                                                                               ^0
  100|       |            } else {
  101|      0|                write!(output, "%param{}: ?", param_id.get())?;
  102|       |            }
  103|       |        }
  104|     63|        if func.is_variadic {
  105|      1|            if !func.params.is_empty() {
  106|      1|                write!(output, ", ")?;
                                                  ^0
  107|      0|            }
  108|      1|            write!(output, "...")?;
                                               ^0
  109|     62|        }
  110|       |
  111|     63|        write!(output, ") -> {}", return_type)?;
                                                            ^0
  112|       |
  113|       |        // For extern functions, don't output any body
  114|     63|        if matches!(func.kind, MirFunctionKind::Extern) {
                         ^59
  115|      4|            writeln!(output)?;
                                          ^0
  116|      4|            return Ok(());
  117|     59|        }
  118|       |
  119|     59|        writeln!(output)?;
                                      ^0
  120|       |
  121|       |        // Function body
  122|     59|        writeln!(output, "{{")?;
                                            ^0
  123|       |
  124|       |        // Dump locals section
  125|     59|        if func.locals.is_empty() == false {
  126|     27|            writeln!(output, "  locals {{")?;
                                                         ^0
  127|     93|            for &local_id in &func.locals {
                               ^66
  128|     66|                if let Some(local) = self.sema_output.locals.get(&local_id) {
  129|     66|                    let local_type = self.type_to_string(local.type_id);
  130|     66|                    let local_name = self.local_to_string(local_id);
  131|     66|                    writeln!(output, "    {}: {}", local_name, local_type)?;
                                                                                        ^0
  132|      0|                }
  133|       |            }
  134|     27|            writeln!(output, "  }}")?;
                                                  ^0
  135|     32|        }
  136|       |
  137|       |        // Dump basic blocks
  138|    169|        for &block_id in &func.blocks {
                           ^110
  139|    110|            if let Some(block) = self.sema_output.blocks.get(&block_id) {
  140|    110|                self.dump_block(output, block_id, block)?;
                                                                      ^0
  141|      0|            }
  142|       |        }
  143|       |
  144|     59|        writeln!(output, "}}")?;
                                            ^0
  145|     59|        Ok(())
  146|     63|    }
  147|       |
  148|       |    /// Dump all type definitions
  149|     42|    fn dump_types(&self, output: &mut String) -> Result<(), std::fmt::Error> {
  150|    138|        for (i, mir_type) in self.sema_output.module.types.iter().enumerate() {
                                           ^42                                  ^42
  151|    138|            let type_id = TypeId::new((i + 1) as u32).unwrap();
  152|    138|            let type_str = self.type_to_string_with_id(type_id, mir_type);
  153|    138|            writeln!(output, "{}", type_str)?;
                                                          ^0
  154|       |        }
  155|     42|        Ok(())
  156|     42|    }
  157|       |
  158|       |    /// Convert MIR type to string representation with type ID
  159|    138|    fn type_to_string_with_id(&self, type_id: TypeId, mir_type: &MirType) -> String {
  160|    138|        let type_index = self.get_type_index_from_type_id(type_id);
  161|    138|        let type_name = format!("%t{}", type_index);
  162|       |
  163|    138|        match mir_type {
  164|      6|            MirType::Void => format!("type {} = void", type_name),
  165|      0|            MirType::Bool => format!("type {} = bool", type_name),
  166|       |
  167|      7|            MirType::I8 => format!("type {} = i8", type_name),
  168|      1|            MirType::I16 => format!("type {} = i16", type_name),
  169|     42|            MirType::I32 => format!("type {} = i32", type_name),
  170|      3|            MirType::I64 => format!("type {} = i64", type_name),
  171|      1|            MirType::U8 => format!("type {} = u8", type_name),
  172|      1|            MirType::U16 => format!("type {} = u16", type_name),
  173|      1|            MirType::U32 => format!("type {} = u32", type_name),
  174|      1|            MirType::U64 => format!("type {} = u64", type_name),
  175|      1|            MirType::F32 => format!("type {} = f32", type_name),
  176|      1|            MirType::F64 => format!("type {} = f64", type_name),
  177|     15|            MirType::Pointer { pointee } => {
  178|     15|                let pointee_index = self.get_type_index_from_type_id(*pointee);
  179|     15|                format!("type {} = ptr<%t{}>", type_name, pointee_index)
  180|       |            }
  181|     20|            MirType::Array { element, size, .. } => {
  182|     20|                let elem_index = self.get_type_index_from_type_id(*element);
  183|     20|                format!("type {} = [{}]%t{}", type_name, size, elem_index)
  184|       |            }
  185|       |            MirType::Function {
  186|     19|                return_type,
  187|     19|                params,
  188|     19|                is_variadic,
  189|       |            } => {
  190|     19|                let ret_index = self.get_type_index_from_type_id(*return_type);
  191|     19|                let mut param_types: Vec<String> = params
  192|     19|                    .iter()
  193|     19|                    .map(|&p| {
                                            ^6
  194|      6|                        let param_index = self.get_type_index_from_type_id(p);
  195|      6|                        format!("%t{}", param_index)
  196|      6|                    })
  197|     19|                    .collect();
  198|     19|                if *is_variadic {
  199|      1|                    param_types.push("...".to_string());
  200|     18|                }
  201|     19|                format!("type {} = fn({}) -> %t{}", type_name, param_types.join(", "), ret_index)
  202|       |            }
  203|       |            MirType::Record {
  204|     19|                name,
  205|     19|                field_types,
  206|     19|                field_names,
  207|     19|                is_union,
  208|       |                ..
  209|       |            } => {
  210|     19|                let field_strs: Vec<String> = field_names
  211|     19|                    .iter()
  212|     19|                    .zip(field_types.iter())
  213|     33|                    .map(|(fname, fid)| {
                                   ^19
  214|     33|                        let field_index = self.get_type_index_from_type_id(*fid);
  215|     33|                        format!("{}: %t{}", fname, field_index)
  216|     33|                    })
  217|     19|                    .collect();
  218|     19|                let kind = if *is_union { "union" } else { "struct" };
                                                        ^3               ^16
  219|     19|                format!("type {} = {} {} {{ {} }}", type_name, kind, name, field_strs.join(", "))
  220|       |            }
  221|       |        }
  222|    138|    }
  223|       |
  224|       |    /// Helper function to get type index from TypeId
  225|    476|    fn get_type_index_from_type_id(&self, type_id: TypeId) -> usize {
  226|       |        // Fallback: assume sequential mapping
  227|    476|        (type_id.get() - 1) as usize
  228|    476|    }
  229|       |
  230|       |    /// Dump a global variable
  231|     25|    fn dump_global(&self, output: &mut String, global: &Global) -> Result<(), std::fmt::Error> {
  232|     25|        let global_type = self.type_to_string(global.type_id);
  233|     25|        write!(output, "global @{}: {}", global.name, global_type)?;
                                                                                ^0
  234|       |
  235|     25|        if let Some(const_id) = global.initial_value {
                                  ^24
  236|       |            // Check if this global represents a string literal
  237|     24|            if let Some(string_repr) = self.try_format_as_string_literal(&global.name.to_string(), const_id) {
                                      ^5
  238|      5|                write!(output, " = {}", string_repr)?;
                                                                  ^0
  239|       |            } else {
  240|     19|                write!(output, " = {}", self.const_to_string(const_id))?;
                                                                                     ^0
  241|       |            }
  242|      1|        }
  243|       |
  244|     25|        Ok(())
  245|     25|    }
  246|       |
  247|       |    /// Dump a basic block
  248|    110|    fn dump_block(&self, output: &mut String, block_id: MirBlockId, block: &MirBlock) -> Result<(), std::fmt::Error> {
  249|    110|        writeln!(output)?;
                                      ^0
  250|    110|        writeln!(output, "  {}:", self.block_to_string(block_id))?;
                                                                               ^0
  251|       |
  252|       |        // Dump statements in the block
  253|    210|        for &stmt_id in &block.statements {
                           ^100
  254|    100|            if let Some(stmt) = self.sema_output.statements.get(&stmt_id) {
  255|    100|                write!(output, "    ")?;
                                                    ^0
  256|    100|                self.dump_statement(output, stmt)?;
                                                               ^0
  257|    100|                writeln!(output)?;
                                              ^0
  258|      0|            }
  259|       |        }
  260|       |
  261|       |        // Dump terminator (MUST be explicit)
  262|    110|        write!(output, "    ")?;
                                            ^0
  263|    110|        self.dump_terminator(output, &block.terminator)?;
                                                                     ^0
  264|    110|        writeln!(output)?;
                                      ^0
  265|       |
  266|    110|        Ok(())
  267|    110|    }
  268|       |
  269|       |    /// Dump a statement
  270|    100|    fn dump_statement(&self, output: &mut String, stmt: &MirStmt) -> Result<(), std::fmt::Error> {
  271|    100|        match stmt {
  272|     80|            MirStmt::Assign(place, rvalue) => {
  273|     80|                write!(output, "{} = ", self.place_to_string(place))?;
                                                                                  ^0
  274|     80|                self.dump_rvalue(output, rvalue)?;
                                                              ^0
  275|       |            }
  276|      0|            MirStmt::Store(operand, place) => {
  277|      0|                write!(output, "store ")?;
  278|      0|                self.dump_operand(output, operand)?;
  279|      0|                write!(output, ", {}", self.place_to_string(place))?;
  280|       |            }
  281|     20|            MirStmt::Call { target, args, dest } => {
  282|     20|                if let Some(place) = dest {
                                          ^6
  283|      6|                    write!(output, "{} = ", self.place_to_string(place))?;
                                                                                      ^0
  284|     14|                }
  285|     20|                write!(output, "call {}(", self.call_target_to_string(target))?;
                                                                                            ^0
  286|     20|                for (i, operand) in args.iter().enumerate() {
                                   ^8 ^8
  287|      8|                    if i > 0 {
  288|      3|                        write!(output, ", ")?;
                                                          ^0
  289|      5|                    }
  290|      8|                    self.dump_operand(output, operand)?;
                                                                    ^0
  291|       |                }
  292|     20|                write!(output, ")")?;
                                                 ^0
  293|       |            }
  294|      0|            MirStmt::Alloc(place, type_id) => {
  295|      0|                write!(
  296|      0|                    output,
  297|      0|                    "{} = alloc {}",
  298|      0|                    self.place_to_string(place),
  299|      0|                    self.type_to_string(*type_id)
  300|      0|                )?;
  301|       |            }
  302|      0|            MirStmt::Dealloc(operand) => {
  303|      0|                write!(output, "dealloc ")?;
  304|      0|                self.dump_operand(output, operand)?;
  305|       |            }
  306|      0|            MirStmt::BuiltinVaStart(ap, last) => {
  307|      0|                write!(
  308|      0|                    output,
  309|      0|                    "va_start({}, {})",
  310|      0|                    self.place_to_string(ap),
  311|      0|                    self.operand_to_string(last)
  312|      0|                )?;
  313|       |            }
  314|      0|            MirStmt::BuiltinVaEnd(ap) => {
  315|      0|                write!(output, "va_end({})", self.place_to_string(ap))?;
  316|       |            }
  317|      0|            MirStmt::BuiltinVaCopy(dst, src) => {
  318|      0|                write!(
  319|      0|                    output,
  320|      0|                    "va_copy({}, {})",
  321|      0|                    self.place_to_string(dst),
  322|      0|                    self.place_to_string(src)
  323|      0|                )?;
  324|       |            }
  325|       |        }
  326|    100|        Ok(())
  327|    100|    }
  328|       |
  329|       |    /// Dump a terminator
  330|    110|    fn dump_terminator(&self, output: &mut String, terminator: &Terminator) -> Result<(), std::fmt::Error> {
  331|    110|        match terminator {
  332|     27|            Terminator::Goto(block_id) => {
  333|     27|                write!(output, "br {}", self.block_to_string(*block_id))?;
                                                                                      ^0
  334|       |            }
  335|     15|            Terminator::If(cond, then_block, else_block) => {
  336|     15|                write!(
  337|     15|                    output,
  338|     15|                    "cond_br {}, {}, {}",
  339|     15|                    self.operand_to_string(cond),
  340|     15|                    self.block_to_string(*then_block),
  341|     15|                    self.block_to_string(*else_block)
  342|      0|                )?;
  343|       |            }
  344|     66|            Terminator::Return(operand) => match operand {
  345|     64|                Some(op) => {
  346|     64|                    write!(output, "return ")?;
                                                           ^0
  347|     64|                    self.dump_operand(output, op)?;
                                                               ^0
  348|       |                }
  349|       |                None => {
  350|      2|                    write!(output, "return")?;
                                                          ^0
  351|       |                }
  352|       |            },
  353|       |            Terminator::Unreachable => {
  354|      2|                write!(output, "unreachable")?;
                                                           ^0
  355|       |            }
  356|       |        }
  357|    110|        Ok(())
  358|    110|    }
  359|       |
  360|       |    /// Convert MIR type to string representation
  361|    245|    fn type_to_string(&self, type_id: TypeId) -> String {
  362|    245|        if let Some(mir_type) = self.sema_output.types.get(&type_id) {
  363|    245|            let type_index = self.get_type_index_from_type_id(type_id);
  364|       |
  365|    245|            match mir_type {
  366|     14|                MirType::Void => "void".to_string(),
  367|      0|                MirType::Bool => "bool".to_string(),
  368|       |
  369|     22|                MirType::I8 => "i8".to_string(),
  370|      2|                MirType::I16 => "i16".to_string(),
  371|    126|                MirType::I32 => "i32".to_string(),
  372|     10|                MirType::I64 => "i64".to_string(),
  373|      2|                MirType::U8 => "u8".to_string(),
  374|      2|                MirType::U16 => "u16".to_string(),
  375|      2|                MirType::U32 => "u32".to_string(),
  376|      4|                MirType::U64 => "u64".to_string(),
  377|      2|                MirType::F32 => "f32".to_string(),
  378|      1|                MirType::F64 => "f64".to_string(),
  379|     31|                MirType::Pointer { pointee } => {
  380|     31|                    let pointee_type = self.type_to_string(*pointee);
  381|     31|                    format!("ptr<{}>", pointee_type)
  382|       |                }
  383|     13|                MirType::Array { element, size, .. } => {
  384|     13|                    let elem_type = self.type_to_string(*element);
  385|     13|                    format!("[{}]{}", size, elem_type)
  386|       |                }
  387|       |                MirType::Function {
  388|      1|                    return_type,
  389|      1|                    params,
  390|      1|                    is_variadic,
  391|       |                } => {
  392|      1|                    let ret_type = self.type_to_string(*return_type);
  393|      1|                    let mut param_types: Vec<String> = params.iter().map(|&p| self.type_to_string(p)).collect();
                                                                                            ^0   ^0             ^0
  394|      1|                    if *is_variadic {
  395|      0|                        param_types.push("...".to_string());
  396|      1|                    }
  397|      1|                    format!("fn({}) -> {}", param_types.join(", "), ret_type)
  398|       |                }
  399|       |                MirType::Record { .. } => {
  400|       |                    // For aggregate types, use the type ID to keep output concise
  401|     13|                    format!("%t{}", type_index)
  402|       |                }
  403|       |            }
  404|       |        } else {
  405|      0|            format!("unknown_type_{}", type_id.get())
  406|       |        }
  407|    245|    }
  408|       |
  409|       |    /// Convert local ID to string representation
  410|    228|    fn local_to_string(&self, local_id: LocalId) -> String {
  411|    228|        let local = self.sema_output.locals.get(&local_id);
  412|    228|        let name = match local {
  413|    228|            Some(local) => {
  414|    228|                if let Some(name) = &local.name {
                                          ^123
  415|    123|                    format!("{}", name)
  416|       |                } else {
  417|    105|                    format!("{}", local.id.get())
  418|       |                }
  419|       |            }
  420|      0|            None => format!("{}", local_id.get()),
  421|       |        };
  422|       |
  423|    228|        format!("%{}", name)
  424|    228|    }
  425|       |
  426|       |    /// Convert global ID to string representation
  427|     15|    fn global_to_string(&self, global_id: GlobalId) -> String {
  428|     15|        if let Some(global) = self.sema_output.globals.get(&global_id) {
  429|     15|            format!("@{}", global.name)
  430|       |        } else {
  431|      0|            format!("@global_{}", global_id.get())
  432|       |        }
  433|     15|    }
  434|       |
  435|       |    /// Convert block ID to string representation
  436|    167|    fn block_to_string(&self, block_id: MirBlockId) -> String {
  437|    167|        format!("bb{}", block_id.get())
  438|    167|    }
  439|       |
  440|       |    /// Convert function ID to string representation
  441|     21|    fn function_to_string(&self, func_id: MirFunctionId) -> String {
  442|     21|        if let Some(func) = self.sema_output.functions.get(&func_id) {
  443|     21|            format!("{}", func.name)
  444|       |        } else {
  445|      0|            format!("func_{}", func_id.get())
  446|       |        }
  447|     21|    }
  448|       |
  449|       |    /// Convert call target to string representation
  450|     20|    fn call_target_to_string(&self, call_target: &CallTarget) -> String {
  451|     20|        match call_target {
  452|     19|            CallTarget::Direct(func_id) => self.function_to_string(*func_id),
  453|      1|            CallTarget::Indirect(operand) => format!("*{}", self.operand_to_string(operand)),
  454|       |        }
  455|     20|    }
  456|       |
  457|       |    /// Try to format a constant as a string literal if applicable
  458|     24|    fn try_format_as_string_literal(&self, global_name: &str, const_id: ConstValueId) -> Option<String> {
  459|       |        // Only format as string if the global name starts with .L.str (our anonymous string literals)
  460|     24|        if !global_name.starts_with(".L.str") {
  461|     19|            return None;
  462|      5|        }
  463|       |
  464|      5|        if let Some(const_value) = self.sema_output.constants.get(&const_id)
  465|      5|            && let ConstValueKind::ArrayLiteral(elements) = &const_value.kind
  466|       |        {
  467|       |            // Try to convert the array elements to a string
  468|      5|            let mut string_content = String::new();
  469|       |
  470|     46|            for &element_id in elements {
  471|     46|                let element = self.sema_output.constants.get(&element_id).unwrap();
  472|     46|                if let ConstValueKind::Int(byte) = &element.kind {
  473|     46|                    let byte = *byte as u8;
  474|     46|                    if byte == 0 {
  475|       |                        // Null terminator - end of string
  476|      5|                        break;
  477|     41|                    }
  478|       |
  479|     39|                    match byte {
  480|      2|                        b'\n' => string_content.push_str("\\n"),
  481|      0|                        b'\r' => string_content.push_str("\\r"),
  482|      0|                        b'\t' => string_content.push_str("\\t"),
  483|      0|                        b'\\' => string_content.push_str("\\\\"),
  484|      0|                        b'"' => string_content.push_str("\\\""),
  485|     39|                        b if (32..=126).contains(&b) => string_content.push(b as char),
  486|       |                        _ => {
  487|       |                            // Use hex escape for other non-printable characters
  488|       |                            use std::fmt::Write;
  489|      0|                            write!(&mut string_content, "\\x{:02x}", byte).ok()?;
  490|       |                        }
  491|       |                    }
  492|       |                } else {
  493|       |                    // Non-integer element, not a string
  494|      0|                    return None;
  495|       |                }
  496|       |            }
  497|       |
  498|      5|            if !string_content.is_empty() {
  499|      5|                return Some(format!("const \"{}\"", string_content));
  500|      0|            }
  501|      0|        }
  502|       |
  503|      0|        None
  504|     24|    }
  505|       |
  506|       |    /// Convert constant ID to string representation
  507|    172|    fn const_to_string(&self, const_id: ConstValueId) -> String {
  508|    172|        if let Some(const_value) = self.sema_output.constants.get(&const_id) {
  509|    172|            match &const_value.kind {
  510|    136|                ConstValueKind::Int(val) => format!("const {}", val),
  511|      2|                ConstValueKind::Float(val) => format!("const {}", val),
  512|      0|                ConstValueKind::Bool(val) => format!("const {}", val),
  513|      0|                ConstValueKind::Null => "const null".to_string(),
  514|     13|                ConstValueKind::Zero => "const zero".to_string(),
  515|      7|                ConstValueKind::StructLiteral(fields) => {
  516|       |                    // Expand struct literal to show field contents
  517|      7|                    let field_strs: Vec<String> = fields
  518|      7|                        .iter()
  519|     16|                        .map(|(field_idx, field_const_id)| {
                                       ^7
  520|     16|                            let field_const_str = self.const_to_string(*field_const_id);
  521|     16|                            format!("{}: {}", field_idx, field_const_str)
  522|     16|                        })
  523|      7|                        .collect();
  524|      7|                    format!("const struct_literal {{ {} }}", field_strs.join(", "))
  525|       |                }
  526|      6|                ConstValueKind::ArrayLiteral(elements) => {
  527|       |                    // Expand array literal to show element contents
  528|      6|                    let element_strs: Vec<String> = elements
  529|      6|                        .iter()
  530|     30|                        .map(|element_const_id| self.const_to_string(*element_const_id))
                                       ^6
  531|      6|                        .collect();
  532|      6|                    format!("const array_literal [{}]", element_strs.join(", "))
  533|       |                }
  534|      6|                ConstValueKind::GlobalAddress(global_id) => {
  535|      6|                    format!("const {}", self.global_to_string(*global_id))
  536|       |                }
  537|      2|                &ConstValueKind::FunctionAddress(func_id) => {
  538|      2|                    format!("const {}", self.function_to_string(func_id))
  539|       |                }
  540|       |            }
  541|       |        } else {
  542|      0|            format!("const unknown_{}", const_id.get())
  543|       |        }
  544|    172|    }
  545|       |
  546|       |    /// Convert place to string representation
  547|    217|    fn place_to_string(&self, place: &Place) -> String {
  548|    217|        match place {
  549|    162|            Place::Local(local_id) => self.local_to_string(*local_id),
  550|     11|            Place::Deref(operand) => format!("deref({})", self.operand_to_string(operand)),
  551|      9|            Place::Global(global_id) => self.global_to_string(*global_id),
  552|     31|            Place::StructField(base_place, field_idx) => {
  553|     31|                format!("{}.field_{}", self.place_to_string(base_place), field_idx)
  554|       |            }
  555|      4|            Place::ArrayIndex(base_place, index) => {
  556|      4|                format!(
  557|      4|                    "{}[{}]",
  558|      4|                    self.place_to_string(base_place),
  559|      4|                    self.operand_to_string(index)
  560|       |                )
  561|       |            }
  562|       |        }
  563|    217|    }
  564|       |
  565|       |    /// Convert operand to string representation
  566|    242|    fn operand_to_string(&self, operand: &Operand) -> String {
  567|    242|        match operand {
  568|     92|            Operand::Copy(place) => self.place_to_string(place),
  569|    107|            Operand::Constant(const_id) => self.const_to_string(*const_id),
  570|      4|            Operand::AddressOf(place) => {
  571|      4|                format!("addr_of({})", self.place_to_string(place))
  572|       |            }
  573|     39|            Operand::Cast(type_id, operand) => {
  574|     39|                format!(
  575|     39|                    "cast<{}>({})",
  576|     39|                    self.type_to_string(*type_id),
  577|     39|                    self.operand_to_string(operand)
  578|       |                )
  579|       |            }
  580|       |        }
  581|    242|    }
  582|       |
  583|       |    /// Dump an operand (for use in statements)
  584|    132|    fn dump_operand(&self, output: &mut String, operand: &Operand) -> Result<(), std::fmt::Error> {
  585|    132|        write!(output, "{}", self.operand_to_string(operand))?;
                                                                           ^0
  586|    132|        Ok(())
  587|    132|    }
  588|       |
  589|       |    /// Dump an rvalue (for use in assignments)
  590|     80|    fn dump_rvalue(&self, output: &mut String, rvalue: &Rvalue) -> Result<(), std::fmt::Error> {
  591|     80|        match rvalue {
  592|     60|            Rvalue::Use(operand) => {
  593|     60|                self.dump_operand(output, operand)?;
                                                                ^0
  594|       |            }
  595|     20|            Rvalue::BinaryIntOp(op, left, right) => {
  596|     20|                write!(
  597|     20|                    output,
  598|     20|                    "{} {} {}",
  599|     20|                    self.operand_to_string(left),
  600|     20|                    self.binary_int_op_to_string(op),
  601|     20|                    self.operand_to_string(right)
  602|      0|                )?;
  603|       |            }
  604|      0|            Rvalue::BinaryFloatOp(op, left, right) => {
  605|      0|                write!(
  606|      0|                    output,
  607|      0|                    "{} {} {}",
  608|      0|                    self.operand_to_string(left),
  609|      0|                    self.binary_float_op_to_string(op),
  610|      0|                    self.operand_to_string(right)
  611|      0|                )?;
  612|       |            }
  613|      0|            Rvalue::UnaryIntOp(op, operand) => {
  614|      0|                write!(
  615|      0|                    output,
  616|      0|                    "{} {}",
  617|      0|                    self.unary_int_op_to_string(op),
  618|      0|                    self.operand_to_string(operand)
  619|      0|                )?;
  620|       |            }
  621|      0|            Rvalue::UnaryFloatOp(op, operand) => {
  622|      0|                write!(
  623|      0|                    output,
  624|      0|                    "{} {}",
  625|      0|                    self.unary_float_op_to_string(op),
  626|      0|                    self.operand_to_string(operand)
  627|      0|                )?;
  628|       |            }
  629|      0|            Rvalue::Cast(type_id, operand) => {
  630|      0|                write!(
  631|      0|                    output,
  632|      0|                    "cast<{}>({})",
  633|      0|                    self.type_to_string(*type_id),
  634|      0|                    self.operand_to_string(operand)
  635|      0|                )?;
  636|       |            }
  637|      0|            Rvalue::PtrAdd(base, offset) => {
  638|      0|                write!(
  639|      0|                    output,
  640|      0|                    "ptradd({}, {})",
  641|      0|                    self.operand_to_string(base),
  642|      0|                    self.operand_to_string(offset)
  643|      0|                )?;
  644|       |            }
  645|      0|            Rvalue::PtrSub(base, offset) => {
  646|      0|                write!(
  647|      0|                    output,
  648|      0|                    "ptrsub({}, {})",
  649|      0|                    self.operand_to_string(base),
  650|      0|                    self.operand_to_string(offset)
  651|      0|                )?;
  652|       |            }
  653|      0|            Rvalue::PtrDiff(left, right) => {
  654|      0|                write!(
  655|      0|                    output,
  656|      0|                    "ptrdiff({}, {})",
  657|      0|                    self.operand_to_string(left),
  658|      0|                    self.operand_to_string(right)
  659|      0|                )?;
  660|       |            }
  661|      0|            Rvalue::StructLiteral(fields) => {
  662|      0|                write!(output, "struct{{")?;
  663|      0|                for (i, (idx, op)) in fields.iter().enumerate() {
  664|      0|                    if i > 0 {
  665|      0|                        write!(output, ", ")?;
  666|      0|                    }
  667|      0|                    write!(output, "{}: {}", idx, self.operand_to_string(op))?;
  668|       |                }
  669|      0|                write!(output, "}}")?;
  670|       |            }
  671|      0|            Rvalue::ArrayLiteral(elements) => {
  672|      0|                write!(output, "[")?;
  673|      0|                for (i, op) in elements.iter().enumerate() {
  674|      0|                    if i > 0 {
  675|      0|                        write!(output, ", ")?;
  676|      0|                    }
  677|      0|                    write!(output, "{}", self.operand_to_string(op))?;
  678|       |                }
  679|      0|                write!(output, "]")?;
  680|       |            }
  681|      0|            Rvalue::Load(operand) => {
  682|      0|                write!(output, "load {}", self.operand_to_string(operand))?;
  683|       |            }
  684|       |
  685|      0|            Rvalue::BuiltinVaArg(ap, ty) => {
  686|      0|                write!(
  687|      0|                    output,
  688|      0|                    "va_arg({}, {})",
  689|      0|                    self.place_to_string(ap),
  690|      0|                    self.type_to_string(*ty)
  691|      0|                )?;
  692|       |            }
  693|       |        }
  694|     80|        Ok(())
  695|     80|    }
  696|       |
  697|       |    /// Convert integer binary operation to string representation
  698|     20|    fn binary_int_op_to_string(&self, op: &BinaryIntOp) -> String {
  699|     20|        match op {
  700|      8|            BinaryIntOp::Add => "+".to_string(),
  701|      4|            BinaryIntOp::Sub => "-".to_string(),
  702|      0|            BinaryIntOp::Mul => "*".to_string(),
  703|      0|            BinaryIntOp::Div => "/".to_string(),
  704|      0|            BinaryIntOp::Mod => "%".to_string(),
  705|      0|            BinaryIntOp::BitAnd => "&".to_string(),
  706|      0|            BinaryIntOp::BitOr => "|".to_string(),
  707|      0|            BinaryIntOp::BitXor => "^".to_string(),
  708|      0|            BinaryIntOp::LShift => "<<".to_string(),
  709|      0|            BinaryIntOp::RShift => ">>".to_string(),
  710|      1|            BinaryIntOp::Eq => "==".to_string(),
  711|      6|            BinaryIntOp::Ne => "!=".to_string(),
  712|      0|            BinaryIntOp::Lt => "<".to_string(),
  713|      0|            BinaryIntOp::Le => "<=".to_string(),
  714|      1|            BinaryIntOp::Gt => ">".to_string(),
  715|      0|            BinaryIntOp::Ge => ">=".to_string(),
  716|       |        }
  717|     20|    }
  718|       |
  719|       |    /// Convert floating-point binary operation to string representation
  720|      0|    fn binary_float_op_to_string(&self, op: &BinaryFloatOp) -> String {
  721|      0|        match op {
  722|      0|            BinaryFloatOp::Add => "fadd".to_string(),
  723|      0|            BinaryFloatOp::Sub => "fsub".to_string(),
  724|      0|            BinaryFloatOp::Mul => "fmul".to_string(),
  725|      0|            BinaryFloatOp::Div => "fdiv".to_string(),
  726|      0|            BinaryFloatOp::Eq => "feq".to_string(),
  727|      0|            BinaryFloatOp::Ne => "fne".to_string(),
  728|      0|            BinaryFloatOp::Lt => "flt".to_string(),
  729|      0|            BinaryFloatOp::Le => "fle".to_string(),
  730|      0|            BinaryFloatOp::Gt => "fgt".to_string(),
  731|      0|            BinaryFloatOp::Ge => "fge".to_string(),
  732|       |        }
  733|      0|    }
  734|       |
  735|       |    /// Convert integer unary operation to string representation
  736|      0|    fn unary_int_op_to_string(&self, op: &UnaryIntOp) -> String {
  737|      0|        match op {
  738|      0|            UnaryIntOp::Neg => "-".to_string(),
  739|      0|            UnaryIntOp::LogicalNot => "!".to_string(),
  740|      0|            UnaryIntOp::BitwiseNot => "~".to_string(),
  741|       |        }
  742|      0|    }
  743|       |
  744|       |    /// Convert floating-point unary operation to string representation
  745|      0|    fn unary_float_op_to_string(&self, op: &UnaryFloatOp) -> String {
  746|      0|        match op {
  747|      0|            UnaryFloatOp::Neg => "fneg".to_string(),
  748|       |        }
  749|      0|    }
  750|       |}

/app/src/mir/validation.rs:
    1|       |//! MIR Validation Pass
    2|       |//!
    3|       |//! This module implements a validation pass that ensures MIR is well-formed
    4|       |//! and ready for code generation. The validation pass checks:
    5|       |//! - All locals have types
    6|       |//! - All blocks end with a Terminator
    7|       |//! - No illegal operations remain
    8|       |//! - MIR is Cranelift-safe
    9|       |
   10|       |use crate::{
   11|       |    mir::MirProgram,
   12|       |    mir::{
   13|       |        BinaryFloatOp, BinaryIntOp, CallTarget, ConstValue, ConstValueId, ConstValueKind, GlobalId, LocalId,
   14|       |        MirBlockId, MirFunction, MirFunctionId, MirFunctionKind, MirModule, MirStmt, MirType, Operand, Place, Rvalue,
   15|       |        Terminator, TypeId, UnaryFloatOp, UnaryIntOp,
   16|       |    },
   17|       |};
   18|       |
   19|       |/// MIR Validation Error
   20|       |#[derive(Debug, PartialEq, Clone)]
   21|       |pub enum ValidationError {
   22|       |    /// Local variable is missing a type
   23|       |    LocalMissingType(LocalId),
   24|       |    /// Illegal operation found in MIR
   25|       |    IllegalOperation(String),
   26|       |    /// Type not found in type table
   27|       |    TypeNotFound(TypeId),
   28|       |    /// Local not found in local table
   29|       |    LocalNotFound(LocalId),
   30|       |    /// Global not found in global table
   31|       |    GlobalNotFound(GlobalId),
   32|       |    /// Function not found in function table
   33|       |    FunctionNotFound(MirFunctionId),
   34|       |    /// Block not found in block table
   35|       |    BlockNotFound(MirBlockId),
   36|       |    /// Invalid pointer arithmetic operation
   37|       |    InvalidPointerArithmetic,
   38|       |    /// Invalid cast operation
   39|       |    InvalidCast(TypeId, TypeId),
   40|       |    /// Function call argument type mismatch
   41|       |    FunctionCallArgTypeMismatch {
   42|       |        func_name: String,
   43|       |        arg_index: usize,
   44|       |        expected_type: TypeId,
   45|       |        actual_type: TypeId,
   46|       |    },
   47|       |    /// Constant value is out of range for its type
   48|       |    ConstantValueOutOfRange {
   49|       |        const_id: ConstValueId,
   50|       |        value: i64,
   51|       |        type_id: TypeId,
   52|       |    },
   53|       |}
   54|       |
   55|       |impl std::fmt::Display for ValidationError {
   56|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   57|      0|        match self {
   58|      0|            ValidationError::LocalMissingType(local_id) => write!(f, "Local {} is missing a type", local_id.get()),
   59|      0|            ValidationError::IllegalOperation(op) => write!(f, "Illegal operation: {}", op),
   60|      0|            ValidationError::TypeNotFound(type_id) => write!(f, "Type {} not found", type_id.get()),
   61|      0|            ValidationError::LocalNotFound(local_id) => write!(f, "Local {} not found", local_id.get()),
   62|      0|            ValidationError::GlobalNotFound(global_id) => write!(f, "Global {} not found", global_id.get()),
   63|      0|            ValidationError::FunctionNotFound(func_id) => write!(f, "Function {} not found", func_id.get()),
   64|      0|            ValidationError::BlockNotFound(block_id) => write!(f, "Block {} not found", block_id.get()),
   65|      0|            ValidationError::InvalidPointerArithmetic => write!(f, "Invalid pointer arithmetic operation"),
   66|      0|            ValidationError::InvalidCast(from, to) => {
   67|      0|                write!(f, "Invalid cast from type {} to type {}", from.get(), to.get())
   68|       |            }
   69|       |            ValidationError::FunctionCallArgTypeMismatch {
   70|      0|                func_name,
   71|      0|                arg_index,
   72|      0|                expected_type,
   73|      0|                actual_type,
   74|       |            } => {
   75|      0|                write!(
   76|      0|                    f,
   77|      0|                    "Function '{}' argument {} type mismatch: expected type {}, got type {}",
   78|       |                    func_name,
   79|       |                    arg_index,
   80|      0|                    expected_type.get(),
   81|      0|                    actual_type.get()
   82|       |                )
   83|       |            }
   84|       |            ValidationError::ConstantValueOutOfRange {
   85|      0|                const_id,
   86|      0|                value,
   87|      0|                type_id,
   88|       |            } => {
   89|      0|                write!(
   90|      0|                    f,
   91|      0|                    "Constant {} value {} is out of range for type {}",
   92|      0|                    const_id.get(),
   93|       |                    value,
   94|      0|                    type_id.get()
   95|       |                )
   96|       |            }
   97|       |        }
   98|      0|    }
   99|       |}
  100|       |
  101|       |/// MIR Validation Pass
  102|       |///
  103|       |/// This pass validates that MIR is well-formed and ready for code generation.
  104|       |/// It performs comprehensive checks but does not modify the MIR.
  105|       |#[derive(Default)]
  106|       |pub struct MirValidator {
  107|       |    errors: Vec<ValidationError>,
  108|       |}
  109|       |
  110|       |impl MirValidator {
  111|       |    /// Create a new MIR validator
  112|     22|    pub(crate) fn new() -> Self {
  113|     22|        Self { errors: Vec::new() }
  114|     22|    }
  115|       |
  116|       |    /// Validate a MIR module
  117|       |    ///
  118|       |    /// Returns Ok(()) if validation passes, or Err(Vec<ValidationError>) if errors are found
  119|     22|    pub(crate) fn validate(&mut self, sema_output: &MirProgram) -> Result<(), Vec<ValidationError>> {
  120|       |        // eprintln!("VALIDATE: Starting validation");
  121|     22|        self.errors.clear();
  122|       |
  123|       |        // Validate the module structure
  124|     22|        self.validate_module(&sema_output.module);
  125|       |
  126|       |        // Validate each function
  127|     46|        for func_id in &sema_output.module.functions {
                          ^24
  128|     24|            if let Some(func) = sema_output.functions.get(func_id) {
  129|     24|                self.validate_function(sema_output, func);
  130|     24|            } else {
  131|      0|                self.errors.push(ValidationError::FunctionNotFound(*func_id));
  132|      0|            }
  133|       |        }
  134|       |
  135|       |        // Validate each global
  136|     32|        for global_id in &sema_output.module.globals {
                          ^10
  137|     10|            if sema_output.globals.get(global_id).is_none() {
  138|      0|                self.errors.push(ValidationError::GlobalNotFound(*global_id));
  139|     10|            }
  140|       |        }
  141|       |
  142|       |        // Validate each type - module.types is a Vec<Type>, not HashMap<TypeId, Type>
  143|       |        // So we validate that each type in the module is accessible via the types HashMap
  144|     60|        for (index, _) in sema_output.module.types.iter().enumerate() {
                                        ^22                             ^22
  145|     60|            let type_id = TypeId::new((index + 1) as u32).unwrap(); // Types are 1-indexed
  146|     60|            if !sema_output.types.contains_key(&type_id) {
  147|      0|                self.errors.push(ValidationError::TypeNotFound(type_id));
  148|     60|            }
  149|       |        }
  150|       |
  151|     22|        if self.errors.is_empty() {
  152|     22|            Ok(())
  153|       |        } else {
  154|      0|            Err(self.errors.clone())
  155|       |        }
  156|     22|    }
  157|       |
  158|       |    /// Validate module structure
  159|     22|    fn validate_module(&mut self, module: &MirModule) {
  160|       |        // Module must have a valid ID
  161|     22|        if module.id.get() == 0 {
  162|      0|            self.errors
  163|      0|                .push(ValidationError::IllegalOperation("Module ID cannot be 0".to_string()));
  164|     22|        }
  165|     22|    }
  166|       |
  167|       |    /// Validate that a constant value can be cast to the target type
  168|     46|    fn validate_constant_cast(
  169|     46|        &mut self,
  170|     46|        sema_output: &MirProgram,
  171|     46|        const_id: ConstValueId,
  172|     46|        const_value: &ConstValue,
  173|     46|        target_type_id: TypeId,
  174|     46|    ) {
  175|       |        // eprintln!(
  176|       |        //     "VALIDATING CAST: const {} value {:?} to type {:?}",
  177|       |        //     const_id.get(),
  178|       |        //     const_value,
  179|       |        //     target_type_id.get()
  180|       |        // );
  181|     46|        if let Some(target_ty) = sema_output.types.get(&target_type_id) {
  182|     46|            match (&const_value.kind, target_ty) {
  183|      1|                (ConstValueKind::Int(value), MirType::I8) | (ConstValueKind::Int(value), MirType::U8) => {
                                                   ^0
  184|       |                    // Allow both signed range [-128, 127] and unsigned range [0, 255]
  185|      1|                    if *value < -128 || *value > 255 {
  186|      0|                        self.errors.push(ValidationError::ConstantValueOutOfRange {
  187|      0|                            const_id,
  188|      0|                            value: *value,
  189|      0|                            type_id: target_type_id,
  190|      0|                        });
  191|      1|                    }
  192|       |                }
  193|      1|                (ConstValueKind::Int(value), MirType::I16) | (ConstValueKind::Int(value), MirType::U16) => {
                                                                                                ^0
  194|       |                    // Allow both signed range [-32768, 32767] and unsigned range [0, 65535]
  195|      1|                    if *value < -32768 || *value > 65535 {
  196|      0|                        self.errors.push(ValidationError::ConstantValueOutOfRange {
  197|      0|                            const_id,
  198|      0|                            value: *value,
  199|      0|                            type_id: target_type_id,
  200|      0|                        });
  201|      1|                    }
  202|       |                }
  203|     20|                (ConstValueKind::Int(value), MirType::I32) | (ConstValueKind::Int(value), MirType::U32) => {
                                                                                                ^2
  204|       |                    // Allow both signed range [-2147483648, 2147483647] and unsigned range [0, 4294967295]
  205|     22|                    if *value < -2147483648 || *value > 4294967295 {
  206|      0|                        self.errors.push(ValidationError::ConstantValueOutOfRange {
  207|      0|                            const_id,
  208|      0|                            value: *value,
  209|      0|                            type_id: target_type_id,
  210|      0|                        });
  211|     22|                    }
  212|       |                }
  213|     16|                (ConstValueKind::Int(_value), MirType::I64) | (ConstValueKind::Int(_value), MirType::U64) => {
                                                   ^1                                            ^15
  214|     16|                    // i64/u64 can hold any i64 value in our representation
  215|     16|                }
  216|      0|                (ConstValueKind::Int(value), MirType::Bool) => {
  217|      0|                    if *value != 0 && *value != 1 {
  218|      0|                        self.errors.push(ValidationError::ConstantValueOutOfRange {
  219|      0|                            const_id,
  220|      0|                            value: *value,
  221|      0|                            type_id: target_type_id,
  222|      0|                        });
  223|      0|                    }
  224|       |                }
  225|       |                // For other types or kinds, no validation needed
  226|      6|                _ => {}
  227|       |            }
  228|      0|        }
  229|     46|    }
  230|       |
  231|       |    /// Validate a function
  232|     24|    fn validate_function(&mut self, sema_output: &MirProgram, func: &MirFunction) {
  233|       |        // Function must have a valid ID
  234|     24|        if func.id.get() == 0 {
  235|      0|            self.errors
  236|      0|                .push(ValidationError::IllegalOperation("Function ID cannot be 0".to_string()));
  237|     24|        }
  238|       |
  239|       |        // Function must have a name
  240|     24|        if func.name.as_str().is_empty() {
  241|      0|            self.errors.push(ValidationError::IllegalOperation(
  242|      0|                "Function name cannot be empty".to_string(),
  243|      0|            ));
  244|     24|        }
  245|       |
  246|       |        // Function must have a valid return type
  247|     24|        if func.return_type.get() == 0 {
  248|      0|            self.errors.push(ValidationError::IllegalOperation(
  249|      0|                "Function return type cannot be 0".to_string(),
  250|      0|            ));
  251|     24|        } else if !sema_output.types.contains_key(&func.return_type) {
  252|      0|            self.errors.push(ValidationError::TypeNotFound(func.return_type));
  253|     24|        }
  254|       |
  255|       |        // Validate all parameters
  256|     26|        for param_id in &func.params {
                          ^2
  257|      2|            if !sema_output.locals.contains_key(param_id) {
  258|      0|                self.errors.push(ValidationError::LocalNotFound(*param_id));
  259|      2|            }
  260|       |        }
  261|       |
  262|       |        // Validate all locals
  263|     99|        for local_id in &func.locals {
                          ^75
  264|     75|            if !sema_output.locals.contains_key(local_id) {
  265|      0|                self.errors.push(ValidationError::LocalNotFound(*local_id));
  266|     75|            }
  267|       |        }
  268|       |
  269|       |        // Validate all blocks
  270|    139|        for block_id in &func.blocks {
                          ^115
  271|    115|            if !sema_output.blocks.contains_key(block_id) {
  272|      0|                self.errors.push(ValidationError::BlockNotFound(*block_id));
  273|    115|            }
  274|       |        }
  275|       |
  276|       |        // Entry block must exist for defined functions
  277|     24|        if let Some(entry_block) = func.entry_block
                                  ^23
  278|     23|            && !sema_output.blocks.contains_key(&entry_block)
  279|      0|        {
  280|      0|            self.errors.push(ValidationError::BlockNotFound(entry_block));
  281|     24|        }
  282|       |        // Extern functions don't need entry blocks
  283|       |        // Validate statements within blocks for defined functions
  284|     24|        if func.kind == MirFunctionKind::Defined {
  285|    138|            for block_id in &func.blocks {
                              ^115
  286|    115|                if let Some(block) = sema_output.blocks.get(block_id) {
  287|    208|                    for stmt_id in &block.statements {
                                      ^93
  288|     93|                        if let Some(stmt) = sema_output.statements.get(stmt_id) {
  289|     93|                            self.validate_statement(sema_output, stmt);
  290|     93|                        } else {
  291|      0|                            self.errors.push(ValidationError::IllegalOperation(format!(
  292|      0|                                "Statement {} not found",
  293|      0|                                stmt_id.get()
  294|      0|                            )));
  295|      0|                        }
  296|       |                    }
  297|    115|                    self.validate_terminator(sema_output, &block.terminator);
  298|      0|                }
  299|       |            }
  300|      1|        }
  301|     24|    }
  302|       |
  303|     93|    fn validate_statement(&mut self, sema_output: &MirProgram, stmt: &MirStmt) {
  304|     93|        match stmt {
  305|     92|            MirStmt::Assign(place, rvalue) => {
  306|     92|                let place_ty = self.validate_place(sema_output, place);
  307|     92|                let rval_ty = self.validate_rvalue(sema_output, rvalue);
  308|     92|                if let (Some(from), Some(to)) = (rval_ty, place_ty)
                                           ^41         ^41
  309|     41|                    && from != to
  310|       |                {
  311|       |                    // Special case for operations that can return multiple types (bool or int)
  312|      9|                    let is_flexible = match rvalue {
                                                          ^0
  313|      0|                        Rvalue::UnaryIntOp(UnaryIntOp::LogicalNot, _) => true,
  314|      9|                        Rvalue::BinaryIntOp(bin, _, _) => matches!(
                                                                        ^0
  315|      9|                            bin,
  316|       |                            BinaryIntOp::Eq
  317|       |                                | BinaryIntOp::Ne
  318|       |                                | BinaryIntOp::Lt
  319|       |                                | BinaryIntOp::Le
  320|       |                                | BinaryIntOp::Gt
  321|       |                                | BinaryIntOp::Ge
  322|       |                        ),
  323|      0|                        Rvalue::BinaryFloatOp(bin, _, _) => matches!(
  324|      0|                            bin,
  325|       |                            BinaryFloatOp::Eq
  326|       |                                | BinaryFloatOp::Ne
  327|       |                                | BinaryFloatOp::Lt
  328|       |                                | BinaryFloatOp::Le
  329|       |                                | BinaryFloatOp::Gt
  330|       |                                | BinaryFloatOp::Ge
  331|       |                        ),
  332|      0|                        _ => false,
  333|       |                    };
  334|       |
  335|      9|                    if is_flexible {
  336|      9|                        let _bool_ty = self.find_bool_type(sema_output);
  337|     18|                        let is_bool_or_int = |tid: TypeId| {
                                          ^9
  338|     18|                            if let Some(ty) = sema_output.types.get(&tid) {
  339|     18|                                ty.is_int()
  340|       |                            } else {
  341|      0|                                false
  342|       |                            }
  343|     18|                        };
  344|       |
  345|      9|                        if is_bool_or_int(from) && is_bool_or_int(to) {
  346|       |                            // Allowed for these flexible operations
  347|      9|                            return;
  348|      0|                        }
  349|      0|                    }
  350|       |
  351|      0|                    if !are_types_compatible(sema_output, from, to) {
  352|      0|                        self.errors.push(ValidationError::InvalidCast(from, to));
  353|      0|                    }
  354|     83|                }
  355|       |            }
  356|      0|            MirStmt::Store(op, place) => {
  357|      0|                let op_ty = self.validate_operand(sema_output, op);
  358|      0|                let place_ty = self.validate_place(sema_output, place);
  359|      0|                if let (Some(from), Some(to)) = (op_ty, place_ty)
  360|      0|                    && from != to
  361|      0|                    && !are_types_compatible(sema_output, from, to)
  362|      0|                {
  363|      0|                    self.errors.push(ValidationError::InvalidCast(from, to));
  364|      0|                }
  365|       |            }
  366|      1|            MirStmt::Call { target, args, dest } => {
  367|      1|                self.validate_call_target(sema_output, target);
  368|      4|                for a in args {
                                  ^3
  369|      3|                    self.validate_operand(sema_output, a);
  370|      3|                }
  371|      1|                if let Some(dest_place) = dest {
                                          ^0
  372|      0|                    self.validate_place(sema_output, dest_place);
  373|      1|                }
  374|       |                // Validate argument types against function signature when possible
  375|      1|                match target {
  376|      0|                    CallTarget::Direct(fid) => {
  377|      0|                        if let Some(func) = sema_output.functions.get(fid) {
  378|       |                            // use param locals to get their types
  379|      0|                            if func.params.len() != args.len() && !func.is_variadic {
  380|      0|                                self.errors.push(ValidationError::IllegalOperation(format!(
  381|      0|                                    "Call to function {} arg count mismatch",
  382|      0|                                    fid.get()
  383|      0|                                )));
  384|      0|                            } else {
  385|      0|                                for (i, arg) in args.iter().enumerate().take(func.params.len()) {
  386|      0|                                    let param_id = func.params[i];
  387|      0|                                    if let Some(param) = sema_output.locals.get(&param_id)
  388|      0|                                        && let Some(arg_ty) = self.validate_operand(sema_output, arg)
  389|      0|                                        && arg_ty != param.type_id
  390|      0|                                    {
  391|      0|                                        self.errors.push(ValidationError::FunctionCallArgTypeMismatch {
  392|      0|                                            func_name: func.name.to_string(),
  393|      0|                                            arg_index: i,
  394|      0|                                            expected_type: param.type_id,
  395|      0|                                            actual_type: arg_ty,
  396|      0|                                        });
  397|      0|                                    }
  398|       |                                }
  399|       |                            }
  400|       |                            // Validate return type if dest is present
  401|      0|                            if let Some(dest_place) = dest {
  402|      0|                                let dest_ty = self.validate_place(sema_output, dest_place);
  403|      0|                                if dest_ty.is_some()
  404|      0|                                    && let Some(func_ret_ty) = sema_output.types.get(&func.return_type)
  405|      0|                                    && matches!(func_ret_ty, MirType::Void)
  406|      0|                                {
  407|      0|                                    self.errors.push(ValidationError::IllegalOperation(format!(
  408|      0|                                        "Call to void function {} with destination",
  409|      0|                                        fid.get()
  410|      0|                                    )));
  411|      0|                                }
  412|       |                            } else {
  413|       |                                // If no dest, function should return void
  414|      0|                                if let Some(func_ret_ty) = sema_output.types.get(&func.return_type)
  415|      0|                                    && !matches!(func_ret_ty, MirType::Void)
  416|      0|                                {
  417|      0|                                    // Allow ignoring non-void returns (common in C)
  418|      0|                                }
  419|       |                            }
  420|      0|                        }
  421|       |                    }
  422|      1|                    CallTarget::Indirect(op) => {
  423|      1|                        if let Some(op_ty) = self.validate_operand(sema_output, op)
  424|      1|                            && let Some(MirType::Pointer { pointee }) = sema_output.types.get(&op_ty)
  425|       |                            && let Some(MirType::Function {
  426|      1|                                params,
  427|      1|                                return_type,
  428|      1|                                is_variadic,
  429|      1|                            }) = sema_output.types.get(pointee)
  430|       |                        {
  431|      1|                            if (*is_variadic && args.len() < params.len())
  432|      1|                                || (!*is_variadic && args.len() != params.len())
                                                                   ^0   ^0
  433|      0|                            {
  434|      0|                                self.errors.push(ValidationError::IllegalOperation(
  435|      0|                                    "Indirect call argument count mismatch".to_string(),
  436|      0|                                ));
  437|      0|                            } else {
  438|      3|                                for (i, arg) in args.iter().enumerate() {
                                                              ^1          ^1
  439|      3|                                    if i < params.len() {
  440|      1|                                        if let Some(arg_ty) = self.validate_operand(sema_output, arg)
                                                                  ^0
  441|      0|                                            && arg_ty != params[i]
  442|      0|                                        {
  443|      0|                                            self.errors.push(ValidationError::FunctionCallArgTypeMismatch {
  444|      0|                                                func_name: "indirect function".to_string(),
  445|      0|                                                arg_index: i,
  446|      0|                                                expected_type: params[i],
  447|      0|                                                actual_type: arg_ty,
  448|      0|                                            });
  449|      1|                                        }
  450|      2|                                    } else {
  451|      2|                                        // Variadic arguments, just validate they exist
  452|      2|                                        self.validate_operand(sema_output, arg);
  453|      2|                                    }
  454|       |                                }
  455|       |                            }
  456|       |                            // Validate return type if dest is present
  457|      1|                            if let Some(dest_place) = dest {
                                                      ^0
  458|      0|                                let dest_ty = self.validate_place(sema_output, dest_place);
  459|      0|                                if dest_ty.is_some()
  460|      0|                                    && let Some(func_ret_ty) = sema_output.types.get(return_type)
  461|      0|                                    && matches!(func_ret_ty, MirType::Void)
  462|      0|                                {
  463|      0|                                    self.errors.push(ValidationError::IllegalOperation(
  464|      0|                                        "Call to void function via indirect call with destination".to_string(),
  465|      0|                                    ));
  466|      0|                                }
  467|      1|                            }
  468|      0|                        }
  469|       |                    }
  470|       |                }
  471|       |            }
  472|      0|            MirStmt::Alloc(place, type_id) => {
  473|      0|                self.validate_place(sema_output, place);
  474|      0|                if !sema_output.types.contains_key(type_id) {
  475|      0|                    self.errors.push(ValidationError::TypeNotFound(*type_id));
  476|      0|                }
  477|       |            }
  478|      0|            MirStmt::Dealloc(op) => {
  479|      0|                self.validate_operand(sema_output, op);
  480|      0|            }
  481|      0|            MirStmt::BuiltinVaStart(ap, last) => {
  482|      0|                self.validate_place(sema_output, ap);
  483|      0|                self.validate_operand(sema_output, last);
  484|      0|            }
  485|      0|            MirStmt::BuiltinVaEnd(ap) => {
  486|      0|                self.validate_place(sema_output, ap);
  487|      0|            }
  488|      0|            MirStmt::BuiltinVaCopy(dst, src) => {
  489|      0|                self.validate_place(sema_output, dst);
  490|      0|                self.validate_place(sema_output, src);
  491|      0|            }
  492|       |        }
  493|     93|    }
  494|       |
  495|    222|    fn validate_place(&mut self, sema_output: &MirProgram, place: &Place) -> Option<TypeId> {
  496|    222|        match place {
  497|    185|            Place::Local(local_id) => {
  498|    185|                if let Some(local) = sema_output.locals.get(local_id) {
  499|    185|                    Some(local.type_id)
  500|       |                } else {
  501|      0|                    self.errors.push(ValidationError::LocalNotFound(*local_id));
  502|      0|                    None
  503|       |                }
  504|       |            }
  505|      3|            Place::Deref(op) => {
  506|      3|                self.validate_operand(sema_output, op);
  507|       |                // try to infer pointer pointee type
  508|      3|                if let Some(op_ty) = self.operand_type(sema_output, op) {
  509|      3|                    if let Some(MirType::Pointer { pointee }) = sema_output.types.get(&op_ty) {
  510|      3|                        Some(*pointee)
  511|       |                    } else {
  512|       |                        // Not a pointer - deref of non-pointer
  513|      0|                        self.errors.push(ValidationError::IllegalOperation(
  514|      0|                            "Deref of non-pointer operand".to_string(),
  515|      0|                        ));
  516|      0|                        None
  517|       |                    }
  518|       |                } else {
  519|      0|                    None
  520|       |                }
  521|       |            }
  522|      8|            Place::Global(gid) => {
  523|      8|                if let Some(g) = sema_output.globals.get(gid) {
  524|      8|                    Some(g.type_id)
  525|       |                } else {
  526|      0|                    self.errors.push(ValidationError::GlobalNotFound(*gid));
  527|      0|                    None
  528|       |                }
  529|       |            }
  530|     12|            Place::StructField(base, idx) => {
  531|     12|                if let Some(base_ty) = self.validate_place(sema_output, base) {
  532|     12|                    if let Some(MirType::Record { field_types, .. }) = sema_output.types.get(&base_ty) {
  533|     12|                        if *idx < field_types.len() {
  534|     12|                            Some(field_types[*idx])
  535|       |                        } else {
  536|      0|                            self.errors.push(ValidationError::IllegalOperation(format!(
  537|      0|                                "Struct field index {} out of bounds",
  538|      0|                                idx
  539|      0|                            )));
  540|      0|                            None
  541|       |                        }
  542|       |                    } else {
  543|      0|                        self.errors.push(ValidationError::IllegalOperation(
  544|      0|                            "Struct field access on non-record type".to_string(),
  545|      0|                        ));
  546|      0|                        None
  547|       |                    }
  548|       |                } else {
  549|      0|                    None
  550|       |                }
  551|       |            }
  552|     14|            Place::ArrayIndex(base, _idx_op) => {
  553|       |                // validate base place and index operand
  554|     14|                let _ = self.validate_place(sema_output, base);
  555|       |                // index operand may be complex; index operand validation is handled where used
  556|     14|                None
  557|       |            }
  558|       |        }
  559|    222|    }
  560|       |
  561|    290|    fn validate_operand(&mut self, sema_output: &MirProgram, op: &Operand) -> Option<TypeId> {
  562|    290|        match op {
  563|     99|            Operand::Copy(place) => self.validate_place(sema_output, place),
  564|    124|            Operand::Constant(cid) => {
  565|    124|                if sema_output.constants.get(cid).is_none() {
  566|      0|                    self.errors.push(ValidationError::IllegalOperation(format!(
  567|      0|                        "Constant {} not found",
  568|      0|                        cid.get()
  569|      0|                    )));
  570|    124|                }
  571|    124|                None
  572|       |            }
  573|      5|            Operand::AddressOf(place) => {
  574|      5|                if let Some(base_ty) = self.validate_place(sema_output, place) {
                                          ^1
  575|       |                    // create or lookup a pointer type for base_ty is non-trivial; try to find existing pointer type
  576|      2|                    for (tid, ty) in &sema_output.types {
  577|      2|                        if let MirType::Pointer { pointee } = ty
                                                                ^1
  578|      1|                            && *pointee == base_ty
  579|       |                        {
  580|      1|                            return Some(*tid);
  581|      1|                        }
  582|       |                    }
  583|      0|                    None
  584|       |                } else {
  585|      4|                    None
  586|       |                }
  587|       |            }
  588|     62|            Operand::Cast(type_id, inner) => {
  589|     62|                if !sema_output.types.contains_key(type_id) {
  590|      0|                    self.errors.push(ValidationError::TypeNotFound(*type_id));
  591|     62|                }
  592|       |                // Check if casting a constant value that doesn't fit in the target type
  593|     62|                if let Operand::Constant(const_id) = inner.as_ref()
                                                       ^46
  594|     46|                    && let Some(const_value) = sema_output.constants.get(const_id)
  595|     46|                {
  596|     46|                    self.validate_constant_cast(sema_output, *const_id, const_value, *type_id);
  597|     46|                }
                              ^16
  598|     62|                self.validate_operand(sema_output, inner);
  599|     62|                Some(*type_id)
  600|       |            }
  601|       |        }
  602|    290|    }
  603|       |
  604|     92|    fn validate_rvalue(&mut self, sema_output: &MirProgram, r: &Rvalue) -> Option<TypeId> {
  605|     92|        match r {
  606|     46|            Rvalue::Use(op) => self.validate_operand(sema_output, op),
  607|     39|            Rvalue::BinaryIntOp(bin, a, b) => {
  608|     39|                let ta = self.validate_operand(sema_output, a);
  609|     39|                let tb = self.validate_operand(sema_output, b);
  610|       |
  611|     39|                match bin {
  612|       |                    BinaryIntOp::Eq
  613|       |                    | BinaryIntOp::Ne
  614|       |                    | BinaryIntOp::Lt
  615|       |                    | BinaryIntOp::Le
  616|       |                    | BinaryIntOp::Gt
  617|     28|                    | BinaryIntOp::Ge => self.find_bool_type(sema_output),
  618|       |                    _ => {
  619|     11|                        if let (Some(ta), Some(tb)) = (ta, tb)
                                                   ^6        ^6
  620|      6|                            && ta != tb
  621|      0|                        {
  622|      0|                            // We could emit a warning or handle implicit promotions here if MIR allowed it,
  623|      0|                            // but MIR should be explicit. For now just return ta.
  624|     11|                        }
  625|     11|                        ta
  626|       |                    }
  627|       |                }
  628|       |            }
  629|      0|            Rvalue::BinaryFloatOp(bin, a, b) => {
  630|      0|                let ta = self.validate_operand(sema_output, a);
  631|      0|                let _tb = self.validate_operand(sema_output, b);
  632|       |
  633|      0|                match bin {
  634|       |                    BinaryFloatOp::Eq
  635|       |                    | BinaryFloatOp::Ne
  636|       |                    | BinaryFloatOp::Lt
  637|       |                    | BinaryFloatOp::Le
  638|       |                    | BinaryFloatOp::Gt
  639|      0|                    | BinaryFloatOp::Ge => self.find_bool_type(sema_output),
  640|      0|                    _ => ta,
  641|       |                }
  642|       |            }
  643|      3|            Rvalue::UnaryIntOp(u, a) => {
  644|      3|                let ta = self.validate_operand(sema_output, a);
  645|      3|                match u {
  646|      0|                    UnaryIntOp::Neg => ta,
  647|      0|                    UnaryIntOp::BitwiseNot => ta,
  648|      3|                    UnaryIntOp::LogicalNot => self.find_bool_type(sema_output),
  649|       |                }
  650|       |            }
  651|      0|            Rvalue::UnaryFloatOp(u, a) => {
  652|      0|                let ta = self.validate_operand(sema_output, a);
  653|      0|                match u {
  654|      0|                    UnaryFloatOp::Neg => ta,
  655|       |                }
  656|       |            }
  657|      0|            Rvalue::Cast(type_id, op) => {
  658|      0|                if !sema_output.types.contains_key(type_id) {
  659|      0|                    self.errors.push(ValidationError::TypeNotFound(*type_id));
  660|      0|                }
  661|      0|                let from_ty = self.validate_operand(sema_output, op);
  662|      0|                if let (Some(from), true) = (from_ty, sema_output.types.contains_key(type_id)) {
  663|       |                    // basic invalid cast check: disallow casts from record/array/enum/function to non-pointer/scalar types
  664|      0|                    if let Some(ty) = sema_output.types.get(&from)
  665|      0|                        && ty.is_aggregate()
  666|       |                    {
  667|      0|                        if let Some(MirType::Pointer { .. }) = sema_output.types.get(type_id) {
  668|      0|                            // pointer casts allowed
  669|      0|                            // pointer casts allowed
  670|      0|                        } else {
  671|      0|                            let type_obj = sema_output.types.get(type_id).unwrap();
  672|      0|                            if type_obj.is_int() || type_obj.is_float() {
  673|      0|                                self.errors.push(ValidationError::InvalidCast(from, *type_id));
  674|      0|                            }
  675|       |                        }
  676|      0|                    }
  677|      0|                }
  678|      0|                Some(*type_id)
  679|       |            }
  680|      1|            Rvalue::PtrAdd(a, b) | Rvalue::PtrSub(a, b) => {
  681|      2|                self.validate_operand(sema_output, a);
  682|      2|                self.validate_operand(sema_output, b);
  683|      2|                None
  684|       |            }
  685|      0|            Rvalue::PtrDiff(a, b) => {
  686|      0|                self.validate_operand(sema_output, a);
  687|      0|                self.validate_operand(sema_output, b);
  688|      0|                None
  689|       |            }
  690|      1|            Rvalue::StructLiteral(fields) => {
  691|      3|                for (_idx, op) in fields {
                                   ^2    ^2
  692|      2|                    self.validate_operand(sema_output, op);
  693|      2|                }
  694|      1|                None
  695|       |            }
  696|      1|            Rvalue::ArrayLiteral(elems) => {
  697|      3|                for e in elems {
                                  ^2
  698|      2|                    self.validate_operand(sema_output, e);
  699|      2|                }
  700|      1|                None
  701|       |            }
  702|      0|            Rvalue::Load(op) => {
  703|      0|                self.validate_operand(sema_output, op);
  704|      0|                None
  705|       |            }
  706|       |
  707|      0|            Rvalue::BuiltinVaArg(ap, type_id) => {
  708|      0|                self.validate_place(sema_output, ap);
  709|      0|                if !sema_output.types.contains_key(type_id) {
  710|      0|                    self.errors.push(ValidationError::TypeNotFound(*type_id));
  711|      0|                }
  712|      0|                Some(*type_id)
  713|       |            }
  714|       |        }
  715|     92|    }
  716|       |
  717|      1|    fn validate_call_target(&mut self, sema_output: &MirProgram, target: &CallTarget) {
  718|      1|        match target {
  719|      0|            CallTarget::Direct(fid) => {
  720|      0|                if sema_output.functions.get(fid).is_none() {
  721|      0|                    self.errors.push(ValidationError::FunctionNotFound(*fid));
  722|      0|                }
  723|       |            }
  724|      1|            CallTarget::Indirect(op) => {
  725|      1|                self.validate_operand(sema_output, op);
  726|      1|            }
  727|       |        }
  728|      1|    }
  729|       |
  730|      3|    fn operand_type(&mut self, sema_output: &MirProgram, op: &Operand) -> Option<TypeId> {
  731|      3|        self.validate_operand(sema_output, op)
  732|      3|    }
  733|    115|    fn validate_terminator(&mut self, sema_output: &MirProgram, term: &Terminator) {
  734|    115|        match term {
  735|     36|            Terminator::Goto(bid) => {
  736|     36|                if !sema_output.blocks.contains_key(bid) {
  737|      0|                    self.errors.push(ValidationError::BlockNotFound(*bid));
  738|     36|                }
  739|       |            }
  740|     32|            Terminator::If(cond, then_bb, else_bb) => {
  741|     32|                self.validate_operand(sema_output, cond);
  742|     32|                if !sema_output.blocks.contains_key(then_bb) {
  743|      0|                    self.errors.push(ValidationError::BlockNotFound(*then_bb));
  744|     32|                }
  745|     32|                if !sema_output.blocks.contains_key(else_bb) {
  746|      0|                    self.errors.push(ValidationError::BlockNotFound(*else_bb));
  747|     32|                }
  748|       |            }
  749|     47|            Terminator::Return(op) => {
  750|     47|                if let Some(op) = op {
  751|     47|                    self.validate_operand(sema_output, op);
  752|     47|                }
                              ^0
  753|       |            }
  754|      0|            Terminator::Unreachable => {}
  755|       |        }
  756|    115|    }
  757|       |
  758|     40|    fn find_bool_type(&self, sema_output: &MirProgram) -> Option<TypeId> {
  759|    147|        for (id, ty) in &sema_output.types {
                           ^128^128
  760|    128|            if matches!(ty, MirType::Bool) {
                             ^107
  761|     21|                return Some(*id);
  762|    107|            }
  763|       |        }
  764|     19|        None
  765|     40|    }
  766|       |}
  767|       |
  768|      0|fn are_types_compatible(sema_output: &MirProgram, t1: TypeId, t2: TypeId) -> bool {
  769|      0|    if t1 == t2 {
  770|      0|        return true;
  771|      0|    }
  772|      0|    let ty1 = sema_output.types.get(&t1);
  773|      0|    let ty2 = sema_output.types.get(&t2);
  774|       |
  775|      0|    if let (Some(type1), Some(type2)) = (ty1, ty2) {
  776|      0|        match (type1, type2) {
  777|      0|            (MirType::Pointer { pointee: p1 }, MirType::Pointer { pointee: p2 }) => {
  778|      0|                are_types_compatible(sema_output, *p1, *p2)
  779|       |            }
  780|       |            (
  781|       |                MirType::Array {
  782|      0|                    element: e1, size: s1, ..
  783|       |                },
  784|       |                MirType::Array {
  785|      0|                    element: e2, size: s2, ..
  786|       |                },
  787|      0|            ) => s1 == s2 && are_types_compatible(sema_output, *e1, *e2),
  788|       |            (
  789|       |                MirType::Function {
  790|      0|                    return_type: r1,
  791|      0|                    params: pm1,
  792|      0|                    is_variadic: v1,
  793|       |                },
  794|       |                MirType::Function {
  795|      0|                    return_type: r2,
  796|      0|                    params: pm2,
  797|      0|                    is_variadic: v2,
  798|       |                },
  799|       |            ) => {
  800|      0|                if v1 != v2 {
  801|      0|                    return false;
  802|      0|                }
  803|      0|                if pm1.len() != pm2.len() {
  804|      0|                    return false;
  805|      0|                }
  806|      0|                are_types_compatible(sema_output, *r1, *r2)
  807|      0|                    && pm1
  808|      0|                        .iter()
  809|      0|                        .zip(pm2.iter())
  810|      0|                        .all(|(a, b)| are_types_compatible(sema_output, *a, *b))
  811|       |            }
  812|      0|            _ => type1 == type2,
  813|       |        }
  814|       |    } else {
  815|      0|        false
  816|       |    }
  817|      0|}

/app/src/parser.rs:
    1|       |//! Parser module for C11 compiler
    2|       |//!
    3|       |//! This module provides the main parser coordination, public API, and state management.
    4|       |//! It orchestrates the parsing process by delegating to specialized sub-modules for
    5|       |//! different language constructs.
    6|       |
    7|       |use crate::ast::*;
    8|       |use crate::diagnostic::{DiagnosticEngine, ParseError};
    9|       |use crate::lexer::{Token, TokenKind};
   10|       |use crate::source_manager::{SourceLoc, SourceSpan};
   11|       |use log::debug;
   12|       |use std::collections::HashSet;
   13|       |
   14|       |pub mod declaration_core;
   15|       |pub mod declarations;
   16|       |pub mod declarator;
   17|       |pub mod enum_parsing;
   18|       |pub mod expressions;
   19|       |pub mod parsed_type_builder;
   20|       |pub mod statements;
   21|       |pub mod struct_parsing;
   22|       |pub mod type_specifiers;
   23|       |pub mod utils;
   24|       |
   25|       |// Re-export commonly used types
   26|       |pub(crate) use expressions::BindingPower;
   27|       |
   28|       |use expressions::parse_expression;
   29|       |
   30|       |/// Type context for tracking typedef names and other type-related state
   31|       |#[derive(Debug)]
   32|       |pub(crate) struct TypeDefContext {
   33|       |    /// Set of typedef names for disambiguation
   34|       |    typedef_names: HashSet<NameId>,
   35|       |}
   36|       |
   37|       |impl Default for TypeDefContext {
   38|      0|    fn default() -> Self {
   39|      0|        Self::new()
   40|      0|    }
   41|       |}
   42|       |
   43|       |impl TypeDefContext {
   44|       |    /// Create a new type context with builtin typedefs
   45|    466|    pub(crate) fn new() -> Self {
   46|    466|        let mut typedef_names = HashSet::new();
   47|       |        // Add builtin typedefs
   48|    466|        typedef_names.insert(NameId::new("va_list"));
   49|    466|        typedef_names.insert(NameId::new("size_t"));
   50|    466|        typedef_names.insert(NameId::new("ptrdiff_t"));
   51|    466|        typedef_names.insert(NameId::new("int8_t"));
   52|    466|        typedef_names.insert(NameId::new("int16_t"));
   53|    466|        typedef_names.insert(NameId::new("int32_t"));
   54|    466|        typedef_names.insert(NameId::new("int64_t"));
   55|    466|        typedef_names.insert(NameId::new("uint8_t"));
   56|    466|        typedef_names.insert(NameId::new("uint16_t"));
   57|    466|        typedef_names.insert(NameId::new("uint32_t"));
   58|    466|        typedef_names.insert(NameId::new("uint64_t"));
   59|    466|        typedef_names.insert(NameId::new("intptr_t"));
   60|    466|        typedef_names.insert(NameId::new("uintptr_t"));
   61|       |
   62|    466|        TypeDefContext { typedef_names }
   63|    466|    }
   64|       |
   65|       |    /// Check if a symbol is a typedef name
   66|  1.33k|    pub(crate) fn is_type_name(&self, symbol: NameId) -> bool {
   67|  1.33k|        let result = self.typedef_names.contains(&symbol);
   68|  1.33k|        debug!("is_type_name({:?}) = {}", symbol, result);
                             ^0
   69|  1.33k|        result
   70|  1.33k|    }
   71|       |
   72|       |    /// Add a typedef name
   73|     13|    pub(crate) fn add_typedef(&mut self, symbol: NameId) {
   74|     13|        self.typedef_names.insert(symbol);
   75|     13|    }
   76|       |}
   77|       |
   78|       |#[derive(Debug, Clone)]
   79|       |pub(crate) struct ParserState {
   80|       |    current_idx: usize,
   81|       |    diag_len: usize,
   82|       |}
   83|       |
   84|       |/// Main parser structure
   85|       |pub struct Parser<'arena, 'src> {
   86|       |    tokens: &'src [Token],
   87|       |    current_idx: usize,
   88|       |    ast: &'arena mut ParsedAst,
   89|       |    diag: &'src mut DiagnosticEngine,
   90|       |
   91|       |    // Type context for typedef tracking
   92|       |    type_context: TypeDefContext,
   93|       |}
   94|       |
   95|       |impl<'arena, 'src> Parser<'arena, 'src> {
   96|       |    /// Create a new parser
   97|    466|    pub fn new(tokens: &'src [Token], ast: &'arena mut ParsedAst, diag: &'src mut DiagnosticEngine) -> Self {
   98|    466|        Parser {
   99|    466|            tokens,
  100|    466|            current_idx: 0,
  101|    466|            ast,
  102|    466|            diag,
  103|    466|            type_context: TypeDefContext::new(),
  104|    466|        }
  105|    466|    }
  106|       |
  107|       |    /// Get the current token (returns None if at end of input)
  108|  43.3k|    fn try_current_token(&self) -> Option<Token> {
  109|  43.3k|        self.tokens.get(self.current_idx).cloned()
  110|  43.3k|    }
  111|       |
  112|       |    /// Get the current token (returns error if at end of input)
  113|  8.85k|    fn current_token(&self) -> Result<Token, ParseError> {
  114|  8.85k|        self.try_current_token().ok_or_else(|| {
                                                             ^0
  115|      0|            let prev = self.tokens.get(self.current_idx - 1);
  116|      0|            let span = match prev {
  117|      0|                Some(token) => token.span,
  118|      0|                None => SourceSpan::empty(),
  119|       |            };
  120|      0|            ParseError::UnexpectedEof { span }
  121|      0|        })
  122|  8.85k|    }
  123|       |
  124|       |    /// Get the current token kind
  125|  21.0k|    fn current_token_kind(&self) -> Option<TokenKind> {
  126|  21.0k|        self.try_current_token().map(|t| t.kind)
  127|  21.0k|    }
  128|       |
  129|       |    /// Get the current token location
  130|  1.55k|    pub(crate) fn current_token_span(&self) -> Result<SourceSpan, ParseError> {
  131|  1.55k|        Ok(self.current_token()?.span)
                                             ^0
  132|  1.55k|    }
  133|       |
  134|       |    /// Get the current token location (infallible, returns empty span on EOF)
  135|    954|    pub(crate) fn current_token_span_or_empty(&self) -> SourceSpan {
  136|    954|        self.try_current_token().map(|t| t.span).unwrap_or_default()
  137|    954|    }
  138|       |
  139|       |    /// Get the location of the previous token, or an empty span if not available.
  140|      0|    pub(crate) fn previous_token_span(&self) -> SourceSpan {
  141|      0|        if self.current_idx > 0 {
  142|      0|            self.tokens
  143|      0|                .get(self.current_idx - 1)
  144|      0|                .map_or(SourceSpan::empty(), |token| token.span)
  145|       |        } else {
  146|      0|            SourceSpan::empty()
  147|       |        }
  148|      0|    }
  149|       |
  150|       |    /// Get the span of the last token (synonym for previous_token_span)
  151|  1.03k|    pub(crate) fn last_token_span(&self) -> Option<SourceSpan> {
  152|  1.03k|        if self.current_idx > 0 {
  153|  1.03k|            self.tokens.get(self.current_idx - 1).map(|token| token.span)
  154|       |        } else {
  155|      0|            None
  156|       |        }
  157|  1.03k|    }
  158|       |
  159|       |    /// Get the span of a token at a specific index
  160|     89|    pub(crate) fn get_token_span(&self, index: usize) -> Option<SourceSpan> {
  161|     89|        self.tokens.get(index).map(|token| token.span)
  162|     89|    }
  163|       |
  164|       |    /// Peek at the next token without consuming it
  165|    246|    fn peek_token(&self, next_index: u32) -> Option<&Token> {
  166|    246|        self.tokens.get(self.current_idx + 1 + next_index as usize)
  167|    246|    }
  168|       |
  169|       |    /// Advance to the next token and return previous token
  170|  11.5k|    fn advance(&mut self) -> Option<Token> {
  171|  11.5k|        if self.current_idx < self.tokens.len() {
  172|  11.5k|            let token = &self.tokens[self.current_idx];
  173|  11.5k|            self.current_idx += 1;
  174|  11.5k|            Some(*token)
  175|       |        } else {
  176|      0|            None
  177|       |        }
  178|  11.5k|    }
  179|       |
  180|       |    /// Accept a specific token kind if found, consume it and return it, otherwise nothing happens
  181|  12.5k|    fn accept(&mut self, accepted: TokenKind) -> Option<Token> {
  182|  12.5k|        if self.current_token_kind() == Some(accepted) {
  183|  2.32k|            self.advance()
  184|       |        } else {
  185|  10.2k|            None
  186|       |        }
  187|  12.5k|    }
  188|       |
  189|       |    /// Expect a specific token kind, consume it if found
  190|  3.49k|    fn expect(&mut self, expected: TokenKind) -> Result<Token, ParseError> {
  191|  3.49k|        let token = self.current_token()?;
                                                      ^0
  192|  3.49k|        if token.kind == expected {
  193|  3.49k|            self.advance();
  194|  3.49k|            Ok(token)
  195|       |        } else {
  196|      2|            Err(ParseError::UnexpectedToken {
  197|      2|                expected_tokens: format!("{:?}", expected),
  198|      2|                found: token.kind,
  199|      2|                span: token.span,
  200|      2|            })
  201|       |        }
  202|  3.49k|    }
  203|       |
  204|       |    /// Check if current token matches any of the given kinds
  205|    338|    fn matches(&self, kinds: &[TokenKind]) -> bool {
  206|    338|        self.current_token_kind().map(|k| kinds.contains(&k)).unwrap_or(false)
  207|    338|    }
  208|       |
  209|       |    /// Check if current token matches the given kind
  210|  7.34k|    fn is_token(&self, kind: TokenKind) -> bool {
  211|  7.34k|        self.current_token_kind() == Some(kind)
  212|  7.34k|    }
  213|       |
  214|       |    /// Skip tokens until we find a synchronization point
  215|      2|    fn synchronize(&mut self) {
  216|      2|        let mut brace_depth = 0;
  217|      2|        let mut paren_depth = 0;
  218|      2|        let mut any_advance = false;
  219|       |
  220|     10|        while let Some(token) = self.try_current_token() {
  221|     10|            match token.kind {
  222|      0|                TokenKind::LeftBrace => {
  223|      0|                    brace_depth += 1;
  224|      0|                    self.advance();
  225|      0|                    any_advance = true;
  226|      0|                }
  227|       |                TokenKind::RightBrace => {
  228|      0|                    brace_depth -= 1;
  229|      0|                    self.advance();
  230|      0|                    any_advance = true;
  231|      0|                    if brace_depth < 0 {
  232|      0|                        break; // Unmatched brace, stop here
  233|      0|                    }
  234|       |                }
  235|      0|                TokenKind::LeftParen => {
  236|      0|                    paren_depth += 1;
  237|      0|                    self.advance();
  238|      0|                    any_advance = true;
  239|      0|                }
  240|       |                TokenKind::RightParen => {
  241|      1|                    paren_depth -= 1;
  242|      1|                    self.advance();
  243|      1|                    any_advance = true;
  244|      1|                    if paren_depth < 0 {
  245|      1|                        break; // Unmatched paren, stop here
  246|      0|                    }
  247|       |                }
  248|       |                TokenKind::Semicolon => {
  249|      1|                    self.advance();
  250|      1|                    any_advance = true;
  251|      1|                    if brace_depth == 0 && paren_depth == 0 {
  252|      1|                        break;
  253|      0|                    }
  254|       |                }
  255|       |                TokenKind::EndOfFile => {
  256|      0|                    self.advance();
  257|      0|                    any_advance = true;
  258|      0|                    break;
  259|       |                }
  260|      8|                _ => {
  261|      8|                    self.advance();
  262|      8|                    any_advance = true;
  263|      8|                }
  264|       |            }
  265|       |        }
  266|       |
  267|       |        // If we didn't advance at all, force advance to avoid infinite loop
  268|      2|        if !any_advance {
  269|      0|            self.advance();
  270|      2|        }
  271|      2|    }
  272|       |
  273|       |    /// Main expression parsing using Pratt algorithm
  274|  1.96k|    pub(crate) fn parse_expression(
  275|  1.96k|        &mut self,
  276|  1.96k|        min_binding_power: expressions::BindingPower,
  277|  1.96k|    ) -> Result<ParsedNodeRef, ParseError> {
  278|  1.96k|        parse_expression(self, min_binding_power)
  279|  1.96k|    }
  280|       |
  281|       |    /// Private helper to parse an expression with a given binding power, ensuring it's not a declaration.
  282|  1.49k|    fn parse_expr_bp(&mut self, min_binding_power: BindingPower) -> Result<ParsedNodeRef, ParseError> {
  283|  1.49k|        self.parse_expression(min_binding_power)
  284|  1.49k|    }
  285|       |
  286|       |    /// Parse expression with minimum binding power
  287|    832|    pub(crate) fn parse_expr_min(&mut self) -> Result<ParsedNodeRef, ParseError> {
  288|    832|        self.parse_expr_bp(BindingPower::MIN)
  289|    832|    }
  290|       |
  291|       |    /// Parse expression up to assignment
  292|    549|    pub(crate) fn parse_expr_assignment(&mut self) -> Result<ParsedNodeRef, ParseError> {
  293|    549|        self.parse_expr_bp(BindingPower::ASSIGNMENT)
  294|    549|    }
  295|       |
  296|       |    /// Parse translation unit (top level)
  297|    363|    pub fn parse_translation_unit(&mut self) -> Result<ParsedNodeRef, ParseError> {
  298|    363|        declarations::parse_translation_unit(self)
  299|    363|    }
  300|       |
  301|       |    /// Check if current token starts an abstract declarator
  302|     42|    fn is_abstract_declarator_start(&self) -> bool {
  303|     42|        declarator::is_abstract_declarator_start(self)
  304|     42|    }
  305|       |
  306|       |    /// Extract the declared name from a declarator, if any
  307|     13|    fn get_declarator_name(&self, declarator: &crate::ast::parsed::ParsedDeclarator) -> Option<NameId> {
  308|     13|        declarator::get_declarator_name(declarator)
  309|     13|    }
  310|       |
  311|       |    /// Disambiguates between a type name and an identifier in ambiguous contexts.
  312|       |    /// This is crucial for parsing C's "declaration-specifier-list" vs "expression" ambiguity.
  313|  1.33k|    fn is_type_name(&self, symbol: NameId) -> bool {
  314|  1.33k|        self.type_context.is_type_name(symbol)
  315|  1.33k|    }
  316|       |
  317|       |    /// Check if a cast expression starts at the current position
  318|       |    /// This is called after consuming an opening parenthesis
  319|     27|    fn is_cast_expression_start(&self) -> bool {
  320|     27|        expressions::is_cast_expression_start(self)
  321|     27|    }
  322|       |
  323|       |    /// Check if the current token can start a type name.
  324|       |    /// This is a lightweight check used for disambiguation.
  325|     44|    pub(crate) fn is_type_name_start(&self) -> bool {
  326|     44|        if let Some(token) = self.try_current_token() {
  327|     44|            match token.kind {
  328|       |                // Basic type specifiers
  329|       |                TokenKind::Void
  330|       |                | TokenKind::Char
  331|       |                | TokenKind::Short
  332|       |                | TokenKind::Int
  333|       |                | TokenKind::Long
  334|       |                | TokenKind::Float
  335|       |                | TokenKind::Double
  336|       |                | TokenKind::Signed
  337|       |                | TokenKind::Unsigned
  338|       |                | TokenKind::Bool
  339|       |                | TokenKind::Complex
  340|       |                // Struct/union/enum specifiers
  341|       |                | TokenKind::Struct
  342|       |                | TokenKind::Union
  343|       |                | TokenKind::Enum
  344|       |                // Type qualifiers that can start a type name
  345|       |                | TokenKind::Const
  346|       |                | TokenKind::Volatile
  347|       |                | TokenKind::Restrict
  348|       |                | TokenKind::Atomic
  349|       |                // GCC attribute extension
  350|     18|                | TokenKind::Attribute => true,
  351|       |                // Check for typedef'd identifiers
  352|     14|                TokenKind::Identifier(symbol) => self.is_type_name(symbol),
  353|     12|                _ => false,
  354|       |            }
  355|       |        } else {
  356|      0|            false
  357|       |        }
  358|     44|    }
  359|       |
  360|       |    /// Parse cast expression given the already parsed type and right paren token
  361|     11|    fn parse_cast_expression_from_type_and_paren(
  362|     11|        &mut self,
  363|     11|        parsed_type: ParsedType,
  364|     11|        right_paren_token: Token,
  365|     11|    ) -> Result<ParsedNodeRef, ParseError> {
  366|     11|        expressions::parse_cast_expression_from_type_and_paren(self, parsed_type, right_paren_token)
  367|     11|    }
  368|       |
  369|       |    /// Parse compound literal given the type and start location
  370|      2|    fn parse_compound_literal_from_type_and_start(
  371|      2|        &mut self,
  372|      2|        parsed_type: ParsedType,
  373|      2|        start_loc: SourceLoc,
  374|      2|    ) -> Result<ParsedNodeRef, ParseError> {
  375|      2|        expressions::parse_compound_literal_from_type_and_start(self, parsed_type, start_loc)
  376|      2|    }
  377|       |
  378|       |    /// parse and accept an identifier name
  379|    148|    fn accept_name(&mut self) -> Option<NameId> {
  380|    148|        if let Some(token) = self.try_current_token()
  381|    148|            && let TokenKind::Identifier(symbol) = token.kind
                                                       ^142
  382|       |        {
  383|    142|            self.advance();
  384|    142|            return Some(symbol);
  385|      6|        }
  386|      6|        None
  387|    148|    }
  388|       |
  389|       |    /// expect and accept an identifier name, returning the symbol or error
  390|    146|    fn expect_name(&mut self) -> Result<(NameId, SourceSpan), ParseError> {
  391|    146|        let token = self.current_token()?;
                                                      ^0
  392|    146|        if let TokenKind::Identifier(symbol) = token.kind {
  393|    146|            self.advance();
  394|    146|            Ok((symbol, token.span))
  395|       |        } else {
  396|      0|            Err(ParseError::UnexpectedToken {
  397|      0|                expected_tokens: "identifier".to_string(),
  398|      0|                found: token.kind,
  399|      0|                span: token.span,
  400|      0|            })
  401|       |        }
  402|    146|    }
  403|       |
  404|       |    /// Add a typedef name to the type context
  405|     13|    pub(crate) fn add_typedef(&mut self, symbol: NameId) {
  406|     13|        debug!("add_typedef: adding {:?} to typedef_names", symbol);
                             ^0
  407|     13|        self.type_context.add_typedef(symbol);
  408|     13|    }
  409|       |
  410|  1.09k|    fn save_state(&self) -> ParserState {
  411|  1.09k|        ParserState {
  412|  1.09k|            current_idx: self.current_idx,
  413|  1.09k|            diag_len: self.diag.diagnostics.len(),
  414|  1.09k|        }
  415|  1.09k|    }
  416|       |
  417|    259|    fn restore_state(&mut self, state: ParserState) {
  418|    259|        self.current_idx = state.current_idx;
  419|    259|        self.diag.diagnostics.truncate(state.diag_len);
  420|    259|    }
  421|       |
  422|  1.09k|    pub(crate) fn start_transaction(&mut self) -> utils::ParserTransaction<'_, 'arena, 'src> {
  423|  1.09k|        utils::ParserTransaction::new(self)
  424|  1.09k|    }
  425|       |
  426|       |    /// Check if the current token can start a declaration
  427|    886|    pub(crate) fn starts_declaration(&self) -> bool {
  428|    886|        if let Some(token) = self.try_current_token() {
  429|    886|            let is_typedef = if let TokenKind::Identifier(symbol) = token.kind {
                                                                        ^193
  430|    193|                self.is_type_name(symbol)
  431|       |            } else {
  432|    693|                false
  433|       |            };
  434|    886|            token.kind.is_declaration_start(is_typedef)
  435|       |        } else {
  436|      0|            false
  437|       |        }
  438|    886|    }
  439|       |}
  440|       |
  441|       |/// contain functions related to AST nodes
  442|       |impl<'arena, 'src> Parser<'arena, 'src> {
  443|       |    /// Push a node to the AST and return its reference
  444|  5.26k|    pub(crate) fn push_node(&mut self, kind: ParsedNodeKind, span: SourceSpan) -> ParsedNodeRef {
  445|  5.26k|        self.ast.push_node(ParsedNode::new(kind, span))
  446|  5.26k|    }
  447|       |
  448|  2.11k|    pub(crate) fn push_dummy(&mut self) -> ParsedNodeRef {
  449|  2.11k|        self.push_node(ParsedNodeKind::Dummy, SourceSpan::empty())
  450|  2.11k|    }
  451|       |
  452|       |    /// Push a node to the AST and return its reference
  453|  1.77k|    pub(crate) fn replace_node(
  454|  1.77k|        &mut self,
  455|  1.77k|        old_ref: ParsedNodeRef,
  456|  1.77k|        kind: ParsedNodeKind,
  457|  1.77k|        span: SourceSpan,
  458|  1.77k|    ) -> ParsedNodeRef {
  459|  1.77k|        self.ast.replace_node(old_ref, ParsedNode::new(kind, span))
  460|  1.77k|    }
  461|       |}

/app/src/parser/declaration_core.rs:
    1|       |//! Core declaration parsing module
    2|       |//!
    3|       |//! This module handles the main declaration parsing logic, including
    4|       |//! declaration specifiers, initializers, and coordination between
    5|       |//! different declaration components.
    6|       |
    7|       |use crate::ast::SourceSpan;
    8|       |use crate::ast::nodes::FunctionSpecifier;
    9|       |use crate::ast::nodes::StorageClass;
   10|       |use crate::ast::nodes::TypeQualifier;
   11|       |// Import all parsed types to be sure
   12|       |use crate::ast::parsed::{
   13|       |    ParsedAlignmentSpecifier, ParsedDeclSpecifier, ParsedDesignatedInitializer, ParsedDesignator, ParsedNodeKind,
   14|       |    ParsedNodeRef, ParsedTypeSpecifier,
   15|       |};
   16|       |use crate::diagnostic::ParseError;
   17|       |use crate::lexer::TokenKind;
   18|       |use log::debug;
   19|       |use thin_vec::ThinVec;
   20|       |
   21|       |use super::Parser;
   22|       |
   23|       |/// Parse declaration specifiers
   24|  1.37k|pub(crate) fn parse_declaration_specifiers(parser: &mut Parser) -> Result<ThinVec<ParsedDeclSpecifier>, ParseError> {
   25|  1.37k|    let mut specifiers = ThinVec::new();
   26|  1.37k|    let mut has_type_specifier = false;
   27|  1.37k|    let start_idx = parser.current_idx;
   28|       |
   29|  1.37k|    debug!(
   30|      0|        "parse_declaration_specifiers: starting at position {}, token {:?}",
   31|       |        start_idx,
   32|      0|        parser.current_token_kind()
   33|       |    );
   34|       |
   35|  2.87k|    while let Some(token) = parser.try_current_token() {
   36|  2.87k|        debug!(
   37|      0|            "parse_declaration_specifiers: loop iteration at position {}, token {:?}",
   38|       |            parser.current_idx, token.kind
   39|       |        );
   40|  2.87k|        match token.kind {
   41|       |            // Storage class specifiers
   42|       |            TokenKind::Typedef
   43|       |            | TokenKind::Extern
   44|       |            | TokenKind::Static
   45|       |            | TokenKind::Auto
   46|       |            | TokenKind::Register
   47|       |            | TokenKind::ThreadLocal => {
   48|     20|                let storage_class = match token.kind {
   49|       |                    TokenKind::Typedef => {
   50|     13|                        debug!("Found Typedef token, setting storage_class Typedef");
                                             ^0
   51|     13|                        StorageClass::Typedef
   52|       |                    }
   53|      4|                    TokenKind::Extern => StorageClass::Extern,
   54|      3|                    TokenKind::Static => StorageClass::Static,
   55|      0|                    TokenKind::Auto => StorageClass::Auto,
   56|      0|                    TokenKind::Register => StorageClass::Register,
   57|      0|                    TokenKind::ThreadLocal => StorageClass::ThreadLocal,
   58|      0|                    _ => unreachable!(),
   59|       |                };
   60|     20|                parser.advance();
   61|     20|                specifiers.push(ParsedDeclSpecifier::StorageClass(storage_class));
   62|       |            }
   63|       |
   64|       |            // Type qualifiers
   65|       |            TokenKind::Const | TokenKind::Volatile | TokenKind::Restrict | TokenKind::Atomic => {
   66|     32|                let qualifier = match token.kind {
                                  ^29
   67|     25|                    TokenKind::Const => TypeQualifier::Const,
   68|      1|                    TokenKind::Volatile => TypeQualifier::Volatile,
   69|      1|                    TokenKind::Restrict => TypeQualifier::Restrict,
   70|       |                    TokenKind::Atomic => {
   71|      5|                        if parser.peek_token(0).is_some_and(|t| t.kind == TokenKind::LeftParen) {
   72|       |                            // This is the `_Atomic(type-name)` form.
   73|      3|                            parser.advance(); // consume `_Atomic`
   74|      3|                            parser.expect(TokenKind::LeftParen)?;
                                                                             ^0
   75|       |
   76|      3|                            let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                                                      ^0
   77|       |
   78|      3|                            parser.expect(TokenKind::RightParen)?;
                                                                              ^0
   79|      3|                            let type_specifier = ParsedTypeSpecifier::Atomic(parsed_type);
   80|      3|                            specifiers.push(ParsedDeclSpecifier::TypeSpecifier(type_specifier));
   81|      3|                            has_type_specifier = true;
   82|      3|                            continue;
   83|      2|                        }
   84|      2|                        TypeQualifier::Atomic
   85|       |                    }
   86|      0|                    _ => unreachable!(),
   87|       |                };
   88|     29|                parser.advance();
   89|     29|                specifiers.push(ParsedDeclSpecifier::TypeQualifier(qualifier));
   90|       |            }
   91|       |
   92|       |            // Function specifiers
   93|       |            TokenKind::Inline | TokenKind::Noreturn => {
   94|      5|                let func_spec = if token.kind == TokenKind::Inline {
   95|      0|                    FunctionSpecifier::Inline
   96|       |                } else {
   97|      5|                    FunctionSpecifier::Noreturn
   98|       |                };
   99|      5|                parser.advance();
  100|      5|                specifiers.push(ParsedDeclSpecifier::FunctionSpecifier(func_spec));
  101|       |            }
  102|       |
  103|       |            TokenKind::Attribute => {
  104|      1|                debug!("parse_declaration_specifiers: found __attribute__, parsing it");
                                     ^0
  105|      1|                if let Err(_e) = parse_attribute(parser) {
                                         ^0
  106|      0|                    // For now, ignore attribute parsing errors
  107|      1|                }
  108|      1|                specifiers.push(ParsedDeclSpecifier::Attribute);
  109|       |            }
  110|       |
  111|       |            // Type specifiers
  112|       |            TokenKind::Void
  113|       |            | TokenKind::Char
  114|       |            | TokenKind::Short
  115|       |            | TokenKind::Int
  116|       |            | TokenKind::Long
  117|       |            | TokenKind::Float
  118|       |            | TokenKind::Double
  119|       |            | TokenKind::Signed
  120|       |            | TokenKind::Unsigned
  121|       |            | TokenKind::Bool
  122|       |            | TokenKind::Complex
  123|       |            | TokenKind::Struct
  124|       |            | TokenKind::Union
  125|       |            | TokenKind::Enum => {
  126|  1.43k|                let type_specifier = super::type_specifiers::parse_type_specifier(parser)?;
                                                                                                       ^0
  127|  1.43k|                specifiers.push(ParsedDeclSpecifier::TypeSpecifier(type_specifier));
  128|  1.43k|                has_type_specifier = true;
  129|       |            }
  130|       |
  131|  1.12k|            TokenKind::Identifier(symbol) => {
  132|  1.12k|                debug!(
  133|      0|                    "parse_declaration_specifiers: found identifier {:?}, calling is_type_name, current position: {}",
  134|       |                    symbol, parser.current_idx
  135|       |                );
  136|  1.12k|                let is_type = parser.is_type_name(symbol);
  137|  1.12k|                debug!(
  138|      0|                    "parse_declaration_specifiers: is_type_name({:?}) = {}, has_type_specifier = {}",
  139|       |                    symbol, is_type, has_type_specifier
  140|       |                );
  141|  1.12k|                if is_type && !has_type_specifier {
                                            ^13
  142|      6|                    debug!(
  143|      0|                        "parse_declaration_specifiers: {:?} is a type name and no type specifier yet, parsing type specifier",
  144|       |                        symbol
  145|       |                    );
  146|      6|                    let type_specifier = super::type_specifiers::parse_type_specifier(parser)?;
                                      ^5                                                                   ^1
  147|      5|                    specifiers.push(ParsedDeclSpecifier::TypeSpecifier(type_specifier));
  148|      5|                    has_type_specifier = true;
  149|       |                } else {
  150|  1.11k|                    debug!(
  151|      0|                        "parse_declaration_specifiers: {:?} is not a type name or already have type specifier, breaking at position {}",
  152|       |                        symbol, parser.current_idx
  153|       |                    );
  154|  1.11k|                    break;
  155|       |                }
  156|       |            }
  157|       |
  158|       |            // Alignment specifier
  159|       |            TokenKind::Alignas => {
  160|      6|                parser.advance(); // consume _Alignas
  161|      6|                let alignment = if parser.accept(TokenKind::LeftParen).is_some() {
  162|      6|                    let next_token = parser.current_token()?;
                                                                         ^0
  163|       |
  164|      6|                    let is_type_start = if let TokenKind::Identifier(symbol) = next_token.kind {
                                                                                   ^0
  165|      0|                        parser.is_type_name(symbol)
  166|       |                    } else {
  167|      6|                        next_token.kind.is_declaration_specifier_start()
  168|       |                    };
  169|       |
  170|      6|                    if is_type_start {
  171|       |                        // _Alignas(type-name)
  172|      1|                        let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                                                  ^0
  173|      1|                        parser.expect(TokenKind::RightParen)?;
                                                                          ^0
  174|      1|                        ParsedAlignmentSpecifier::Type(parsed_type)
  175|       |                    } else {
  176|       |                        // _Alignas(constant-expression)
  177|      5|                        let expr = parser.parse_expr_min()?;
                                                                        ^0
  178|      5|                        parser.expect(TokenKind::RightParen)?;
                                                                          ^0
  179|      5|                        ParsedAlignmentSpecifier::Expr(expr)
  180|       |                    }
  181|       |                } else {
  182|      0|                    return Err(ParseError::UnexpectedToken {
  183|      0|                        expected_tokens: "'(' after _Alignas".to_string(),
  184|      0|                        found: token.kind,
  185|      0|                        span: token.span,
  186|      0|                    });
  187|       |                };
  188|       |
  189|      6|                specifiers.push(ParsedDeclSpecifier::AlignmentSpecifier(alignment));
  190|       |            }
  191|       |
  192|       |            _ => {
  193|    259|                debug!(
  194|      0|                    "parse_declaration_specifiers: token {:?} not recognized as declaration specifier, breaking at position {}",
  195|       |                    token.kind, parser.current_idx
  196|       |                );
  197|    259|                if let TokenKind::Identifier(symbol) = &token.kind {
                                                           ^0
  198|      0|                    debug!("parse_declaration_specifiers: unrecognized identifier: {:?}", symbol);
  199|    259|                }
  200|    259|                break;
  201|       |            }
  202|       |        }
  203|       |    }
  204|       |
  205|  1.37k|    debug!(
  206|      0|        "parse_declaration_specifiers: ending at position {}, specifiers len={}, found {} specifiers",
  207|       |        parser.current_idx,
  208|      0|        specifiers.len(),
  209|      0|        specifiers.len()
  210|       |    );
  211|       |
  212|  1.37k|    if specifiers.is_empty() {
  213|      1|        let current_token = parser.current_token()?;
                                                                ^0
  214|      1|        return Err(ParseError::UnexpectedToken {
  215|      1|            expected_tokens: "declaration specifiers".to_string(),
  216|      1|            found: current_token.kind,
  217|      1|            span: current_token.span,
  218|      1|        });
  219|  1.37k|    }
  220|       |
  221|  1.37k|    Ok(specifiers)
  222|  1.37k|}
  223|       |
  224|       |/// Parse initializer
  225|    432|pub(crate) fn parse_initializer(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  226|    432|    debug!(
  227|      0|        "parse_initializer: called at position {}, current token: {:?}",
  228|       |        parser.current_idx,
  229|      0|        parser.current_token_kind()
  230|       |    );
  231|    432|    let span = parser.current_token_span()?;
                                                        ^0
  232|       |
  233|    432|    if parser.accept(TokenKind::LeftBrace).is_some() {
  234|     67|        debug!("parse_initializer: found LeftBrace, parsing compound initializer");
                             ^0
  235|       |        // Compound initializer
  236|     67|        let mut initializers = Vec::new();
  237|       |
  238|    188|        while !parser.is_token(TokenKind::RightBrace) {
  239|       |            // Check if this is a designated initializer (starts with . or [)
  240|    188|            let is_designated = parser.matches(&[TokenKind::Dot, TokenKind::LeftBracket]);
  241|       |
  242|    188|            let initializer = if is_designated {
  243|       |                // Parse designated initializer
  244|     50|                parse_designated_initializer(parser)?
                                                                  ^0
  245|       |            } else {
  246|       |                // Parse regular initializer (expression or nested compound initializer)
  247|    138|                let expr_or_compound = if parser.is_token(TokenKind::LeftBrace) {
  248|       |                    // Nested compound initializer
  249|      2|                    parse_initializer(parser)?
                                                           ^0
  250|       |                } else {
  251|       |                    // Expression initializer - parse until comma or closing brace
  252|    136|                    parse_initializer_expression(parser)?
                                                                      ^0
  253|       |                };
  254|       |
  255|       |                // Wrap in ParsedDesignatedInitializer with empty designation
  256|    138|                ParsedDesignatedInitializer {
  257|    138|                    designation: Vec::new(),
  258|    138|                    initializer: expr_or_compound,
  259|    138|                }
  260|       |            };
  261|       |
  262|    188|            initializers.push(initializer);
  263|       |
  264|    188|            if parser.accept(TokenKind::Comma).is_none() {
  265|     67|                break;
  266|    121|            }
  267|       |        }
  268|       |
  269|     67|        let end_token = parser.expect(TokenKind::RightBrace)?;
                                                                          ^0
  270|     67|        let span = SourceSpan::new(span.start(), end_token.span.end());
  271|     67|        let initializer = parser.push_node(ParsedNodeKind::InitializerList(initializers), span);
  272|     67|        Ok(initializer)
  273|       |    } else {
  274|    365|        debug!(
  275|      0|            "parse_initializer: no LeftBrace found, current token: {:?}, trying expression initializer",
  276|      0|            parser.current_token_kind()
  277|       |        );
  278|       |        // Expression initializer - use simple parsing to avoid comma operators
  279|    365|        let node = parse_initializer_expression(parser)?;
                                                                     ^0
  280|    365|        Ok(node)
  281|       |    }
  282|    432|}
  283|       |
  284|       |/// Parse designated initializer
  285|     50|fn parse_designated_initializer(parser: &mut Parser) -> Result<ParsedDesignatedInitializer, ParseError> {
  286|     50|    let designation = if parser.matches(&[TokenKind::Dot, TokenKind::LeftBracket]) {
  287|     50|        parse_designation(parser)?
                                               ^0
  288|       |    } else {
  289|      0|        Vec::new()
  290|       |    };
  291|       |
  292|     50|    parser.expect(TokenKind::Assign)?;
                                                  ^0
  293|     50|    let initializer = parse_initializer(parser)?;
                                                             ^0
  294|       |
  295|     50|    Ok(ParsedDesignatedInitializer {
  296|     50|        designation,
  297|     50|        initializer,
  298|     50|    })
  299|     50|}
  300|       |
  301|       |/// Parse designation
  302|     50|fn parse_designation(parser: &mut Parser) -> Result<Vec<ParsedDesignator>, ParseError> {
  303|     50|    let mut designators = Vec::new();
  304|       |
  305|    100|    while parser.matches(&[TokenKind::Dot, TokenKind::LeftBracket]) {
  306|     50|        if parser.accept(TokenKind::Dot).is_some() {
  307|     21|            let (field_name, _) = parser.expect_name()?;
                                                                    ^0
  308|     21|            designators.push(ParsedDesignator::FieldName(field_name));
  309|     29|        } else if parser.accept(TokenKind::LeftBracket).is_some() {
  310|       |            // Check if this is a range designator (contains ellipsis)
  311|     29|            let start_expr = parser.parse_expr_min()?;
                                                                  ^0
  312|       |
  313|       |            // Check for ellipsis token indicating range syntax
  314|     29|            if parser.accept(TokenKind::Ellipsis).is_some() {
  315|      7|                let end_expr = parser.parse_expr_min()?;
                                                                    ^0
  316|      7|                parser.expect(TokenKind::RightBracket)?;
                                                                    ^0
  317|      7|                designators.push(ParsedDesignator::GnuArrayRange(start_expr, end_expr));
  318|       |            } else {
  319|       |                // Single index designator
  320|     22|                parser.expect(TokenKind::RightBracket)?;
                                                                    ^0
  321|     22|                designators.push(ParsedDesignator::ArrayIndex(start_expr));
  322|       |            }
  323|      0|        }
  324|       |    }
  325|       |
  326|     50|    Ok(designators)
  327|     50|}
  328|       |
  329|       |/// Parse expression for initializer (stops at commas that separate declarators)
  330|    501|fn parse_initializer_expression(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  331|       |    // Parse expressions in initializers, but stop at comma operators to avoid
  332|       |    // consuming declarator-separating commas. Use assignment precedence to allow
  333|       |    // most binary operators but prevent comma operators.
  334|    501|    parser.parse_expr_assignment()
  335|    501|}
  336|       |
  337|       |/// Parse GCC __attribute__ syntax: __attribute__ (( attribute-list ))
  338|       |/// For now, we parse and skip the attribute construct
  339|      1|pub(crate) fn parse_attribute(parser: &mut Parser) -> Result<(), ParseError> {
  340|      1|    debug!("parse_attribute: parsing __attribute__ construct");
                         ^0
  341|       |
  342|       |    // Expect __attribute__
  343|      1|    parser.expect(TokenKind::Attribute)?;
                                                     ^0
  344|       |
  345|       |    // Expect opening (
  346|      1|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  347|       |
  348|       |    // Expect opening (
  349|      1|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  350|       |
  351|       |    // Skip attribute list until we find ))
  352|      1|    let mut paren_depth = 2;
  353|      3|    while let Some(token) = parser.try_current_token() {
  354|      3|        match token.kind {
  355|      0|            TokenKind::LeftParen => {
  356|      0|                paren_depth += 1;
  357|      0|            }
  358|       |            TokenKind::RightParen => {
  359|      2|                paren_depth -= 1;
  360|      2|                if paren_depth == 0 {
  361|      1|                    parser.advance();
  362|      1|                    break;
  363|      1|                }
  364|       |            }
  365|      1|            _ => {}
  366|       |        }
  367|      2|        parser.advance();
  368|       |    }
  369|       |
  370|      1|    debug!("parse_attribute: successfully parsed __attribute__ construct");
                         ^0
  371|      1|    Ok(())
  372|      1|}

/app/src/parser/declarations.rs:
    1|       |//! Declaration parsing module
    2|       |//!
    3|       |//! This module handles all declaration parsing logic, including type specifiers,
    4|       |//! declarators, initializers, and top-level constructs like function definitions
    5|       |//! and translation units.
    6|       |
    7|       |use crate::ast::{parsed::*, *};
    8|       |use crate::diagnostic::ParseError;
    9|       |use crate::lexer::{Token, TokenKind};
   10|       |use crate::parser::declaration_core::parse_declaration_specifiers;
   11|       |use crate::source_manager::{SourceLoc, SourceSpan};
   12|       |use log::debug;
   13|       |use thin_vec::ThinVec;
   14|       |
   15|       |use super::Parser;
   16|       |
   17|       |/// Parse a declaration
   18|    880|pub(crate) fn parse_declaration(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
   19|    880|    let trx = parser.start_transaction();
   20|    880|    let start_loc = trx.parser.current_token_span()?.start();
                                                                 ^0
   21|       |
   22|    880|    let dummy = trx.parser.push_dummy();
   23|       |
   24|    880|    debug!(
   25|      0|        "parse_declaration: starting at position {}, token {:?}",
   26|       |        trx.parser.current_idx,
   27|      0|        trx.parser.current_token_kind()
   28|       |    );
   29|       |
   30|       |    // Check for _Static_assert (C11)
   31|    880|    if let Some(token) = trx.parser.accept(TokenKind::StaticAssert) {
                              ^20
   32|     20|        let result = parse_static_assert(trx.parser, token);
   33|     20|        if result.is_ok() {
   34|     20|            trx.commit();
   35|     20|        }
                      ^0
   36|       |        // The transaction will be rolled back on error automatically
   37|     20|        return result;
   38|    860|    }
   39|       |
   40|       |    // Try to parse declaration specifiers
   41|    860|    let specifiers = match parse_declaration_specifiers(trx.parser) {
   42|    860|        Ok(specifiers) => {
   43|    860|            debug!(
   44|      0|                "parse_declaration: parsed {} specifiers, current token {:?}",
   45|      0|                specifiers.len(),
   46|      0|                trx.parser.current_token_kind()
   47|       |            );
   48|    860|            debug!(
   49|      0|                "parse_declaration: current token after specifiers: {:?}",
   50|      0|                trx.parser.current_token_kind()
   51|       |            );
   52|    860|            if let Some(last_specifier) = specifiers.last() {
   53|    860|                debug!(
   54|      0|                    "parse_declaration: last specifier type: {:?}",
   55|      0|                    match last_specifier {
   56|      0|                        ParsedDeclSpecifier::TypeSpecifier(ts) => std::mem::discriminant(ts),
   57|      0|                        _ => std::mem::discriminant(&ParsedTypeSpecifier::Void),
   58|       |                    }
   59|       |                );
   60|      0|            }
   61|    860|            specifiers
   62|       |        }
   63|      0|        Err(e) => {
   64|      0|            return Err(e);
   65|       |        }
   66|       |    };
   67|       |
   68|       |    // Special handling for struct/union/enum declarations
   69|       |    // Check if any specifier is a struct/union/enum specifier (definition or forward declaration)
   70|    962|    let has_record_enum_type = specifiers.iter().any(|s| {
                      ^860                   ^860              ^860
   71|    826|        matches!(
   72|    916|            s,
   73|       |            ParsedDeclSpecifier::TypeSpecifier(ParsedTypeSpecifier::Record(_, _, _) | ParsedTypeSpecifier::Enum(_, _))
   74|       |        )
   75|    962|    });
   76|    860|    let has_storage_class = specifiers
   77|    860|        .iter()
   78|    940|        .any(|s| matches!(s, ParsedDeclSpecifier::StorageClass(_)));
                       ^860
   79|    860|    let is_record_enum_specifier = has_record_enum_type && !has_storage_class;
                                                                         ^136
   80|       |
   81|       |    // If we have a struct/union/enum specifier, we need to check if there are declarators following
   82|       |    // The logic should be:
   83|       |    // - If next token is semicolon: treat as record/enum declaration (definition or forward)
   84|       |    // - If next token is declarator-starting token: continue with normal declaration parsing
   85|    860|    if is_record_enum_specifier {
   86|    132|        if let Some(semi) = trx.parser.accept(TokenKind::Semicolon) {
                                  ^60
   87|       |            // This is either:
   88|       |            // 1. A pure struct/union/enum definition like "struct foo { ... };" or "enum E { ... };"
   89|       |            // 2. A forward struct/union/enum declaration like "struct foo;" or "enum E;"
   90|       |            // In both cases, consume the semicolon and create declaration with no declarators
   91|     60|            let declaration_data = ParsedDeclarationData {
   92|     60|                specifiers,
   93|     60|                init_declarators: ThinVec::new(),
   94|     60|            };
   95|       |
   96|     60|            let end_loc = semi.span.end();
   97|     60|            let span = SourceSpan::new(start_loc, end_loc);
   98|       |
   99|     60|            let node = trx
  100|     60|                .parser
  101|     60|                .push_node(ParsedNodeKind::Declaration(declaration_data), span);
  102|     60|            debug!(
  103|      0|                "parse_declaration: successfully parsed record/enum declaration, node_id={}",
  104|      0|                node.get()
  105|       |            );
  106|     60|            trx.commit();
  107|     60|            return Ok(node);
  108|       |        } else {
  109|       |            // This is a record/enum specifier with declarators
  110|       |            // Continue with normal declaration parsing (e.g., "struct foo { ... } var;")
  111|     72|            debug!("parse_declaration: record/enum specifier with declarators, continuing with normal parsing");
                                 ^0
  112|       |        }
  113|    728|    }
  114|       |
  115|       |    // For all other cases, check if we have declarators
  116|    800|    let has_declarators = if trx.parser.is_token(TokenKind::Semicolon) {
  117|       |        // Definitely no declarators
  118|      0|        false
  119|       |    } else {
  120|       |        // Check if we have a declarator-starting token
  121|       |        // This includes: identifier, star, or left paren
  122|      1|        matches!(
  123|    800|            trx.parser.current_token_kind(),
  124|       |            Some(TokenKind::Identifier(_)) | Some(TokenKind::Star) | Some(TokenKind::LeftParen)
  125|       |        )
  126|       |    };
  127|    800|    debug!("parse_declaration: has_declarators = {}", has_declarators);
                         ^0
  128|       |
  129|       |    // If no declarators and this is not a record/enum definition, it's an error
  130|    800|    if !has_declarators {
  131|       |        // Check if this looks like a record/enum definition
  132|       |        // by looking at the last parsed specifier
  133|      2|        let message = if let Some(ParsedDeclSpecifier::TypeSpecifier(ts)) = specifiers.last() {
  134|      2|            match ts {
  135|      1|                ParsedTypeSpecifier::Record(_, _, _) => "Expected ';' after struct/union definition",
  136|      0|                ParsedTypeSpecifier::Enum(_, _) => "Expected ';' after enum definition",
  137|      1|                _ => "Expected declarator or identifier after type specifier",
  138|       |            }
  139|       |        } else {
  140|       |            // No specifiers at all - this shouldn't happen
  141|      0|            "Expected type specifiers"
  142|       |        };
  143|       |
  144|      2|        let current_token = trx.parser.current_token()?;
                                                                    ^0
  145|      2|        return Err(ParseError::UnexpectedToken {
  146|      2|            expected_tokens: message.to_string(),
  147|      2|            found: current_token.kind,
  148|      2|            span: current_token.span,
  149|      2|        });
  150|    798|    }
  151|       |
  152|       |    // Parse init declarators
  153|    798|    let mut init_declarators = ThinVec::new();
  154|       |
  155|       |    loop {
  156|    813|        let declarator_start_idx = trx.parser.current_idx;
  157|    813|        let start_span = trx.parser.current_token_span_or_empty();
  158|       |
  159|    813|        debug!(
  160|      0|            "parse_declaration: parsing declarator at position {}, token {:?}",
  161|       |            declarator_start_idx,
  162|      0|            trx.parser.current_token_kind()
  163|       |        );
  164|       |
  165|    813|        let declarator = match super::declarator::parse_declarator(trx.parser, None) {
                          ^809
  166|    809|            Ok(declarator) => {
  167|    809|                debug!(
  168|      0|                    "parse_declaration: parsed declarator, current token {:?}",
  169|      0|                    trx.parser.current_token_kind()
  170|       |                );
  171|    809|                declarator
  172|       |            }
  173|      4|            Err(e) => {
  174|      4|                return Err(e);
  175|       |            }
  176|       |        };
  177|       |
  178|    809|        let initializer = if trx.parser.accept(TokenKind::Assign).is_some() {
  179|    365|            debug!(
  180|      0|                "parse_declaration: found '=', parsing initializer at position {}",
  181|       |                trx.parser.current_idx
  182|       |            );
  183|    365|            match super::declaration_core::parse_initializer(trx.parser) {
  184|    365|                Ok(initializer) => {
  185|    365|                    debug!(
  186|      0|                        "parse_declaration: parsed initializer, now at position {} with token {:?}",
  187|       |                        trx.parser.current_idx,
  188|      0|                        trx.parser.current_token_kind()
  189|       |                    );
  190|    365|                    Some(initializer)
  191|       |                }
  192|      0|                Err(e) => {
  193|      0|                    return Err(e);
  194|       |                }
  195|       |            }
  196|       |        } else {
  197|    444|            None
  198|       |        };
  199|       |
  200|    809|        let end_span = trx.parser.last_token_span().unwrap_or(start_span);
  201|    809|        let span = start_span.merge(end_span);
  202|       |
  203|    809|        init_declarators.push(ParsedInitDeclarator {
  204|    809|            declarator,
  205|    809|            initializer,
  206|    809|            span,
  207|    809|        });
  208|       |
  209|    809|        if !trx.parser.is_token(TokenKind::Comma) {
  210|    794|            break;
  211|     15|        }
  212|     15|        trx.parser.advance(); // consume comma
  213|       |    }
  214|       |
  215|       |    // Check for __attribute__ after declarator (GCC extension)
  216|    794|    if trx.parser.is_token(TokenKind::Attribute) {
  217|      0|        debug!("parse_declaration: found __attribute__ after declarator, parsing it");
  218|      0|        if let Err(_e) = super::declaration_core::parse_attribute(trx.parser) {
  219|      0|            debug!("parse_declaration: failed to parse __attribute__: {:?}", _e);
  220|      0|        }
  221|    794|    }
  222|       |
  223|       |    // Check for semicolon at current position
  224|    794|    debug!(
  225|      0|        "parse_declaration: expecting semicolon, current token {:?}",
  226|      0|        trx.parser.current_token_kind()
  227|       |    );
  228|    794|    let semicolon_token = if let Some(token) = trx.parser.accept(TokenKind::Semicolon) {
                      ^541                          ^541
  229|    541|        token
  230|       |    } else {
  231|    253|        let current_token = trx.parser.current_token()?;
                                                                    ^0
  232|    253|        return Err(ParseError::UnexpectedToken {
  233|    253|            expected_tokens: "';' after declaration".to_string(),
  234|    253|            found: current_token.kind,
  235|    253|            span: current_token.span,
  236|    253|        });
  237|       |    };
  238|       |
  239|    541|    let end_loc = semicolon_token.span.end();
  240|       |
  241|    541|    let span = SourceSpan::new(start_loc, end_loc);
  242|       |
  243|       |    // Track typedef names for disambiguation
  244|  1.17k|    for specifier in &specifiers {
                      ^635
  245|    623|        if matches!(specifier, ParsedDeclSpecifier::StorageClass(StorageClass::Typedef)) {
                                  ^20
  246|     13|            debug!("Found Typedef specifier, adding typedef names");
                                 ^0
  247|     26|            for init_declarator in &init_declarators {
                              ^13
  248|     13|                let name = trx.parser.get_declarator_name(&init_declarator.declarator);
  249|     13|                debug!("get_declarator_name returned: {:?}", name);
                                     ^0
  250|     13|                if let Some(name) = name {
  251|     13|                    debug!("Adding typedef name: {:?}", name);
                                         ^0
  252|     13|                    trx.parser.add_typedef(name);
  253|      0|                }
  254|       |            }
  255|    622|        }
  256|       |    }
  257|       |
  258|    541|    let declaration_data = ParsedDeclarationData {
  259|    541|        specifiers,
  260|    541|        init_declarators,
  261|    541|    };
  262|       |
  263|    541|    let node = trx
  264|    541|        .parser
  265|    541|        .replace_node(dummy, ParsedNodeKind::Declaration(declaration_data), span);
  266|    541|    debug!(
  267|      0|        "parse_declaration: successfully parsed declaration, node_id={}",
  268|      0|        node.get()
  269|       |    );
  270|    541|    trx.commit();
  271|    541|    Ok(node)
  272|    880|}
  273|       |
  274|       |/// Parse function definition
  275|    253|fn parse_function_definition(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  276|    253|    let start_loc = parser.current_token()?.span.start();
                                                        ^0
  277|    253|    let dummy = parser.push_dummy();
  278|       |
  279|       |    // Parse declaration specifiers
  280|    253|    let specifiers = parse_declaration_specifiers(parser)?;
                                                                       ^0
  281|       |
  282|       |    // Parse declarator (should be a function declarator)
  283|    253|    let declarator = super::declarator::parse_declarator(parser, None)?;
                                                                                    ^0
  284|       |
  285|       |    // Parse function body
  286|    253|    let (body, body_end_loc) = super::statements::parse_compound_statement(parser)?;
                                                                                                ^0
  287|       |
  288|    253|    let span = SourceSpan::new(start_loc, body_end_loc);
  289|       |
  290|    253|    let function_def = ParsedFunctionDefData {
  291|    253|        specifiers,
  292|    253|        declarator: Box::new(declarator),
  293|    253|        body,
  294|    253|    };
  295|       |
  296|    253|    let node = parser.replace_node(dummy, ParsedNodeKind::FunctionDef(function_def), span);
  297|    253|    Ok(node)
  298|    253|}
  299|       |
  300|       |/// Parse translation unit (top level)
  301|    363|pub(crate) fn parse_translation_unit(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  302|    363|    let start_loc = parser.current_token()?.span.start();
                                                        ^0
  303|    363|    let mut end_loc = SourceLoc::builtin();
  304|       |
  305|    363|    let mut top_level_declarations = Vec::new();
  306|    363|    let mut iteration_count = 0;
  307|       |    const MAX_ITERATIONS: usize = 1000; // Prevent infinite loops
  308|       |
  309|       |    // TU must be placed as first node so reserve it place with dummy node before placing it last
  310|    363|    let dummy = parser.push_dummy();
  311|       |
  312|    974|    while let Some(token) = parser.try_current_token() {
  313|    974|        if token.kind == TokenKind::EndOfFile {
  314|    361|            end_loc = token.span.end();
  315|    361|            break;
  316|    613|        }
  317|       |
  318|       |        // Prevent infinite loops by limiting iterations
  319|    613|        iteration_count += 1;
  320|    613|        if iteration_count > MAX_ITERATIONS {
  321|      2|            debug!(
  322|      0|                "Parser exceeded maximum iteration limit at token {:?}, position {}",
  323|       |                token.kind, parser.current_idx
  324|       |            );
  325|      2|            return Err(ParseError::InfiniteLoop { span: token.span });
  326|    611|        }
  327|       |
  328|    611|        let initial_idx = parser.current_idx;
  329|       |
  330|       |        // Try parsing as declaration first
  331|    611|        match parse_declaration(parser) {
  332|    358|            Ok(declaration) => {
  333|    358|                top_level_declarations.push(declaration);
  334|    358|            }
  335|       |            Err(_) => {
  336|       |                // If declaration parsing failed, try function definition
  337|       |                // Reset to initial position for backtracking
  338|    253|                parser.current_idx = initial_idx;
  339|    253|                match parse_function_definition(parser) {
  340|    253|                    Ok(func_def) => {
  341|    253|                        top_level_declarations.push(func_def);
  342|    253|                    }
  343|      0|                    Err(e) => {
  344|      0|                        parser.diag.report(e);
  345|      0|                        parser.synchronize();
  346|      0|                    }
  347|       |                }
  348|       |            }
  349|       |        }
  350|       |    }
  351|       |
  352|    361|    let span = SourceSpan::new(start_loc, end_loc);
  353|    361|    let node = parser.replace_node(dummy, ParsedNodeKind::TranslationUnit(top_level_declarations), span);
  354|       |
  355|    361|    Ok(node)
  356|    363|}
  357|       |
  358|       |/// Parse static assert (C11)
  359|     20|fn parse_static_assert(parser: &mut Parser, start_token: Token) -> Result<ParsedNodeRef, ParseError> {
  360|       |    // already consumed `_Static_assert`
  361|     20|    let start_loc = start_token.span.start();
  362|     20|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  363|       |
  364|     20|    let condition = parser.parse_expr_assignment()?;
                                                                ^0
  365|       |
  366|     20|    parser.expect(TokenKind::Comma)?;
                                                 ^0
  367|       |
  368|     20|    let token = parser.current_token()?;
                                                    ^0
  369|     20|    let message = match token.kind {
  370|     20|        TokenKind::StringLiteral(symbol) => symbol,
  371|       |        _ => {
  372|      0|            return Err(ParseError::UnexpectedToken {
  373|      0|                expected_tokens: "string literal".to_string(),
  374|      0|                found: token.kind,
  375|      0|                span: token.span,
  376|      0|            });
  377|       |        }
  378|       |    };
  379|       |
  380|     20|    parser.advance();
  381|     20|    parser.expect(TokenKind::RightParen)?;
                                                      ^0
  382|     20|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  383|     20|    let end_loc = semicolon_token.span.end();
  384|     20|    let span = SourceSpan::new(start_loc, end_loc);
  385|     20|    let node = parser.push_node(ParsedNodeKind::StaticAssert(condition, message), span);
  386|     20|    Ok(node)
  387|     20|}

/app/src/parser/declarator.rs:
    1|       |//! Declarator parsing module
    2|       |//!
    3|       |//! This module handles the parsing of C declarators, which are the most complex
    4|       |//! part of C's declaration syntax. Declarators can be nested and include pointers,
    5|       |//! arrays, and functions.
    6|       |
    7|       |use crate::diagnostic::ParseError;
    8|       |use crate::lexer::TokenKind;
    9|       |use crate::parser::declaration_core::parse_declaration_specifiers;
   10|       |use crate::{ast::*, semantic::TypeQualifiers};
   11|       |use log::debug;
   12|       |use thin_vec::{ThinVec, thin_vec};
   13|       |
   14|       |use super::Parser;
   15|       |
   16|       |/// Helper enum for reconstructing complex declarators
   17|       |#[derive(Debug)]
   18|       |enum DeclaratorComponent {
   19|       |    Pointer(TypeQualifiers),
   20|       |}
   21|       |
   22|       |/// Validate declarator combinations
   23|    662|fn validate_declarator_combination(
   24|    662|    base: &ParsedDeclarator,
   25|    662|    new_kind: &str,
   26|    662|    span: SourceSpan,
   27|    662|) -> Result<(), ParseError> {
   28|    662|    match base {
   29|       |        ParsedDeclarator::Function { .. } => {
   30|      2|            if new_kind == "array" {
   31|      1|                return Err(ParseError::DeclarationNotAllowed { span });
   32|      1|            }
   33|      1|            if new_kind == "function" {
   34|      1|                return Err(ParseError::DeclarationNotAllowed { span });
   35|      0|            }
   36|       |        }
   37|       |        ParsedDeclarator::Array(..) => {
   38|      3|            if new_kind == "function" {
   39|      1|                return Err(ParseError::DeclarationNotAllowed { span });
   40|      2|            }
   41|       |        }
   42|    657|        _ => {}
   43|       |    }
   44|    659|    Ok(())
   45|    662|}
   46|       |
   47|       |/// Parse declarator
   48|  1.27k|pub(crate) fn parse_declarator(
   49|  1.27k|    parser: &mut Parser,
   50|  1.27k|    initial_declarator: Option<NameId>,
   51|  1.27k|) -> Result<ParsedDeclarator, ParseError> {
   52|  1.27k|    debug!(
   53|      0|        "parse_declarator: starting at position {}, token: {:?}, initial_declarator: {:?}",
   54|       |        parser.current_idx,
   55|      0|        parser.current_token_kind(),
   56|       |        initial_declarator
   57|       |    );
   58|       |
   59|       |    // Check for __attribute__ before declarator (GCC extension)
   60|  1.27k|    if parser.is_token(TokenKind::Attribute)
   61|      0|        && let Err(_e) = super::declaration_core::parse_attribute(parser)
   62|       |    {
   63|      0|        debug!("parse_declarator: failed to parse __attribute__: {:?}", _e);
   64|  1.27k|    }
   65|       |
   66|       |    // Parse leading pointers and their qualifiers
   67|  1.27k|    let declarator_chain = parse_leading_pointers(parser)?;
                                                                       ^0
   68|       |
   69|       |    // Parse direct declarator (identifier or parenthesized declarator)
   70|  1.27k|    let base_declarator = if parser.accept(TokenKind::LeftParen).is_some() {
   71|     20|        debug!("parse_declarator: found LeftParen, parsing parenthesized declarator");
                             ^0
   72|     20|        let inner_declarator = parse_declarator(parser, None)?;
                                                                           ^0
   73|     20|        debug!(
   74|      0|            "parse_declarator: consumed RightParen, current token: {:?}",
   75|      0|            parser.current_token_kind()
   76|       |        );
   77|     20|        parser.expect(TokenKind::RightParen)?; // Consume ')'
                                                          ^0
   78|     20|        inner_declarator
   79|  1.25k|    } else if let Some(ident_symbol) = initial_declarator {
                                     ^0
   80|      0|        ParsedDeclarator::Identifier(ident_symbol, TypeQualifiers::empty())
   81|  1.25k|    } else if let Some(token) = parser.try_current_token() {
   82|  1.25k|        if let TokenKind::Identifier(symbol) = token.kind {
                                                   ^1.25k
   83|  1.25k|            parser.advance(); // Consume identifier
   84|  1.25k|            ParsedDeclarator::Identifier(symbol, TypeQualifiers::empty())
   85|      2|        } else if parser.is_abstract_declarator_start() {
   86|      0|            parse_abstract_declarator(parser)?
   87|       |        } else {
   88|       |            // For abstract declarator, if nothing matches, it's just abstract
   89|      2|            ParsedDeclarator::Abstract
   90|       |        }
   91|       |    } else {
   92|       |        // Consume invalid tokens until ) or end
   93|      0|        while let Some(token) = parser.try_current_token() {
   94|      0|            if token.kind == TokenKind::RightParen {
   95|      0|                break;
   96|      0|            }
   97|      0|            debug!("parse_declarator: unexpected token {:?}, consuming", token.kind);
   98|      0|            parser.advance();
   99|       |        }
  100|       |        // For abstract declarator, if no token, it's abstract
  101|      0|        ParsedDeclarator::Abstract
  102|       |    };
  103|       |
  104|       |    // Parse trailing array and function declarators
  105|  1.27k|    let current_base = parse_trailing_declarators(parser, base_declarator)?;
                      ^1.27k                                                            ^4
  106|       |
  107|       |    // Reconstruct the declarator chain in reverse order
  108|  1.27k|    let final_declarator = reconstruct_declarator_chain(declarator_chain, current_base);
  109|       |
  110|  1.27k|    Ok(final_declarator)
  111|  1.27k|}
  112|       |
  113|       |/// Helper to parse type qualifiers
  114|    258|fn parse_type_qualifiers(parser: &mut Parser) -> Result<TypeQualifiers, ParseError> {
  115|    258|    let mut qualifiers = TypeQualifiers::empty();
  116|    278|    while let Some(token) = parser.try_current_token() {
  117|    278|        match token.kind {
  118|     10|            TokenKind::Const => {
  119|     10|                qualifiers.insert(TypeQualifiers::CONST);
  120|     10|                parser.advance();
  121|     10|            }
  122|      6|            TokenKind::Volatile => {
  123|      6|                qualifiers.insert(TypeQualifiers::VOLATILE);
  124|      6|                parser.advance();
  125|      6|            }
  126|      4|            TokenKind::Restrict => {
  127|      4|                qualifiers.insert(TypeQualifiers::RESTRICT);
  128|      4|                parser.advance();
  129|      4|            }
  130|      0|            TokenKind::Atomic => {
  131|      0|                qualifiers.insert(TypeQualifiers::ATOMIC);
  132|      0|                parser.advance();
  133|      0|            }
  134|    258|            _ => break,
  135|       |        }
  136|       |    }
  137|    258|    Ok(qualifiers)
  138|    258|}
  139|       |
  140|       |/// Helper to parse array size
  141|     98|fn parse_array_size(parser: &mut Parser) -> Result<ParsedArraySize, ParseError> {
  142|     98|    let is_static = parser.accept(TokenKind::Static).is_some();
  143|     98|    let qualifiers = parse_type_qualifiers(parser)?;
                                                                ^0
  144|       |
  145|     98|    if parser.accept(TokenKind::Star).is_some() {
  146|      0|        Ok(ParsedArraySize::Star { qualifiers })
  147|     98|    } else if parser.is_token(TokenKind::RightBracket) {
  148|       |        // Empty []
  149|     10|        Ok(ParsedArraySize::Incomplete)
  150|       |    } else {
  151|       |        // Assume it's an expression for the size
  152|     88|        let expr_node = parser.parse_expr_min()?;
                                                             ^0
  153|     88|        if is_static || !qualifiers.is_empty() {
  154|      7|            Ok(ParsedArraySize::VlaSpecifier {
  155|      7|                is_static,
  156|      7|                qualifiers,
  157|      7|                size: Some(expr_node),
  158|      7|            })
  159|       |        } else {
  160|     81|            Ok(ParsedArraySize::Expression {
  161|     81|                expr: expr_node,
  162|     81|                qualifiers,
  163|     81|            })
  164|       |        }
  165|       |    }
  166|     98|}
  167|       |
  168|       |/// Parse leading pointers and their qualifiers, building a declarator component chain
  169|  1.30k|fn parse_leading_pointers(parser: &mut Parser) -> Result<Vec<DeclaratorComponent>, ParseError> {
  170|  1.30k|    let mut declarator_chain: Vec<DeclaratorComponent> = Vec::new();
  171|       |
  172|  1.46k|    while parser.accept(TokenKind::Star).is_some() {
  173|    160|        let current_qualifiers = parse_type_qualifiers(parser)?;
                                                                            ^0
  174|    160|        declarator_chain.push(DeclaratorComponent::Pointer(current_qualifiers));
  175|       |    }
  176|       |
  177|  1.30k|    Ok(declarator_chain)
  178|  1.30k|}
  179|       |
  180|       |/// Parse trailing declarators (arrays, functions) that follow the base declarator
  181|       |/// This is used for abstract declarators in type names where bit-fields are not allowed
  182|     26|fn parse_trailing_declarators_for_type_names(
  183|     26|    parser: &mut Parser,
  184|     26|    mut current_base: ParsedDeclarator,
  185|     26|) -> Result<ParsedDeclarator, ParseError> {
  186|       |    loop {
  187|     34|        let current_token_span = parser.try_current_token().map_or(SourceSpan::empty(), |t| t.span);
  188|     34|        if parser.accept(TokenKind::LeftBracket).is_some() {
  189|       |            // Array declarator
  190|      2|            validate_declarator_combination(&current_base, "array", current_token_span)?;
                                                                                                     ^0
  191|      2|            let array_size = parse_array_size(parser)?;
                                                                   ^0
  192|      2|            parser.expect(TokenKind::RightBracket)?; // Consume ']'
                                                                ^0
  193|      2|            current_base = ParsedDeclarator::Array(Box::new(current_base), array_size);
  194|     32|        } else if parser.accept(TokenKind::LeftParen).is_some() {
  195|       |            // Function declarator
  196|      6|            validate_declarator_combination(&current_base, "function", current_token_span)?;
                                                                                                        ^0
  197|      6|            let (parameters, is_variadic) = parse_function_parameters(parser)?;
                                                                                           ^0
  198|      6|            parser.expect(TokenKind::RightParen)?; // Consume ')'
                                                              ^0
  199|      6|            current_base = ParsedDeclarator::Function {
  200|      6|                inner: Box::new(current_base),
  201|      6|                params: parameters,
  202|      6|                is_variadic,
  203|      6|            };
  204|       |        } else {
  205|     26|            break;
  206|       |        }
  207|       |    }
  208|       |
  209|     26|    Ok(current_base)
  210|     26|}
  211|       |
  212|       |/// Parse trailing declarators (arrays, functions, bit-fields) that follow the base declarator
  213|  1.27k|fn parse_trailing_declarators(
  214|  1.27k|    parser: &mut Parser,
  215|  1.27k|    mut current_base: ParsedDeclarator,
  216|  1.27k|) -> Result<ParsedDeclarator, ParseError> {
  217|       |    loop {
  218|  1.93k|        let current_token_span = parser.try_current_token().map_or(SourceSpan::empty(), |t| t.span);
  219|  1.93k|        if parser.accept(TokenKind::LeftBracket).is_some() {
  220|       |            // Array declarator
  221|     96|            validate_declarator_combination(&current_base, "array", current_token_span)?;
                                                                                                     ^1
  222|     95|            let array_size = parse_array_size(parser)?;
                                                                   ^0
  223|     95|            parser.expect(TokenKind::RightBracket)?; // Consume ']'
                                                                ^0
  224|     95|            current_base = ParsedDeclarator::Array(Box::new(current_base), array_size);
  225|  1.84k|        } else if parser.accept(TokenKind::LeftParen).is_some() {
  226|       |            // Function declarator
  227|    558|            validate_declarator_combination(&current_base, "function", current_token_span)?;
                                                                                                        ^2
  228|    556|            let (parameters, is_variadic) = parse_function_parameters(parser)?;
                                                                                           ^0
  229|    556|            parser.expect(TokenKind::RightParen)?; // Consume ')'
                                                              ^1
  230|    555|            current_base = ParsedDeclarator::Function {
  231|    555|                inner: Box::new(current_base),
  232|    555|                params: parameters,
  233|    555|                is_variadic,
  234|    555|            };
  235|  1.28k|        } else if parser.accept(TokenKind::Colon).is_some() {
  236|       |            // Bit-field declarator: name : width
  237|      8|            let bit_width_expr = parser.parse_expr_min()?;
                                                                      ^0
  238|      8|            current_base = ParsedDeclarator::BitField(Box::new(current_base), bit_width_expr);
  239|       |        } else {
  240|  1.27k|            break;
  241|       |        }
  242|       |    }
  243|       |
  244|  1.27k|    Ok(current_base)
  245|  1.27k|}
  246|       |
  247|       |/// Reconstruct the declarator chain by applying pointer qualifiers in reverse order
  248|  1.30k|fn reconstruct_declarator_chain(
  249|  1.30k|    declarator_chain: Vec<DeclaratorComponent>,
  250|  1.30k|    base_declarator: ParsedDeclarator,
  251|  1.30k|) -> ParsedDeclarator {
  252|  1.30k|    let mut final_declarator = base_declarator;
  253|  1.30k|    for component in declarator_chain.into_iter().rev() {
                      ^160
  254|    160|        final_declarator = match component {
  255|    160|            DeclaratorComponent::Pointer(qualifiers) => {
  256|    160|                ParsedDeclarator::Pointer(qualifiers, Some(Box::new(final_declarator)))
  257|    160|            }
  258|    160|        };
  259|    160|    }
  260|  1.30k|    final_declarator
  261|  1.30k|}
  262|       |
  263|       |/// Helper to parse function parameters
  264|    562|fn parse_function_parameters(parser: &mut Parser) -> Result<(ThinVec<ParsedParamData>, bool), ParseError> {
  265|    562|    let mut params = ThinVec::new();
  266|    562|    let mut is_variadic = false;
  267|       |
  268|    562|    if !parser.is_token(TokenKind::RightParen) {
  269|     73|        if parser.is_token(TokenKind::Void) && parser.peek_token(0).is_some_and(|t| t.kind == TokenKind::RightParen) {
                                                             ^5     ^5            ^5              ^5        ^5
  270|       |            // void parameter list (only if followed effectively by ')')
  271|      4|            parser.expect(TokenKind::Void)?;
                                                        ^0
  272|       |        } else {
  273|       |            loop {
  274|     94|                if parser.accept(TokenKind::Ellipsis).is_some() {
  275|      5|                    is_variadic = true;
  276|      5|                    break;
  277|     89|                }
  278|       |
  279|       |                // Check if we have a valid start for parameter declaration
  280|     89|                if !parser.starts_declaration() {
  281|      0|                    break;
  282|     89|                }
  283|       |
  284|     89|                let start_idx = parser.current_idx;
  285|       |
  286|       |                // Parse declaration specifiers for this parameter
  287|     89|                let specifiers_start_idx = parser.current_idx;
  288|     89|                let saved_diagnostic_count = parser.diag.diagnostics.len();
  289|       |
  290|     89|                debug!(
  291|      0|                    "parse_function_parameters: attempting to parse specifiers at position {}, token: {:?}, is_type_name: {}",
  292|       |                    start_idx,
  293|      0|                    parser.current_token_kind(),
  294|      0|                    if let Some(TokenKind::Identifier(sym)) = parser.current_token_kind() {
  295|      0|                        parser.is_type_name(sym)
  296|       |                    } else {
  297|      0|                        false
  298|       |                    }
  299|       |                );
  300|       |
  301|     89|                let specifiers = match parse_declaration_specifiers(parser) {
  302|     89|                    Ok(specifiers) => {
  303|     89|                        debug!(
  304|      0|                            "parse_function_parameters: successfully parsed specifiers, current token: {:?}",
  305|      0|                            parser.current_token_kind()
  306|       |                        );
  307|     89|                        specifiers
  308|       |                    }
  309|      0|                    Err(_e) => {
  310|       |                        // If specifier parsing fails, we might be at a position where we need
  311|       |                        // to fall back to parsing without a proper declarator
  312|      0|                        debug!(
  313|      0|                            "parse_function_parameters: specifier parsing failed at position {}, token: {:?}, error: {:?}, rolling back",
  314|       |                            parser.current_idx,
  315|      0|                            parser.current_token_kind(),
  316|       |                            _e
  317|       |                        );
  318|      0|                        parser.current_idx = specifiers_start_idx;
  319|      0|                        parser.diag.diagnostics.truncate(saved_diagnostic_count);
  320|       |
  321|       |                        // Create a simple default specifier
  322|      0|                        thin_vec![ParsedDeclSpecifier::TypeSpecifier(ParsedTypeSpecifier::Int)]
  323|       |                    }
  324|       |                };
  325|       |
  326|       |                // Try to parse declarator, but be more careful about failures
  327|     89|                let declarator = if !parser.is_token(TokenKind::Comma)
  328|     81|                    && !parser.is_token(TokenKind::RightParen)
  329|     60|                    && !parser.is_token(TokenKind::Ellipsis)
  330|       |                {
  331|       |                    // Special handling for abstract declarators in parameter context
  332|     59|                    if parser.is_token(TokenKind::LeftParen) {
  333|      7|                        debug!("parse_function_parameters: found LeftParen, trying abstract declarator parsing");
                                             ^0
  334|      7|                        let start_idx = parser.current_idx;
  335|      7|                        match parse_abstract_declarator(parser) {
  336|      7|                            Ok(abstract_decl) => {
  337|      7|                                debug!("parse_function_parameters: abstract declarator parsed successfully");
                                                     ^0
  338|      7|                                Some(abstract_decl)
  339|       |                            }
  340|      0|                            Err(e) => {
  341|      0|                                debug!(
  342|      0|                                    "parse_function_parameters: abstract declarator failed: {:?}, rolling back to {}",
  343|       |                                    e, start_idx
  344|       |                                );
  345|      0|                                parser.current_idx = start_idx;
  346|       |                                // Try regular declarator parsing as fallback
  347|      0|                                match parse_declarator(parser, None) {
  348|      0|                                    Ok(decl) => {
  349|      0|                                        debug!("parse_function_parameters: fallback declarator parsing succeeded");
  350|      0|                                        Some(decl)
  351|       |                                    }
  352|       |                                    Err(_) => {
  353|      0|                                        debug!(
  354|      0|                                            "parse_function_parameters: both abstract and regular declarator parsing failed"
  355|       |                                        );
  356|      0|                                        None
  357|       |                                    }
  358|       |                                }
  359|       |                            }
  360|       |                        }
  361|       |                    } else {
  362|       |                        // Regular declarator parsing for other cases
  363|     52|                        match parse_declarator(parser, None) {
  364|     52|                            Ok(declarator) => {
  365|     52|                                debug!(
  366|      0|                                    "parse_function_parameters: declarator parsed successfully, current token: {:?}",
  367|      0|                                    parser.current_token_kind()
  368|       |                                );
  369|     52|                                Some(declarator)
  370|       |                            }
  371|      0|                            Err(e) => {
  372|      0|                                debug!(
  373|      0|                                    "parse_function_parameters: declarator parsing failed: {:?}, current token: {:?}, position: {}",
  374|       |                                    e,
  375|      0|                                    parser.current_token_kind(),
  376|       |                                    parser.current_idx
  377|       |                                );
  378|      0|                                None
  379|       |                            }
  380|       |                        }
  381|       |                    }
  382|       |                } else {
  383|     30|                    debug!(
  384|      0|                        "parse_function_parameters: skipping declarator parsing due to comma/paren/ellipsis, token: {:?}",
  385|      0|                        parser.current_token_kind()
  386|       |                    );
  387|     30|                    None
  388|       |                };
  389|       |
  390|       |                // Calculate span for the parameter
  391|     89|                let end_span = parser
  392|     89|                    .last_token_span()
  393|     89|                    .unwrap_or_else(|| parser.current_token_span_or_empty());
                                                     ^0     ^0
  394|     89|                let start_token_span = parser.get_token_span(start_idx).unwrap_or_default();
  395|     89|                let span = start_token_span.merge(end_span);
  396|       |
  397|     89|                params.push(ParsedParamData {
  398|     89|                    specifiers,
  399|     89|                    declarator,
  400|     89|                    span,
  401|     89|                });
  402|       |
  403|     89|                debug!(
  404|      0|                    "parse_function_parameters: pushed parameter, current token: {:?}, position: {}",
  405|      0|                    parser.current_token_kind(),
  406|       |                    parser.current_idx
  407|       |                );
  408|       |
  409|     89|                if parser.accept(TokenKind::Comma).is_none() {
  410|     64|                    debug!(
  411|      0|                        "parse_function_parameters: no comma found, breaking from parameter loop. Current token: {:?}, position: {}",
  412|      0|                        parser.current_token_kind(),
  413|       |                        parser.current_idx
  414|       |                    );
  415|     64|                    break;
  416|     25|                }
  417|     25|                debug!("parse_function_parameters: found comma, continuing to next parameter");
                                     ^0
  418|       |
  419|       |                // After consuming comma, verify we're in a good state to continue
  420|     25|                if parser.is_token(TokenKind::RightParen) {
  421|      0|                    debug!("parse_function_parameters: found unexpected right paren after comma, breaking");
  422|      0|                    break;
  423|     25|                }
  424|       |            }
  425|       |        }
  426|    489|    }
  427|       |
  428|    562|    Ok((params, is_variadic))
  429|    562|}
  430|       |
  431|       |/// Check if current token starts an abstract declarator
  432|     42|pub(crate) fn is_abstract_declarator_start(parser: &Parser) -> bool {
  433|     42|    if let Some(token) = parser.try_current_token() {
  434|     42|        match token.kind {
  435|      8|            TokenKind::Star => true,        // pointer
  436|      2|            TokenKind::LeftParen => true,   // parenthesized abstract declarator
  437|      0|            TokenKind::LeftBracket => true, // array
  438|     32|            _ => false,
  439|       |        }
  440|       |    } else {
  441|      0|        false
  442|       |    }
  443|     42|}
  444|       |
  445|       |/// Extract the declared name from a declarator, if any
  446|     13|pub(crate) fn get_declarator_name(declarator: &ParsedDeclarator) -> Option<NameId> {
  447|      0|    match declarator {
  448|     13|        ParsedDeclarator::Identifier(name, _) => Some(*name),
  449|      0|        ParsedDeclarator::Pointer(_, Some(inner)) => get_declarator_name(inner),
  450|      0|        ParsedDeclarator::Array(inner, _) => get_declarator_name(inner),
  451|      0|        ParsedDeclarator::Function { inner, .. } => get_declarator_name(inner),
  452|      0|        ParsedDeclarator::BitField(inner, _) => get_declarator_name(inner),
  453|      0|        ParsedDeclarator::AnonymousRecord(_, _) => None,
  454|      0|        ParsedDeclarator::Abstract => None,
  455|      0|        ParsedDeclarator::Pointer(_, None) => None,
  456|       |    }
  457|     13|}
  458|       |
  459|       |/// Parse abstract declarator (for type names without identifiers)
  460|     26|pub(crate) fn parse_abstract_declarator(parser: &mut Parser) -> Result<ParsedDeclarator, ParseError> {
  461|     26|    debug!(
  462|      0|        "parse_abstract_declarator: starting at position {}, token {:?}",
  463|       |        parser.current_idx,
  464|      0|        parser.current_token_kind()
  465|       |    );
  466|       |
  467|       |    // Check for __attribute__ at the beginning (GCC extension)
  468|     26|    if parser.is_token(TokenKind::Attribute)
  469|      0|        && let Err(_e) = super::declaration_core::parse_attribute(parser)
  470|       |    {
  471|      0|        debug!("parse_abstract_declarator: failed to parse __attribute__: {:?}", _e);
  472|     26|    }
  473|       |
  474|       |    // Parse leading pointers and their qualifiers
  475|     26|    let declarator_chain = parse_leading_pointers(parser)?;
                                                                       ^0
  476|       |
  477|       |    // Parse direct abstract declarator (parenthesized or array/function)
  478|     26|    let base_declarator = if let Some(token) = parser.try_current_token() {
  479|     26|        match token.kind {
  480|      5|            TokenKind::Identifier(symbol) => {
  481|      5|                if parser.is_type_name(symbol) {
  482|      0|                    parser.advance(); // consume type name
  483|       |                    // Check if next is identifier for named abstract declarator
  484|      0|                    if let Some(next_token) = parser.try_current_token() {
  485|      0|                        if let TokenKind::Identifier(name) = next_token.kind {
  486|      0|                            parser.advance(); // consume identifier
  487|      0|                            ParsedDeclarator::Identifier(name, TypeQualifiers::empty())
  488|       |                        } else {
  489|      0|                            ParsedDeclarator::Abstract
  490|       |                        }
  491|       |                    } else {
  492|      0|                        ParsedDeclarator::Abstract
  493|       |                    }
  494|       |                } else {
  495|      5|                    parser.advance(); // consume invalid identifier
  496|      5|                    ParsedDeclarator::Abstract
  497|       |                }
  498|       |            }
  499|       |            TokenKind::Int => {
  500|      0|                parser.advance(); // consume int
  501|       |                // Check if next is identifier
  502|      0|                if let Some(next_token) = parser.try_current_token() {
  503|      0|                    if let TokenKind::Identifier(name) = next_token.kind {
  504|      0|                        parser.advance(); // consume identifier
  505|      0|                        ParsedDeclarator::Identifier(name, TypeQualifiers::empty())
  506|       |                    } else {
  507|      0|                        ParsedDeclarator::Abstract
  508|       |                    }
  509|       |                } else {
  510|      0|                    ParsedDeclarator::Abstract
  511|       |                }
  512|       |            }
  513|       |            TokenKind::LeftParen => {
  514|      9|                debug!("parse_abstract_declarator: found LeftParen, parsing parenthesized");
                                     ^0
  515|      9|                parser.advance(); // Consume '('
  516|      9|                if parser.accept(TokenKind::RightParen).is_some() {
  517|       |                    // Empty parameter list: ()
  518|      0|                    ParsedDeclarator::Function {
  519|      0|                        inner: Box::new(ParsedDeclarator::Abstract),
  520|      0|                        params: ThinVec::new(),
  521|      0|                        is_variadic: false,
  522|      0|                    }
  523|       |                } else {
  524|      9|                    let start_idx = parser.current_idx;
  525|      9|                    let inner_declarator = parse_abstract_declarator(parser)?;
                                                                                          ^0
  526|      9|                    debug!(
  527|      0|                        "parse_abstract_declarator: inner declarator parsed, current token: {:?}",
  528|      0|                        parser.current_token_kind()
  529|       |                    );
  530|      9|                    if parser.accept(TokenKind::RightParen).is_some() {
  531|      9|                        inner_declarator
  532|       |                    } else {
  533|       |                        // Check if we're dealing with a function parameter syntax like "int (int)"
  534|       |                        // In this case, the closing paren might be part of the parameter list context
  535|      0|                        debug!(
  536|      0|                            "parse_abstract_declarator: expected RightParen but found {:?}, position: {}",
  537|      0|                            parser.current_token_kind(),
  538|       |                            parser.current_idx
  539|       |                        );
  540|       |                        // Try to parse as function declarator if we see another LeftParen
  541|      0|                        if parser.accept(TokenKind::LeftParen).is_some() {
  542|      0|                            debug!(
  543|      0|                                "parse_abstract_declarator: found another LeftParen, treating as function declarator"
  544|       |                            );
  545|      0|                            let (parameters, is_variadic) = parse_function_parameters(parser)?;
  546|      0|                            parser.expect(TokenKind::RightParen)?; // Consume ')'
  547|      0|                            ParsedDeclarator::Function {
  548|      0|                                inner: Box::new(inner_declarator),
  549|      0|                                params: parameters,
  550|      0|                                is_variadic,
  551|      0|                            }
  552|       |                        } else {
  553|       |                            // Roll back and try a different approach
  554|      0|                            parser.current_idx = start_idx;
  555|      0|                            ParsedDeclarator::Abstract
  556|       |                        }
  557|       |                    }
  558|       |                }
  559|       |            }
  560|       |            TokenKind::LeftBracket => {
  561|      1|                parser.advance(); // Consume '['
  562|      1|                let array_size = parse_array_size(parser)?;
                                                                       ^0
  563|      1|                parser.expect(TokenKind::RightBracket)?; // Consume ']'
                                                                    ^0
  564|      1|                ParsedDeclarator::Array(Box::new(ParsedDeclarator::Abstract), array_size)
  565|       |            }
  566|       |            TokenKind::Star => {
  567|      0|                parser.advance(); // Consume '*'
  568|      0|                let qualifiers = parse_type_qualifiers(parser)?;
  569|      0|                ParsedDeclarator::Pointer(qualifiers, Some(Box::new(ParsedDeclarator::Abstract)))
  570|       |            }
  571|       |            _ => {
  572|       |                // invalid token, don't consume
  573|     11|                ParsedDeclarator::Abstract
  574|       |            }
  575|       |        }
  576|       |    } else {
  577|      0|        ParsedDeclarator::Abstract
  578|       |    };
  579|       |
  580|     26|    debug!(
  581|      0|        "parse_abstract_declarator: base_declarator parsed, current token {:?}",
  582|      0|        parser.current_token_kind()
  583|       |    );
  584|       |
  585|       |    // Parse trailing array and function declarators
  586|     26|    let current_base = parse_trailing_declarators_for_type_names(parser, base_declarator)?;
                                                                                                       ^0
  587|       |
  588|       |    // Reconstruct the declarator chain in reverse order
  589|     26|    let final_declarator = reconstruct_declarator_chain(declarator_chain, current_base);
  590|       |
  591|     26|    Ok(final_declarator)
  592|     26|}

/app/src/parser/enum_parsing.rs:
    1|       |//! Enum parsing module
    2|       |//!
    3|       |//! This module handles parsing of enum declarations and enumerators.
    4|       |
    5|       |use crate::ast::*;
    6|       |use crate::diagnostic::ParseError;
    7|       |use crate::lexer::TokenKind;
    8|       |
    9|       |use super::Parser;
   10|       |
   11|       |/// Parse enum specifier
   12|     28|pub(crate) fn parse_enum_specifier(parser: &mut Parser) -> Result<ParsedTypeSpecifier, ParseError> {
   13|     28|    let tag = parser.accept_name();
   14|     28|    let enumerators = if parser.accept(TokenKind::LeftBrace).is_some() {
   15|     24|        let enums = parse_enumerator_list(parser)?;
                                                               ^0
   16|     24|        parser.expect(TokenKind::RightBrace)?;
                                                          ^0
   17|     24|        Some(enums)
   18|       |    } else {
   19|      4|        None
   20|       |    };
   21|       |
   22|     28|    Ok(ParsedTypeSpecifier::Enum(tag, enumerators))
   23|     28|}
   24|       |
   25|       |/// Parse enumerator list
   26|     24|fn parse_enumerator_list(parser: &mut Parser) -> Result<Vec<ParsedNodeRef>, ParseError> {
   27|     24|    let mut enumerators = Vec::new();
   28|       |
   29|       |    loop {
   30|     62|        let enumerator = parse_enumerator(parser)?;
                                                               ^0
   31|     62|        enumerators.push(enumerator);
   32|       |
   33|     62|        if !parser.is_token(TokenKind::Comma) {
   34|     24|            break;
   35|     38|        }
   36|     38|        parser.advance(); // consume comma
   37|       |
   38|       |        // Allow trailing comma
   39|     38|        if parser.is_token(TokenKind::RightBrace) {
   40|      0|            break;
   41|     38|        }
   42|       |    }
   43|       |
   44|     24|    Ok(enumerators)
   45|     24|}
   46|       |
   47|       |/// Parse enumerator
   48|     62|fn parse_enumerator(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
   49|     62|    let (name, mut span) = parser.expect_name()?;
                                                             ^0
   50|     62|    let value = if parser.accept(TokenKind::Assign).is_some() {
   51|     22|        let expr = parser.parse_expr_assignment()?;
                                                               ^0
   52|     22|        span = SourceSpan::new(span.start(), parser.ast.get_node(expr).span.end());
   53|     22|        Some(expr)
   54|       |    } else {
   55|     40|        None
   56|       |    };
   57|       |
   58|     62|    let node = parser.push_node(ParsedNodeKind::EnumConstant(name, value), span);
   59|     62|    Ok(node)
   60|     62|}

/app/src/parser/expressions.rs:
    1|       |//! Expression parsing module
    2|       |//!
    3|       |//! This module handles all expression parsing logic, including the Pratt parser
    4|       |//! implementation for operator precedence and associativity.
    5|       |
    6|       |use crate::ast::{parsed::*, *};
    7|       |use crate::diagnostic::ParseError;
    8|       |use crate::lexer::{Token, TokenKind};
    9|       |use crate::source_manager::{SourceLoc, SourceSpan};
   10|       |use log::{debug, trace};
   11|       |
   12|       |use super::Parser;
   13|       |
   14|       |/// Binding power for Pratt parser operator precedence
   15|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
   16|       |pub(crate) struct BindingPower(u8);
   17|       |
   18|       |impl BindingPower {
   19|       |    pub(crate) const MIN: Self = Self(0);
   20|       |    pub const COMMA: Self = Self(2);
   21|       |    pub const ASSIGNMENT: Self = Self(4);
   22|       |    pub const CONDITIONAL: Self = Self(6);
   23|       |    pub const LOGICAL_OR: Self = Self(8);
   24|       |    pub const LOGICAL_AND: Self = Self(10);
   25|       |    pub const BITWISE_OR: Self = Self(12);
   26|       |    pub const BITWISE_XOR: Self = Self(14);
   27|       |    pub const BITWISE_AND: Self = Self(16);
   28|       |    pub const EQUALITY: Self = Self(18);
   29|       |    pub const RELATIONAL: Self = Self(20);
   30|       |    pub const SHIFT: Self = Self(22);
   31|       |    pub const ADDITIVE: Self = Self(24);
   32|       |    pub const MULTIPLICATIVE: Self = Self(26);
   33|       |    pub const CAST: Self = Self(28);
   34|       |    pub const UNARY: Self = Self(30);
   35|       |    pub const POSTFIX: Self = Self(32);
   36|       |    // pub const PRIMARY: Self = Self(34);
   37|       |}
   38|       |
   39|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   40|       |pub(crate) enum Associativity {
   41|       |    Left,
   42|       |    Right,
   43|       |}
   44|       |
   45|       |/// Pratt parser implementation
   46|       |pub(crate) struct PrattParser;
   47|       |
   48|       |impl PrattParser {
   49|  2.50k|    fn get_binding_power(token_kind: TokenKind) -> Option<(BindingPower, Associativity)> {
   50|  2.50k|        match token_kind {
   51|       |            // Assignment operators (right-associative)
   52|       |            TokenKind::Assign
   53|       |            | TokenKind::PlusAssign
   54|       |            | TokenKind::MinusAssign
   55|       |            | TokenKind::StarAssign
   56|       |            | TokenKind::DivAssign
   57|       |            | TokenKind::ModAssign
   58|       |            | TokenKind::AndAssign
   59|       |            | TokenKind::OrAssign
   60|       |            | TokenKind::XorAssign
   61|       |            | TokenKind::LeftShiftAssign
   62|     98|            | TokenKind::RightShiftAssign => Some((BindingPower::ASSIGNMENT, Associativity::Right)),
   63|       |
   64|       |            // Comma operator (left-associative, lowest precedence)
   65|    242|            TokenKind::Comma => Some((BindingPower::COMMA, Associativity::Left)),
   66|       |
   67|       |            // Conditional operator (right-associative)
   68|      6|            TokenKind::Question => Some((BindingPower::CONDITIONAL, Associativity::Right)),
   69|       |
   70|       |            // Logical operators (left-associative)
   71|     12|            TokenKind::LogicOr => Some((BindingPower::LOGICAL_OR, Associativity::Left)),
   72|      1|            TokenKind::LogicAnd => Some((BindingPower::LOGICAL_AND, Associativity::Left)),
   73|       |
   74|       |            // Bitwise operators (left-associative)
   75|      0|            TokenKind::Or => Some((BindingPower::BITWISE_OR, Associativity::Left)),
   76|      0|            TokenKind::Xor => Some((BindingPower::BITWISE_XOR, Associativity::Left)),
   77|      0|            TokenKind::And => Some((BindingPower::BITWISE_AND, Associativity::Left)),
   78|       |
   79|       |            // Comparison operators (left-associative)
   80|     51|            TokenKind::Equal | TokenKind::NotEqual => Some((BindingPower::EQUALITY, Associativity::Left)),
   81|       |            TokenKind::Less | TokenKind::Greater | TokenKind::LessEqual | TokenKind::GreaterEqual => {
   82|     85|                Some((BindingPower::RELATIONAL, Associativity::Left))
   83|       |            }
   84|       |
   85|       |            // Shift operators (left-associative)
   86|      0|            TokenKind::LeftShift | TokenKind::RightShift => Some((BindingPower::SHIFT, Associativity::Left)),
   87|       |
   88|       |            // Additive operators (left-associative)
   89|     58|            TokenKind::Plus | TokenKind::Minus => Some((BindingPower::ADDITIVE, Associativity::Left)),
   90|       |
   91|       |            // Multiplicative operators (left-associative)
   92|       |            TokenKind::Star | TokenKind::Slash | TokenKind::Percent => {
   93|     11|                Some((BindingPower::MULTIPLICATIVE, Associativity::Left))
   94|       |            }
   95|       |
   96|       |            // Postfix operators
   97|       |            TokenKind::Increment
   98|       |            | TokenKind::Decrement
   99|       |            | TokenKind::LeftParen
  100|       |            | TokenKind::LeftBracket
  101|       |            | TokenKind::Dot
  102|    255|            | TokenKind::Arrow => Some((BindingPower::POSTFIX, Associativity::Left)),
  103|       |
  104|  1.68k|            _ => None,
  105|       |        }
  106|  2.50k|    }
  107|       |}
  108|       |
  109|       |/// Main expression parsing using Pratt algorithm
  110|  1.96k|pub(crate) fn parse_expression(
  111|  1.96k|    parser: &mut Parser,
  112|  1.96k|    min_binding_power: BindingPower,
  113|  1.96k|) -> Result<ParsedNodeRef, ParseError> {
  114|  1.96k|    trace!("parse_expression: min_binding_power={}", min_binding_power.0);
                         ^0
  115|  1.96k|    let mut left = parse_prefix(parser)?;
                      ^1.96k                         ^1
  116|       |
  117|  2.50k|    while let Some(current_token) = parser.try_current_token() {
  118|  2.50k|        debug!(
  119|      0|            "parse_expression: loop iteration, current token {:?}, min_binding_power={}",
  120|       |            current_token.kind, min_binding_power.0
  121|       |        );
  122|       |
  123|  2.50k|        let Some((binding_power, associativity)) = PrattParser::get_binding_power(current_token.kind) else {
                                ^819           ^819
  124|  1.68k|            debug!(
  125|      0|                "parse_expression: no binding power for {:?}, breaking",
  126|       |                current_token.kind
  127|       |            );
  128|  1.68k|            break;
  129|       |        };
  130|       |
  131|    819|        let should_break = match associativity {
  132|    715|            Associativity::Left => binding_power <= min_binding_power,
  133|    104|            Associativity::Right => binding_power < min_binding_power,
  134|       |        };
  135|       |
  136|    819|        if should_break {
  137|    270|            debug!(
  138|      0|                "parse_expression: binding power {:?} should break at min {:?} (assoc {:?}), breaking",
  139|       |                binding_power.0, min_binding_power.0, associativity
  140|       |            );
  141|    270|            break;
  142|    549|        }
  143|       |
  144|    549|        let op_token = current_token;
  145|    549|        parser.advance(); // Consume the operator token
  146|       |
  147|       |        // Dispatch to the correct parsing function based on the operator kind
  148|    549|        left = match op_token.kind {
  149|       |            // Postfix operators are handled here directly
  150|     31|            TokenKind::Increment => parse_postfix_increment(parser, left, op_token)?,
                                                                                                 ^2
  151|     17|            TokenKind::Decrement => parse_postfix_decrement(parser, left, op_token)?,
                                                                                                 ^0
  152|    120|            TokenKind::LeftParen => parse_function_call(parser, left)?,
                                                                                   ^0
  153|     30|            TokenKind::LeftBracket => parse_index_access(parser, left)?,
                                                                                    ^0
  154|     42|            TokenKind::Dot => parse_member_access(parser, left, false)?,
                                                                                    ^0
  155|     15|            TokenKind::Arrow => parse_member_access(parser, left, true)?,
                                                                                     ^0
  156|       |
  157|       |            // Ternary operator is a special case
  158|       |            TokenKind::Question => {
  159|       |                // The middle operand is an `expression`, which allows assignment.
  160|       |                // C11: logical-OR-expression ? expression : conditional-expression
  161|      6|                let true_expr = parser.parse_expr_assignment()?;
                                                                            ^0
  162|      6|                parser.expect(TokenKind::Colon)?;
                                                             ^0
  163|       |                // The third operand is a `conditional-expression`, which has higher precedence.
  164|      6|                let false_expr = parser.parse_expr_bp(BindingPower::CONDITIONAL)?;
                                                                                              ^0
  165|       |
  166|      6|                let span = SourceSpan::new(
  167|      6|                    parser.ast.get_node(left).span.start(),
  168|      6|                    parser.ast.get_node(false_expr).span.end(),
  169|       |                );
  170|      6|                parser.push_node(ParsedNodeKind::TernaryOp(left, true_expr, false_expr), span)
  171|       |            }
  172|       |
  173|       |            // All other operators are binary/infix
  174|       |            _ => {
  175|    288|                let next_min_bp = if associativity == Associativity::Left {
  176|    196|                    BindingPower(binding_power.0 + 1)
  177|       |                } else {
  178|     92|                    binding_power
  179|       |                };
  180|    288|                parse_infix(parser, left, op_token, next_min_bp)?
                                                                              ^0
  181|       |            }
  182|       |        };
  183|       |    }
  184|       |
  185|  1.95k|    Ok(left)
  186|  1.96k|}
  187|       |
  188|       |/// Parse prefix expression
  189|  1.96k|fn parse_prefix(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  190|  1.96k|    let token = parser.current_token()?;
                                                    ^0
  191|       |
  192|  1.96k|    debug!("parse_prefix: token={:?} at {}", token.kind, token.span);
                         ^0
  193|  1.96k|    match token.kind {
  194|    608|        TokenKind::Identifier(symbol) => {
  195|    608|            parser.advance();
  196|    608|            debug!("parse_prefix: parsed identifier {:?}", symbol);
                                 ^0
  197|    608|            let node = parser.push_node(ParsedNodeKind::Ident(symbol), token.span);
  198|    608|            Ok(node)
  199|       |        }
  200|  1.00k|        TokenKind::IntegerConstant(val) => {
  201|  1.00k|            parser.advance();
  202|  1.00k|            let node = parser.push_node(
  203|  1.00k|                ParsedNodeKind::Literal(literal::Literal::Int { val, suffix: None }),
  204|  1.00k|                token.span,
  205|       |            );
  206|  1.00k|            Ok(node)
  207|       |        }
  208|     41|        TokenKind::FloatConstant(val) => {
  209|     41|            parser.advance();
  210|     41|            let node = parser.push_node(ParsedNodeKind::Literal(literal::Literal::Float(val)), token.span);
  211|     41|            Ok(node)
  212|       |        }
  213|    110|        TokenKind::StringLiteral(s) => {
  214|    110|            parser.advance();
  215|    110|            let node = parser.push_node(ParsedNodeKind::Literal(literal::Literal::String(s)), token.span);
  216|    110|            Ok(node)
  217|       |        }
  218|     53|        TokenKind::CharacterConstant(c) => {
  219|     53|            parser.advance();
  220|     53|            let node = parser.push_node(ParsedNodeKind::Literal(literal::Literal::Char(c)), token.span);
  221|     53|            Ok(node)
  222|       |        }
  223|       |        TokenKind::LeftParen => {
  224|     27|            let left_paren_token = token; // Save the opening paren token for span calculation
  225|     27|            parser.advance();
  226|       |            // Check if this is a cast expression or compound literal by looking ahead for a type name
  227|     27|            if parser.is_cast_expression_start() {
  228|       |                // Parse the type name
  229|     13|                let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                                          ^0
  230|       |                // Expect closing parenthesis
  231|     13|                parser.expect(TokenKind::RightParen)?;
                                                                  ^0
  232|       |
  233|       |                // Check if this is a compound literal (next token is '{')
  234|     13|                if parser.is_token(TokenKind::LeftBrace) {
  235|       |                    // This is a compound literal: (type-name){initializer}
  236|      2|                    parser.parse_compound_literal_from_type_and_start(parsed_type, left_paren_token.span.start())
  237|       |                } else {
  238|       |                    // This is a cast expression: (type-name)expression
  239|     11|                    let dummy_right_paren = Token {
  240|     11|                        kind: TokenKind::RightParen,
  241|     11|                        span: SourceSpan::new(left_paren_token.span.end(), left_paren_token.span.end()),
  242|     11|                    };
  243|     11|                    parser.parse_cast_expression_from_type_and_paren(parsed_type, dummy_right_paren)
  244|       |                }
  245|     14|            } else if parser.is_token(TokenKind::LeftBrace) {
  246|       |                // This is a GNU statement expression: ({ ... })
  247|      1|                parse_gnu_statement_expression(parser, left_paren_token.span.start())
  248|       |            } else {
  249|       |                // Regular parenthesized expression
  250|     13|                let expr = parser.parse_expr_min()?;
                                                                ^0
  251|     13|                parser.expect(TokenKind::RightParen)?;
                                                                  ^0
  252|     13|                Ok(expr)
  253|       |            }
  254|       |        }
  255|       |        TokenKind::Plus
  256|       |        | TokenKind::Minus
  257|       |        | TokenKind::Not
  258|       |        | TokenKind::Tilde
  259|       |        | TokenKind::Increment
  260|       |        | TokenKind::Decrement
  261|       |        | TokenKind::Star
  262|     80|        | TokenKind::And => parse_unary_operator(parser, token),
  263|     14|        TokenKind::Generic => parse_generic_selection(parser),
  264|      0|        TokenKind::Alignof => parse_alignof(parser),
  265|       |        TokenKind::Sizeof => {
  266|     19|            debug!(
  267|      0|                "parse_prefix: parsing sizeof expression at position {}",
  268|       |                parser.current_idx
  269|       |            );
  270|     19|            parse_sizeof(parser)
  271|       |        }
  272|      0|        TokenKind::BuiltinVaArg => parse_builtin_va_arg(parser),
  273|      0|        TokenKind::BuiltinVaStart => parse_builtin_va_start(parser),
  274|      0|        TokenKind::BuiltinVaEnd => parse_builtin_va_end(parser),
  275|      0|        TokenKind::BuiltinVaCopy => parse_builtin_va_copy(parser),
  276|       |        _ => {
  277|      0|            let expected = "identifier, integer, float, string, char, or '('";
  278|      0|            Err(ParseError::UnexpectedToken {
  279|      0|                expected_tokens: expected.to_string(),
  280|      0|                found: token.kind,
  281|      0|                span: token.span,
  282|      0|            })
  283|       |        }
  284|       |    }
  285|  1.96k|}
  286|       |
  287|       |/// Parse unary operator
  288|     80|fn parse_unary_operator(parser: &mut Parser, token: Token) -> Result<ParsedNodeRef, ParseError> {
  289|     80|    let op = match token.kind {
  290|      1|        TokenKind::Plus => UnaryOp::Plus,
  291|     10|        TokenKind::Minus => UnaryOp::Minus,
  292|      4|        TokenKind::Not => UnaryOp::LogicNot,
  293|      2|        TokenKind::Tilde => UnaryOp::BitNot,
  294|      3|        TokenKind::Increment => UnaryOp::PreIncrement,
  295|      2|        TokenKind::Decrement => UnaryOp::PreDecrement,
  296|      5|        TokenKind::Star => UnaryOp::Deref,
  297|     53|        TokenKind::And => UnaryOp::AddrOf,
  298|       |        _ => {
  299|      0|            return Err(ParseError::InvalidUnaryOperator { span: token.span });
  300|       |        }
  301|       |    };
  302|       |
  303|     80|    parser.advance();
  304|     80|    let operand_node = parser.parse_expr_bp(BindingPower::UNARY)?;
                                                                              ^0
  305|     80|    let span = SourceSpan::new(token.span.start(), parser.ast.get_node(operand_node).span.end());
  306|     80|    let node = parser.push_node(ParsedNodeKind::UnaryOp(op, operand_node), span);
  307|     80|    Ok(node)
  308|     80|}
  309|       |
  310|       |/// Parse infix operator
  311|    288|fn parse_infix(
  312|    288|    parser: &mut Parser,
  313|    288|    left: ParsedNodeRef,
  314|    288|    operator_token: Token,
  315|    288|    min_bp: BindingPower,
  316|    288|) -> Result<ParsedNodeRef, ParseError> {
  317|    288|    debug!(
  318|      0|        "parse_infix: processing operator {:?} at {}",
  319|       |        operator_token.kind, operator_token.span
  320|       |    );
  321|       |
  322|       |    // For all binary operators, parse the right operand
  323|    288|    let right_node = parser.parse_expression(min_bp)?;
                                                                  ^0
  324|       |
  325|    288|    let op = match operator_token.kind {
  326|     39|        TokenKind::Plus => BinaryOp::Add,
  327|     12|        TokenKind::Minus => BinaryOp::Sub,
  328|      7|        TokenKind::Star => BinaryOp::Mul,
  329|      1|        TokenKind::Slash => BinaryOp::Div,
  330|      2|        TokenKind::Percent => BinaryOp::Mod,
  331|      9|        TokenKind::Equal => BinaryOp::Equal,
  332|     34|        TokenKind::NotEqual => BinaryOp::NotEqual,
  333|     49|        TokenKind::Less => BinaryOp::Less,
  334|     31|        TokenKind::Greater => BinaryOp::Greater,
  335|      1|        TokenKind::LessEqual => BinaryOp::LessEqual,
  336|      1|        TokenKind::GreaterEqual => BinaryOp::GreaterEqual,
  337|      0|        TokenKind::And => BinaryOp::BitAnd,
  338|      0|        TokenKind::Or => BinaryOp::BitOr,
  339|      0|        TokenKind::Xor => BinaryOp::BitXor,
  340|      0|        TokenKind::LeftShift => BinaryOp::LShift,
  341|      0|        TokenKind::RightShift => BinaryOp::RShift,
  342|      1|        TokenKind::LogicAnd => BinaryOp::LogicAnd,
  343|      6|        TokenKind::LogicOr => BinaryOp::LogicOr,
  344|     83|        TokenKind::Assign => BinaryOp::Assign,
  345|      3|        TokenKind::PlusAssign => BinaryOp::AssignAdd,
  346|      3|        TokenKind::MinusAssign => BinaryOp::AssignSub,
  347|      1|        TokenKind::StarAssign => BinaryOp::AssignMul,
  348|      1|        TokenKind::DivAssign => BinaryOp::AssignDiv,
  349|      1|        TokenKind::ModAssign => BinaryOp::AssignMod,
  350|      0|        TokenKind::AndAssign => BinaryOp::AssignBitAnd,
  351|      0|        TokenKind::OrAssign => BinaryOp::AssignBitOr,
  352|      0|        TokenKind::XorAssign => BinaryOp::AssignBitXor,
  353|      0|        TokenKind::LeftShiftAssign => BinaryOp::AssignLShift,
  354|      0|        TokenKind::RightShiftAssign => BinaryOp::AssignRShift,
  355|      3|        TokenKind::Comma => BinaryOp::Comma,
  356|       |        // Postfix operators are handled in `parse_expression` and should not reach here.
  357|       |        _ => {
  358|      0|            return Err(ParseError::UnexpectedToken {
  359|      0|                expected_tokens: "binary operator".to_string(),
  360|      0|                found: operator_token.kind,
  361|      0|                span: operator_token.span,
  362|      0|            });
  363|       |        }
  364|       |    };
  365|       |
  366|    288|    let span = SourceSpan::new(
  367|    288|        parser.ast.get_node(left).span.start(),
  368|    288|        parser.ast.get_node(right_node).span.end(),
  369|       |    );
  370|       |
  371|    288|    let node = if op.is_assignment() {
  372|     92|        parser.push_node(ParsedNodeKind::Assignment(op, left, right_node), span)
  373|       |    } else {
  374|    196|        parser.push_node(ParsedNodeKind::BinaryOp(op, left, right_node), span)
  375|       |    };
  376|    288|    Ok(node)
  377|    288|}
  378|       |
  379|       |/// Parse GNU statement expression: ({ compound-statement })
  380|      1|fn parse_gnu_statement_expression(parser: &mut Parser, start_loc: SourceLoc) -> Result<ParsedNodeRef, ParseError> {
  381|      1|    debug!("parse_gnu_statement_expression: parsing GNU statement expression");
                         ^0
  382|       |
  383|       |    // Parse the compound statement (parse_compound_statement expects LeftBrace)
  384|      1|    let (compound_stmt, _) = super::statements::parse_compound_statement(parser)?;
                                                                                              ^0
  385|       |
  386|       |    // Expect the closing parenthesis
  387|      1|    let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                              ^0
  388|       |
  389|       |    // For GNU statement expressions, the result is the last expression in the compound statement
  390|       |    // We need to extract it from the compound statement
  391|      1|    let result_expr = extract_last_expression_from_compound_statement(parser, compound_stmt);
  392|       |
  393|      1|    let end_loc = right_paren_token.span.end();
  394|      1|    let span = SourceSpan::new(start_loc, end_loc);
  395|       |
  396|      1|    let node = parser.push_node(ParsedNodeKind::GnuStatementExpression(compound_stmt, result_expr), span);
  397|      1|    debug!("parse_gnu_statement_expression: successfully parsed GNU statement expression");
                         ^0
  398|      1|    Ok(node)
  399|      1|}
  400|       |
  401|       |/// Extract the last expression from a compound statement for GNU statement expressions
  402|      1|fn extract_last_expression_from_compound_statement(
  403|      1|    parser: &mut Parser,
  404|      1|    compound_stmt_node_ref: ParsedNodeRef,
  405|      1|) -> ParsedNodeRef {
  406|       |    // Get the compound statement node
  407|      1|    let compound_stmt_node = parser.ast.get_node(compound_stmt_node_ref);
  408|       |
  409|      1|    if let ParsedNodeKind::CompoundStatement(statements) = &compound_stmt_node.kind {
  410|       |        // Find the last expression statement in the compound statement
  411|      1|        for &stmt_ref in statements.iter().rev() {
  412|      1|            let stmt_node = parser.ast.get_node(stmt_ref);
  413|      1|            if let ParsedNodeKind::ExpressionStatement(Some(expr)) = &stmt_node.kind {
  414|      1|                return *expr;
  415|      0|            }
  416|       |        }
  417|       |
  418|       |        // If no expression statement found, create a dummy expression
  419|       |        // This shouldn't happen in valid GNU statement expressions
  420|      0|        let dummy_expr = parser.push_node(ParsedNodeKind::Dummy, compound_stmt_node.span);
  421|      0|        return dummy_expr;
  422|      0|    }
  423|       |
  424|       |    // Fallback: create a dummy expression
  425|      0|    parser.push_node(ParsedNodeKind::Dummy, compound_stmt_node.span)
  426|      1|}
  427|       |
  428|       |/// Parse function call
  429|    120|fn parse_function_call(parser: &mut Parser, function: ParsedNodeRef) -> Result<ParsedNodeRef, ParseError> {
  430|    120|    debug!("parse_function_call: parsing function call with LeftParen");
                         ^0
  431|       |
  432|       |    // Parse the argument list using the utility function
  433|    120|    let args = super::utils::expr_patterns::parse_expr_list(parser, BindingPower::ASSIGNMENT)?;
                                                                                                           ^0
  434|       |
  435|    120|    let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                              ^0
  436|    120|    debug!(
  437|      0|        "parse_function_call: successfully parsed function call with {} arguments",
  438|      0|        args.len()
  439|       |    );
  440|       |
  441|    120|    let span = SourceSpan::new(parser.ast.get_node(function).span.start(), right_paren_token.span.end());
  442|    120|    let node = parser.push_node(ParsedNodeKind::FunctionCall(function, args), span);
  443|    120|    Ok(node)
  444|    120|}
  445|       |
  446|       |/// Parse array index access
  447|     30|fn parse_index_access(parser: &mut Parser, array: ParsedNodeRef) -> Result<ParsedNodeRef, ParseError> {
  448|     30|    debug!("parse_index_access: parsing array index");
                         ^0
  449|       |
  450|       |    // The `[` token has already been consumed by the caller (`parse_infix`).
  451|       |    // We are now at the start of the index expression.
  452|     30|    let index_node = parser.parse_expr_min()?;
                                                          ^0
  453|       |
  454|     30|    let right_bracket_token = parser.expect(TokenKind::RightBracket)?;
                                                                                  ^0
  455|     30|    debug!(
  456|      0|        "parse_index_access: parsed closing bracket, current token now {:?}",
  457|      0|        parser.current_token_kind()
  458|       |    );
  459|       |
  460|     30|    let span = SourceSpan::new(parser.ast.get_node(array).span.start(), right_bracket_token.span.end());
  461|     30|    let node = parser.push_node(ParsedNodeKind::IndexAccess(array, index_node), span);
  462|     30|    Ok(node)
  463|     30|}
  464|       |
  465|       |/// Parse member access
  466|     57|fn parse_member_access(
  467|     57|    parser: &mut Parser,
  468|     57|    object: ParsedNodeRef,
  469|     57|    is_arrow: bool,
  470|     57|) -> Result<ParsedNodeRef, ParseError> {
  471|     57|    let (symbol, span) = parser.expect_name()?;
                                                           ^0
  472|     57|    let span = SourceSpan::new(parser.ast.get_node(object).span.start(), span.end());
  473|     57|    let node = parser.push_node(ParsedNodeKind::MemberAccess(object, symbol, is_arrow), span);
  474|     57|    Ok(node)
  475|     57|}
  476|       |
  477|       |/// Parse postfix increment
  478|     31|fn parse_postfix_increment(
  479|     31|    parser: &mut Parser,
  480|     31|    operand: ParsedNodeRef,
  481|     31|    operator_token: Token,
  482|     31|) -> Result<ParsedNodeRef, ParseError> {
  483|     31|    let span = SourceSpan::new(parser.ast.get_node(operand).span.start(), operator_token.span.end());
  484|     31|    let node = parser.push_node(ParsedNodeKind::PostIncrement(operand), span);
  485|     31|    Ok(node)
  486|     31|}
  487|       |
  488|       |/// Parse postfix decrement
  489|     17|fn parse_postfix_decrement(
  490|     17|    parser: &mut Parser,
  491|     17|    operand: ParsedNodeRef,
  492|     17|    operator_token: Token,
  493|     17|) -> Result<ParsedNodeRef, ParseError> {
  494|     17|    let span = SourceSpan::new(parser.ast.get_node(operand).span.start(), operator_token.span.end());
  495|     17|    let node = parser.push_node(ParsedNodeKind::PostDecrement(operand), span);
  496|     17|    Ok(node)
  497|     17|}
  498|       |
  499|       |/// Parse _Generic selection (C11)
  500|     14|fn parse_generic_selection(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  501|     14|    let token = parser.expect(TokenKind::Generic)?;
                                                               ^0
  502|     14|    let start_loc = token.span.start();
  503|       |
  504|     14|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  505|       |
  506|       |    // The controlling expression is an assignment-expression, so we parse with ASSIGNMENT binding power.
  507|     14|    let controlling_expr = parser.parse_expr_bp(BindingPower::ASSIGNMENT)?;
                                                                                       ^0
  508|       |
  509|     14|    parser.expect(TokenKind::Comma)?;
                                                 ^0
  510|       |
  511|       |    // Reserve slot for the generic selection node so that any nested parsing
  512|       |    // that might push nodes won't accidentally observe an unstable index.
  513|     14|    let dummy = parser.push_dummy();
  514|       |
  515|     14|    let mut associations: Vec<ParsedGenericAssociation> = Vec::new();
  516|       |
  517|       |    loop {
  518|     28|        let type_name = if parser.accept(TokenKind::Default).is_some() {
                          ^27
  519|      9|            None
  520|       |        } else {
  521|     19|            let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                              ^18                                                                     ^1
  522|     18|            Some(parsed_type)
  523|       |        };
  524|       |
  525|     27|        parser.expect(TokenKind::Colon)?;
                                                     ^0
  526|       |
  527|     27|        let result_expr = parser.parse_expression(BindingPower::COMMA)?;
                                                                                    ^0
  528|       |
  529|     27|        associations.push(ParsedGenericAssociation { type_name, result_expr });
  530|       |
  531|     27|        if !parser.is_token(TokenKind::Comma) {
  532|     13|            break;
  533|     14|        }
  534|     14|        parser.advance(); // consume comma
  535|       |    }
  536|       |
  537|     13|    let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                              ^0
  538|     13|    let end_loc = right_paren_token.span.end();
  539|     13|    let span = SourceSpan::new(start_loc, end_loc);
  540|       |
  541|     13|    let node = parser.replace_node(
  542|     13|        dummy,
  543|     13|        ParsedNodeKind::GenericSelection(controlling_expr, associations),
  544|     13|        span,
  545|       |    );
  546|     13|    Ok(node)
  547|     14|}
  548|       |
  549|       |/// Parse compound literal given the type and start location
  550|      2|pub(crate) fn parse_compound_literal_from_type_and_start(
  551|      2|    parser: &mut Parser,
  552|      2|    parsed_type: ParsedType,
  553|      2|    start_loc: SourceLoc,
  554|      2|) -> Result<ParsedNodeRef, ParseError> {
  555|      2|    let initializer_ref = super::declaration_core::parse_initializer(parser)?;
                                                                                          ^0
  556|       |
  557|      2|    let end_loc = parser.current_token_span()?.end();
                                                           ^0
  558|      2|    let span = SourceSpan::new(start_loc, end_loc);
  559|      2|    let node = parser.push_node(ParsedNodeKind::CompoundLiteral(parsed_type, initializer_ref), span);
  560|      2|    Ok(node)
  561|      2|}
  562|       |
  563|       |/// Parse sizeof expression or type
  564|     19|fn parse_sizeof(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  565|     19|    let token = parser.expect(TokenKind::Sizeof)?;
                                                              ^0
  566|     19|    let start_loc = token.span.start();
  567|       |
  568|     19|    let node = if parser.accept(TokenKind::LeftParen).is_some() {
  569|     17|        debug!(
  570|      0|            "parse_sizeof: found '(', now at position {}, token {:?}",
  571|       |            parser.current_idx,
  572|      0|            parser.current_token_kind()
  573|       |        );
  574|       |
  575|       |        // Check if it's a type name or expression
  576|     17|        if parser.is_type_name_start() {
  577|      5|            debug!("parse_sizeof: detected type name start, parsing type name");
                                 ^0
  578|      5|            let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                                      ^0
  579|      5|            debug!(
  580|      0|                "parse_sizeof: parsed type name, now at position {}, token {:?}",
  581|       |                parser.current_idx,
  582|      0|                parser.current_token_kind()
  583|       |            );
  584|       |
  585|      5|            let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                                      ^0
  586|       |
  587|      5|            let end_loc = right_paren_token.span.end();
  588|      5|            let span = SourceSpan::new(start_loc, end_loc);
  589|       |
  590|      5|            debug!("parse_sizeof: successfully parsed sizeof(type)");
                                 ^0
  591|      5|            parser.push_node(ParsedNodeKind::SizeOfType(parsed_type), span)
  592|       |        } else {
  593|     12|            debug!("parse_sizeof: detected expression, parsing expression");
                                 ^0
  594|     12|            let expr = parser.parse_expr_min()?;
                                                            ^0
  595|     12|            let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                                      ^0
  596|       |
  597|     12|            let end_loc = right_paren_token.span.end();
  598|     12|            let span = SourceSpan::new(start_loc, end_loc);
  599|       |
  600|     12|            debug!("parse_sizeof: successfully parsed sizeof(expression)");
                                 ^0
  601|     12|            parser.push_node(ParsedNodeKind::SizeOfExpr(expr), span)
  602|       |        }
  603|       |    } else {
  604|      2|        debug!("parse_sizeof: no '(', parsing unary expression");
                             ^0
  605|      2|        let expr = parser.parse_expr_bp(BindingPower::UNARY)?;
                                                                          ^0
  606|       |
  607|      2|        let end_loc = parser.ast.get_node(expr).span.end();
  608|      2|        let span = SourceSpan::new(start_loc, end_loc);
  609|       |
  610|      2|        debug!("parse_sizeof: successfully parsed sizeof unary expression");
                             ^0
  611|      2|        parser.push_node(ParsedNodeKind::SizeOfExpr(expr), span)
  612|       |    };
  613|       |
  614|     19|    Ok(node)
  615|     19|}
  616|       |
  617|       |/// Parse _Alignof (C11)
  618|      0|fn parse_alignof(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  619|      0|    let token = parser.expect(TokenKind::Alignof)?;
  620|      0|    let start_loc = token.span.start();
  621|       |
  622|      0|    parser.expect(TokenKind::LeftParen)?;
  623|       |
  624|      0|    let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
  625|      0|    let right_paren_token = parser.expect(TokenKind::RightParen)?;
  626|       |
  627|      0|    let end_loc = right_paren_token.span.end();
  628|       |
  629|      0|    let span = SourceSpan::new(start_loc, end_loc);
  630|       |
  631|       |    // Use ParsedAlignOf for the parser phase
  632|      0|    let node = parser.push_node(ParsedNodeKind::AlignOf(parsed_type), span);
  633|      0|    Ok(node)
  634|      0|}
  635|       |
  636|       |/// Check if a cast expression starts at the current position
  637|       |/// This is called after consuming an opening parenthesis
  638|     27|pub(crate) fn is_cast_expression_start(parser: &Parser) -> bool {
  639|       |    //  Bolt: This is much more efficient than the old lookahead implementation.
  640|       |    // It avoids a manual loop over the token stream by using the centralized
  641|       |    // `is_type_name_start` helper, which performs a simple and fast check
  642|       |    // on the current token.
  643|     27|    parser.is_type_name_start()
  644|     27|}
  645|       |
  646|       |/// Parse cast expression given the already parsed type and right paren token
  647|     11|pub(crate) fn parse_cast_expression_from_type_and_paren(
  648|     11|    parser: &mut Parser,
  649|     11|    parsed_type: ParsedType,
  650|     11|    right_paren_token: Token,
  651|     11|) -> Result<ParsedNodeRef, ParseError> {
  652|       |    // Parse the expression being cast
  653|     11|    let expr_node = parser.parse_expr_bp(BindingPower::CAST)?;
                                                                          ^0
  654|       |
  655|     11|    let span = SourceSpan::new(
  656|     11|        right_paren_token.span.start(), // Start from the opening paren
  657|     11|        parser.ast.get_node(expr_node).span.end(),
  658|       |    );
  659|       |
  660|     11|    let node = parser.push_node(ParsedNodeKind::Cast(parsed_type, expr_node), span);
  661|       |
  662|     11|    debug!("parse_cast_expression: successfully parsed cast expression");
                         ^0
  663|     11|    Ok(node)
  664|     11|}
  665|       |
  666|       |/// Parse __builtin_va_arg(expr, type)
  667|      0|fn parse_builtin_va_arg(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  668|      0|    let token = parser.expect(TokenKind::BuiltinVaArg)?;
  669|      0|    let start_loc = token.span.start();
  670|       |
  671|      0|    parser.expect(TokenKind::LeftParen)?;
  672|       |
  673|       |    // Parse expression (ap)
  674|      0|    let expr = parser.parse_expr_assignment()?;
  675|       |
  676|      0|    parser.expect(TokenKind::Comma)?;
  677|       |
  678|       |    // Parse type
  679|      0|    let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
  680|       |
  681|      0|    let right_paren = parser.expect(TokenKind::RightParen)?;
  682|      0|    let end_loc = right_paren.span.end();
  683|      0|    let span = SourceSpan::new(start_loc, end_loc);
  684|       |
  685|      0|    let node = parser.push_node(ParsedNodeKind::BuiltinVaArg(parsed_type, expr), span);
  686|      0|    Ok(node)
  687|      0|}
  688|       |
  689|       |/// Parse __builtin_va_start(ap, last_param)
  690|      0|fn parse_builtin_va_start(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  691|      0|    let token = parser.expect(TokenKind::BuiltinVaStart)?;
  692|      0|    let start_loc = token.span.start();
  693|       |
  694|      0|    parser.expect(TokenKind::LeftParen)?;
  695|       |
  696|      0|    let ap = parser.parse_expr_assignment()?;
  697|      0|    parser.expect(TokenKind::Comma)?;
  698|      0|    let last = parser.parse_expr_assignment()?;
  699|       |
  700|      0|    let right_paren = parser.expect(TokenKind::RightParen)?;
  701|      0|    let end_loc = right_paren.span.end();
  702|      0|    let span = SourceSpan::new(start_loc, end_loc);
  703|       |
  704|      0|    let node = parser.push_node(ParsedNodeKind::BuiltinVaStart(ap, last), span);
  705|      0|    Ok(node)
  706|      0|}
  707|       |
  708|       |/// Parse __builtin_va_end(ap)
  709|      0|fn parse_builtin_va_end(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  710|      0|    let token = parser.expect(TokenKind::BuiltinVaEnd)?;
  711|      0|    let start_loc = token.span.start();
  712|       |
  713|      0|    parser.expect(TokenKind::LeftParen)?;
  714|       |
  715|      0|    let ap = parser.parse_expr_assignment()?;
  716|       |
  717|      0|    let right_paren = parser.expect(TokenKind::RightParen)?;
  718|      0|    let end_loc = right_paren.span.end();
  719|      0|    let span = SourceSpan::new(start_loc, end_loc);
  720|       |
  721|      0|    let node = parser.push_node(ParsedNodeKind::BuiltinVaEnd(ap), span);
  722|      0|    Ok(node)
  723|      0|}
  724|       |
  725|       |/// Parse __builtin_va_copy(dst, src)
  726|      0|fn parse_builtin_va_copy(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  727|      0|    let token = parser.expect(TokenKind::BuiltinVaCopy)?;
  728|      0|    let start_loc = token.span.start();
  729|       |
  730|      0|    parser.expect(TokenKind::LeftParen)?;
  731|       |
  732|      0|    let dst = parser.parse_expr_assignment()?;
  733|      0|    parser.expect(TokenKind::Comma)?;
  734|      0|    let src = parser.parse_expr_assignment()?;
  735|       |
  736|      0|    let right_paren = parser.expect(TokenKind::RightParen)?;
  737|      0|    let end_loc = right_paren.span.end();
  738|      0|    let span = SourceSpan::new(start_loc, end_loc);
  739|       |
  740|      0|    let node = parser.push_node(ParsedNodeKind::BuiltinVaCopy(dst, src), span);
  741|      0|    Ok(node)
  742|      0|}

/app/src/parser/parsed_type_builder.rs:
    1|       |//! ParsedType builder functions for the parser phase.
    2|       |//!
    3|       |//! This module provides helper functions to build ParsedType objects
    4|       |//! from declaration specifiers and declarators during the parsing phase.
    5|       |//! These functions ensure that no semantic types (TypeRef) are created
    6|       |//! during parsing, only syntactic types (ParsedType).
    7|       |
    8|       |use crate::ast::*;
    9|       |use crate::diagnostic::ParseError;
   10|       |use crate::semantic::TypeQualifiers;
   11|       |use thin_vec::ThinVec;
   12|       |
   13|       |use super::Parser;
   14|       |
   15|       |/// Build a ParsedType from declaration specifiers and an optional declarator
   16|     41|pub(crate) fn build_parsed_type_from_specifiers(
   17|     41|    parser: &mut Parser,
   18|     41|    specifiers: &ThinVec<ParsedDeclSpecifier>,
   19|     41|    declarator: Option<&ParsedDeclarator>,
   20|     41|) -> Result<ParsedType, ParseError> {
   21|     41|    let (base_type_ref, qualifiers) = parse_base_type_and_qualifiers(parser, specifiers)?;
                                                                                                      ^0
   22|       |
   23|     41|    let declarator_ref = if let Some(d) = declarator {
                                                   ^10
   24|     10|        build_parsed_declarator(parser, d)?
                                                        ^0
   25|       |    } else {
   26|     31|        parser
   27|     31|            .ast
   28|     31|            .parsed_types
   29|     31|            .alloc_decl(ParsedDeclaratorNode::Identifier { name: None })
   30|       |    };
   31|       |
   32|     41|    Ok(ParsedType {
   33|     41|        base: base_type_ref,
   34|     41|        declarator: declarator_ref,
   35|     41|        qualifiers,
   36|     41|    })
   37|     41|}
   38|       |
   39|       |/// Parse base type and qualifiers from declaration specifiers
   40|     41|fn parse_base_type_and_qualifiers(
   41|     41|    parser: &mut Parser,
   42|     41|    specifiers: &ThinVec<ParsedDeclSpecifier>,
   43|     41|) -> Result<(ParsedBaseTypeRef, TypeQualifiers), ParseError> {
   44|     41|    let mut qualifiers = TypeQualifiers::empty();
   45|     41|    let mut base_type_node = None;
   46|       |
   47|     86|    for spec in specifiers {
                      ^45
   48|     45|        match spec {
   49|     41|            ParsedDeclSpecifier::TypeSpecifier(ts) => {
   50|     41|                let parsed_base = parse_type_specifier_to_parsed_base(parser, ts)?;
                                                                                               ^0
   51|     41|                base_type_node = Some(parsed_base);
   52|       |            }
   53|      3|            ParsedDeclSpecifier::TypeQualifier(q) => {
   54|      3|                let qualifier = match q {
   55|      3|                    crate::ast::nodes::TypeQualifier::Const => TypeQualifiers::CONST,
   56|      0|                    crate::ast::nodes::TypeQualifier::Volatile => TypeQualifiers::VOLATILE,
   57|      0|                    crate::ast::nodes::TypeQualifier::Restrict => TypeQualifiers::RESTRICT,
   58|      0|                    crate::ast::nodes::TypeQualifier::Atomic => TypeQualifiers::ATOMIC,
   59|       |                };
   60|      3|                qualifiers |= qualifier;
   61|       |            }
   62|      1|            _ => {
   63|      1|                // Other specifiers (storage class, function specifiers, etc.)
   64|      1|                // are handled elsewhere and don't affect the base type
   65|      1|            }
   66|       |        }
   67|       |    }
   68|       |
   69|     41|    let base_type_ref = base_type_node.unwrap_or_else(|| {
                                                                       ^0
   70|       |        // Default to int if no type specifier found
   71|      0|        parser
   72|      0|            .ast
   73|      0|            .parsed_types
   74|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Int))
   75|      0|    });
   76|       |
   77|     41|    Ok((base_type_ref, qualifiers))
   78|     41|}
   79|       |
   80|       |/// Convert a TypeSpecifier to a ParsedBaseTypeNode
   81|     41|fn parse_type_specifier_to_parsed_base(
   82|     41|    parser: &mut Parser,
   83|     41|    ts: &ParsedTypeSpecifier,
   84|     41|) -> Result<ParsedBaseTypeRef, ParseError> {
   85|     41|    match ts {
   86|      5|        ParsedTypeSpecifier::Void => Ok(parser
   87|      5|            .ast
   88|      5|            .parsed_types
   89|      5|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Void))),
   90|      2|        ParsedTypeSpecifier::Char => Ok(parser
   91|      2|            .ast
   92|      2|            .parsed_types
   93|      2|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Char))),
   94|      0|        ParsedTypeSpecifier::Short => Ok(parser
   95|      0|            .ast
   96|      0|            .parsed_types
   97|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Short))),
   98|     27|        ParsedTypeSpecifier::Int => Ok(parser
   99|     27|            .ast
  100|     27|            .parsed_types
  101|     27|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Int))),
  102|      2|        ParsedTypeSpecifier::Long => Ok(parser
  103|      2|            .ast
  104|      2|            .parsed_types
  105|      2|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Long))),
  106|      0|        ParsedTypeSpecifier::LongLong => Ok(parser
  107|      0|            .ast
  108|      0|            .parsed_types
  109|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::LongLong))),
  110|      0|        ParsedTypeSpecifier::Float => Ok(parser
  111|      0|            .ast
  112|      0|            .parsed_types
  113|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Float))),
  114|      1|        ParsedTypeSpecifier::Double => Ok(parser
  115|      1|            .ast
  116|      1|            .parsed_types
  117|      1|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Double))),
  118|      0|        ParsedTypeSpecifier::LongDouble => Ok(parser
  119|      0|            .ast
  120|      0|            .parsed_types
  121|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::LongDouble))),
  122|      0|        ParsedTypeSpecifier::Signed => Ok(parser
  123|      0|            .ast
  124|      0|            .parsed_types
  125|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Signed))),
  126|      0|        ParsedTypeSpecifier::Unsigned => Ok(parser
  127|      0|            .ast
  128|      0|            .parsed_types
  129|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Unsigned))),
  130|      0|        ParsedTypeSpecifier::Bool => Ok(parser
  131|      0|            .ast
  132|      0|            .parsed_types
  133|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Bool))),
  134|      0|        ParsedTypeSpecifier::Complex => Ok(parser
  135|      0|            .ast
  136|      0|            .parsed_types
  137|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Complex))),
  138|      0|        ParsedTypeSpecifier::Atomic(parsed_type) => {
  139|       |            // _Atomic(type-name) - the parsed_type already contains the parsed inner type
  140|      0|            Ok(parser
  141|      0|                .ast
  142|      0|                .parsed_types
  143|      0|                .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Atomic(*parsed_type))))
  144|       |        }
  145|      3|        ParsedTypeSpecifier::Record(is_union, tag, definition) => {
  146|      3|            let members = if let Some(def_data) = definition {
                                                    ^0
  147|      0|                if let Some(member_decls) = &def_data.members {
  148|      0|                    let mut parsed_members = Vec::new();
  149|      0|                    for decl in member_decls {
  150|       |                        // Parse each member declaration
  151|      0|                        for init_decl in &decl.init_declarators {
  152|      0|                            if let Some(member_name) = super::declarator::get_declarator_name(&init_decl.declarator) {
  153|      0|                                let member_parsed_type = build_parsed_type_from_specifiers(
  154|      0|                                    parser,
  155|      0|                                    &decl.specifiers,
  156|      0|                                    Some(&init_decl.declarator),
  157|      0|                                )?;
  158|       |
  159|      0|                                parsed_members.push(ParsedStructMember {
  160|      0|                                    name: Some(member_name),
  161|      0|                                    ty: member_parsed_type,
  162|      0|                                    bit_field_size: None,
  163|      0|                                    span: init_decl.span,
  164|      0|                                });
  165|      0|                            }
  166|       |                        }
  167|       |                    }
  168|      0|                    Some(parser.ast.parsed_types.alloc_struct_members(parsed_members))
  169|       |                } else {
  170|      0|                    None
  171|       |                }
  172|       |            } else {
  173|      3|                None
  174|       |            };
  175|       |
  176|      3|            Ok(parser.ast.parsed_types.alloc_base_type(ParsedBaseTypeNode::Record {
  177|      3|                tag: *tag,
  178|      3|                members,
  179|      3|                is_union: *is_union,
  180|      3|            }))
  181|       |        }
  182|      1|        ParsedTypeSpecifier::Enum(tag, enumerators) => {
  183|      1|            let parsed_enumerators = if let Some(enum_node_refs) = enumerators {
  184|      1|                let mut parsed_enums = Vec::new();
  185|      2|                for &enum_ref in enum_node_refs {
                                   ^1
  186|      1|                    let enum_node = parser.ast.get_node(enum_ref);
  187|      1|                    if let ParsedNodeKind::EnumConstant(name, value_expr_ref) = &enum_node.kind {
  188|      1|                        parsed_enums.push(ParsedEnumConstant {
  189|      1|                            name: *name,
  190|      1|                            value: value_expr_ref.as_ref().and_then(|expr_ref| {
  191|       |                                // Try to evaluate constant expression
  192|      0|                                if let ParsedNodeKind::Literal(literal::Literal::Int { val, .. }) =
  193|      1|                                    parser.ast.get_node(*expr_ref).kind
  194|       |                                {
  195|      0|                                    Some(val)
  196|       |                                } else {
  197|      1|                                    None
  198|       |                                }
  199|      1|                            }),
  200|      1|                            span: enum_node.span,
  201|       |                        });
  202|      0|                    }
  203|       |                }
  204|      1|                Some(parser.ast.parsed_types.alloc_enum_constants(parsed_enums))
  205|       |            } else {
  206|      0|                None
  207|       |            };
  208|       |
  209|      1|            Ok(parser.ast.parsed_types.alloc_base_type(ParsedBaseTypeNode::Enum {
  210|      1|                tag: *tag,
  211|      1|                enumerators: parsed_enumerators,
  212|      1|            }))
  213|       |        }
  214|      0|        ParsedTypeSpecifier::TypedefName(name) => Ok(parser
  215|      0|            .ast
  216|      0|            .parsed_types
  217|      0|            .alloc_base_type(ParsedBaseTypeNode::Typedef(*name))),
  218|       |    }
  219|     41|}
  220|       |
  221|       |/// Build a ParsedDeclaratorNode from a ParsedDeclarator
  222|     22|fn build_parsed_declarator(parser: &mut Parser, declarator: &ParsedDeclarator) -> Result<ParsedDeclRef, ParseError> {
  223|     22|    match declarator {
  224|      0|        ParsedDeclarator::Identifier(name, qualifiers) => {
  225|       |            // Simple identifier with optional qualifiers
  226|      0|            if qualifiers.is_empty() {
  227|      0|                Ok(parser
  228|      0|                    .ast
  229|      0|                    .parsed_types
  230|      0|                    .alloc_decl(ParsedDeclaratorNode::Identifier { name: Some(*name) }))
  231|       |            } else {
  232|       |                // Create a pointer declarator with the qualifiers
  233|      0|                let inner = parser
  234|      0|                    .ast
  235|      0|                    .parsed_types
  236|      0|                    .alloc_decl(ParsedDeclaratorNode::Identifier { name: Some(*name) });
  237|      0|                Ok(parser.ast.parsed_types.alloc_decl(ParsedDeclaratorNode::Pointer {
  238|      0|                    qualifiers: *qualifiers,
  239|      0|                    inner,
  240|      0|                }))
  241|       |            }
  242|       |        }
  243|     10|        ParsedDeclarator::Pointer(ptr_qualifiers, inner_decl) => {
  244|     10|            let inner_ref = if let Some(inner) = inner_decl {
  245|     10|                build_parsed_declarator(parser, inner)?
                                                                    ^0
  246|       |            } else {
  247|      0|                parser
  248|      0|                    .ast
  249|      0|                    .parsed_types
  250|      0|                    .alloc_decl(ParsedDeclaratorNode::Identifier { name: None })
  251|       |            };
  252|       |
  253|     10|            Ok(parser.ast.parsed_types.alloc_decl(ParsedDeclaratorNode::Pointer {
  254|     10|                qualifiers: *ptr_qualifiers,
  255|     10|                inner: inner_ref,
  256|     10|            }))
  257|       |        }
  258|      0|        ParsedDeclarator::Array(inner, size) => {
  259|      0|            let inner_ref = build_parsed_declarator(parser, inner)?;
  260|       |
  261|      0|            Ok(parser.ast.parsed_types.alloc_decl(ParsedDeclaratorNode::Array {
  262|      0|                size: size.clone(),
  263|      0|                inner: inner_ref,
  264|      0|            }))
  265|       |        }
  266|       |        ParsedDeclarator::Function {
  267|      2|            inner,
  268|      2|            params,
  269|      2|            is_variadic,
  270|       |        } => {
  271|      2|            let inner_ref = build_parsed_declarator(parser, inner)?;
                                                                                ^0
  272|       |
  273|       |            // Parse parameters
  274|      2|            let mut parsed_params = Vec::new();
  275|      3|            for param in params {
                              ^1
  276|      1|                let param_parsed_type =
  277|      1|                    build_parsed_type_from_specifiers(parser, &param.specifiers, param.declarator.as_ref())?;
                                                                                                                         ^0
  278|       |
  279|      1|                parsed_params.push(ParsedFunctionParam {
  280|      1|                    name: param
  281|      1|                        .declarator
  282|      1|                        .as_ref()
  283|      1|                        .and_then(super::declarator::get_declarator_name),
  284|      1|                    ty: param_parsed_type,
  285|      1|                    span: param.span,
  286|      1|                });
  287|       |            }
  288|       |
  289|      2|            let param_range = parser.ast.parsed_types.alloc_params(parsed_params);
  290|       |
  291|      2|            Ok(parser.ast.parsed_types.alloc_decl(ParsedDeclaratorNode::Function {
  292|      2|                params: param_range,
  293|      2|                flags: FunctionFlags {
  294|      2|                    is_variadic: *is_variadic,
  295|      2|                },
  296|      2|                inner: inner_ref,
  297|      2|            }))
  298|       |        }
  299|     10|        ParsedDeclarator::Abstract => Ok(parser
  300|     10|            .ast
  301|     10|            .parsed_types
  302|     10|            .alloc_decl(ParsedDeclaratorNode::Identifier { name: None })),
  303|       |
  304|      0|        ParsedDeclarator::BitField(inner, _width_expr) => {
  305|       |            // BitFields inside structs are usually handled by struct parsing,
  306|       |            // creating ParsedStructMember directly.
  307|       |            // But if we encounter one here (rare in types?), we probably treat as identifier
  308|       |            // or maybe we need to represent it.
  309|       |            // For types, a bitfield declarator resolves to the underlying type declarator.
  310|      0|            build_parsed_declarator(parser, inner)
  311|       |        }
  312|       |
  313|      0|        ParsedDeclarator::AnonymousRecord(_is_union, _members) => {
  314|       |            // Anonymous records are handled elsewhere or ignored in type building
  315|       |            // as they declare types themselves, not just a declarator.
  316|      0|            Ok(parser
  317|      0|                .ast
  318|      0|                .parsed_types
  319|      0|                .alloc_decl(ParsedDeclaratorNode::Identifier { name: None }))
  320|       |        }
  321|       |    }
  322|     22|}
  323|       |
  324|       |/// Parse a type name and return ParsedType (for casts, sizeof, etc.)
  325|     41|pub(crate) fn parse_parsed_type_name(parser: &mut Parser) -> Result<ParsedType, ParseError> {
  326|       |    // Parse declaration specifiers
  327|     41|    let specifiers = super::declaration_core::parse_declaration_specifiers(parser)?;
                      ^40                                                                       ^1
  328|       |
  329|       |    // Parse abstract declarator (optional)
  330|     40|    let declarator = if parser.is_abstract_declarator_start() {
  331|     10|        Some(super::declarator::parse_abstract_declarator(parser)?)
                                                                               ^0
  332|       |    } else {
  333|     30|        None
  334|       |    };
  335|       |
  336|       |    // Build the ParsedType from specifiers and declarator
  337|     40|    build_parsed_type_from_specifiers(parser, &specifiers, declarator.as_ref())
  338|     41|}

/app/src/parser/statements.rs:
    1|       |//! Statement parsing module
    2|       |//!
    3|       |//! This module handles all statement parsing logic, including control flow
    4|       |//! statements, compound statements, and expression statements.
    5|       |
    6|       |use super::Parser;
    7|       |use crate::ast::*;
    8|       |use crate::diagnostic::ParseError;
    9|       |use crate::lexer::TokenKind;
   10|       |use crate::parser::declaration_core::parse_declaration_specifiers;
   11|       |use crate::parser::declarator::parse_declarator;
   12|       |use crate::parser::utils::expr_patterns::parse_parenthesized_expr;
   13|       |use crate::source_manager::{SourceLoc, SourceSpan};
   14|       |use log::debug;
   15|       |use thin_vec::thin_vec;
   16|       |
   17|       |/// Parse a statement
   18|    795|pub(crate) fn parse_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
   19|    795|    let token = parser.current_token()?;
                                                    ^0
   20|       |
   21|       |    // Check for label: identifier :
   22|    795|    debug!("parse_statement: token is {:?}, looking for label pattern", token.kind);
                         ^0
   23|       |
   24|       |    // Try to check if current token is identifier followed by colon
   25|    795|    if let TokenKind::Identifier(label_symbol) = token.kind
                                               ^236
   26|    236|        && let Some(next_token) = parser.peek_token(0)
   27|       |    {
   28|    236|        debug!(
   29|      0|            "parse_statement: identifier '{}' followed by {:?}",
   30|       |            label_symbol, next_token.kind
   31|       |        );
   32|    236|        if next_token.kind == TokenKind::Colon {
   33|     22|            debug!("parse_statement: found label pattern, calling parse_label_statement");
                                 ^0
   34|     22|            return parse_label_statement(parser, label_symbol);
   35|    214|        }
   36|    559|    }
   37|       |
   38|    773|    match token.kind {
   39|       |        TokenKind::LeftBrace => {
   40|    106|            let (node, _) = parse_compound_statement(parser)?;
                                                                          ^0
   41|    106|            Ok(node)
   42|       |        }
   43|     72|        TokenKind::If => parse_if_statement(parser),
   44|      9|        TokenKind::Switch => parse_switch_statement(parser),
   45|     15|        TokenKind::While => parse_while_statement(parser),
   46|     13|        TokenKind::Do => parse_do_while_statement(parser),
   47|     14|        TokenKind::For => parse_for_statement(parser),
   48|      6|        TokenKind::Goto => parse_goto_statement(parser),
   49|      1|        TokenKind::Continue => parse_continue_statement(parser),
   50|     20|        TokenKind::Break => parse_break_statement(parser),
   51|    255|        TokenKind::Return => parse_return_statement(parser),
   52|      2|        TokenKind::Semicolon => parse_empty_statement(parser),
   53|     20|        TokenKind::Case => parse_case_statement(parser),
   54|      8|        TokenKind::Default => parse_default_statement(parser),
   55|    232|        _ => parse_expression_statement(parser),
   56|       |    }
   57|    795|}
   58|       |
   59|       |/// Parse compound statement (block)
   60|    363|pub(crate) fn parse_compound_statement(parser: &mut Parser) -> Result<(ParsedNodeRef, SourceLoc), ParseError> {
   61|    363|    let token = parser.expect(TokenKind::LeftBrace)?;
                                                                 ^0
   62|    363|    let start_loc = token.span.start();
   63|    363|    let dummy = parser.push_dummy();
   64|       |
   65|    363|    let mut block_items = Vec::new();
   66|       |
   67|  1.14k|    while !parser.is_token(TokenKind::RightBrace) {
   68|    784|        let initial_idx = parser.current_idx;
   69|       |
   70|    784|        debug!(
   71|      0|            "parse_compound_statement: parsing block item, current token {:?}, position {}",
   72|      0|            parser.current_token_kind(),
   73|       |            initial_idx
   74|       |        );
   75|       |
   76|       |        // Try parsing as declaration first, but only if it looks like a declaration start
   77|    784|        let should_try_declaration = parser.starts_declaration();
   78|    784|        let mut declaration_attempt: Option<Result<ParsedNodeRef, ParseError>> = None;
   79|       |
   80|    784|        if should_try_declaration {
   81|    210|            let trx = parser.start_transaction();
   82|    210|            debug!(
   83|      0|                "parse_compound_statement: trying declaration parsing at position {}",
   84|       |                trx.parser.current_idx
   85|       |            );
   86|    210|            match super::declarations::parse_declaration(trx.parser) {
   87|    209|                Ok(declaration) => {
   88|    209|                    debug!("parse_compound_statement: successfully parsed declaration");
                                         ^0
   89|    209|                    block_items.push(declaration);
   90|    209|                    trx.commit();
   91|       |                }
   92|      1|                Err(decl_error) => {
   93|      1|                    debug!("parse_compound_statement: declaration parsing failed: {:?}", decl_error);
                                         ^0
   94|      1|                    declaration_attempt = Some(Err(decl_error));
   95|       |                }
   96|       |            }
   97|    574|        }
   98|       |
   99|       |        // If declaration failed or wasn't attempted, try as statement
  100|    784|        if declaration_attempt.is_some() || !should_try_declaration {
                                                          ^783
  101|    575|            if declaration_attempt.is_some() {
  102|      1|                debug!(
  103|      0|                    "parse_compound_statement: reset to position {}, trying statement",
  104|       |                    initial_idx
  105|       |                );
  106|       |            } else {
  107|    574|                debug!("parse_compound_statement: not a declaration start, trying statement");
                                     ^0
  108|       |            }
  109|       |
  110|    575|            match parse_statement(parser) {
  111|    573|                Ok(statement) => {
  112|    573|                    debug!("parse_compound_statement: successfully parsed statement");
                                         ^0
  113|    573|                    block_items.push(statement);
  114|       |                }
  115|      2|                Err(stmt_error) => {
  116|      2|                    debug!(
  117|      0|                        "parse_compound_statement: statement parsing also failed: {:?}",
  118|       |                        stmt_error
  119|       |                    );
  120|       |                    // Both declaration and statement parsing failed
  121|       |                    // Report the declaration error and try to synchronize
  122|      0|                    if let Some(Err(decl_error)) = declaration_attempt {
  123|      0|                        parser.diag.report(decl_error);
  124|      2|                    } else {
  125|      2|                        parser.diag.report(stmt_error);
  126|      2|                    }
  127|      2|                    parser.synchronize();
  128|       |                }
  129|       |            }
  130|    209|        }
  131|       |    }
  132|       |
  133|    363|    let right_brace_token = parser.expect(TokenKind::RightBrace)?;
                                                                              ^0
  134|    363|    let end_loc = right_brace_token.span.end();
  135|       |
  136|    363|    let span = SourceSpan::new(start_loc, end_loc);
  137|       |
  138|    363|    let node = parser.replace_node(dummy, ParsedNodeKind::CompoundStatement(block_items), span);
  139|    363|    Ok((node, end_loc))
  140|    363|}
  141|       |
  142|       |/// Parse if statement
  143|     72|fn parse_if_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  144|     72|    let token = parser.expect(TokenKind::If)?;
                                                          ^0
  145|     72|    let start_loc = token.span.start();
  146|       |
  147|     72|    let condition = parse_parenthesized_expr(parser)?;
                                                                  ^0
  148|     72|    let then_branch = parse_statement(parser)?;
                                                           ^0
  149|       |
  150|     72|    let else_branch = if parser.accept(TokenKind::Else).is_some() {
  151|     33|        Some(parse_statement(parser)?)
                                                  ^0
  152|       |    } else {
  153|     39|        None
  154|       |    };
  155|       |
  156|     72|    let end_loc = match &else_branch {
  157|     33|        Some(else_stmt) => parser.ast.get_node(*else_stmt).span.end(),
  158|     39|        None => parser.ast.get_node(then_branch).span.end(),
  159|       |    };
  160|       |
  161|     72|    let span = SourceSpan::new(start_loc, end_loc);
  162|       |
  163|     72|    let if_stmt = ParsedIfStmt {
  164|     72|        condition,
  165|     72|        then_branch,
  166|     72|        else_branch,
  167|     72|    };
  168|       |
  169|     72|    let node = parser.push_node(ParsedNodeKind::If(if_stmt), span);
  170|     72|    Ok(node)
  171|     72|}
  172|       |
  173|       |/// Parse switch statement
  174|      9|fn parse_switch_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  175|      9|    let token = parser.expect(TokenKind::Switch)?;
                                                              ^0
  176|      9|    let start_loc = token.span.start();
  177|       |
  178|      9|    let condition = parse_parenthesized_expr(parser)?;
                                                                  ^0
  179|       |
  180|      9|    debug!("parse_for_statement: parsing body");
                         ^0
  181|       |
  182|      9|    let body = parse_statement(parser)?;
                                                    ^0
  183|       |
  184|      9|    let end_loc = parser.ast.get_node(body).span.end();
  185|       |
  186|      9|    let span = SourceSpan::new(start_loc, end_loc);
  187|       |
  188|      9|    let node = parser.push_node(ParsedNodeKind::Switch(condition, body), span);
  189|      9|    Ok(node)
  190|      9|}
  191|       |
  192|       |/// Parse while statement
  193|     15|fn parse_while_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  194|     15|    let token = parser.expect(TokenKind::While)?;
                                                             ^0
  195|     15|    let start_loc = token.span.start();
  196|       |
  197|     15|    let condition = parse_parenthesized_expr(parser)?;
                                                                  ^0
  198|     15|    let body = parse_statement(parser)?;
                                                    ^0
  199|       |
  200|     15|    let end_loc = parser.ast.get_node(body).span.end();
  201|       |
  202|     15|    let span = SourceSpan::new(start_loc, end_loc);
  203|       |
  204|     15|    let while_stmt = ParsedWhileStmt { condition, body };
  205|       |
  206|     15|    let node = parser.push_node(ParsedNodeKind::While(while_stmt), span);
  207|     15|    Ok(node)
  208|     15|}
  209|       |
  210|       |/// Parse do-while statement
  211|     13|fn parse_do_while_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  212|     13|    let token = parser.expect(TokenKind::Do)?;
                                                          ^0
  213|     13|    let start_loc = token.span.start();
  214|       |
  215|     13|    let body = parse_statement(parser)?;
                                                    ^0
  216|       |
  217|     13|    parser.expect(TokenKind::While)?;
                                                 ^0
  218|     13|    let condition = parse_parenthesized_expr(parser)?;
                                                                  ^0
  219|     13|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  220|     13|    let end_loc = semicolon_token.span.end();
  221|       |
  222|     13|    let span = SourceSpan::new(start_loc, end_loc);
  223|       |
  224|     13|    let node = parser.push_node(ParsedNodeKind::DoWhile(body, condition), span);
  225|     13|    Ok(node)
  226|     13|}
  227|       |
  228|       |/// Parse for statement
  229|     14|fn parse_for_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  230|     14|    let token = parser.expect(TokenKind::For)?;
                                                           ^0
  231|     14|    let start_loc = token.span.start();
  232|     14|    let dummy = parser.push_dummy();
  233|       |
  234|     14|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  235|       |
  236|     14|    debug!("parse_for_statement: parsing initialization");
                         ^0
  237|       |
  238|       |    // Parse initialization
  239|     14|    let init = if parser.is_token(TokenKind::Semicolon) {
  240|      1|        None
  241|     13|    } else if parser.starts_declaration() {
  242|     13|        debug!("parse_for_statement: parsing declaration in init");
                             ^0
  243|       |        // Parse declaration specifiers
  244|     13|        let specifiers = parse_declaration_specifiers(parser)?;
                                                                           ^0
  245|     13|        let declarator_start_span = parser.current_token_span_or_empty();
  246|       |        // Parse declarator
  247|     13|        let declarator = parse_declarator(parser, None)?;
                                                                     ^0
  248|       |        // Parse initializer if present
  249|     13|        let initializer = if parser.accept(TokenKind::Assign).is_some() {
  250|     13|            Some(super::declaration_core::parse_initializer(parser)?)
                                                                                 ^0
  251|       |        } else {
  252|      0|            None
  253|       |        };
  254|       |
  255|     13|        let end_span = parser.last_token_span().unwrap_or(declarator_start_span);
  256|     13|        let span = declarator_start_span.merge(end_span);
  257|       |
  258|     13|        let init_declarator = ParsedInitDeclarator {
  259|     13|            declarator,
  260|     13|            initializer,
  261|     13|            span,
  262|     13|        };
  263|       |
  264|     13|        let declaration_data = ParsedDeclarationData {
  265|     13|            specifiers,
  266|     13|            init_declarators: thin_vec![init_declarator],
  267|     13|        };
  268|       |
  269|       |        // Don't consume semicolon here - it will be consumed by the normal for loop flow
  270|     13|        let span = SourceSpan::new(start_loc, parser.current_token_span()?.end());
                                                                                       ^0
  271|       |
  272|     13|        Some(parser.push_node(ParsedNodeKind::Declaration(declaration_data), span))
  273|       |    } else {
  274|      0|        debug!("parse_for_statement: parsing expression in init");
  275|      0|        Some(parser.parse_expr_min()?)
  276|       |    };
  277|       |
  278|     14|    parser.expect(TokenKind::Semicolon)?;
                                                     ^0
  279|       |
  280|     14|    debug!("parse_for_statement: parsing condition");
                         ^0
  281|       |
  282|       |    // Parse condition
  283|     14|    let condition = if parser.is_token(TokenKind::Semicolon) {
  284|      0|        None
  285|       |    } else {
  286|     14|        Some(parser.parse_expr_min()?)
                                                  ^0
  287|       |    };
  288|       |
  289|     14|    parser.expect(TokenKind::Semicolon)?;
                                                     ^0
  290|       |
  291|     14|    debug!("parse_for_statement: parsing increment");
                         ^0
  292|       |
  293|       |    // Parse increment
  294|     14|    let increment = if parser.is_token(TokenKind::RightParen) {
  295|      1|        None
  296|       |    } else {
  297|     13|        Some(parser.parse_expr_min()?)
                                                  ^0
  298|       |    };
  299|       |
  300|     14|    parser.expect(TokenKind::RightParen)?;
                                                      ^0
  301|       |
  302|     14|    let body = parse_statement(parser)?;
                                                    ^0
  303|       |
  304|     14|    let end_loc = parser.ast.get_node(body).span.end();
  305|       |
  306|     14|    let span = SourceSpan::new(start_loc, end_loc);
  307|       |
  308|     14|    let for_stmt = ParsedForStmt {
  309|     14|        init,
  310|     14|        condition,
  311|     14|        increment,
  312|     14|        body,
  313|     14|    };
  314|       |
  315|     14|    let node = parser.replace_node(dummy, ParsedNodeKind::For(for_stmt), span);
  316|     14|    Ok(node)
  317|     14|}
  318|       |
  319|       |/// Parse goto statement
  320|      6|fn parse_goto_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  321|      6|    let token = parser.expect(TokenKind::Goto)?;
                                                            ^0
  322|      6|    let start_loc = token.span.start();
  323|       |
  324|      6|    let (label, _) = parser.expect_name()?;
                                                       ^0
  325|       |
  326|      6|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  327|      6|    let end_loc = semicolon_token.span.end();
  328|       |
  329|      6|    let span = SourceSpan::new(start_loc, end_loc);
  330|      6|    let node = parser.push_node(ParsedNodeKind::Goto(label), span);
  331|      6|    Ok(node)
  332|      6|}
  333|       |
  334|       |/// Parse continue statement
  335|      1|fn parse_continue_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  336|      1|    let token = parser.expect(TokenKind::Continue)?;
                                                                ^0
  337|      1|    let start_loc = token.span.start();
  338|       |
  339|      1|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  340|      1|    let end_loc = semicolon_token.span.end();
  341|       |
  342|      1|    let span = SourceSpan::new(start_loc, end_loc);
  343|       |
  344|      1|    let node = parser.push_node(ParsedNodeKind::Continue, span);
  345|      1|    Ok(node)
  346|      1|}
  347|       |
  348|       |/// Parse break statement
  349|     20|fn parse_break_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  350|     20|    let token = parser.expect(TokenKind::Break)?;
                                                             ^0
  351|     20|    let start_loc = token.span.start();
  352|       |
  353|     20|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  354|     20|    let end_loc = semicolon_token.span.end();
  355|       |
  356|     20|    let span = SourceSpan::new(start_loc, end_loc);
  357|       |
  358|     20|    let node = parser.push_node(ParsedNodeKind::Break, span);
  359|     20|    Ok(node)
  360|     20|}
  361|       |
  362|       |/// Parse return statement
  363|    255|fn parse_return_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  364|    255|    let token = parser.expect(TokenKind::Return)?;
                                                              ^0
  365|    255|    let start_loc = token.span.start();
  366|       |
  367|    255|    let value = if parser.is_token(TokenKind::Semicolon) {
  368|      4|        None
  369|       |    } else {
  370|    251|        let expr = parser.parse_expr_min()?;
                                                        ^0
  371|    251|        Some(expr)
  372|       |    };
  373|       |
  374|    255|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  375|    255|    let end_loc = semicolon_token.span.end();
  376|       |
  377|    255|    let span = SourceSpan::new(start_loc, end_loc);
  378|       |
  379|    255|    let node = parser.push_node(ParsedNodeKind::Return(value), span);
  380|    255|    Ok(node)
  381|    255|}
  382|       |
  383|       |/// Parse empty statement
  384|      2|fn parse_empty_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  385|      2|    let token = parser.expect(TokenKind::Semicolon)?;
                                                                 ^0
  386|      2|    let span = token.span;
  387|      2|    let node = parser.push_node(ParsedNodeKind::EmptyStatement, span);
  388|      2|    Ok(node)
  389|      2|}
  390|       |
  391|       |/// Parse case statement (including GNU case ranges)
  392|     20|fn parse_case_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  393|     20|    let token = parser.expect(TokenKind::Case)?;
                                                            ^0
  394|     20|    let start_loc = token.span.start();
  395|       |
  396|     20|    let start_expr = parser.parse_expr_min()?;
                                                          ^0
  397|       |
  398|       |    // Check for GNU case range extension: case 1 ... 10:
  399|     20|    let (end_expr, is_range) = if parser.accept(TokenKind::Ellipsis).is_some() {
  400|      1|        let end_expr = parser.parse_expr_min()?;
                                                            ^0
  401|      1|        (Some(end_expr), true)
  402|       |    } else {
  403|     19|        (None, false)
  404|       |    };
  405|       |
  406|     20|    parser.expect(TokenKind::Colon)?;
                                                 ^0
  407|       |
  408|     20|    let statement = parse_statement(parser)?;
                                                         ^0
  409|       |
  410|     20|    let end_loc = parser.ast.get_node(statement).span.end();
  411|       |
  412|     20|    let span = SourceSpan::new(start_loc, end_loc);
  413|       |
  414|     20|    let node = if is_range {
  415|      1|        parser.push_node(
  416|      1|            ParsedNodeKind::CaseRange(start_expr, end_expr.unwrap(), statement),
  417|      1|            span,
  418|       |        )
  419|       |    } else {
  420|     19|        parser.push_node(ParsedNodeKind::Case(start_expr, statement), span)
  421|       |    };
  422|     20|    Ok(node)
  423|     20|}
  424|       |
  425|       |/// Parse default statement
  426|      8|fn parse_default_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  427|      8|    let token = parser.expect(TokenKind::Default)?;
                                                               ^0
  428|      8|    let start_loc = token.span.start();
  429|       |
  430|      8|    parser.expect(TokenKind::Colon)?;
                                                 ^0
  431|       |
  432|      8|    let statement = parse_statement(parser)?;
                                                         ^0
  433|      8|    let end_loc = parser.ast.get_node(statement).span.end();
  434|       |
  435|      8|    let span = SourceSpan::new(start_loc, end_loc);
  436|       |
  437|      8|    let node = parser.push_node(ParsedNodeKind::Default(statement), span);
  438|      8|    Ok(node)
  439|      8|}
  440|       |
  441|       |/// Parse label statement
  442|     22|fn parse_label_statement(parser: &mut Parser, label_symbol: NameId) -> Result<ParsedNodeRef, ParseError> {
  443|     22|    let token = parser.advance().unwrap(); // consume the identifier
  444|     22|    let start_loc = token.span.start();
  445|       |
  446|     22|    parser.expect(TokenKind::Colon)?; // consume the colon
                                                 ^0
  447|       |
  448|     22|    let statement = parse_statement(parser)?;
                                                         ^0
  449|     22|    let end_loc = parser.ast.get_node(statement).span.end();
  450|       |
  451|     22|    let span = SourceSpan::new(start_loc, end_loc);
  452|       |
  453|       |    // ParsedNodeKind::Label(NameId, ParsedNodeRef)
  454|     22|    let node = parser.push_node(ParsedNodeKind::Label(label_symbol, statement), span);
  455|     22|    Ok(node)
  456|     22|}
  457|       |
  458|       |/// Parse expression statement
  459|    232|fn parse_expression_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  460|    232|    let start_loc = parser.current_token_span()?.start();
                                                             ^0
  461|    232|    let dummy = parser.push_dummy();
  462|       |
  463|    232|    let (semi, expr) = if let Some(token) = parser.accept(TokenKind::Semicolon) {
                       ^230  ^230                ^0
  464|      0|        (token, None)
  465|       |    } else {
  466|    232|        let expr = parser.parse_expr_min()?;
                          ^231                          ^1
  467|    231|        (parser.expect(TokenKind::Semicolon)?, Some(expr))
                                                          ^1 ^230
  468|       |    };
  469|       |
  470|    230|    let end_loc = semi.span.end();
  471|    230|    let span = SourceSpan::new(start_loc, end_loc);
  472|       |
  473|    230|    let node = parser.replace_node(dummy, ParsedNodeKind::ExpressionStatement(expr), span);
  474|    230|    Ok(node)
  475|    232|}

/app/src/parser/struct_parsing.rs:
    1|       |//! Struct and union parsing module
    2|       |//!
    3|       |//! This module handles parsing of struct and union declarations,
    4|       |//! including member declarations and anonymous structs/unions.
    5|       |
    6|       |use thin_vec::{ThinVec, thin_vec};
    7|       |
    8|       |use crate::ast::*;
    9|       |use crate::diagnostic::ParseError;
   10|       |use crate::lexer::TokenKind;
   11|       |
   12|       |use super::Parser;
   13|       |
   14|       |/// Parse struct or union specifier with context
   15|    115|pub(crate) fn parse_record_specifier_with_context(
   16|    115|    parser: &mut Parser,
   17|    115|    is_union: bool,
   18|    115|    in_struct_member: bool,
   19|    115|) -> Result<ParsedTypeSpecifier, ParseError> {
   20|       |    // Check for __attribute__ after struct/union keyword (GCC extension)
   21|    115|    if parser.is_token(TokenKind::Attribute)
   22|      0|        && let Err(_e) = super::declaration_core::parse_attribute(parser)
   23|      0|    {
   24|      0|        // For now, ignore attribute parsing errors
   25|    115|    }
   26|       |
   27|    115|    let tag = parser.accept_name();
   28|       |
   29|       |    // In struct member context, only parse members if we have a specific tag
   30|       |    // to avoid confusion with anonymous nested structs
   31|    115|    let definition = if parser.accept(TokenKind::LeftBrace).is_some() && (!in_struct_member || tag.is_some()) {
                                                                                        ^66                  ^0  ^0
   32|     66|        let members = parse_struct_declaration_list(parser)?;
                                                                         ^0
   33|     66|        parser.expect(TokenKind::RightBrace)?;
                                                          ^0
   34|       |
   35|       |        // Check for __attribute__ after struct definition (GCC extension)
   36|     66|        if parser.is_token(TokenKind::Attribute)
   37|      0|            && let Err(_e) = super::declaration_core::parse_attribute(parser)
   38|      0|        {
   39|      0|            // For now, ignore attribute parsing errors
   40|     66|        }
   41|       |
   42|     66|        Some(ParsedRecordDefData {
   43|     66|            tag,
   44|     66|            members: Some(members),
   45|     66|            is_union,
   46|     66|        })
   47|       |    } else {
   48|     49|        None
   49|       |    };
   50|       |
   51|    115|    Ok(ParsedTypeSpecifier::Record(is_union, tag, definition))
   52|    115|}
   53|       |
   54|       |/// Parse struct declaration list
   55|     76|fn parse_struct_declaration_list(parser: &mut Parser) -> Result<Vec<ParsedDeclarationData>, ParseError> {
   56|     76|    let mut declarations = Vec::new();
   57|       |
   58|    213|    while !parser.is_token(TokenKind::RightBrace) {
   59|    137|        let declaration = parse_struct_declaration(parser)?;
                                                                        ^0
   60|    137|        declarations.push(declaration);
   61|       |    }
   62|       |
   63|     76|    Ok(declarations)
   64|     76|}
   65|       |
   66|       |/// Parse struct declaration
   67|    137|fn parse_struct_declaration(parser: &mut Parser) -> Result<ParsedDeclarationData, ParseError> {
   68|       |    // Check if we have an anonymous struct/union
   69|    137|    let is_struct = parser.accept(TokenKind::Struct).is_some();
   70|    137|    let is_union = if !is_struct {
   71|    127|        parser.accept(TokenKind::Union).is_some()
   72|       |    } else {
   73|     10|        false
   74|       |    };
   75|    137|    if is_struct || is_union {
                                  ^127
   76|       |        // Check if this is an anonymous struct
   77|     15|        if parser.is_token(TokenKind::LeftBrace) {
   78|       |            // Anonymous struct definition
   79|     10|            parser.expect(TokenKind::LeftBrace)?;
                                                             ^0
   80|     10|            let members = parse_struct_declaration_list(parser)?;
                                                                             ^0
   81|     10|            parser.expect(TokenKind::RightBrace)?;
                                                              ^0
   82|       |
   83|       |            // After parsing { members }, check the next token
   84|       |            // If the next token is ';', treat it as an anonymous struct member (no declarator needed)
   85|       |            // If the next token is an identifier or declarator start, continue with variable declaration parsing
   86|     10|            let init_declarators = if parser.is_token(TokenKind::Semicolon) {
   87|       |                // Anonymous struct member: struct { members };
   88|     10|                parser.expect(TokenKind::Semicolon)?;
                                                                 ^0
   89|     10|                ThinVec::new()
   90|       |            } else {
   91|       |                // Variable declaration with anonymous struct type: struct { members } variable;
   92|      0|                let mut init_declarators = ThinVec::new();
   93|       |                loop {
   94|      0|                    let start_span = parser.current_token_span_or_empty();
   95|      0|                    let declarator = super::declarator::parse_declarator(parser, None)?;
   96|      0|                    let end_span = parser.last_token_span().unwrap_or(start_span);
   97|      0|                    let span = start_span.merge(end_span);
   98|       |
   99|      0|                    init_declarators.push(ParsedInitDeclarator {
  100|      0|                        declarator,
  101|      0|                        initializer: None,
  102|      0|                        span,
  103|      0|                    });
  104|       |
  105|      0|                    if parser.accept(TokenKind::Comma).is_none() {
  106|      0|                        break;
  107|      0|                    }
  108|       |                }
  109|      0|                init_declarators
  110|       |            };
  111|       |
  112|     10|            let type_specifier = ParsedTypeSpecifier::Record(
  113|     10|                is_union,
  114|     10|                None,
  115|     10|                Some(ParsedRecordDefData {
  116|     10|                    tag: None,
  117|     10|                    members: Some(members),
  118|     10|                    is_union,
  119|     10|                }),
  120|     10|            );
  121|       |
  122|     10|            let specifiers = thin_vec![ParsedDeclSpecifier::TypeSpecifier(type_specifier)];
  123|       |
  124|       |            // Only expect semicolon if we haven't already consumed it in the anonymous case
  125|     10|            if !init_declarators.is_empty() {
  126|      0|                parser.expect(TokenKind::Semicolon)?;
  127|     10|            }
  128|       |
  129|     10|            Ok(ParsedDeclarationData {
  130|     10|                specifiers,
  131|     10|                init_declarators,
  132|     10|            })
  133|       |        } else {
  134|       |            // Named struct - read the tag first
  135|      5|            let tag = parser.accept_name();
  136|       |
  137|       |            // Check if it's defined inline
  138|      5|            if parser.is_token(TokenKind::LeftBrace) {
  139|       |                // Named struct with definition
  140|      0|                parser.expect(TokenKind::LeftBrace)?;
  141|      0|                let members = parse_struct_declaration_list(parser)?;
  142|      0|                parser.expect(TokenKind::RightBrace)?;
  143|       |
  144|       |                // After parsing { members }, check the next token
  145|      0|                let init_declarators = if parser.is_token(TokenKind::Semicolon) {
  146|       |                    // Named struct definition: struct tag { members };
  147|      0|                    parser.expect(TokenKind::Semicolon)?;
  148|      0|                    ThinVec::new()
  149|       |                } else {
  150|       |                    // Variable declaration with named struct type: struct tag { members } variable;
  151|      0|                    let mut init_declarators = ThinVec::new();
  152|       |                    loop {
  153|      0|                        let start_span = parser.current_token_span_or_empty();
  154|      0|                        let declarator = super::declarator::parse_declarator(parser, None)?;
  155|      0|                        let end_span = parser.last_token_span().unwrap_or(start_span);
  156|      0|                        let span = start_span.merge(end_span);
  157|       |
  158|      0|                        init_declarators.push(ParsedInitDeclarator {
  159|      0|                            declarator,
  160|      0|                            initializer: None,
  161|      0|                            span,
  162|      0|                        });
  163|       |
  164|      0|                        if parser.accept(TokenKind::Comma).is_none() {
  165|      0|                            break;
  166|      0|                        }
  167|       |                    }
  168|      0|                    init_declarators
  169|       |                };
  170|       |
  171|      0|                let type_specifier = ParsedTypeSpecifier::Record(
  172|      0|                    is_union,
  173|      0|                    tag,
  174|      0|                    Some(ParsedRecordDefData {
  175|      0|                        tag,
  176|      0|                        members: Some(members),
  177|      0|                        is_union,
  178|      0|                    }),
  179|      0|                );
  180|       |
  181|      0|                let specifiers = thin_vec![ParsedDeclSpecifier::TypeSpecifier(type_specifier)];
  182|       |
  183|       |                // Only expect semicolon if we haven't already consumed it
  184|      0|                if !init_declarators.is_empty() {
  185|      0|                    parser.expect(TokenKind::Semicolon)?;
  186|      0|                }
  187|       |
  188|      0|                Ok(ParsedDeclarationData {
  189|      0|                    specifiers,
  190|      0|                    init_declarators,
  191|      0|                })
  192|       |            } else {
  193|       |                // Named struct type with declarators: struct tag declarator1, declarator2;
  194|       |                // OR forward declaration: struct tag;
  195|      5|                let type_specifier = ParsedTypeSpecifier::Record(is_union, tag, None);
  196|       |
  197|      5|                let specifiers = thin_vec![ParsedDeclSpecifier::TypeSpecifier(type_specifier)];
  198|       |
  199|       |                // Check if there are declarators following
  200|      5|                if parser.is_token(TokenKind::Semicolon) {
  201|       |                    // Just a forward declaration: struct tag;
  202|      0|                    parser.expect(TokenKind::Semicolon)?;
  203|       |
  204|      0|                    Ok(ParsedDeclarationData {
  205|      0|                        specifiers,
  206|      0|                        init_declarators: ThinVec::new(),
  207|      0|                    })
  208|       |                } else {
  209|       |                    // Named struct type with declarators: struct tag declarator1, declarator2;
  210|      5|                    let mut init_declarators = ThinVec::new();
  211|       |                    loop {
  212|      6|                        let start_span = parser.current_token_span_or_empty();
  213|      6|                        let declarator = super::declarator::parse_declarator(parser, None)?;
                                                                                                        ^0
  214|      6|                        let end_span = parser.last_token_span().unwrap_or(start_span);
  215|      6|                        let span = start_span.merge(end_span);
  216|       |
  217|      6|                        init_declarators.push(ParsedInitDeclarator {
  218|      6|                            declarator,
  219|      6|                            initializer: None,
  220|      6|                            span,
  221|      6|                        });
  222|       |
  223|      6|                        if parser.accept(TokenKind::Comma).is_none() {
  224|      5|                            break;
  225|      1|                        }
  226|       |                    }
  227|       |
  228|      5|                    parser.expect(TokenKind::Semicolon)?;
                                                                     ^0
  229|       |
  230|      5|                    Ok(ParsedDeclarationData {
  231|      5|                        specifiers,
  232|      5|                        init_declarators,
  233|      5|                    })
  234|       |                }
  235|       |            }
  236|       |        }
  237|       |    } else {
  238|       |        // Regular member: declaration specifiers + multiple declarators
  239|    122|        let specifiers = super::declaration_core::parse_declaration_specifiers(parser)?;
                                                                                                    ^0
  240|       |
  241|    122|        let mut init_declarators = ThinVec::new();
  242|       |        loop {
  243|    122|            let start_span = parser.current_token_span_or_empty();
  244|    122|            let declarator = super::declarator::parse_declarator(parser, None)?; // This needs to enable ParsedDeclarator
                                                                                            ^0
  245|    122|            let end_span = parser.last_token_span().unwrap_or(start_span);
  246|    122|            let span = start_span.merge(end_span);
  247|       |
  248|    122|            init_declarators.push(ParsedInitDeclarator {
  249|    122|                declarator,
  250|    122|                initializer: None,
  251|    122|                span,
  252|    122|            });
  253|       |
  254|    122|            if parser.accept(TokenKind::Comma).is_none() {
  255|    122|                break;
  256|      0|            }
  257|       |        }
  258|       |
  259|    122|        parser.expect(TokenKind::Semicolon)?;
                                                         ^0
  260|       |
  261|    122|        Ok(ParsedDeclarationData {
  262|    122|            specifiers,
  263|    122|            init_declarators,
  264|    122|        })
  265|       |    }
  266|    137|}

/app/src/parser/type_specifiers.rs:
    1|       |//! Type specifier parsing module
    2|       |//!
    3|       |//! This module handles parsing of C type specifiers including basic types,
    4|       |//! typedef names, struct/union/enum specifiers, and atomic types.
    5|       |
    6|       |use crate::ast::*;
    7|       |use crate::diagnostic::ParseError;
    8|       |use crate::lexer::TokenKind;
    9|       |
   10|       |use super::Parser;
   11|       |
   12|       |/// Parse type specifier
   13|  1.43k|pub(crate) fn parse_type_specifier(parser: &mut Parser) -> Result<ParsedTypeSpecifier, ParseError> {
   14|  1.43k|    parse_type_specifier_with_context(parser, false)
   15|  1.43k|}
   16|       |
   17|       |/// Parse type specifier with context
   18|  1.43k|fn parse_type_specifier_with_context(
   19|  1.43k|    parser: &mut Parser,
   20|  1.43k|    in_struct_member: bool,
   21|  1.43k|) -> Result<ParsedTypeSpecifier, ParseError> {
   22|  1.43k|    let token = parser.try_current_token().ok_or_else(|| ParseError::UnexpectedEof {
   23|      0|        span: parser.previous_token_span(),
   24|      0|    })?;
   25|       |
   26|  1.43k|    match token.kind {
   27|       |        TokenKind::Void => {
   28|     58|            parser.advance();
   29|     58|            Ok(ParsedTypeSpecifier::Void)
   30|       |        }
   31|       |        TokenKind::Char => {
   32|     83|            parser.advance();
   33|     83|            Ok(ParsedTypeSpecifier::Char)
   34|       |        }
   35|       |        TokenKind::Short => {
   36|      8|            parser.advance();
   37|      8|            Ok(ParsedTypeSpecifier::Short)
   38|       |        }
   39|       |        TokenKind::Int => {
   40|    999|            parser.advance();
   41|    999|            Ok(ParsedTypeSpecifier::Int)
   42|       |        }
   43|       |        TokenKind::Long => {
   44|     27|            parser.advance();
   45|       |            // Check for long long or long double
   46|     27|            if let Some(next_token) = parser.try_current_token() {
   47|     27|                match next_token.kind {
   48|       |                    TokenKind::Long => {
   49|      7|                        parser.advance();
   50|      7|                        Ok(ParsedTypeSpecifier::LongLong)
   51|       |                    }
   52|       |                    TokenKind::Double => {
   53|      1|                        parser.advance();
   54|      1|                        Ok(ParsedTypeSpecifier::LongDouble)
   55|       |                    }
   56|     19|                    _ => Ok(ParsedTypeSpecifier::Long),
   57|       |                }
   58|       |            } else {
   59|      0|                Ok(ParsedTypeSpecifier::Long)
   60|       |            }
   61|       |        }
   62|       |        TokenKind::Float => {
   63|     31|            parser.advance();
   64|     31|            Ok(ParsedTypeSpecifier::Float)
   65|       |        }
   66|       |        TokenKind::Double => {
   67|     24|            parser.advance();
   68|     24|            Ok(ParsedTypeSpecifier::Double)
   69|       |        }
   70|       |        TokenKind::Signed => {
   71|     19|            parser.advance();
   72|     19|            Ok(ParsedTypeSpecifier::Signed)
   73|       |        }
   74|       |        TokenKind::Unsigned => {
   75|     39|            parser.advance();
   76|     39|            Ok(ParsedTypeSpecifier::Unsigned)
   77|       |        }
   78|       |        TokenKind::Bool => {
   79|      1|            parser.advance();
   80|      1|            Ok(ParsedTypeSpecifier::Bool)
   81|       |        }
   82|       |        TokenKind::Complex => {
   83|      0|            parser.advance();
   84|       |            // Parse optional base type for _Complex (C11 allows _Complex float, _Complex double, etc.)
   85|       |            // For now, just consume the base type - full implementation would create proper type
   86|      0|            if parser.accept(TokenKind::Float).is_some()
   87|      0|                || parser.accept(TokenKind::Double).is_some()
   88|      0|                || parser.accept(TokenKind::Long).is_some()
   89|       |            {
   90|       |                // For now, just consume the base type - full implementation would create proper type
   91|      0|                if parser.accept(TokenKind::Double).is_some() {
   92|      0|                    // consume double for long double
   93|      0|                }
   94|      0|            }
   95|      0|            Ok(ParsedTypeSpecifier::Complex)
   96|       |        }
   97|       |        TokenKind::Struct => {
   98|    113|            parser.advance();
   99|    113|            super::struct_parsing::parse_record_specifier_with_context(parser, false, in_struct_member)
  100|       |        }
  101|       |        TokenKind::Union => {
  102|      2|            parser.advance();
  103|      2|            super::struct_parsing::parse_record_specifier_with_context(parser, true, in_struct_member)
  104|       |        }
  105|       |        TokenKind::Enum => {
  106|     28|            parser.advance();
  107|     28|            super::enum_parsing::parse_enum_specifier(parser)
  108|       |        }
  109|      6|        TokenKind::Identifier(symbol) => {
  110|      6|            parser.advance();
  111|      6|            Ok(ParsedTypeSpecifier::TypedefName(symbol))
  112|       |        }
  113|       |        _ => {
  114|      0|            let expected = "void, char, short, int, long, float, double, signed, unsigned, bool, complex, atomic, struct, union, enum, or identifier";
  115|      0|            Err(ParseError::UnexpectedToken {
  116|      0|                expected_tokens: expected.to_string(),
  117|      0|                found: token.kind,
  118|      0|                span: token.span,
  119|      0|            })
  120|       |        }
  121|       |    }
  122|  1.43k|}

/app/src/parser/utils.rs:
    1|       |//! Common parsing utilities and helper functions
    2|       |//!
    3|       |//! This module provides utility functions that abstract repetitive patterns
    4|       |//! found throughout the parser, including expression result handling,
    5|       |//! binding power utilities, and common parsing operations.
    6|       |
    7|       |use crate::ast::*;
    8|       |use crate::diagnostic::ParseError;
    9|       |use log::debug;
   10|       |
   11|       |use super::expressions::BindingPower;
   12|       |use super::{Parser, ParserState};
   13|       |
   14|       |/// Common expression parsing patterns
   15|       |pub(crate) mod expr_patterns {
   16|       |    use super::*;
   17|       |
   18|       |    /// Parse a parenthesized expression: (expression)
   19|    109|    pub(crate) fn parse_parenthesized_expr(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
   20|    109|        debug!("parse_parenthesized_expr: parsing parenthesized expression");
                             ^0
   21|    109|        parser.expect(crate::lexer::TokenKind::LeftParen)?;
                                                                       ^0
   22|    109|        let expr = parser.parse_expr_min()?;
                                                        ^0
   23|    109|        parser.expect(crate::lexer::TokenKind::RightParen)?;
                                                                        ^0
   24|    109|        Ok(expr)
   25|    109|    }
   26|       |
   27|       |    /// Parse a comma-separated list of expressions with specified binding power
   28|    120|    pub(crate) fn parse_expr_list(
   29|    120|        parser: &mut Parser,
   30|    120|        binding_power: BindingPower,
   31|    120|    ) -> Result<Vec<ParsedNodeRef>, ParseError> {
   32|    120|        debug!("parse_expr_list: parsing expression list");
                             ^0
   33|    120|        let mut args = Vec::new();
   34|       |
   35|    120|        if parser.is_token(crate::lexer::TokenKind::RightParen) {
   36|     22|            return Ok(args);
   37|     98|        }
   38|       |
   39|       |        loop {
   40|    123|            let arg = parser.parse_expression(binding_power)?;
                                                                          ^0
   41|    123|            args.push(arg);
   42|       |
   43|    123|            if !parser.is_token(crate::lexer::TokenKind::Comma) {
   44|     98|                break;
   45|     25|            }
   46|     25|            parser.advance(); // consume comma
   47|       |        }
   48|       |
   49|     98|        Ok(args)
   50|    120|    }
   51|       |}
   52|       |
   53|       |pub(crate) struct ParserTransaction<'a, 'arena, 'src> {
   54|       |    pub(crate) parser: &'a mut Parser<'arena, 'src>,
   55|       |    state: ParserState,
   56|       |    committed: bool,
   57|       |}
   58|       |
   59|       |impl<'a, 'arena, 'src> ParserTransaction<'a, 'arena, 'src> {
   60|  1.09k|    pub(crate) fn new(parser: &'a mut Parser<'arena, 'src>) -> Self {
   61|  1.09k|        let state = parser.save_state();
   62|  1.09k|        Self {
   63|  1.09k|            parser,
   64|  1.09k|            state,
   65|  1.09k|            committed: false,
   66|  1.09k|        }
   67|  1.09k|    }
   68|       |
   69|    829|    pub(crate) fn commit(mut self) {
   70|    829|        self.committed = true;
   71|    829|    }
   72|       |}
   73|       |
   74|       |impl<'a, 'arena, 'src> Drop for ParserTransaction<'a, 'arena, 'src> {
   75|  1.08k|    fn drop(&mut self) {
   76|  1.08k|        if !self.committed {
   77|    259|            self.parser.restore_state(self.state.clone());
   78|    829|        }
   79|  1.08k|    }
   80|       |}

/app/src/pp/interpreter.rs:
    1|       |use crate::ast::{BinaryOp, UnaryOp};
    2|       |use crate::intern::StringId;
    3|       |use crate::pp::{PPError, PPToken, PPTokenKind, Preprocessor};
    4|       |
    5|       |#[derive(Debug)]
    6|       |pub(crate) enum PPExpr {
    7|       |    Number(i64),
    8|       |    Identifier(String),
    9|       |    Defined(Box<PPExpr>),
   10|       |    HasInclude(String, bool), // (path, is_angled)
   11|       |    Binary(BinaryOp, Box<PPExpr>, Box<PPExpr>),
   12|       |    Unary(UnaryOp, Box<PPExpr>),
   13|       |    Conditional(Box<PPExpr>, Box<PPExpr>, Box<PPExpr>),
   14|       |}
   15|       |
   16|       |impl PPExpr {
   17|     63|    pub(crate) fn evaluate(&self, pp: &Preprocessor) -> Result<i64, PPError> {
   18|     63|        match self {
   19|     31|            PPExpr::Number(n) => Ok(*n),
   20|      3|            PPExpr::Identifier(_s) => Ok(0), // C11 6.10.1p4: All remaining identifiers are replaced with 0
   21|      0|            PPExpr::Defined(ident) => {
   22|      0|                if let PPExpr::Identifier(s) = &**ident {
   23|      0|                    Ok(if pp.is_macro_defined(&StringId::new(s)) { 1 } else { 0 })
   24|       |                } else {
   25|      0|                    Err(PPError::InvalidConditionalExpression)
   26|       |                }
   27|       |            }
   28|      6|            PPExpr::HasInclude(path, is_angled) => Ok(if pp.check_header_exists(path, *is_angled) { 1 } else { 0 }),
                                                                                                                  ^3         ^3
   29|     21|            PPExpr::Binary(op, left, right) => {
   30|     21|                let l = left.evaluate(pp)?;
                                                       ^0
   31|     21|                match op {
   32|       |                    BinaryOp::LogicAnd => {
   33|      0|                        if l == 0 {
   34|      0|                            Ok(0)
   35|       |                        } else {
   36|      0|                            let r = right.evaluate(pp)?;
   37|      0|                            Ok(if l != 0 && r != 0 { 1 } else { 0 })
   38|       |                        }
   39|       |                    }
   40|       |                    BinaryOp::LogicOr => {
   41|      2|                        if l != 0 {
   42|      1|                            Ok(1)
   43|       |                        } else {
   44|      1|                            let r = right.evaluate(pp)?;
                                                                    ^0
   45|      1|                            Ok(if l != 0 || r != 0 { 1 } else { 0 })
                                                                   ^0
   46|       |                        }
   47|       |                    }
   48|       |                    _ => {
   49|     19|                        let r = right.evaluate(pp)?;
                                                                ^0
   50|     19|                        match op {
   51|      1|                            BinaryOp::BitOr => Ok(l | r),
   52|      0|                            BinaryOp::BitXor => Ok(l ^ r),
   53|      0|                            BinaryOp::BitAnd => Ok(l & r),
   54|      0|                            BinaryOp::Equal => Ok(if l == r { 1 } else { 0 }),
   55|      8|                            BinaryOp::NotEqual => Ok(if l != r { 1 } else { 0 }),
                                                                               ^0
   56|      0|                            BinaryOp::Less => Ok(if l < r { 1 } else { 0 }),
   57|      0|                            BinaryOp::LessEqual => Ok(if l <= r { 1 } else { 0 }),
   58|      1|                            BinaryOp::Greater => Ok(if l > r { 1 } else { 0 }),
                                                                             ^0
   59|      1|                            BinaryOp::GreaterEqual => Ok(if l >= r { 1 } else { 0 }),
                                                                                              ^0
   60|      1|                            BinaryOp::LShift => Ok(l << r),
   61|      0|                            BinaryOp::RShift => Ok(((l as u64) >> r) as i64),
   62|      5|                            BinaryOp::Add => Ok(l + r),
   63|      0|                            BinaryOp::Sub => Ok(l - r),
   64|      2|                            BinaryOp::Mul => Ok(l * r),
   65|       |                            BinaryOp::Div => {
   66|      0|                                if r == 0 {
   67|      0|                                    Err(PPError::InvalidConditionalExpression)
   68|       |                                } else {
   69|      0|                                    Ok(l / r)
   70|       |                                }
   71|       |                            }
   72|       |                            BinaryOp::Mod => {
   73|      0|                                if r == 0 {
   74|      0|                                    Err(PPError::InvalidConditionalExpression)
   75|       |                                } else {
   76|      0|                                    Ok(l % r)
   77|       |                                }
   78|       |                            }
   79|      0|                            _ => unreachable!(),
   80|       |                        }
   81|       |                    }
   82|       |                }
   83|       |            }
   84|      2|            PPExpr::Unary(op, operand) => {
   85|      2|                let o = operand.evaluate(pp)?;
                                                          ^0
   86|      2|                match op {
   87|      0|                    UnaryOp::Plus => Ok(o),
   88|      2|                    UnaryOp::Minus => Ok(-o),
   89|      0|                    UnaryOp::BitNot => Ok(!o),
   90|      0|                    UnaryOp::LogicNot => Ok(if o != 0 { 0 } else { 1 }),
   91|      0|                    _ => unreachable!("Unsupported unary operator in preprocessor"),
   92|       |                }
   93|       |            }
   94|      0|            PPExpr::Conditional(cond, true_e, false_e) => {
   95|      0|                let c = cond.evaluate(pp)?;
   96|      0|                if c != 0 {
   97|      0|                    true_e.evaluate(pp)
   98|       |                } else {
   99|      0|                    false_e.evaluate(pp)
  100|       |                }
  101|       |            }
  102|       |        }
  103|     63|    }
  104|       |}
  105|       |
  106|       |/// Expression interpreter for preprocessor arithmetic
  107|       |pub(crate) struct Interpreter<'a> {
  108|       |    tokens: &'a [PPToken],
  109|       |    pos: usize,
  110|       |    preprocessor: &'a Preprocessor<'a>,
  111|       |}
  112|       |
  113|       |impl<'a> Interpreter<'a> {
  114|     21|    pub(crate) fn new(tokens: &'a [PPToken], preprocessor: &'a Preprocessor<'a>) -> Self {
  115|     21|        Interpreter {
  116|     21|            tokens,
  117|     21|            pos: 0,
  118|     21|            preprocessor,
  119|     21|        }
  120|     21|    }
  121|       |
  122|     21|    pub(crate) fn evaluate(&mut self) -> Result<i64, PPError> {
  123|     21|        let expr = self.parse_conditional()?;
                          ^20                            ^1
  124|     20|        expr.evaluate(self.preprocessor)
  125|     21|    }
  126|       |
  127|     31|    fn parse_conditional(&mut self) -> Result<PPExpr, PPError> {
  128|     31|        let cond = self.parse_or()?;
                          ^30                   ^1
  129|     30|        if self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::Question) {
                                                         ^10      ^10
  130|      0|            self.pos += 1; // consume ?
  131|      0|            let true_e = self.parse_conditional()?; // allow nesting
  132|      0|            if self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::Colon) {
  133|      0|                self.pos += 1; // consume :
  134|      0|                let false_e = self.parse_conditional()?;
  135|      0|                Ok(PPExpr::Conditional(Box::new(cond), Box::new(true_e), Box::new(false_e)))
  136|       |            } else {
  137|      0|                Err(PPError::InvalidConditionalExpression)
  138|       |            }
  139|       |        } else {
  140|     30|            Ok(cond)
  141|       |        }
  142|     31|    }
  143|       |
  144|     31|    fn parse_or(&mut self) -> Result<PPExpr, PPError> {
  145|     31|        let mut left = self.parse_and()?;
                          ^30                        ^1
  146|     32|        while self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::LogicOr) {
                                                            ^10      ^12
  147|      2|            self.pos += 1;
  148|      2|            let right = self.parse_and()?;
                                                      ^0
  149|      2|            left = PPExpr::Binary(BinaryOp::LogicOr, Box::new(left), Box::new(right));
  150|       |        }
  151|     30|        Ok(left)
  152|     31|    }
  153|       |
  154|     33|    fn parse_and(&mut self) -> Result<PPExpr, PPError> {
  155|     33|        let mut left = self.parse_bitwise_or()?;
                          ^32                               ^1
  156|     32|        while self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::LogicAnd) {
                                                            ^12      ^12
  157|      0|            self.pos += 1;
  158|      0|            let right = self.parse_bitwise_or()?;
  159|      0|            left = PPExpr::Binary(BinaryOp::LogicAnd, Box::new(left), Box::new(right));
  160|       |        }
  161|     32|        Ok(left)
  162|     33|    }
  163|       |
  164|     33|    fn parse_bitwise_or(&mut self) -> Result<PPExpr, PPError> {
  165|     33|        let mut left = self.parse_bitwise_xor()?;
                          ^32                                ^1
  166|     33|        while self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::Or) {
                                                            ^12      ^13
  167|      1|            self.pos += 1;
  168|      1|            let right = self.parse_bitwise_xor()?;
                                                              ^0
  169|      1|            left = PPExpr::Binary(BinaryOp::BitOr, Box::new(left), Box::new(right));
  170|       |        }
  171|     32|        Ok(left)
  172|     33|    }
  173|       |
  174|     34|    fn parse_bitwise_xor(&mut self) -> Result<PPExpr, PPError> {
  175|     34|        let mut left = self.parse_bitwise_and()?;
                          ^33                                ^1
  176|     33|        while self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::Xor) {
                                                            ^13      ^13
  177|      0|            self.pos += 1;
  178|      0|            let right = self.parse_bitwise_and()?;
  179|      0|            left = PPExpr::Binary(BinaryOp::BitXor, Box::new(left), Box::new(right));
  180|       |        }
  181|     33|        Ok(left)
  182|     34|    }
  183|       |
  184|     34|    fn parse_bitwise_and(&mut self) -> Result<PPExpr, PPError> {
  185|     34|        let mut left = self.parse_equality()?;
                          ^33                             ^1
  186|     33|        while self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::And) {
                                                            ^13      ^13
  187|      0|            self.pos += 1;
  188|      0|            let right = self.parse_equality()?;
  189|      0|            left = PPExpr::Binary(BinaryOp::BitAnd, Box::new(left), Box::new(right));
  190|       |        }
  191|     33|        Ok(left)
  192|     34|    }
  193|       |
  194|     34|    fn parse_equality(&mut self) -> Result<PPExpr, PPError> {
  195|     34|        let mut left = self.parse_relational()?;
                          ^33                               ^1
  196|     41|        while self.pos < self.tokens.len() {
  197|     21|            let op = &self.tokens[self.pos].kind;
  198|     21|            if matches!(op, PPTokenKind::Equal | PPTokenKind::NotEqual) {
                             ^13
  199|      8|                self.pos += 1;
  200|      8|                let right = self.parse_relational()?;
                                                                 ^0
  201|      8|                let bin_op = match op {
  202|      0|                    PPTokenKind::Equal => BinaryOp::Equal,
  203|      8|                    PPTokenKind::NotEqual => BinaryOp::NotEqual,
  204|      0|                    _ => unreachable!(),
  205|       |                };
  206|      8|                left = PPExpr::Binary(bin_op, Box::new(left), Box::new(right));
  207|       |            } else {
  208|     13|                break;
  209|       |            }
  210|       |        }
  211|     33|        Ok(left)
  212|     34|    }
  213|       |
  214|     42|    fn parse_relational(&mut self) -> Result<PPExpr, PPError> {
  215|     42|        let mut left = self.parse_shift()?;
                          ^41                          ^1
  216|     43|        while self.pos < self.tokens.len() {
  217|     23|            let op = &self.tokens[self.pos].kind;
  218|     21|            if matches!(
  219|     23|                op,
  220|       |                PPTokenKind::Less | PPTokenKind::LessEqual | PPTokenKind::Greater | PPTokenKind::GreaterEqual
  221|       |            ) {
  222|      2|                self.pos += 1;
  223|      2|                let right = self.parse_shift()?;
                                                            ^0
  224|      2|                let bin_op = match op {
  225|      0|                    PPTokenKind::Less => BinaryOp::Less,
  226|      0|                    PPTokenKind::LessEqual => BinaryOp::LessEqual,
  227|      1|                    PPTokenKind::Greater => BinaryOp::Greater,
  228|      1|                    PPTokenKind::GreaterEqual => BinaryOp::GreaterEqual,
  229|      0|                    _ => unreachable!(),
  230|       |                };
  231|      2|                left = PPExpr::Binary(bin_op, Box::new(left), Box::new(right));
  232|       |            } else {
  233|     21|                break;
  234|       |            }
  235|       |        }
  236|     41|        Ok(left)
  237|     42|    }
  238|       |
  239|     44|    fn parse_shift(&mut self) -> Result<PPExpr, PPError> {
  240|     44|        let mut left = self.parse_additive()?;
                          ^43                             ^1
  241|     44|        while self.pos < self.tokens.len() {
  242|     24|            let op = &self.tokens[self.pos].kind;
  243|     24|            if matches!(op, PPTokenKind::LeftShift | PPTokenKind::RightShift) {
                             ^23
  244|      1|                self.pos += 1;
  245|      1|                let right = self.parse_additive()?;
                                                               ^0
  246|      1|                let bin_op = match op {
  247|      1|                    PPTokenKind::LeftShift => BinaryOp::LShift,
  248|      0|                    PPTokenKind::RightShift => BinaryOp::RShift,
  249|      0|                    _ => unreachable!(),
  250|       |                };
  251|      1|                left = PPExpr::Binary(bin_op, Box::new(left), Box::new(right));
  252|       |            } else {
  253|     23|                break;
  254|       |            }
  255|       |        }
  256|     43|        Ok(left)
  257|     44|    }
  258|       |
  259|     45|    fn parse_additive(&mut self) -> Result<PPExpr, PPError> {
  260|     45|        let mut left = self.parse_multiplicative()?;
                          ^44                                   ^1
  261|     49|        while self.pos < self.tokens.len() {
  262|     29|            let op = &self.tokens[self.pos].kind;
  263|     29|            if matches!(op, PPTokenKind::Plus | PPTokenKind::Minus) {
                             ^24
  264|      5|                self.pos += 1;
  265|      5|                let right = self.parse_multiplicative()?;
                                                                     ^0
  266|      5|                let bin_op = match op {
  267|      5|                    PPTokenKind::Plus => BinaryOp::Add,
  268|      0|                    PPTokenKind::Minus => BinaryOp::Sub,
  269|      0|                    _ => unreachable!(),
  270|       |                };
  271|      5|                left = PPExpr::Binary(bin_op, Box::new(left), Box::new(right));
  272|       |            } else {
  273|     24|                break;
  274|       |            }
  275|       |        }
  276|     44|        Ok(left)
  277|     45|    }
  278|       |
  279|     50|    fn parse_multiplicative(&mut self) -> Result<PPExpr, PPError> {
  280|     50|        let mut left = self.parse_unary()?;
                          ^49                          ^1
  281|     51|        while self.pos < self.tokens.len() {
  282|     31|            let op = &self.tokens[self.pos].kind;
  283|     31|            if matches!(op, PPTokenKind::Star | PPTokenKind::Slash | PPTokenKind::Percent) {
                             ^29
  284|      2|                self.pos += 1;
  285|      2|                let right = self.parse_unary()?;
                                                            ^0
  286|      2|                let bin_op = match op {
  287|      2|                    PPTokenKind::Star => BinaryOp::Mul,
  288|      0|                    PPTokenKind::Slash => BinaryOp::Div,
  289|      0|                    PPTokenKind::Percent => BinaryOp::Mod,
  290|      0|                    _ => unreachable!(),
  291|       |                };
  292|      2|                left = PPExpr::Binary(bin_op, Box::new(left), Box::new(right));
  293|       |            } else {
  294|     29|                break;
  295|       |            }
  296|       |        }
  297|     49|        Ok(left)
  298|     50|    }
  299|       |
  300|     54|    fn parse_unary(&mut self) -> Result<PPExpr, PPError> {
  301|     54|        if self.pos >= self.tokens.len() {
  302|      0|            return Err(PPError::InvalidConditionalExpression);
  303|     54|        }
  304|     54|        let token = &self.tokens[self.pos];
  305|     10|        if matches!(token.kind, PPTokenKind::Identifier(sym) if sym == self.preprocessor.defined_symbol()) {
                         ^0                                           ^0                                              ^0
  306|      0|            self.pos += 1;
  307|      0|            let ident = if self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::LeftParen)
  308|       |            {
  309|      0|                self.pos += 1;
  310|      0|                let ident = self.parse_primary()?;
  311|      0|                if self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::RightParen) {
  312|      0|                    self.pos += 1;
  313|      0|                    ident
  314|       |                } else {
  315|      0|                    return Err(PPError::InvalidConditionalExpression);
  316|       |                }
  317|       |            } else {
  318|      0|                self.parse_primary()?
  319|       |            };
  320|      0|            Ok(PPExpr::Defined(Box::new(ident)))
  321|     10|        } else if matches!(token.kind, PPTokenKind::Identifier(sym) if sym == self.preprocessor.has_include_symbol()) {
                                ^7                                           ^7                                                  ^7
  322|      7|            self.pos += 1; // consume __has_include
  323|       |
  324|       |            // Expect LeftParen
  325|      7|            if self.pos >= self.tokens.len() || self.tokens[self.pos].kind != PPTokenKind::LeftParen {
  326|      0|                return Err(PPError::InvalidConditionalExpression);
  327|      7|            }
  328|      7|            self.pos += 1;
  329|       |
  330|       |            // Parse argument
  331|      7|            if self.pos >= self.tokens.len() {
  332|      0|                return Err(PPError::InvalidConditionalExpression);
  333|      7|            }
  334|       |
  335|      7|            let (path, is_angled) = match &self.tokens[self.pos].kind {
                               ^6    ^6
  336|      2|                PPTokenKind::StringLiteral(sym) => {
  337|      2|                    let full_str = sym.as_str();
  338|      2|                    if full_str.starts_with('"') && full_str.ends_with('"') {
  339|      2|                        self.pos += 1;
  340|      2|                        (full_str[1..full_str.len() - 1].to_string(), false)
  341|       |                    } else {
  342|      0|                        return Err(PPError::InvalidConditionalExpression);
  343|       |                    }
  344|       |                }
  345|       |                PPTokenKind::Less => {
  346|       |                    // Angled include
  347|      4|                    self.pos += 1;
  348|      4|                    let mut path_str = String::new();
  349|       |                    loop {
  350|     18|                        if self.pos >= self.tokens.len() {
  351|      0|                            return Err(PPError::InvalidConditionalExpression);
  352|     18|                        }
  353|     18|                        let token = &self.tokens[self.pos];
  354|     18|                        if token.kind == PPTokenKind::Greater {
  355|      4|                            self.pos += 1;
  356|      4|                            break;
  357|     14|                        }
  358|     14|                        path_str.push_str(self.preprocessor.get_token_text(token));
  359|     14|                        self.pos += 1;
  360|       |                    }
  361|      4|                    (path_str, true)
  362|       |                }
  363|      1|                _ => return Err(PPError::InvalidConditionalExpression),
  364|       |            };
  365|       |
  366|       |            // Expect RightParen
  367|      6|            if self.pos >= self.tokens.len() || self.tokens[self.pos].kind != PPTokenKind::RightParen {
  368|      0|                return Err(PPError::InvalidConditionalExpression);
  369|      6|            }
  370|      6|            self.pos += 1;
  371|       |
  372|      6|            Ok(PPExpr::HasInclude(path, is_angled))
  373|     45|        } else if matches!(
  374|     47|            token.kind,
  375|       |            PPTokenKind::Plus | PPTokenKind::Minus | PPTokenKind::Tilde | PPTokenKind::Not
  376|       |        ) {
  377|      2|            self.pos += 1;
  378|      2|            let operand = self.parse_unary()?;
                                                          ^0
  379|      2|            let unary_op = match token.kind {
  380|      0|                PPTokenKind::Plus => UnaryOp::Plus,
  381|      2|                PPTokenKind::Minus => UnaryOp::Minus,
  382|      0|                PPTokenKind::Tilde => UnaryOp::BitNot,
  383|      0|                PPTokenKind::Not => UnaryOp::LogicNot,
  384|      0|                _ => unreachable!(),
  385|       |            };
  386|      2|            Ok(PPExpr::Unary(unary_op, Box::new(operand)))
  387|       |        } else {
  388|     45|            self.parse_primary()
  389|       |        }
  390|     54|    }
  391|       |
  392|     45|    fn parse_primary(&mut self) -> Result<PPExpr, PPError> {
  393|     45|        if self.pos >= self.tokens.len() {
  394|      0|            return Err(PPError::InvalidConditionalExpression);
  395|     45|        }
  396|     45|        let token = &self.tokens[self.pos];
  397|     45|        self.pos += 1;
  398|     45|        match &token.kind {
  399|     32|            PPTokenKind::Number(sym) => {
  400|     32|                let text = sym.as_str();
  401|       |                // Strip suffixes: u U l L ll LL (case insensitive)
  402|     32|                let mut num_text = text;
  403|     32|                let lower = text.to_lowercase();
  404|     32|                if lower.ends_with("ull") || lower.ends_with("llu") {
  405|      0|                    num_text = &text[..text.len() - 3];
  406|     32|                } else if lower.ends_with("ul") || lower.ends_with("lu") || lower.ends_with("ll") {
  407|      0|                    num_text = &text[..text.len() - 2];
  408|     32|                } else if lower.ends_with("u") || lower.ends_with("l") {
  409|      0|                    num_text = &text[..text.len() - 1];
  410|     32|                }
  411|       |                // Parse as i64, handle hex, octal, decimal
  412|     32|                let num = if num_text.starts_with("0x") || num_text.starts_with("0X") {
                                                                         ^30      ^30
  413|      2|                    i64::from_str_radix(&num_text[2..], 16)
  414|     30|                } else if num_text.starts_with("0") && num_text.len() > 1 {
                                                                     ^5
  415|      0|                    i64::from_str_radix(num_text, 8)
  416|       |                } else {
  417|     30|                    num_text.parse::<i64>()
  418|       |                }
  419|     32|                .map_err(|_| PPError::InvalidConditionalExpression)?;
                                                                                 ^0
  420|     32|                Ok(PPExpr::Number(num))
  421|       |            }
  422|      0|            PPTokenKind::CharLiteral(codepoint, _) => Ok(PPExpr::Number(*codepoint as i64)),
  423|      3|            PPTokenKind::Identifier(sym) => {
  424|       |                // Identifiers are 0 if not defined, but since we expanded macros, should be numbers
  425|      3|                Ok(PPExpr::Identifier(sym.as_str().to_string()))
  426|       |            }
  427|       |            PPTokenKind::LeftParen => {
  428|     10|                let result = self.parse_conditional()?;
                                                                   ^0
  429|     10|                if self.pos < self.tokens.len() && matches!(self.tokens[self.pos].kind, PPTokenKind::RightParen) {
                                                                 ^0
  430|     10|                    self.pos += 1;
  431|     10|                    Ok(result)
  432|       |                } else {
  433|      0|                    Err(PPError::InvalidConditionalExpression)
  434|       |                }
  435|       |            }
  436|      0|            _ => Err(PPError::InvalidConditionalExpression),
  437|       |        }
  438|     45|    }
  439|       |}

/app/src/pp/pp_lexer.rs:
    1|       |use crate::{
    2|       |    intern::StringId,
    3|       |    source_manager::{SourceId, SourceLoc},
    4|       |};
    5|       |
    6|       |// Packed token flags for preprocessor tokens
    7|       |bitflags::bitflags! {
    8|       |    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    9|       |    pub struct PPTokenFlags: u8 {
   10|       |        const LEADING_SPACE = 1 << 0;  // Token has leading whitespace
   11|       |        const STARTS_PP_LINE = 1 << 1; // Token starts a preprocessing line
   12|       |        const NEEDS_CLEANUP = 1 << 2;  // Token needs cleanup after expansion
   13|       |        const MACRO_EXPANDED = 1 << 3; // Token was generated by macro expansion
   14|       |    }
   15|       |}
   16|       |
   17|       |/// Token kinds for preprocessor tokens
   18|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   19|       |pub enum PPTokenKind {
   20|       |    // Punctuation and operators
   21|       |    Plus,
   22|       |    Minus,
   23|       |    Star,
   24|       |    Slash,
   25|       |    Percent, // + - * / %
   26|       |    And,
   27|       |    Or,
   28|       |    Xor,
   29|       |    Not,
   30|       |    Tilde, // & | ^ ! ~
   31|       |    Less,
   32|       |    Greater,
   33|       |    LessEqual,
   34|       |    GreaterEqual,
   35|       |    Equal,
   36|       |    NotEqual, // < > <= >= == !=
   37|       |    LeftShift,
   38|       |    RightShift, // << >>
   39|       |    Assign,
   40|       |    PlusAssign,
   41|       |    MinusAssign, // = += -=
   42|       |    StarAssign,
   43|       |    DivAssign,
   44|       |    ModAssign, // *= /= %=
   45|       |    AndAssign,
   46|       |    OrAssign,
   47|       |    XorAssign, // &= |= ^=
   48|       |    LeftShiftAssign,
   49|       |    RightShiftAssign, // <<= >>=
   50|       |    Increment,
   51|       |    Decrement, // ++ --
   52|       |    Arrow,
   53|       |    Dot, // -> .
   54|       |    Question,
   55|       |    Colon, // ? :
   56|       |    Comma,
   57|       |    Semicolon, // , ;
   58|       |    LeftParen,
   59|       |    RightParen, // ( )
   60|       |    LeftBracket,
   61|       |    RightBracket, // [ ]
   62|       |    LeftBrace,
   63|       |    RightBrace, // { }
   64|       |    Ellipsis,   // ...
   65|       |    LogicAnd,
   66|       |    LogicOr, // && ||
   67|       |    Hash,
   68|       |    HashHash, // # ##
   69|       |    // Literals and identifiers
   70|       |    Identifier(StringId),      // Interned identifier
   71|       |    StringLiteral(StringId),   // Interned string literal
   72|       |    CharLiteral(u8, StringId), // byte char value and raw text
   73|       |    Number(StringId),          // Raw numeric literal text for parser
   74|       |    // Special
   75|       |    Eof,
   76|       |    Eod,
   77|       |    Unknown,
   78|       |}
   79|       |
   80|       |/// Token structure for preprocessor tokens
   81|       |#[derive(Clone, Copy, Debug)]
   82|       |pub struct PPToken {
   83|       |    pub kind: PPTokenKind,
   84|       |    pub flags: PPTokenFlags,
   85|       |    pub location: SourceLoc, // Contains file ID and byte offset
   86|       |    pub length: u16,         // Maximum token length (64KB should be sufficient for any token)
   87|       |}
   88|       |
   89|       |impl PPToken {
   90|       |    /// Create a PPToken with full control over all fields
   91|  25.9k|    pub fn new(kind: PPTokenKind, flags: PPTokenFlags, location: SourceLoc, length: u16) -> Self {
   92|  25.9k|        PPToken {
   93|  25.9k|            kind,
   94|  25.9k|            flags,
   95|  25.9k|            location,
   96|  25.9k|            length,
   97|  25.9k|        }
   98|  25.9k|    }
   99|       |
  100|       |    /// Create a simple PPToken with empty flags and length 1 (most common case)
  101|    695|    pub fn simple(kind: PPTokenKind, location: SourceLoc) -> Self {
  102|    695|        PPToken::new(kind, PPTokenFlags::empty(), location, 1)
  103|    695|    }
  104|       |
  105|       |    /// Create a PPToken with text-based length
  106|  5.94k|    pub fn text(kind: PPTokenKind, flags: PPTokenFlags, location: SourceLoc, text: &str) -> Self {
  107|  5.94k|        PPToken::new(kind, flags, location, text.len() as u16)
  108|  5.94k|    }
  109|       |
  110|       |    /// Create a PPToken with custom flags and length 1
  111|    201|    pub fn with_flags(kind: PPTokenKind, flags: PPTokenFlags, location: SourceLoc) -> Self {
  112|    201|        PPToken::new(kind, flags, location, 1)
  113|    201|    }
  114|       |
  115|       |    /// Get the raw byte slice from the source buffer for this token
  116|     17|    pub fn get_raw_slice<'a>(&self, buffer: &'a [u8]) -> &'a [u8] {
  117|     17|        let start = self.location.offset() as usize;
  118|     17|        let end = start + self.length as usize;
  119|     17|        &buffer[start..end]
  120|     17|    }
  121|       |
  122|       |    /// Get the text representation of the token
  123|    768|    pub fn get_text(&self) -> &str {
  124|    768|        match &self.kind {
  125|    241|            PPTokenKind::Identifier(sym) => sym.as_str(),
  126|    135|            PPTokenKind::Number(sym) => sym.as_str(),
  127|     57|            PPTokenKind::StringLiteral(sym) => sym.as_str(),
  128|      5|            PPTokenKind::CharLiteral(_, sym) => sym.as_str(),
  129|     56|            PPTokenKind::LeftParen => "(",
  130|     56|            PPTokenKind::RightParen => ")",
  131|      3|            PPTokenKind::LeftBracket => "[",
  132|      2|            PPTokenKind::RightBracket => "]",
  133|      2|            PPTokenKind::LeftBrace => "{",
  134|      2|            PPTokenKind::RightBrace => "}",
  135|      7|            PPTokenKind::Plus => "+",
  136|      1|            PPTokenKind::Minus => "-",
  137|     11|            PPTokenKind::Star => "*",
  138|      1|            PPTokenKind::Slash => "/",
  139|      2|            PPTokenKind::Percent => "%",
  140|      1|            PPTokenKind::And => "&",
  141|      1|            PPTokenKind::Or => "|",
  142|      1|            PPTokenKind::Xor => "^",
  143|      1|            PPTokenKind::Not => "!",
  144|      1|            PPTokenKind::Tilde => "~",
  145|      2|            PPTokenKind::Less => "<",
  146|      1|            PPTokenKind::Greater => ">",
  147|      1|            PPTokenKind::LessEqual => "<=",
  148|      1|            PPTokenKind::GreaterEqual => ">=",
  149|      1|            PPTokenKind::Equal => "==",
  150|      1|            PPTokenKind::NotEqual => "!=",
  151|      1|            PPTokenKind::LeftShift => "<<",
  152|      1|            PPTokenKind::RightShift => ">>",
  153|     57|            PPTokenKind::Assign => "=",
  154|      4|            PPTokenKind::PlusAssign => "+=",
  155|      1|            PPTokenKind::MinusAssign => "-=",
  156|      1|            PPTokenKind::StarAssign => "*=",
  157|      1|            PPTokenKind::DivAssign => "/=",
  158|      1|            PPTokenKind::ModAssign => "%=",
  159|      1|            PPTokenKind::AndAssign => "&=",
  160|      1|            PPTokenKind::OrAssign => "|=",
  161|      1|            PPTokenKind::XorAssign => "^=",
  162|      1|            PPTokenKind::LeftShiftAssign => "<<=",
  163|      1|            PPTokenKind::RightShiftAssign => ">>=",
  164|      1|            PPTokenKind::Increment => "++",
  165|      1|            PPTokenKind::Decrement => "--",
  166|      1|            PPTokenKind::Arrow => "->",
  167|      1|            PPTokenKind::Dot => ".",
  168|      1|            PPTokenKind::Question => "?",
  169|      2|            PPTokenKind::Colon => ":",
  170|     22|            PPTokenKind::Comma => ",",
  171|     63|            PPTokenKind::Semicolon => ";",
  172|      1|            PPTokenKind::Ellipsis => "...",
  173|      1|            PPTokenKind::LogicAnd => "&&",
  174|      1|            PPTokenKind::LogicOr => "||",
  175|      4|            PPTokenKind::Hash => "#",
  176|      2|            PPTokenKind::HashHash => "##",
  177|      0|            PPTokenKind::Eof => "",
  178|      2|            PPTokenKind::Eod => "",
  179|      0|            PPTokenKind::Unknown => "?",
  180|       |        }
  181|    768|    }
  182|       |}
  183|       |
  184|       |/// Manages lexing from different source buffers
  185|       |pub(crate) struct PPLexer {
  186|       |    pub(crate) source_id: SourceId,
  187|       |    buffer: Vec<u8>,
  188|       |    pub(crate) position: u32, // its okay to use u32 here since source files are limited to 4 MB
  189|       |    line_starts: Vec<u32>,
  190|       |    put_back_token: Option<PPToken>,
  191|       |    pub(crate) line_offset: u32,
  192|       |    // pub filename_override: Option<String>,
  193|       |    pub(crate) in_directive_line: bool, // Whether we are currently processing tokens on a directive line
  194|       |}
  195|       |
  196|       |impl PPLexer {
  197|    770|    pub(crate) fn new(source_id: SourceId, buffer: Vec<u8>) -> Self {
  198|    770|        let line_starts = vec![0]; // First line starts at offset 0
  199|       |
  200|    770|        PPLexer {
  201|    770|            source_id,
  202|    770|            buffer,
  203|    770|            position: 0,
  204|    770|            line_starts,
  205|    770|            put_back_token: None,
  206|    770|            line_offset: 0,
  207|    770|            // filename_override: None,
  208|    770|            in_directive_line: false,
  209|    770|        }
  210|    770|    }
  211|       |
  212|       |    /// Get the next character, handling line splicing transparently
  213|       |    /// Line splicing: backslash followed by newline removes both characters
  214|   125k|    pub(crate) fn next_char(&mut self) -> Option<u8> {
  215|   125k|        if self.position as usize >= self.buffer.len() {
  216|  1.23k|            return None;
  217|   123k|        }
  218|       |
  219|   123k|        let mut result = self.buffer[self.position as usize];
  220|   123k|        self.position += 1;
  221|       |
  222|       |        // Handle line splicing: backslash followed by newline or carriage return
  223|       |        loop {
  224|   123k|            if result == b'\\' && (self.position as usize) < self.buffer.len() {
                                                ^61
  225|     60|                let next = self.buffer[self.position as usize];
  226|     60|                if next == b'\n' || next == b'\r' {
                                                  ^36
  227|     35|                    self.position += 1;
  228|     35|                    if next == b'\r'
  229|     11|                        && (self.position as usize) < self.buffer.len()
  230|     10|                        && self.buffer[self.position as usize] == b'\n'
  231|      8|                    {
  232|      8|                        self.position += 1;
  233|     27|                    }
  234|       |                    // Get the character after the line ending for splicing
  235|     35|                    if (self.position as usize) < self.buffer.len() {
  236|     34|                        result = self.buffer[self.position as usize];
  237|     34|                        self.position += 1;
  238|     34|                        continue;
  239|       |                    } else {
  240|      1|                        return None;
  241|       |                    }
  242|     25|                }
  243|   123k|            }
  244|   123k|            break;
  245|       |        }
  246|       |
  247|       |        // Update line starts for regular newlines
  248|   123k|        if result == b'\n' {
  249|  4.51k|            self.line_starts.push(self.position);
  250|   119k|        }
  251|       |
  252|   123k|        Some(result)
  253|   125k|    }
  254|       |
  255|       |    /// Peek at the next character without consuming it, handling line splicing
  256|  52.4k|    pub(crate) fn peek_char(&mut self) -> Option<u8> {
  257|  52.4k|        let saved_position = self.position;
  258|  52.4k|        let saved_line_starts = self.line_starts.clone();
  259|       |
  260|  52.4k|        let result = self.next_char();
  261|       |
  262|       |        // Restore state
  263|  52.4k|        self.position = saved_position;
  264|  52.4k|        self.line_starts = saved_line_starts;
  265|       |
  266|  52.4k|        result
  267|  52.4k|    }
  268|       |
  269|       |    ///  Bolt: Consolidated operator lexing.
  270|       |    /// This helper function centralizes the logic for lexing single and multi-character operators,
  271|       |    /// significantly reducing code duplication and branching in the main `next_token` function.
  272|       |    /// This improves performance by making the tokenization logic more direct and predictable
  273|       |    /// for the compiler to optimize. It also fixes a bug in the original `...` lexing logic.
  274|  6.16k|    fn lex_operator(&mut self, start_pos: u32, ch: u8, flags: PPTokenFlags) -> PPToken {
  275|  6.16k|        let loc = SourceLoc::new(self.source_id, start_pos);
  276|       |
  277|       |        // Helper macro to reduce boilerplate when creating a token.
  278|       |        macro_rules! token {
  279|       |            ($kind:expr, $len:expr) => {
  280|       |                PPToken::new($kind, flags, loc, $len)
  281|       |            };
  282|       |        }
  283|       |
  284|       |        // Helper macro to check the next character and consume it if it matches.
  285|       |        macro_rules! consume_if {
  286|       |            ($c:expr) => {{
  287|       |                if self.peek_char() == Some($c) {
  288|       |                    self.next_char();
  289|       |                    true
  290|       |                } else {
  291|       |                    false
  292|       |                }
  293|       |            }};
  294|       |        }
  295|       |
  296|  6.16k|        match ch {
  297|       |            b'+' => {
  298|     96|                if consume_if!(b'+') {
  299|     38|                    token!(PPTokenKind::Increment, 2)
  300|     58|                } else if consume_if!(b'=') {
  301|      6|                    token!(PPTokenKind::PlusAssign, 2)
  302|       |                } else {
  303|     52|                    token!(PPTokenKind::Plus, 1)
  304|       |                }
  305|       |            }
  306|       |            b'-' => {
  307|     69|                if consume_if!(b'-') {
  308|     21|                    token!(PPTokenKind::Decrement, 2)
  309|     48|                } else if consume_if!(b'=') {
  310|      5|                    token!(PPTokenKind::MinusAssign, 2)
  311|     43|                } else if consume_if!(b'>') {
  312|     17|                    token!(PPTokenKind::Arrow, 2)
  313|       |                } else {
  314|     26|                    token!(PPTokenKind::Minus, 1)
  315|       |                }
  316|       |            }
  317|       |            b'*' => {
  318|    189|                if consume_if!(b'=') {
  319|      3|                    token!(PPTokenKind::StarAssign, 2)
  320|       |                } else {
  321|    186|                    token!(PPTokenKind::Star, 1)
  322|       |                }
  323|       |            }
  324|       |            b'/' => {
  325|      7|                if consume_if!(b'=') {
  326|      3|                    token!(PPTokenKind::DivAssign, 2)
  327|       |                } else {
  328|      4|                    token!(PPTokenKind::Slash, 1)
  329|       |                }
  330|       |            }
  331|       |            b'%' => {
  332|      9|                if consume_if!(b'=') {
  333|      3|                    token!(PPTokenKind::ModAssign, 2)
  334|      6|                } else if consume_if!(b'>') {
  335|      1|                    token!(PPTokenKind::RightBrace, 2)
  336|       |                } else {
  337|      5|                    token!(PPTokenKind::Percent, 1)
  338|       |                }
  339|       |            }
  340|       |            b'=' => {
  341|    623|                if consume_if!(b'=') {
  342|     11|                    token!(PPTokenKind::Equal, 2)
  343|       |                } else {
  344|    612|                    token!(PPTokenKind::Assign, 1)
  345|       |                }
  346|       |            }
  347|       |            b'!' => {
  348|     50|                if consume_if!(b'=') {
  349|     44|                    token!(PPTokenKind::NotEqual, 2)
  350|       |                } else {
  351|      6|                    token!(PPTokenKind::Not, 1)
  352|       |                }
  353|       |            }
  354|       |            b'<' => {
  355|     71|                if consume_if!(b'<') {
  356|      5|                    if consume_if!(b'=') {
  357|      2|                        token!(PPTokenKind::LeftShiftAssign, 3)
  358|       |                    } else {
  359|      3|                        token!(PPTokenKind::LeftShift, 2)
  360|       |                    }
  361|     66|                } else if consume_if!(b'=') {
  362|      3|                    token!(PPTokenKind::LessEqual, 2)
  363|     63|                } else if consume_if!(b':') {
  364|      2|                    token!(PPTokenKind::LeftBracket, 2)
  365|     61|                } else if consume_if!(b'%') {
  366|      1|                    token!(PPTokenKind::LeftBrace, 2)
  367|       |                } else {
  368|     60|                    token!(PPTokenKind::Less, 1)
  369|       |                }
  370|       |            }
  371|       |            b'>' => {
  372|     49|                if consume_if!(b'>') {
  373|      4|                    if consume_if!(b'=') {
  374|      2|                        token!(PPTokenKind::RightShiftAssign, 3)
  375|       |                    } else {
  376|      2|                        token!(PPTokenKind::RightShift, 2)
  377|       |                    }
  378|     45|                } else if consume_if!(b'=') {
  379|      4|                    token!(PPTokenKind::GreaterEqual, 2)
  380|       |                } else {
  381|     41|                    token!(PPTokenKind::Greater, 1)
  382|       |                }
  383|       |            }
  384|       |            b'&' => {
  385|     61|                if consume_if!(b'&') {
  386|      3|                    token!(PPTokenKind::LogicAnd, 2)
  387|     58|                } else if consume_if!(b'=') {
  388|      2|                    token!(PPTokenKind::AndAssign, 2)
  389|       |                } else {
  390|     56|                    token!(PPTokenKind::And, 1)
  391|       |                }
  392|       |            }
  393|       |            b'|' => {
  394|     16|                if consume_if!(b'|') {
  395|     11|                    token!(PPTokenKind::LogicOr, 2)
  396|      5|                } else if consume_if!(b'=') {
  397|      2|                    token!(PPTokenKind::OrAssign, 2)
  398|       |                } else {
  399|      3|                    token!(PPTokenKind::Or, 1)
  400|       |                }
  401|       |            }
  402|       |            b'^' => {
  403|      4|                if consume_if!(b'=') {
  404|      2|                    token!(PPTokenKind::XorAssign, 2)
  405|       |                } else {
  406|      2|                    token!(PPTokenKind::Xor, 1)
  407|       |                }
  408|       |            }
  409|      4|            b'~' => token!(PPTokenKind::Tilde, 1),
  410|       |            b'.' => 'ellipsis: {
  411|     87|                let pos_after_first = self.position;
  412|     87|                if self.peek_char() == Some(b'.') {
  413|     17|                    self.next_char(); // Consume second '.'
  414|     17|                    if self.peek_char() == Some(b'.') {
  415|     17|                        self.next_char(); // Consume third '.'
  416|     17|                        break 'ellipsis token!(PPTokenKind::Ellipsis, 3);
  417|      0|                    }
  418|       |                    // It was '..', which is not a valid C token. Backtrack to handle it as a single '.'
  419|      0|                    self.position = pos_after_first;
  420|     70|                }
  421|     70|                token!(PPTokenKind::Dot, 1)
  422|       |            }
  423|      8|            b'?' => token!(PPTokenKind::Question, 1),
  424|       |            b':' => {
  425|     97|                if consume_if!(b'>') {
  426|      1|                    token!(PPTokenKind::RightBracket, 2)
  427|       |                } else {
  428|     96|                    token!(PPTokenKind::Colon, 1)
  429|       |                }
  430|       |            }
  431|    311|            b',' => token!(PPTokenKind::Comma, 1),
  432|  1.41k|            b';' => token!(PPTokenKind::Semicolon, 1),
  433|    793|            b'(' => token!(PPTokenKind::LeftParen, 1),
  434|    792|            b')' => token!(PPTokenKind::RightParen, 1),
  435|    162|            b'[' => token!(PPTokenKind::LeftBracket, 1),
  436|    162|            b']' => token!(PPTokenKind::RightBracket, 1),
  437|    545|            b'{' => token!(PPTokenKind::LeftBrace, 1),
  438|    542|            b'}' => token!(PPTokenKind::RightBrace, 1),
  439|      0|            _ => token!(PPTokenKind::Unknown, 1),
  440|       |        }
  441|  6.16k|    }
  442|       |
  443|  13.2k|    pub(crate) fn next_token(&mut self) -> Option<PPToken> {
  444|  13.2k|        if let Some(token) = self.put_back_token.take() {
                                  ^0
  445|      0|            return Some(token);
  446|  13.2k|        }
  447|       |
  448|  13.2k|        let saved_position = self.position;
  449|  13.2k|        self.skip_whitespace_and_comments();
  450|  13.2k|        let had_leading_space = self.position > saved_position;
  451|       |
  452|  13.2k|        if self.position as usize >= self.buffer.len() {
  453|    718|            if self.in_directive_line {
  454|     24|                self.in_directive_line = false;
  455|     24|                return Some(PPToken::new(
  456|     24|                    PPTokenKind::Eod,
  457|     24|                    PPTokenFlags::empty(),
  458|     24|                    SourceLoc::new(self.source_id, self.position),
  459|     24|                    0,
  460|     24|                ));
  461|       |            } else {
  462|    694|                return None;
  463|       |            }
  464|  12.5k|        }
  465|       |
  466|  12.5k|        let flags = if had_leading_space {
  467|  6.80k|            PPTokenFlags::LEADING_SPACE
  468|       |        } else {
  469|  5.74k|            PPTokenFlags::empty()
  470|       |        };
  471|       |
  472|  12.5k|        let start_pos = self.position;
  473|  12.5k|        let ch = self.next_char().unwrap_or(b' ');
  474|       |
  475|       |        // Check if this is a newline that ends a directive line
  476|       |        // Only \n triggers Eod, \r is treated as whitespace (Windows \r\n support)
  477|  12.5k|        if ch == b'\n' && self.in_directive_line {
                                        ^162
  478|    162|            self.in_directive_line = false;
  479|    162|            return Some(PPToken::new(
  480|    162|                PPTokenKind::Eod,
  481|    162|                flags,
  482|    162|                SourceLoc::new(self.source_id, start_pos),
  483|    162|                1,
  484|    162|            ));
  485|  12.3k|        }
  486|       |
  487|  12.3k|        match ch {
  488|  5.15k|            b'a'..=b'z' | b'A'..=b'Z' | b'_' => {
                                        ^1.90k
  489|  4.51k|                if ch == b'L' || ch == b'u' || ch == b'U' {
                                               ^4.49k        ^4.41k
  490|    109|                    let next_ch = self.peek_char();
  491|    109|                    if next_ch == Some(b'"') {
  492|     20|                        Some(self.lex_string_literal(start_pos, ch, flags))
  493|     89|                    } else if next_ch == Some(b'\'') {
  494|      3|                        Some(self.lex_char_literal(start_pos, ch, flags))
  495|       |                    } else {
  496|     86|                        Some(self.lex_identifier(start_pos, ch, flags))
  497|       |                    }
  498|       |                } else {
  499|  4.40k|                    Some(self.lex_identifier(start_pos, ch, flags))
  500|       |                }
  501|       |            }
  502|  1.22k|            b'0'..=b'9' => Some(self.lex_number(start_pos, ch, flags)),
                                         ^1.22k^1.22k^1.22k     ^1.22k
  503|    215|            b'"' => Some(self.lex_string_literal(start_pos, ch, flags)),
  504|     57|            b'\'' => Some(self.lex_char_literal(start_pos, ch, flags)),
  505|       |            b'#' => {
  506|    207|                let mut token_flags = flags;
  507|    207|                token_flags |= PPTokenFlags::STARTS_PP_LINE;
  508|    207|                if self.peek_char() == Some(b'#') {
  509|      9|                    self.next_char(); // consume the second #
  510|      9|                    Some(PPToken::new(
  511|      9|                        PPTokenKind::HashHash,
  512|      9|                        flags, // HashHash does not start a PP line
  513|      9|                        SourceLoc::new(self.source_id, start_pos),
  514|      9|                        2,
  515|      9|                    ))
  516|       |                } else {
  517|       |                    // Set directive line flag when we encounter a # that starts a preprocessor line
  518|    198|                    self.in_directive_line = true;
  519|    198|                    Some(PPToken::with_flags(
  520|    198|                        PPTokenKind::Hash,
  521|    198|                        token_flags,
  522|    198|                        SourceLoc::new(self.source_id, start_pos),
  523|    198|                    ))
  524|       |                }
  525|       |            }
  526|       |            b'%' => {
  527|     14|                if self.peek_char() == Some(b':') {
  528|      5|                    self.next_char(); // consume :
  529|       |                    // Check for %:%: (##)
  530|      5|                    let saved_pos = self.position;
  531|      5|                    let saved_lines = self.line_starts.clone();
  532|       |
  533|      5|                    if self.peek_char() == Some(b'%') {
  534|      2|                        self.next_char(); // consume %
  535|      2|                        if self.peek_char() == Some(b':') {
  536|      2|                            self.next_char(); // consume :
  537|      2|                            Some(PPToken::new(
  538|      2|                                PPTokenKind::HashHash,
  539|      2|                                flags,
  540|      2|                                SourceLoc::new(self.source_id, start_pos),
  541|      2|                                4,
  542|      2|                            ))
  543|       |                        } else {
  544|       |                            // Backtrack
  545|      0|                            self.position = saved_pos;
  546|      0|                            self.line_starts = saved_lines;
  547|       |
  548|      0|                            let mut token_flags = flags;
  549|      0|                            token_flags |= PPTokenFlags::STARTS_PP_LINE;
  550|      0|                            self.in_directive_line = true;
  551|      0|                            Some(PPToken::with_flags(
  552|      0|                                PPTokenKind::Hash,
  553|      0|                                token_flags,
  554|      0|                                SourceLoc::new(self.source_id, start_pos),
  555|      0|                            ))
  556|       |                        }
  557|       |                    } else {
  558|       |                        // %: -> Hash
  559|      3|                        let mut token_flags = flags;
  560|      3|                        token_flags |= PPTokenFlags::STARTS_PP_LINE;
  561|      3|                        self.in_directive_line = true;
  562|      3|                        Some(PPToken::with_flags(
  563|      3|                            PPTokenKind::Hash,
  564|      3|                            token_flags,
  565|      3|                            SourceLoc::new(self.source_id, start_pos),
  566|      3|                        ))
  567|       |                    }
  568|       |                } else {
  569|      9|                    Some(self.lex_operator(start_pos, ch, flags))
  570|       |                }
  571|       |            }
  572|       |            // All operators and punctuation are handled by the optimized helper function.
  573|       |            b'+' | b'-' | b'*' | b'/' | b'=' | b'!' | b'<' | b'>' | b'&' | b'|' | b'^' | b'~' | b'.' | b'?' | b':'
  574|  6.15k|            | b',' | b';' | b'(' | b')' | b'[' | b']' | b'{' | b'}' => Some(self.lex_operator(start_pos, ch, flags)),
  575|      1|            _ => Some(PPToken::new(
  576|      1|                PPTokenKind::Unknown,
  577|      1|                flags,
  578|      1|                SourceLoc::new(self.source_id, start_pos),
  579|      1|                1,
  580|      1|            )),
  581|       |        }
  582|  13.2k|    }
  583|       |
  584|  13.2k|    fn skip_whitespace_and_comments(&mut self) {
  585|       |        loop {
  586|       |            // Skip whitespace, handling line splicing
  587|       |            // But don't skip newlines if we're in a directive line (let them be processed as tokens)
  588|  32.5k|            while let Some(ch) = self.peek_char() {
                                         ^31.7k
  589|  31.7k|                if ch.is_ascii_whitespace() && !(ch == b'\n' && self.in_directive_line) {
                                                               ^19.3k         ^1.51k
  590|  19.2k|                    self.next_char();
  591|  19.2k|                } else {
  592|  12.5k|                    break;
  593|       |                }
  594|       |            }
  595|       |
  596|  13.2k|            if self.position as usize >= self.buffer.len() {
  597|    718|                break;
  598|  12.5k|            }
  599|       |
  600|       |            // Check for comments by temporarily consuming
  601|  12.5k|            let saved_position = self.position;
  602|  12.5k|            let saved_line_starts = self.line_starts.clone();
  603|       |
  604|  12.5k|            let ch1 = self.next_char();
  605|  12.5k|            let ch2 = self.next_char();
  606|       |
  607|  12.5k|            if ch1 == Some(b'/') && ch2 == Some(b'/') {
                                                  ^41
  608|       |                // Line comment, skip to end of line
  609|    986|                while let Some(ch) = self.next_char() {
  610|    986|                    if ch == b'\n' {
  611|     34|                        break;
  612|    952|                    }
  613|       |                }
  614|       |                // Continue loop
  615|  12.5k|            } else if ch1 == Some(b'/') && ch2 == Some(b'*') {
                                                         ^7
  616|       |                // Block comment, skip to */
  617|      0|                while let Some(ch) = self.next_char() {
  618|      0|                    if ch == b'*' && self.peek_char() == Some(b'/') {
  619|      0|                        self.next_char(); // consume '/'
  620|      0|                        break;
  621|      0|                    }
  622|       |                }
  623|       |                // Continue loop
  624|       |            } else {
  625|       |                // Not a comment, restore position
  626|  12.5k|                self.position = saved_position;
  627|  12.5k|                self.line_starts = saved_line_starts;
  628|  12.5k|                break;
  629|       |            }
  630|       |        }
  631|  13.2k|    }
  632|       |
  633|       |    /// Consumes characters based on a predicate, building a string.
  634|       |    ///
  635|       |    /// The predicate receives the current state and the character.
  636|       |    /// It should return `true` to consume the character, or `false` to stop.
  637|       |    /// The closure can modify state (e.g., tracking scientific notation 'e').
  638|  5.71k|    fn consume_while<F, S>(&mut self, mut state: S, first_ch: u8, mut pred: F) -> String
  639|  5.71k|    where
  640|  5.71k|        F: FnMut(&mut S, u8) -> bool,
  641|       |    {
  642|  5.71k|        let mut chars = vec![first_ch];
  643|  17.6k|        while let Some(ch) = self.peek_char() {
                                     ^17.5k
  644|  17.5k|            if pred(&mut state, ch) {
  645|  11.9k|                chars.push(self.next_char().unwrap());
  646|  11.9k|            } else {
  647|  5.60k|                break;
  648|       |            }
  649|       |        }
  650|       |        // Safety: We assume the caller only consumes valid UTF-8 characters (identifiers/numbers)
  651|       |        // or we handle validation later. For identifiers/numbers constructed from ascii, this is safe.
  652|       |        // Actually, identifiers can contain unicode in some extensions, but here we assume standard handling.
  653|       |        // PPLexer usually deals with bytes, but text tokens are generally UTF-8 compatible.
  654|  5.71k|        String::from_utf8(chars).unwrap()
  655|  5.71k|    }
  656|       |
  657|  4.49k|    fn lex_identifier(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
  658|  15.7k|        let text = self.consume_while((), first_ch, |_, ch| ch.is_ascii_alphanumeric() || ch == b'_');
                          ^4.49k ^4.49k^4.49k        ^4.49k^4.49k                                          ^4.61k
  659|       |
  660|  4.49k|        let symbol = StringId::new(&text);
  661|  4.49k|        let kind = PPTokenKind::Identifier(symbol);
  662|       |
  663|  4.49k|        PPToken::text(kind, flags, SourceLoc::new(self.source_id, start_pos), &text)
  664|  4.49k|    }
  665|       |
  666|  1.22k|    fn lex_number(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
  667|  1.76k|        let text = self.consume_while(false, first_ch, |seen_e, ch| {
                          ^1.22k ^1.22k^1.22k               ^1.22k
  668|  1.76k|            if ch.is_ascii_digit() || ch == b'.' || ch.is_ascii_alphabetic() || ch == b'_' {
                                                    ^1.32k        ^1.28k^1.28k                   ^1.17k
  669|    582|                if ch == b'e' || ch == b'E' {
                                               ^581
  670|      1|                    *seen_e = true;
  671|    581|                }
  672|    582|                true
  673|  1.17k|            } else if (ch == b'+' || ch == b'-') && *seen_e {
                                                   ^1.17k         ^7
  674|       |                // Allow + or - after e/E for scientific notation
  675|      1|                *seen_e = false; // Reset so we don't allow multiple +/- immediately
  676|      1|                true
  677|       |            } else {
  678|  1.17k|                false
  679|       |            }
  680|  1.76k|        });
  681|       |
  682|  1.22k|        let symbol = StringId::new(&text);
  683|       |
  684|  1.22k|        PPToken::text(
  685|  1.22k|            PPTokenKind::Number(symbol),
  686|  1.22k|            flags,
  687|  1.22k|            SourceLoc::new(self.source_id, start_pos),
  688|  1.22k|            &text,
  689|       |        )
  690|  1.22k|    }
  691|       |
  692|    295|    fn lex_common_literal_body(&mut self, delimiter: u8, chars: &mut Vec<u8>) {
  693|  2.45k|        while let Some(ch) = self.next_char() {
                                     ^2.45k
  694|  2.45k|            chars.push(ch);
  695|  2.45k|            if ch == delimiter {
  696|    294|                break; // End of literal
  697|  2.15k|            } else if ch == b'\\' {
  698|       |                // Handle escape sequences, including line splicing
  699|     20|                if let Some(next_ch) = self.next_char() {
  700|     20|                    chars.push(next_ch);
  701|     20|                    if next_ch == b'\n' {
  702|       |                        // This is line splicing within a string - the newline is consumed as part of the escape
  703|      0|                        continue;
  704|     20|                    }
  705|      0|                }
  706|  2.13k|            } else if ch >= 0x80 {
  707|       |                // Handle UTF-8 multi-byte characters
  708|     43|                if self.is_valid_utf8_start(ch) {
  709|       |                    // Consume continuation bytes for valid UTF-8 sequences
  710|    102|                    while let Some(continuation_ch) = self.peek_char() {
  711|    102|                        if (0x80..0xC0).contains(&continuation_ch) {
  712|     59|                            chars.push(self.next_char().unwrap());
  713|     59|                        } else {
  714|     43|                            break;
  715|       |                        }
  716|       |                    }
  717|      0|                }
  718|  2.09k|            }
  719|       |        }
  720|    295|    }
  721|       |
  722|    235|    fn lex_string_literal(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
  723|    235|        let has_prefix = first_ch == b'L' || first_ch == b'u' || first_ch == b'U';
                                                           ^219                ^217
  724|    235|        let mut chars = vec![first_ch];
  725|       |
  726|    235|        if has_prefix {
  727|     20|            // consume the "
  728|     20|            let quote = self.next_char().unwrap();
  729|     20|            chars.push(quote);
  730|    215|        }
  731|       |
  732|    235|        self.lex_common_literal_body(b'"', &mut chars);
  733|       |
  734|    235|        let text = String::from_utf8(chars).unwrap();
  735|    235|        let symbol = StringId::new(&text);
  736|       |
  737|    235|        PPToken::text(
  738|    235|            PPTokenKind::StringLiteral(symbol),
  739|    235|            flags,
  740|    235|            SourceLoc::new(self.source_id, start_pos),
  741|    235|            &text,
  742|       |        )
  743|    235|    }
  744|       |
  745|       |    /// Check if a byte is a valid start of a UTF-8 sequence
  746|       |    /// Returns true if this could be the start of a valid UTF-8 sequence
  747|     43|    fn is_valid_utf8_start(&self, byte: u8) -> bool {
  748|       |        // Valid UTF-8 start bytes:
  749|       |        // 0x00-0x7F: ASCII (single byte, handled elsewhere)
  750|       |        // 0xC2-0xF4: Start of multi-byte sequence
  751|       |        // Invalid starts: 0x80-0xBF (continuation bytes), 0xC0, 0xC1, 0xF5-0xFF
  752|     43|        (0xC2..=0xF4).contains(&byte)
  753|     43|    }
  754|       |
  755|     60|    fn lex_char_literal(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
  756|     60|        let has_prefix = first_ch == b'L' || first_ch == b'u' || first_ch == b'U';
                                                           ^59                 ^58
  757|     60|        let mut chars = vec![first_ch];
  758|       |
  759|     60|        if has_prefix {
  760|      3|            // consume the '
  761|      3|            let quote = self.next_char().unwrap();
  762|      3|            chars.push(quote);
  763|     57|        }
  764|       |
  765|     60|        self.lex_common_literal_body(b'\'', &mut chars);
  766|       |
  767|       |        // Parse character literal content
  768|     60|        let quote_start = if has_prefix { 1 } else { 0 };
                                                        ^3         ^57
  769|     60|        let content_start = quote_start + 1;
  770|     60|        let content_len = chars.len() - content_start - 1; // exclude closing '
  771|       |
  772|     60|        let codepoint = if content_len == 1 {
  773|     57|            chars[content_start]
  774|      3|        } else if content_len == 2 && chars[content_start] == b'\\' {
  775|       |            // Handle escape sequences
  776|      3|            match chars[content_start + 1] {
  777|      2|                b'0' => 0,                     // null
  778|      1|                b'n' => 10,                    // newline
  779|      0|                b't' => 9,                     // tab
  780|      0|                b'r' => 13,                    // carriage return
  781|      0|                b'\\' => 92,                   // backslash
  782|      0|                b'\'' => 39,                   // single quote
  783|      0|                b'"' => 34,                    // double quote
  784|      0|                _ => chars[content_start + 1], // fallback to the escaped char
  785|       |            }
  786|       |        } else {
  787|      0|            0 // placeholder for complex cases (multibyte chars, etc.)
  788|       |        };
  789|       |
  790|     60|        let text = String::from_utf8(chars).unwrap();
  791|     60|        let symbol = StringId::new(&text);
  792|       |
  793|     60|        PPToken::new(
  794|     60|            PPTokenKind::CharLiteral(codepoint, symbol),
  795|     60|            flags,
  796|     60|            SourceLoc::new(self.source_id, start_pos),
  797|     60|            text.len() as u16,
  798|       |        )
  799|     60|    }
  800|       |
  801|    184|    pub(crate) fn get_line(&self, offset: u32) -> u32 {
  802|    736|        self.line_starts.partition_point(|&x| x <= offset) as u32 + self.line_offset
                      ^184             ^184                                       ^184
  803|    184|    }
  804|       |
  805|     30|    pub(crate) fn get_current_line(&self) -> u32 {
  806|     30|        self.line_starts.len() as u32 + self.line_offset
  807|     30|    }
  808|       |
  809|    667|    pub(crate) fn get_line_starts(&self) -> &Vec<u32> {
  810|    667|        &self.line_starts
  811|    667|    }
  812|       |}

/app/src/pp/preprocessor.rs:
    1|       |use crate::diagnostic::{Diagnostic, DiagnosticEngine, DiagnosticLevel};
    2|       |use crate::intern::StringId;
    3|       |use crate::lang_options::LangOptions;
    4|       |use crate::source_manager::{SourceId, SourceLoc, SourceManager, SourceSpan};
    5|       |use chrono::{DateTime, Datelike, Timelike, Utc};
    6|       |use hashbrown::HashMap;
    7|       |use std::collections::{HashSet, VecDeque};
    8|       |
    9|       |use super::pp_lexer::PPLexer;
   10|       |use crate::pp::interpreter::Interpreter;
   11|       |use crate::pp::{PPToken, PPTokenFlags, PPTokenKind};
   12|       |use std::path::{Path, PathBuf};
   13|       |use target_lexicon::{Architecture, OperatingSystem, Triple};
   14|       |
   15|       |/// Preprocessor directive kinds
   16|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   17|       |pub enum DirectiveKind {
   18|       |    Define,
   19|       |    Undef,
   20|       |    Include,
   21|       |    If,
   22|       |    Ifdef,
   23|       |    Ifndef,
   24|       |    Elif,
   25|       |    Else,
   26|       |    Endif,
   27|       |    Line,
   28|       |    Pragma,
   29|       |    Error,
   30|       |    Warning,
   31|       |}
   32|       |
   33|       |/// Table of pre-interned preprocessor directive names for O(1) keyword recognition
   34|       |#[derive(Clone)]
   35|       |pub(crate) struct DirectiveKeywordTable {
   36|       |    define: StringId,
   37|       |    undef: StringId,
   38|       |    include: StringId,
   39|       |    if_: StringId,
   40|       |    ifdef: StringId,
   41|       |    ifndef: StringId,
   42|       |    elif: StringId,
   43|       |    else_: StringId,
   44|       |    endif: StringId,
   45|       |    line: StringId,
   46|       |    pragma: StringId,
   47|       |    error: StringId,
   48|       |    warning: StringId,
   49|       |    defined: StringId, // For the defined operator in expressions
   50|       |    has_include: StringId,
   51|       |}
   52|       |
   53|       |impl Default for DirectiveKeywordTable {
   54|      0|    fn default() -> Self {
   55|      0|        Self::new()
   56|      0|    }
   57|       |}
   58|       |
   59|       |impl DirectiveKeywordTable {
   60|    697|    pub(crate) fn new() -> Self {
   61|    697|        DirectiveKeywordTable {
   62|    697|            define: StringId::new("define"),
   63|    697|            undef: StringId::new("undef"),
   64|    697|            include: StringId::new("include"),
   65|    697|            if_: StringId::new("if"),
   66|    697|            ifdef: StringId::new("ifdef"),
   67|    697|            ifndef: StringId::new("ifndef"),
   68|    697|            elif: StringId::new("elif"),
   69|    697|            else_: StringId::new("else"),
   70|    697|            endif: StringId::new("endif"),
   71|    697|            line: StringId::new("line"),
   72|    697|            pragma: StringId::new("pragma"),
   73|    697|            error: StringId::new("error"),
   74|    697|            warning: StringId::new("warning"),
   75|    697|            defined: StringId::new("defined"),
   76|    697|            has_include: StringId::new("__has_include"),
   77|    697|        }
   78|    697|    }
   79|       |
   80|    178|    pub(crate) fn is_directive(&self, symbol: StringId) -> Option<DirectiveKind> {
   81|    178|        if symbol == self.define {
   82|     54|            Some(DirectiveKind::Define)
   83|    124|        } else if symbol == self.undef {
   84|      2|            Some(DirectiveKind::Undef)
   85|    122|        } else if symbol == self.include {
   86|     27|            Some(DirectiveKind::Include)
   87|     95|        } else if symbol == self.if_ {
   88|     23|            Some(DirectiveKind::If)
   89|     72|        } else if symbol == self.ifdef {
   90|      2|            Some(DirectiveKind::Ifdef)
   91|     70|        } else if symbol == self.ifndef {
   92|      2|            Some(DirectiveKind::Ifndef)
   93|     68|        } else if symbol == self.elif {
   94|      1|            Some(DirectiveKind::Elif)
   95|     67|        } else if symbol == self.else_ {
   96|     15|            Some(DirectiveKind::Else)
   97|     52|        } else if symbol == self.endif {
   98|     26|            Some(DirectiveKind::Endif)
   99|     26|        } else if symbol == self.line {
  100|      6|            Some(DirectiveKind::Line)
  101|     20|        } else if symbol == self.pragma {
  102|     11|            Some(DirectiveKind::Pragma)
  103|      9|        } else if symbol == self.error {
  104|      9|            Some(DirectiveKind::Error)
  105|      0|        } else if symbol == self.warning {
  106|      0|            Some(DirectiveKind::Warning)
  107|       |        } else {
  108|      0|            None
  109|       |        }
  110|    178|    }
  111|       |
  112|       |    /// Get the interned symbol for the "defined" operator
  113|     22|    pub(crate) fn defined_symbol(&self) -> StringId {
  114|     22|        self.defined
  115|     22|    }
  116|       |
  117|       |    /// Get the interned symbol for the "__has_include" operator
  118|     10|    pub(crate) fn has_include_symbol(&self) -> StringId {
  119|     10|        self.has_include
  120|     10|    }
  121|       |}
  122|       |
  123|       |// Packed boolean flags for macro properties
  124|       |bitflags::bitflags! {
  125|       |    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
  126|       |    pub struct MacroFlags: u8 {
  127|       |        const FUNCTION_LIKE = 1 << 0;
  128|       |        const C99_VARARGS = 1 << 1;
  129|       |        const GNU_VARARGS = 1 << 2;
  130|       |        const BUILTIN = 1 << 3;
  131|       |        const DISABLED = 1 << 4;
  132|       |        const USED = 1 << 5;
  133|       |    }
  134|       |}
  135|       |
  136|       |/// Represents a macro definition
  137|       |#[derive(Clone)]
  138|       |pub(crate) struct MacroInfo {
  139|       |    pub(crate) location: SourceLoc,
  140|       |    pub(crate) flags: MacroFlags, // Packed boolean flags
  141|       |    pub(crate) tokens: Vec<PPToken>,
  142|       |    pub(crate) parameter_list: Vec<StringId>,
  143|       |    pub(crate) variadic_arg: Option<StringId>,
  144|       |}
  145|       |
  146|       |/// Represents conditional compilation state
  147|       |#[derive(Debug, Clone)]
  148|       |pub(crate) struct PPConditionalInfo {
  149|       |    was_skipping: bool,
  150|       |    found_else: bool,
  151|       |    found_non_skipping: bool,
  152|       |}
  153|       |
  154|       |/// Manages header search paths and include resolution
  155|       |#[derive(Clone)]
  156|       |pub(crate) struct HeaderSearch {
  157|       |    system_path: Vec<PathBuf>,
  158|       |    framework_path: Vec<PathBuf>,
  159|       |    quoted_includes: Vec<String>,
  160|       |    angled_includes: Vec<String>,
  161|       |}
  162|       |
  163|       |impl HeaderSearch {
  164|       |    /// Add a system include path
  165|     18|    pub(crate) fn add_system_path(&mut self, path: PathBuf) {
  166|     18|        self.system_path.push(path);
  167|     18|    }
  168|       |
  169|       |    /// Add a quoted include path (-iquote)
  170|      0|    pub(crate) fn add_quoted_path(&mut self, path: PathBuf) {
  171|      0|        self.quoted_includes.push(path.to_string_lossy().to_string());
  172|      0|    }
  173|       |
  174|       |    /// Add an angled include path (-I)
  175|     18|    pub(crate) fn add_angled_path(&mut self, path: PathBuf) {
  176|     18|        self.angled_includes.push(path.to_string_lossy().to_string());
  177|     18|    }
  178|       |
  179|       |    /// Add a framework path
  180|     18|    pub(crate) fn add_framework_path(&mut self, path: PathBuf) {
  181|     18|        self.framework_path.push(path);
  182|     18|    }
  183|       |
  184|       |    /// Resolve an include path to an absolute path
  185|    138|    pub(crate) fn resolve_path(&self, include_path: &str, is_angled: bool, current_dir: &Path) -> Option<PathBuf> {
  186|    138|        if is_angled {
  187|       |            // Angled includes: search angled_includes, then system_path, then framework_path
  188|    129|            for include_path_str in &self.angled_includes {
                              ^72
  189|     72|                let candidate = Path::new(include_path_str).join(include_path);
  190|     72|                if candidate.exists() {
  191|     18|                    return Some(candidate);
  192|     54|                }
  193|       |            }
  194|     93|            for search_path in &self.system_path {
                              ^54
  195|     54|                let candidate = search_path.join(include_path);
  196|     54|                if candidate.exists() {
  197|     18|                    return Some(candidate);
  198|     36|                }
  199|       |            }
  200|     57|            for search_path in &self.framework_path {
                              ^36
  201|     36|                let candidate = search_path.join(include_path);
  202|     36|                if candidate.exists() {
  203|     18|                    return Some(candidate);
  204|     18|                }
  205|       |            }
  206|       |        } else {
  207|       |            // Quoted includes: search current_dir, then quoted_includes, then angled_includes, then system_path, then framework_path
  208|     63|            let candidate = current_dir.join(include_path);
  209|     63|            if candidate.exists() {
  210|     28|                return Some(candidate);
  211|     35|            }
  212|     35|            for include_path_str in &self.quoted_includes {
                              ^0
  213|      0|                let candidate = Path::new(include_path_str).join(include_path);
  214|      0|                if candidate.exists() {
  215|      0|                    return Some(candidate);
  216|      0|                }
  217|       |            }
  218|     53|            for include_path_str in &self.angled_includes {
                              ^18
  219|     18|                let candidate = Path::new(include_path_str).join(include_path);
  220|     18|                if candidate.exists() {
  221|      0|                    return Some(candidate);
  222|     18|                }
  223|       |            }
  224|     35|            for search_path in &self.system_path {
                              ^18
  225|     18|                let candidate = search_path.join(include_path);
  226|     18|                if candidate.exists() {
  227|     18|                    return Some(candidate);
  228|      0|                }
  229|       |            }
  230|     17|            for search_path in &self.framework_path {
                              ^0
  231|      0|                let candidate = search_path.join(include_path);
  232|      0|                if candidate.exists() {
  233|      0|                    return Some(candidate);
  234|      0|                }
  235|       |            }
  236|       |        }
  237|     38|        None
  238|    138|    }
  239|       |}
  240|       |
  241|       |/// Include stack information
  242|       |#[derive(Clone)]
  243|       |pub(crate) struct IncludeStackInfo {
  244|       |    pub(crate) file_id: SourceId,
  245|       |    // pub location: SourceLoc,
  246|       |}
  247|       |
  248|       |/// Configuration for preprocessor
  249|       |#[derive(Debug, Clone)]
  250|       |pub struct PPConfig {
  251|       |    pub max_include_depth: usize,
  252|       |    pub system_include_paths: Vec<PathBuf>,
  253|       |    pub quoted_include_paths: Vec<PathBuf>,
  254|       |    pub angled_include_paths: Vec<PathBuf>,
  255|       |    pub framework_paths: Vec<PathBuf>,
  256|       |    pub lang_options: LangOptions,
  257|       |    pub target: Triple,
  258|       |}
  259|       |
  260|       |impl Default for PPConfig {
  261|    698|    fn default() -> Self {
  262|    698|        Self {
  263|    698|            max_include_depth: 200,
  264|    698|            system_include_paths: Vec::new(),
  265|    698|            quoted_include_paths: Vec::new(),
  266|    698|            angled_include_paths: Vec::new(),
  267|    698|            framework_paths: Vec::new(),
  268|    698|            lang_options: LangOptions::default(),
  269|    698|            target: Triple::host(),
  270|    698|        }
  271|    698|    }
  272|       |}
  273|       |
  274|       |/// Main preprocessor structure
  275|       |pub struct Preprocessor<'src> {
  276|       |    source_manager: &'src mut SourceManager,
  277|       |    diag: &'src mut DiagnosticEngine,
  278|       |    lang_opts: LangOptions,
  279|       |    target: Triple,
  280|       |
  281|       |    // Pre-interned directive keywords for fast comparison
  282|       |    directive_keywords: DirectiveKeywordTable,
  283|       |
  284|       |    // Macro management
  285|       |    macros: HashMap<StringId, MacroInfo>,
  286|       |    macro_stack: HashMap<StringId, Vec<Option<MacroInfo>>>,
  287|       |
  288|       |    // Include management
  289|       |    once_included: HashSet<SourceId>,
  290|       |
  291|       |    // Conditional compilation state
  292|       |    conditional_stack: Vec<PPConditionalInfo>,
  293|       |
  294|       |    // Include handling
  295|       |    include_stack: Vec<IncludeStackInfo>,
  296|       |    header_search: HeaderSearch,
  297|       |    built_in_headers: HashMap<&'static str, &'static str>,
  298|       |    built_in_file_ids: HashMap<String, SourceId>,
  299|       |
  300|       |    // Token management
  301|       |    lexer_stack: Vec<PPLexer>,
  302|       |    pending_tokens: VecDeque<PPToken>,
  303|       |
  304|       |    // State
  305|       |    include_depth: usize,
  306|       |    max_include_depth: usize,
  307|       |    counter: u32,
  308|       |}
  309|       |
  310|       |/// Preprocessor errors
  311|       |#[derive(Debug, thiserror::Error)]
  312|       |pub enum PPError {
  313|       |    #[error("File not found")]
  314|       |    FileNotFound,
  315|       |    #[error("Invalid UTF-8 sequence")]
  316|       |    InvalidUtf8,
  317|       |    #[error("Include depth exceeded")]
  318|       |    IncludeDepthExceeded,
  319|       |    #[error("Macro redefinition")]
  320|       |    MacroRedefinition,
  321|       |    #[error("Expected identifier")]
  322|       |    ExpectedIdentifier,
  323|       |    #[error("Invalid directive")]
  324|       |    InvalidDirective,
  325|       |    #[error("Unexpected end of file")]
  326|       |    UnexpectedEndOfFile,
  327|       |    #[error("Invalid macro parameter")]
  328|       |    InvalidMacroParameter { span: SourceSpan },
  329|       |    #[error("Invalid include path")]
  330|       |    InvalidIncludePath,
  331|       |    #[error("Unmatched #endif")]
  332|       |    UnmatchedEndif,
  333|       |    #[error("#error directive: {0}")]
  334|       |    ErrorDirective(String),
  335|       |    #[error("Invalid conditional expression")]
  336|       |    InvalidConditionalExpression,
  337|       |    #[error("Invalid #line directive")]
  338|       |    InvalidLineDirective,
  339|       |    #[error("Unmatched #else")]
  340|       |    UnmatchedElse,
  341|       |    #[error("Unmatched #elif")]
  342|       |    UnmatchedElif,
  343|       |    #[error("#elif without #if")]
  344|       |    ElifWithoutIf,
  345|       |    #[error("#else without #if")]
  346|       |    ElseWithoutIf,
  347|       |    #[error("Macro expansion recursion detected")]
  348|       |    MacroRecursion,
  349|       |    #[error("Invalid token pasting")]
  350|       |    InvalidTokenPasting,
  351|       |    #[error("Invalid stringification")]
  352|       |    InvalidStringification,
  353|       |    #[error("Circular include detected")]
  354|       |    CircularInclude,
  355|       |    #[error("Expected end of directive")]
  356|       |    ExpectedEod,
  357|       |    #[error("Unknown pragma: {0}")]
  358|       |    UnknownPragma(String),
  359|       |    #[error("Pragma error: {0}")]
  360|       |    PragmaError(String),
  361|       |}
  362|       |
  363|       |impl PPError {
  364|      0|    pub(crate) fn span(&self) -> SourceSpan {
  365|      0|        match self {
  366|      0|            PPError::InvalidMacroParameter { span } => *span,
  367|      0|            _ => SourceSpan::new(SourceLoc::builtin(), SourceLoc::builtin()),
  368|       |        }
  369|      0|    }
  370|       |}
  371|       |
  372|       |impl From<PPError> for Diagnostic {
  373|      0|    fn from(val: PPError) -> Self {
  374|      0|        let level = match &val {
  375|      0|            PPError::ErrorDirective(_) => DiagnosticLevel::Error,
  376|      0|            PPError::PragmaError(_) => DiagnosticLevel::Error,
  377|      0|            PPError::UnknownPragma(_) => DiagnosticLevel::Error,
  378|      0|            _ => DiagnosticLevel::Error,
  379|       |        };
  380|       |
  381|      0|        Diagnostic {
  382|      0|            level,
  383|      0|            message: val.to_string(),
  384|      0|            span: val.span(),
  385|      0|            ..Default::default()
  386|      0|        }
  387|      0|    }
  388|       |}
  389|       |
  390|       |impl<'src> Preprocessor<'src> {
  391|       |    /// Create a new preprocessor
  392|    698|    pub fn new(source_manager: &'src mut SourceManager, diag: &'src mut DiagnosticEngine, config: &PPConfig) -> Self {
  393|    698|        let mut header_search = HeaderSearch {
  394|    698|            system_path: Vec::new(),
  395|    698|            framework_path: Vec::new(),
  396|    698|            quoted_includes: Vec::new(),
  397|    698|            angled_includes: Vec::new(),
  398|    698|        };
  399|       |
  400|       |        // Populate the new fields
  401|    698|        for path in &config.system_include_paths {
                          ^0
  402|      0|            header_search.add_system_path(path.clone());
  403|      0|        }
  404|    698|        for path in &config.quoted_include_paths {
                          ^0
  405|      0|            header_search.add_quoted_path(path.clone());
  406|      0|        }
  407|    698|        for path in &config.angled_include_paths {
                          ^0
  408|      0|            header_search.add_angled_path(path.clone());
  409|      0|        }
  410|    698|        for path in &config.framework_paths {
                          ^0
  411|      0|            header_search.add_framework_path(path.clone());
  412|      0|        }
  413|       |
  414|    698|        let mut built_in_headers = HashMap::new();
  415|    698|        built_in_headers.insert("stddef.h", include_str!("../../custom-include/stddef.h"));
  416|    698|        built_in_headers.insert("stdint.h", include_str!("../../custom-include/stdint.h"));
  417|    698|        built_in_headers.insert("stdarg.h", include_str!("../../custom-include/stdarg.h"));
  418|    698|        built_in_headers.insert("stdbool.h", include_str!("../../custom-include/stdbool.h"));
  419|       |
  420|    698|        let mut preprocessor = Preprocessor {
  421|    698|            source_manager,
  422|    698|            diag,
  423|    698|            lang_opts: config.lang_options,
  424|    698|            directive_keywords: DirectiveKeywordTable::new(),
  425|    698|            macros: HashMap::new(),
  426|    698|            macro_stack: HashMap::new(),
  427|    698|            once_included: HashSet::new(),
  428|    698|            conditional_stack: Vec::new(),
  429|    698|            include_stack: Vec::new(),
  430|    698|            header_search,
  431|    698|            built_in_headers,
  432|    698|            built_in_file_ids: HashMap::new(),
  433|    698|            lexer_stack: Vec::new(),
  434|    698|            pending_tokens: VecDeque::new(),
  435|    698|            include_depth: 0,
  436|    698|            max_include_depth: config.max_include_depth,
  437|    698|            target: config.target.clone(),
  438|    698|            counter: 0,
  439|    698|        };
  440|       |
  441|       |        // Initialize built-in headers
  442|  3.48k|        for (name, content) in &preprocessor.built_in_headers {
                           ^2.78k^2.78k
  443|  2.78k|            let source_id = preprocessor.source_manager.add_buffer(
  444|  2.78k|                content.as_bytes().to_vec(),
  445|  2.78k|                name,
  446|  2.78k|                None, // No include location for initialization
  447|  2.78k|            );
  448|  2.78k|            preprocessor.built_in_file_ids.insert(name.to_string(), source_id);
  449|  2.78k|        }
  450|       |
  451|    698|        preprocessor.initialize_builtin_macros();
  452|    698|        preprocessor
  453|    698|    }
  454|       |
  455|       |    /// Get the next value for __COUNTER__
  456|      7|    fn get_next_counter(&mut self) -> u32 {
  457|      7|        let val = self.counter;
  458|      7|        self.counter += 1;
  459|      7|        val
  460|      7|    }
  461|       |
  462|       |    /// Initialize built-in macros
  463|    697|    fn initialize_builtin_macros(&mut self) {
  464|    697|        let now: DateTime<Utc> = Utc::now();
  465|       |
  466|       |        // __DATE__
  467|    697|        let date_str = format!("\"{:02} {:02} {}\"", now.format("%b"), now.day(), now.year());
  468|    697|        let date_tokens = self.tokenize_string(&date_str);
  469|    697|        self.define_builtin_macro("__DATE__", date_tokens);
  470|       |
  471|       |        // __TIME__
  472|    697|        let time_str = format!("\"{:02}:{:02}:{:02}\"", now.hour(), now.minute(), now.second());
  473|    697|        let time_tokens = self.tokenize_string(&time_str);
  474|    697|        self.define_builtin_macro("__TIME__", time_tokens);
  475|       |
  476|       |        // Other built-ins
  477|    697|        self.define_builtin_macro(
  478|    697|            "__STDC__",
  479|    697|            vec![PPToken::simple(
  480|    697|                PPTokenKind::Number(StringId::new("1")),
  481|    697|                SourceLoc::builtin(),
  482|       |            )],
  483|       |        );
  484|       |
  485|       |        // Target specific macros
  486|       |        // Architecture
  487|    697|        match self.target.architecture {
  488|    695|            Architecture::X86_64 => {
  489|    695|                self.define_builtin_macro_simple("__x86_64__", "1");
  490|    695|                self.define_builtin_macro_simple("__x86_64", "1");
  491|    695|                self.define_builtin_macro_simple("__amd64__", "1");
  492|    695|                self.define_builtin_macro_simple("__amd64", "1");
  493|    695|            }
  494|      0|            Architecture::X86_32(_) => {
  495|      0|                self.define_builtin_macro_simple("__i386__", "1");
  496|      0|                self.define_builtin_macro_simple("__i386", "1");
  497|      0|            }
  498|      0|            Architecture::Aarch64(_) => {
  499|      0|                self.define_builtin_macro_simple("__aarch64__", "1");
  500|      0|            }
  501|      2|            Architecture::Arm(_) => {
  502|      2|                self.define_builtin_macro_simple("__arm__", "1");
  503|      2|            }
  504|      0|            _ => {}
  505|       |        }
  506|       |
  507|       |        // Pointer width
  508|    697|        if self.target.pointer_width().ok().map(|w| w.bits()).unwrap_or(64) == 64 {
                                                                  ^695^695
  509|    695|            self.define_builtin_macro_simple("__LP64__", "1");
  510|    695|            self.define_builtin_macro_simple("_LP64", "1");
  511|    695|        } else {
  512|      2|            self.define_builtin_macro_simple("__ILP32__", "1");
  513|      2|            self.define_builtin_macro_simple("_ILP32", "1");
  514|      2|        }
  515|       |
  516|       |        // OS
  517|    697|        match self.target.operating_system {
  518|    695|            OperatingSystem::Linux => {
  519|    695|                self.define_builtin_macro_simple("__linux__", "1");
  520|    695|                self.define_builtin_macro_simple("__linux", "1");
  521|    695|                self.define_builtin_macro_simple("__unix__", "1");
  522|    695|                self.define_builtin_macro_simple("__unix", "1");
  523|    695|                self.define_builtin_macro_simple("__ELF__", "1");
  524|    695|                self.define_builtin_macro_simple("__gnu_linux__", "1");
  525|    695|            }
  526|      2|            OperatingSystem::Darwin(_) => {
  527|      2|                self.define_builtin_macro_simple("__APPLE__", "1");
  528|      2|                self.define_builtin_macro_simple("__MACH__", "1");
  529|      2|            }
  530|       |            OperatingSystem::Windows => {
  531|      0|                self.define_builtin_macro_simple("_WIN32", "1");
  532|      0|                if self.target.pointer_width().ok().map(|w| w.bits()).unwrap_or(32) == 64 {
  533|      0|                    self.define_builtin_macro_simple("_WIN64", "1");
  534|      0|                }
  535|       |            }
  536|      0|            _ => {}
  537|       |        }
  538|       |
  539|    697|        if self.lang_opts.is_c11() {
  540|      0|            self.define_builtin_macro(
  541|      0|                "__STDC_VERSION__",
  542|      0|                vec![PPToken::new(
  543|      0|                    PPTokenKind::Number(StringId::new("201112")),
  544|      0|                    PPTokenFlags::empty(),
  545|      0|                    SourceLoc::builtin(),
  546|      0|                    6,
  547|      0|                )],
  548|      0|            );
  549|      0|            self.define_builtin_macro(
  550|      0|                "__STDC_HOSTED__",
  551|      0|                vec![PPToken::simple(
  552|      0|                    PPTokenKind::Number(StringId::new("1")),
  553|      0|                    SourceLoc::builtin(),
  554|      0|                )],
  555|      0|            );
  556|      0|            self.define_builtin_macro(
  557|      0|                "__STDC_MB_MIGHT_NEQ_WC__",
  558|      0|                vec![PPToken::simple(
  559|      0|                    PPTokenKind::Number(StringId::new("1")),
  560|      0|                    SourceLoc::builtin(),
  561|      0|                )],
  562|      0|            );
  563|      0|            self.define_builtin_macro(
  564|      0|                "__STDC_IEC_559__",
  565|      0|                vec![PPToken::simple(
  566|      0|                    PPTokenKind::Number(StringId::new("1")),
  567|      0|                    SourceLoc::builtin(),
  568|      0|                )],
  569|      0|            );
  570|      0|            self.define_builtin_macro(
  571|      0|                "__STDC_IEC_559_COMPLEX__",
  572|      0|                vec![PPToken::simple(
  573|      0|                    PPTokenKind::Number(StringId::new("1")),
  574|      0|                    SourceLoc::builtin(),
  575|      0|                )],
  576|      0|            );
  577|      0|            self.define_builtin_macro(
  578|      0|                "__STDC_ISO_10646__",
  579|      0|                vec![PPToken::new(
  580|      0|                    PPTokenKind::Number(StringId::new("201103L")),
  581|      0|                    PPTokenFlags::empty(),
  582|      0|                    SourceLoc::builtin(),
  583|      0|                    7,
  584|      0|                )],
  585|      0|            );
  586|    697|        }
  587|       |
  588|       |        // Variadic argument macros
  589|       |        // Define va_start as function-like macro expanding to va_start
  590|    697|        self.define_builtin_function_macro(
  591|    697|            "va_start",
  592|    697|            vec![StringId::new("ap"), StringId::new("param")],
  593|    697|            vec![PPToken::new(
  594|    697|                PPTokenKind::Identifier(StringId::new("va_start")),
  595|    697|                PPTokenFlags::empty(),
  596|    697|                SourceLoc::builtin(),
  597|       |                7,
  598|       |            )],
  599|       |        );
  600|       |        // Define va_end as function-like macro expanding to va_end
  601|    697|        self.define_builtin_function_macro(
  602|    697|            "va_end",
  603|    697|            vec![StringId::new("ap")],
  604|    697|            vec![PPToken::new(
  605|    697|                PPTokenKind::Identifier(StringId::new("va_end")),
  606|    697|                PPTokenFlags::empty(),
  607|    697|                SourceLoc::builtin(),
  608|       |                6,
  609|       |            )],
  610|       |        );
  611|       |        // Define va_arg as function-like macro expanding to va_arg so the parser can detect it
  612|    697|        self.define_builtin_function_macro(
  613|    697|            "va_arg",
  614|    697|            vec![StringId::new("ap"), StringId::new("type")],
  615|    697|            vec![PPToken::new(
  616|    697|                PPTokenKind::Identifier(StringId::new("va_arg")),
  617|    697|                PPTokenFlags::empty(),
  618|    697|                SourceLoc::builtin(),
  619|       |                6,
  620|       |            )],
  621|       |        );
  622|    697|    }
  623|       |
  624|       |    /// Helper to define a simple macro with a value
  625|  8.34k|    fn define_builtin_macro_simple(&mut self, name: &str, value: &str) {
  626|  8.34k|        let tokens = vec![PPToken::new(
  627|  8.34k|            PPTokenKind::Number(StringId::new(value)),
  628|  8.34k|            PPTokenFlags::empty(),
  629|  8.34k|            SourceLoc::builtin(),
  630|  8.34k|            value.len() as u16,
  631|       |        )];
  632|  8.34k|        self.define_builtin_macro(name, tokens);
  633|  8.34k|    }
  634|       |
  635|       |    /// Define a built-in macro
  636|  10.4k|    fn define_builtin_macro(&mut self, name: &str, tokens: Vec<PPToken>) {
  637|  10.4k|        let symbol = StringId::new(name);
  638|  10.4k|        let macro_info = MacroInfo {
  639|  10.4k|            location: SourceLoc::builtin(),
  640|  10.4k|            flags: MacroFlags::BUILTIN,
  641|  10.4k|            tokens,
  642|  10.4k|            parameter_list: Vec::new(),
  643|  10.4k|            variadic_arg: None,
  644|  10.4k|        };
  645|  10.4k|        self.macros.insert(symbol, macro_info);
  646|  10.4k|    }
  647|       |
  648|       |    /// Define a built-in function-like macro
  649|  2.08k|    fn define_builtin_function_macro(&mut self, name: &str, params: Vec<StringId>, tokens: Vec<PPToken>) {
  650|  2.08k|        let symbol = StringId::new(name);
  651|  2.08k|        let macro_info = MacroInfo {
  652|  2.08k|            location: SourceLoc::builtin(),
  653|  2.08k|            flags: MacroFlags::BUILTIN | MacroFlags::FUNCTION_LIKE,
  654|  2.08k|            tokens,
  655|  2.08k|            parameter_list: params,
  656|  2.08k|            variadic_arg: None,
  657|  2.08k|        };
  658|  2.08k|        self.macros.insert(symbol, macro_info);
  659|  2.08k|    }
  660|       |
  661|       |    /// Tokenize a string into PP tokens (simplified)
  662|  1.39k|    fn tokenize_string(&self, s: &str) -> Vec<PPToken> {
  663|  1.39k|        vec![PPToken::new(
  664|  1.39k|            PPTokenKind::StringLiteral(StringId::new(s)),
  665|  1.39k|            PPTokenFlags::empty(),
  666|  1.39k|            SourceLoc::builtin(),
  667|  1.39k|            s.len() as u16,
  668|       |        )]
  669|  1.39k|    }
  670|       |
  671|       |    /// Check if a macro is defined
  672|      0|    pub(crate) fn is_macro_defined(&self, symbol: &StringId) -> bool {
  673|      0|        self.macros.contains_key(symbol)
  674|      0|    }
  675|       |
  676|       |    /// Get the interned symbol for the "defined" operator
  677|     22|    pub(crate) fn defined_symbol(&self) -> StringId {
  678|     22|        self.directive_keywords.defined_symbol()
  679|     22|    }
  680|       |
  681|       |    /// Get the interned symbol for the "__has_include" operator
  682|     10|    pub(crate) fn has_include_symbol(&self) -> StringId {
  683|     10|        self.directive_keywords.has_include_symbol()
  684|     10|    }
  685|       |
  686|       |    /// Get the text associated with a token
  687|     14|    pub(crate) fn get_token_text(&self, token: &PPToken) -> &str {
  688|     14|        let buffer = self.source_manager.get_buffer(token.location.source_id());
  689|     14|        let start = token.location.offset() as usize;
  690|     14|        let end = start + token.length as usize;
  691|     14|        if end <= buffer.len() {
  692|     14|            unsafe { std::str::from_utf8_unchecked(&buffer[start..end]) }
  693|       |        } else {
  694|      0|            ""
  695|       |        }
  696|     14|    }
  697|       |
  698|       |    /// Check if a header exists
  699|      6|    pub(crate) fn check_header_exists(&self, path: &str, is_angled: bool) -> bool {
  700|       |        // Get current directory
  701|      6|        let current_dir = if let Some(lexer) = self.lexer_stack.last() {
  702|      6|            let current_file_id = lexer.source_id;
  703|      6|            if let Some(current_file_info) = self.source_manager.get_file_info(current_file_id) {
  704|      6|                current_file_info.path.parent().unwrap_or(Path::new("."))
  705|       |            } else {
  706|      0|                Path::new(".")
  707|       |            }
  708|       |        } else {
  709|      0|            Path::new(".")
  710|       |        };
  711|       |
  712|      6|        if is_angled {
  713|       |            // Check built-in headers
  714|      4|            if self.built_in_headers.contains_key(path) {
  715|      1|                return true;
  716|      3|            }
  717|      3|            self.header_search.resolve_path(path, is_angled, current_dir).is_some()
  718|       |        } else {
  719|      2|            self.header_search.resolve_path(path, is_angled, current_dir).is_some()
  720|      2|                || self.source_manager.get_file_id(path).is_some()
  721|       |        }
  722|      6|    }
  723|       |
  724|       |    /// Expect and consume an Eod token or end of file
  725|     70|    fn expect_eod(&mut self) -> Result<(), PPError> {
  726|     70|        match self.lex_token() {
  727|     70|            Some(token) if token.kind == PPTokenKind::Eod => Ok(()),
  728|      0|            None => Ok(()), // End of file is acceptable
  729|      0|            Some(_) => Err(PPError::ExpectedEod),
  730|       |        }
  731|     70|    }
  732|       |
  733|       |    /// Process source file and return preprocessed tokens
  734|    677|    pub fn process(&mut self, source_id: SourceId, _config: &PPConfig) -> Result<Vec<PPToken>, PPError> {
  735|       |        // Initialize lexer for main file
  736|    677|        let buffer = self.source_manager.get_buffer(source_id);
  737|    677|        let buffer_len = buffer.len() as u32;
  738|       |
  739|    677|        let lexer = PPLexer::new(source_id, buffer.to_vec());
  740|    677|        self.lexer_stack.push(lexer);
  741|       |
  742|       |        // FIXME: need to create line_start on the fly instead of computing all at once
  743|       |        // Set line starts for the source manager so presumed locations work during processing
  744|    677|        let mut line_starts = vec![0];
  745|  46.4k|        for (i, &byte) in buffer.iter().enumerate() {
                                        ^677   ^677   ^677
  746|  46.4k|            if byte == b'\n' {
  747|  1.54k|                line_starts.push((i + 1) as u32);
  748|  44.8k|            }
  749|       |        }
  750|    677|        self.source_manager.set_line_starts(source_id, line_starts);
  751|       |
  752|    677|        let mut result_tokens = Vec::new();
  753|       |
  754|       |        // Process tokens with string literal concatenation
  755|  12.1k|        while let Some(token) = self.lex_token() {
                                     ^11.4k
  756|  11.4k|            if token.kind == PPTokenKind::Hash && !token.flags.contains(PPTokenFlags::MACRO_EXPANDED) {
                                                                ^178
  757|       |                // Handle directive - always process directives regardless of skipping
  758|    178|                self.handle_directive()?;
                                                     ^10
  759|       |            } else {
  760|  11.2k|                if self.is_currently_skipping() {
  761|       |                    // Skip tokens when in conditional compilation skip mode
  762|     65|                    continue;
  763|  11.2k|                }
  764|       |
  765|  11.2k|                match token.kind {
  766|      1|                    PPTokenKind::Eod => continue,
  767|  4.01k|                    PPTokenKind::Identifier(symbol) => {
  768|  4.01k|                        let sym_str = symbol.as_str();
  769|  4.01k|                        if sym_str == "__LINE__" {
  770|      1|                            let line = if let Some(presumed) = self.source_manager.get_presumed_location(token.location)
  771|       |                            {
  772|      1|                                presumed.0
  773|       |                            } else {
  774|      0|                                1
  775|       |                            };
  776|      1|                            let line_str = line.to_string();
  777|      1|                            let line_symbol = StringId::new(&line_str);
  778|      1|                            result_tokens.push(PPToken::new(
  779|      1|                                PPTokenKind::Number(line_symbol),
  780|      1|                                PPTokenFlags::empty(),
  781|      1|                                token.location,
  782|      1|                                line_str.len() as u16,
  783|       |                            ));
  784|  4.01k|                        } else if sym_str == "__FILE__" {
  785|      2|                            let filename =
  786|      2|                                if let Some(presumed) = self.source_manager.get_presumed_location(token.location) {
  787|      2|                                    if let Some(name) = presumed.2 {
  788|      2|                                        format!("\"{}\"", name)
  789|      0|                                    } else if let Some(file_info) =
  790|      0|                                        self.source_manager.get_file_info(token.location.source_id())
  791|       |                                    {
  792|      0|                                        format!("\"{}\"", file_info.path.display())
  793|       |                                    } else {
  794|      0|                                        "\"<unknown>\"".to_string()
  795|       |                                    }
  796|      0|                                } else if let Some(file_info) =
  797|      0|                                    self.source_manager.get_file_info(token.location.source_id())
  798|       |                                {
  799|      0|                                    format!("\"{}\"", file_info.path.display())
  800|       |                                } else {
  801|      0|                                    "\"<unknown>\"".to_string()
  802|       |                                };
  803|      2|                            let file_symbol = StringId::new(&filename);
  804|      2|                            result_tokens.push(PPToken::new(
  805|      2|                                PPTokenKind::StringLiteral(file_symbol),
  806|      2|                                PPTokenFlags::empty(),
  807|      2|                                token.location,
  808|      2|                                filename.len() as u16,
  809|       |                            ));
  810|  4.01k|                        } else if sym_str == "__COUNTER__" {
  811|      3|                            let val = self.get_next_counter();
  812|      3|                            let val_str = val.to_string();
  813|      3|                            let val_symbol = StringId::new(&val_str);
  814|      3|                            result_tokens.push(PPToken::new(
  815|      3|                                PPTokenKind::Number(val_symbol),
  816|      3|                                PPTokenFlags::empty(),
  817|      3|                                token.location,
  818|      3|                                val_str.len() as u16,
  819|      3|                            ));
  820|  4.01k|                        } else if sym_str == "_Pragma" {
  821|      5|                            self.handle_pragma_operator()?;
                                                                       ^0
  822|       |                        } else {
  823|       |                            // Check for macro expansion
  824|       |                            // Don't expand if recursively expanding the same macro
  825|  4.00k|                            if self.is_recursive_expansion(token.location, sym_str) {
  826|      0|                                result_tokens.push(token);
  827|  4.00k|                            } else if let Some(expanded) = self.expand_macro(&token)? {
                                                             ^40                                  ^3
  828|       |                                // Push expanded tokens to pending_tokens (in reverse order so they come out in order)
  829|     77|                                for t in expanded.into_iter().rev() {
                                                       ^40      ^40         ^40
  830|     77|                                    self.pending_tokens.push_front(t);
  831|     77|                                }
  832|  3.96k|                            } else {
  833|  3.96k|                                result_tokens.push(token);
  834|  3.96k|                            }
  835|       |                        }
  836|       |                    }
  837|  7.18k|                    _ => {
  838|  7.18k|                        result_tokens.push(token);
  839|  7.18k|                    }
  840|       |                }
  841|       |            }
  842|       |        }
  843|       |
  844|       |        // Add EOF token
  845|    664|        result_tokens.push(PPToken::new(
  846|    664|            PPTokenKind::Eof,
  847|    664|            PPTokenFlags::empty(),
  848|    664|            SourceLoc::new(source_id, buffer_len),
  849|       |            0,
  850|       |        ));
  851|       |
  852|    664|        if !self.conditional_stack.is_empty() {
  853|      0|            let start_loc = if let Some(_info) = self.conditional_stack.last() {
  854|       |                // Ideally we would have the location of the #if that started this
  855|       |                // For now, use current location
  856|      0|                self.get_current_location()
  857|       |            } else {
  858|      0|                self.get_current_location()
  859|       |            };
  860|       |
  861|      0|            let diag = Diagnostic {
  862|      0|                level: DiagnosticLevel::Error,
  863|      0|                message: "Unclosed preprocessor conditional directive".to_string(),
  864|      0|                span: SourceSpan::new(start_loc, start_loc),
  865|      0|                code: Some("unclosed_conditional".to_string()),
  866|      0|                hints: vec!["Expected #endif before end of file".to_string()],
  867|      0|                related: Vec::new(),
  868|      0|            };
  869|      0|            self.diag.report_diagnostic(diag);
  870|      0|            return Err(PPError::UnexpectedEndOfFile);
  871|    664|        }
  872|       |
  873|    664|        Ok(result_tokens)
  874|    677|    }
  875|       |
  876|       |    /// Get the current location from the lexer stack
  877|      7|    fn get_current_location(&self) -> SourceLoc {
  878|      7|        if let Some(lexer) = self.lexer_stack.last() {
  879|      7|            SourceLoc::new(lexer.source_id, lexer.position)
  880|       |        } else {
  881|      0|            SourceLoc::builtin()
  882|       |        }
  883|      7|    }
  884|       |
  885|       |    /// Check if we are currently skipping tokens
  886|  11.4k|    fn is_currently_skipping(&self) -> bool {
  887|       |        // Check if any conditional in the stack is currently skipping
  888|  11.4k|        self.conditional_stack.iter().any(|info| info.was_skipping)
  889|  11.4k|    }
  890|       |
  891|       |    /// Set the skipping state for the current conditional level
  892|     21|    fn set_skipping(&mut self, skipping: bool) {
  893|     21|        if let Some(info) = self.conditional_stack.last_mut() {
  894|     21|            info.was_skipping = skipping;
  895|     21|        } else {
  896|      0|            // No conditionals, don't skip
  897|      0|        }
  898|     21|    }
  899|       |
  900|       |    /// Parse a conditional expression for #if and #elif
  901|     24|    fn parse_conditional_expression(&mut self) -> Result<Vec<PPToken>, PPError> {
  902|     24|        let mut tokens = Vec::new();
  903|     24|        let start_line = if let Some(lexer) = self.lexer_stack.last() {
  904|     24|            lexer.get_current_line()
  905|       |        } else {
  906|      0|            0
  907|       |        };
  908|       |
  909|    184|        while let Some(token) = self.lex_token() {
  910|    184|            let token_line = if let Some(lexer) = self.lexer_stack.last() {
  911|    184|                lexer.get_line(token.location.offset())
  912|       |            } else {
  913|      0|                0
  914|       |            };
  915|    184|            if token_line != start_line {
  916|       |                // Put back the token from the next line
  917|     24|                self.pending_tokens.push_front(token);
  918|     24|                break;
  919|    160|            }
  920|    160|            tokens.push(token);
  921|       |        }
  922|       |
  923|     24|        if tokens.is_empty() {
  924|      0|            let span = SourceSpan::new(self.get_current_location(), self.get_current_location());
  925|      0|            let diag = Diagnostic {
  926|      0|                level: DiagnosticLevel::Error,
  927|      0|                message: "Invalid conditional expression".to_string(),
  928|      0|                span,
  929|      0|                code: Some("invalid_conditional_expression".to_string()),
  930|      0|                hints: vec!["Conditional directives require an expression".to_string()],
  931|      0|                related: Vec::new(),
  932|      0|            };
  933|      0|            self.diag.report_diagnostic(diag);
  934|      0|            return Err(PPError::InvalidConditionalExpression);
  935|     24|        }
  936|       |
  937|     24|        Ok(tokens)
  938|     24|    }
  939|       |
  940|       |    /// Evaluate a conditional expression (simplified - handle defined and basic arithmetic)
  941|     24|    fn evaluate_conditional_expression(&mut self, tokens: &[PPToken]) -> Result<bool, PPError> {
  942|       |        // Filter out Eod tokens
  943|    160|        let tokens: Vec<PPToken> = tokens.iter().filter(|t| t.kind != PPTokenKind::Eod).cloned().collect();
                          ^24     ^24            ^24    ^24    ^24                                    ^24      ^24
  944|       |
  945|     24|        if tokens.is_empty() {
  946|       |            // For empty expressions, treat as false
  947|      0|            return Ok(false);
  948|     24|        }
  949|       |
  950|       |        // Check for defined(identifier) or defined identifier before macro expansion
  951|     24|        if tokens.len() >= 2 && matches!(tokens[0].kind, PPTokenKind::Identifier(sym) if sym == self.defined_symbol()) {
                                              ^3       ^20                                     ^3      ^12    ^12  ^12            ^3
  952|      3|            if tokens.len() == 2 {
  953|       |                // defined identifier
  954|      1|                if let PPTokenKind::Identifier(sym) = &tokens[1].kind {
  955|      1|                    let is_defined = self.macros.contains_key(sym);
  956|      1|                    return Ok(is_defined);
  957|      0|                }
  958|      2|            } else if tokens.len() >= 4
  959|      2|                && matches!(tokens[1].kind, PPTokenKind::LeftParen)
                                 ^0
  960|      2|                && matches!(tokens[3].kind, PPTokenKind::RightParen)
                                 ^0
  961|       |            {
  962|       |                // defined(identifier)
  963|      2|                if let PPTokenKind::Identifier(sym) = &tokens[2].kind {
  964|      2|                    let is_defined = self.macros.contains_key(sym);
  965|      2|                    return Ok(is_defined);
  966|      0|                }
  967|      0|            }
  968|     21|        }
  969|       |
  970|       |        // First, expand macros in the expression
  971|     21|        let mut expanded_tokens = tokens.to_vec();
  972|     21|        match self.expand_tokens(&mut expanded_tokens, true) {
  973|     21|            Ok(_) => {}
  974|      0|            Err(_e) => {
  975|       |                // If macro expansion fails, emit diagnostic and treat as false
  976|      0|                let span = if !tokens.is_empty() {
  977|      0|                    SourceSpan::new(tokens[0].location, tokens.last().unwrap().location)
  978|       |                } else {
  979|      0|                    let loc = self.get_current_location();
  980|      0|                    SourceSpan::new(loc, loc)
  981|       |                };
  982|      0|                let diag = Diagnostic {
  983|      0|                    level: DiagnosticLevel::Warning,
  984|      0|                    message: "Failed to expand macros in conditional expression".to_string(),
  985|      0|                    span,
  986|      0|                    code: Some("macro_expansion_failed".to_string()),
  987|      0|                    hints: vec!["Expression will be treated as false".to_string()],
  988|      0|                    related: Vec::new(),
  989|      0|                };
  990|      0|                self.diag.report_diagnostic(diag);
  991|      0|                return Ok(false);
  992|       |            }
  993|       |        }
  994|       |
  995|       |        // Evaluate arithmetic expression with better error handling
  996|     21|        self.evaluate_arithmetic_expression(&expanded_tokens)
  997|     24|    }
  998|       |
  999|       |    /// Evaluate a simple arithmetic expression for #if/#elif
 1000|     21|    fn evaluate_arithmetic_expression(&mut self, tokens: &[PPToken]) -> Result<bool, PPError> {
 1001|     21|        if tokens.is_empty() {
 1002|      0|            return Err(PPError::InvalidConditionalExpression);
 1003|     21|        }
 1004|       |
 1005|     21|        let mut interpreter = Interpreter::new(tokens, self);
 1006|     21|        let result = interpreter.evaluate();
 1007|       |
 1008|     21|        match result {
 1009|     20|            Ok(val) => Ok(val != 0),
 1010|       |            Err(_) => {
 1011|       |                // For complex expressions that can't be parsed, emit a warning and treat as false
 1012|      1|                let span = if !tokens.is_empty() {
 1013|      1|                    SourceSpan::new(tokens[0].location, tokens.last().unwrap().location)
 1014|       |                } else {
 1015|      0|                    let loc = self.get_current_location();
 1016|      0|                    SourceSpan::new(loc, loc)
 1017|       |                };
 1018|      1|                let diag = Diagnostic {
 1019|      1|                    level: DiagnosticLevel::Warning,
 1020|      1|                    message: "Invalid conditional expression in preprocessor directive".to_string(),
 1021|      1|                    span,
 1022|      1|                    code: Some("invalid_conditional_expression".to_string()),
 1023|      1|                    hints: vec!["Expression will be treated as false".to_string()],
 1024|      1|                    related: Vec::new(),
 1025|      1|                };
 1026|      1|                self.diag.report_diagnostic(diag);
 1027|       |                // Return false for unparseable expressions to allow compilation to continue
 1028|      1|                Ok(false)
 1029|       |            }
 1030|       |        }
 1031|     21|    }
 1032|       |
 1033|       |    /// Lex the next token
 1034|  13.2k|    fn lex_token(&mut self) -> Option<PPToken> {
 1035|  13.2k|        if let Some(token) = self.pending_tokens.pop_front() {
                                  ^202
 1036|    202|            return Some(token);
 1037|  13.0k|        }
 1038|       |
 1039|       |        loop {
 1040|  13.0k|            if let Some(lexer) = self.lexer_stack.last_mut() {
 1041|  13.0k|                if let Some(token) = lexer.next_token() {
                                          ^12.3k
 1042|  12.3k|                    return Some(token);
 1043|       |                } else {
 1044|       |                    // EOF reached, pop the lexer
 1045|    667|                    let popped_lexer = self.lexer_stack.pop().unwrap();
 1046|       |
 1047|       |                    // If this was an included file, pop from include stack and decrement depth.
 1048|    667|                    if let Some(include_info) = self.include_stack.last()
                                              ^3
 1049|      3|                        && include_info.file_id == popped_lexer.source_id
 1050|      3|                    {
 1051|      3|                        self.include_stack.pop();
 1052|      3|                        self.include_depth -= 1;
 1053|    664|                    }
 1054|       |
 1055|       |                    // Set the line_starts from the lexer to the source manager
 1056|    667|                    self.source_manager
 1057|    667|                        .set_line_starts(popped_lexer.source_id, popped_lexer.get_line_starts().clone());
 1058|    667|                    if self.lexer_stack.is_empty() {
 1059|    664|                        return None;
 1060|      3|                    }
 1061|       |                    // Continue to try the next lexer in the stack
 1062|       |                }
 1063|       |            } else {
 1064|      0|                return None;
 1065|       |            }
 1066|       |        }
 1067|  13.2k|    }
 1068|       |
 1069|       |    /// Handle preprocessor directives
 1070|    178|    fn handle_directive(&mut self) -> Result<(), PPError> {
 1071|    178|        let token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                      ^0
 1072|       |
 1073|    178|        match token.kind {
 1074|    178|            PPTokenKind::Identifier(sym) => {
 1075|       |                // Use O(1) interned keyword comparison
 1076|    178|                match self.directive_keywords.is_directive(sym) {
 1077|     54|                    Some(DirectiveKind::Define) => self.check_skipping_and_execute(|this| this.handle_define()),
 1078|      2|                    Some(DirectiveKind::Undef) => self.check_skipping_and_execute(|this| this.handle_undef()),
 1079|     27|                    Some(DirectiveKind::Include) => self.check_skipping_and_execute(|this| this.handle_include()),
 1080|       |                    Some(DirectiveKind::If) => {
 1081|       |                        // Always process #if to track nesting
 1082|     23|                        if self.is_currently_skipping() {
 1083|      0|                            self.push_skipped_conditional();
 1084|      0|                            self.skip_directive()?;
 1085|       |                        } else {
 1086|     23|                            let expr_tokens = self.parse_conditional_expression().unwrap_or_default();
 1087|     23|                            let condition = self.evaluate_conditional_expression(&expr_tokens).unwrap_or(false);
 1088|     23|                            self.handle_if_directive(condition)?;
                                                                             ^0
 1089|       |                        }
 1090|     23|                        Ok(())
 1091|       |                    }
 1092|       |                    Some(DirectiveKind::Ifdef) => {
 1093|      2|                        if self.is_currently_skipping() {
 1094|      0|                            self.push_skipped_conditional();
 1095|      0|                            self.skip_directive()?;
 1096|       |                        } else {
 1097|      2|                            self.handle_ifdef()?;
                                                             ^0
 1098|       |                        }
 1099|      2|                        Ok(())
 1100|       |                    }
 1101|       |                    Some(DirectiveKind::Ifndef) => {
 1102|      2|                        if self.is_currently_skipping() {
 1103|      0|                            self.push_skipped_conditional();
 1104|      0|                            self.skip_directive()?;
 1105|       |                        } else {
 1106|      2|                            self.handle_ifndef()?;
                                                              ^0
 1107|       |                        }
 1108|      2|                        Ok(())
 1109|       |                    }
 1110|       |                    Some(DirectiveKind::Elif) => {
 1111|      1|                        if self.should_evaluate_conditional() {
 1112|      1|                            let expr_tokens = self.parse_conditional_expression().unwrap_or_default();
 1113|      1|                            let condition = self.evaluate_conditional_expression(&expr_tokens).unwrap_or(false);
 1114|      1|                            self.handle_elif_directive(condition, token.location)?;
                                                                                               ^0
 1115|       |                        } else {
 1116|       |                            // Just update state to keep skipping
 1117|      0|                            self.handle_elif_directive(false, token.location)?;
 1118|       |                        }
 1119|      1|                        Ok(())
 1120|       |                    }
 1121|     15|                    Some(DirectiveKind::Else) => self.handle_else(token.location),
 1122|     26|                    Some(DirectiveKind::Endif) => self.handle_endif(token.location),
 1123|      6|                    Some(DirectiveKind::Line) => self.check_skipping_and_execute(|this| this.handle_line()),
 1124|     11|                    Some(DirectiveKind::Pragma) => self.check_skipping_and_execute(|this| this.handle_pragma()),
 1125|      9|                    Some(DirectiveKind::Error) => self.check_skipping_and_execute(|this| this.handle_error()),
                                                                                                       ^1   ^1
 1126|      0|                    Some(DirectiveKind::Warning) => self.check_skipping_and_execute(|this| this.handle_warning()),
 1127|       |                    None => {
 1128|      0|                        let name = sym.as_str();
 1129|      0|                        let diag = Diagnostic {
 1130|      0|                            level: DiagnosticLevel::Error,
 1131|      0|                            message: format!("Invalid preprocessor directive '{name}'"),
 1132|      0|                            span: SourceSpan::new(token.location, token.location),
 1133|      0|                            code: Some("invalid_directive".to_string()),
 1134|      0|                            hints: vec!["Valid directives include #define, #include, #if, #ifdef, #ifndef, #elif, #else, #endif, #line, #pragma, #error, #warning".to_string()],
 1135|      0|                            related: Vec::new(),
 1136|      0|                        };
 1137|      0|                        self.diag.report_diagnostic(diag);
 1138|      0|                        Err(PPError::InvalidDirective)
 1139|       |                    }
 1140|       |                }
 1141|       |            }
 1142|       |            _ => {
 1143|      0|                let diag = Diagnostic {
 1144|      0|                    level: DiagnosticLevel::Error,
 1145|      0|                    message: "Invalid preprocessor directive".to_string(),
 1146|      0|                    span: SourceSpan::new(token.location, token.location),
 1147|      0|                    code: Some("invalid_directive".to_string()),
 1148|      0|                    hints: vec!["Valid directives include #define, #include, #if, #ifdef, #ifndef, #elif, #else, #endif, #line, #pragma, #error, #warning".to_string()],
 1149|      0|                    related: Vec::new(),
 1150|      0|                };
 1151|      0|                self.diag.report_diagnostic(diag);
 1152|      0|                Err(PPError::InvalidDirective)
 1153|       |            }
 1154|       |        }
 1155|    178|    }
 1156|       |
 1157|       |    /// Check if skipping is active, and if so, skip the directive. Otherwise, execute the action.
 1158|    109|    fn check_skipping_and_execute<F>(&mut self, action: F) -> Result<(), PPError>
 1159|    109|    where
 1160|    109|        F: FnOnce(&mut Self) -> Result<(), PPError>,
 1161|       |    {
 1162|    109|        if self.is_currently_skipping() {
 1163|      8|            self.skip_directive()
 1164|       |        } else {
 1165|    101|            action(self)
 1166|       |        }
 1167|    109|    }
 1168|       |
 1169|       |    /// Handle _Pragma("...") operator
 1170|      5|    fn handle_pragma_operator(&mut self) -> Result<(), PPError> {
 1171|       |        // We have already consumed the `_Pragma` identifier.
 1172|       |        // Expect '('.
 1173|      5|        if self.lex_token().is_none_or(|t| t.kind != PPTokenKind::LeftParen) {
 1174|      0|            return Err(PPError::InvalidDirective);
 1175|      5|        }
 1176|       |
 1177|       |        // Expect string literal.
 1178|      5|        let string_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                             ^0
 1179|      5|        let pragma_content = if let PPTokenKind::StringLiteral(symbol) = string_token.kind {
 1180|      5|            self.destringize(symbol.as_str())
 1181|       |        } else {
 1182|      0|            return Err(PPError::InvalidDirective);
 1183|       |        };
 1184|       |
 1185|       |        // Expect ')'.
 1186|      5|        if self.lex_token().is_none_or(|t| t.kind != PPTokenKind::RightParen) {
 1187|      0|            return Err(PPError::InvalidDirective);
 1188|      5|        }
 1189|       |
 1190|      5|        self.perform_pragma(&pragma_content);
 1191|       |
 1192|      5|        Ok(())
 1193|      5|    }
 1194|       |
 1195|       |    /// Destringize a string literal (remove quotes and handle escapes)
 1196|    230|    fn destringize(&self, full_str: &str) -> String {
 1197|    230|        let inner_content = &full_str[1..full_str.len() - 1];
 1198|    230|        let mut content = String::with_capacity(inner_content.len());
 1199|    230|        let mut chars = inner_content.chars().peekable();
 1200|  1.10k|        while let Some(c) = chars.next() {
                                     ^877
 1201|    877|            if c == '\\' {
 1202|    348|                match chars.next() {
 1203|     18|                    Some('\'') => content.push('\''),
 1204|     42|                    Some('"') => content.push('"'),
 1205|      0|                    Some('?') => content.push('?'),
 1206|     36|                    Some('\\') => content.push('\\'),
 1207|      0|                    Some('a') => content.push('\x07'),
 1208|      0|                    Some('b') => content.push('\x08'),
 1209|      0|                    Some('f') => content.push('\x0c'),
 1210|     18|                    Some('n') => content.push('\n'),
 1211|     18|                    Some('r') => content.push('\r'),
 1212|     36|                    Some('t') => content.push('\t'),
 1213|      0|                    Some('v') => content.push('\x0b'),
 1214|     90|                    Some(first_digit @ '0'..='7') => {
 1215|       |                        // Bolt : Optimized octal escape parsing.
 1216|       |                        // Instead of creating a temporary string for the octal digits, this
 1217|       |                        // parses the digits directly into a numeric value. This avoids a heap
 1218|       |                        // allocation for the string, improving performance.
 1219|     90|                        let mut octal_val = first_digit.to_digit(8).unwrap() as u8;
 1220|    198|                        for _ in 0..2 {
 1221|    144|                            if let Some(digit @ '0'..='7') = chars.peek() {
                                                      ^108    ^108
 1222|    108|                                let digit_val = digit.to_digit(8).unwrap() as u8;
 1223|    108|                                octal_val = octal_val.saturating_mul(8).saturating_add(digit_val);
 1224|    108|                                chars.next();
 1225|    108|                            } else {
 1226|     36|                                break;
 1227|       |                            }
 1228|       |                        }
 1229|     90|                        content.push(octal_val as char);
 1230|       |                    }
 1231|       |                    Some('x') => {
 1232|       |                        // Bolt : Optimized hexadecimal escape parsing.
 1233|       |                        // This avoids allocating a temporary string by parsing hex digits
 1234|       |                        // directly into a numeric value. This is more efficient as it
 1235|       |                        // prevents a heap allocation inside the loop.
 1236|     90|                        let mut hex_val: u8 = 0;
 1237|     90|                        let mut has_digits = false;
 1238|    270|                        while let Some(digit) = chars.peek() {
                                                     ^216
 1239|    216|                            if let Some(digit_val) = digit.to_digit(16) {
                                                      ^180
 1240|    180|                                hex_val = hex_val.saturating_mul(16).saturating_add(digit_val as u8);
 1241|    180|                                chars.next(); // consume the digit
 1242|    180|                                has_digits = true;
 1243|    180|                            } else {
 1244|     36|                                break;
 1245|       |                            }
 1246|       |                        }
 1247|     90|                        if has_digits {
 1248|     90|                            content.push(hex_val as char);
 1249|     90|                        }
                                      ^0
 1250|       |                    }
 1251|      0|                    Some(other) => {
 1252|      0|                        content.push('\\');
 1253|      0|                        content.push(other);
 1254|      0|                    }
 1255|      0|                    None => {} // Invalid escape at end of string
 1256|       |                }
 1257|    529|            } else {
 1258|    529|                content.push(c);
 1259|    529|            }
 1260|       |        }
 1261|    230|        content
 1262|    230|    }
 1263|       |
 1264|       |    /// Perform the action of a pragma directive
 1265|      6|    fn perform_pragma(&mut self, pragma_content: &str) {
 1266|       |        // Create a buffer for the pragma content
 1267|      6|        let source_id = self
 1268|      6|            .source_manager
 1269|      6|            .add_buffer(pragma_content.as_bytes().to_vec(), "<_Pragma>", None);
 1270|      6|        let buffer = self.source_manager.get_buffer(source_id);
 1271|      6|        let mut temp_lexer = PPLexer::new(source_id, buffer.to_vec());
 1272|       |
 1273|       |        // Collect all tokens from the pragma content
 1274|      6|        let mut tokens = Vec::new();
 1275|     23|        while let Some(token) = temp_lexer.next_token() {
                                     ^17
 1276|     17|            if matches!(token.kind, PPTokenKind::Eod | PPTokenKind::Eof) {
 1277|      0|                continue;
 1278|     17|            }
 1279|     17|            tokens.push(token);
 1280|       |        }
 1281|       |
 1282|       |        // Determine location for the synthetic EOD
 1283|      6|        let eod_loc = if let Some(last) = tokens.last() {
 1284|      6|            last.location
 1285|       |        } else {
 1286|      0|            SourceLoc::new(source_id, 0)
 1287|       |        };
 1288|       |
 1289|       |        // Append EOD token to mark end of pragma
 1290|      6|        tokens.push(PPToken::new(PPTokenKind::Eod, PPTokenFlags::empty(), eod_loc, 0));
 1291|       |
 1292|       |        // Push to pending_tokens in reverse order so they come out in correct order
 1293|     23|        for token in tokens.into_iter().rev() {
                                   ^6     ^6          ^6
 1294|     23|            self.pending_tokens.push_front(token);
 1295|     23|        }
 1296|       |
 1297|       |        // Execute pragma handler
 1298|       |        // handle_pragma will consume tokens from pending_tokens
 1299|      6|        if self.handle_pragma().is_err() {
 1300|       |            // If handle_pragma failed (e.g. unknown pragma), it might not have consumed all tokens.
 1301|       |            // We must consume the remaining tokens of this pragma until EOD to ensure they don't leak.
 1302|      3|            while let Some(token) = self.lex_token() {
 1303|      3|                if token.kind == PPTokenKind::Eod {
 1304|      1|                    break;
 1305|      2|                }
 1306|       |            }
 1307|      5|        }
 1308|      6|    }
 1309|       |
 1310|       |    /// Handle #define directive
 1311|     54|    fn handle_define(&mut self) -> Result<(), PPError> {
 1312|     54|        let name_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                           ^0
 1313|     54|        let name = match name_token.kind {
 1314|     54|            PPTokenKind::Identifier(sym) => sym,
 1315|      0|            _ => return Err(PPError::ExpectedIdentifier),
 1316|       |        };
 1317|       |
 1318|     54|        let mut flags = MacroFlags::empty();
 1319|     54|        let mut params = Vec::new();
 1320|     54|        let mut variadic = None;
 1321|     54|        let next = self.lex_token();
 1322|     54|        if let Some(token) = next {
 1323|     54|            if token.kind == PPTokenKind::LeftParen && !token.flags.contains(PPTokenFlags::LEADING_SPACE) {
                                                                     ^27
 1324|     26|                let first_param = self.lex_token();
 1325|     26|                if let Some(fp) = first_param {
 1326|      0|                    if matches!(
 1327|     26|                        fp.kind,
 1328|       |                        PPTokenKind::RightParen | PPTokenKind::Identifier(_) | PPTokenKind::Ellipsis
 1329|       |                    ) {
 1330|     26|                        flags |= MacroFlags::FUNCTION_LIKE;
 1331|     26|                        self.pending_tokens.push_front(fp);
 1332|       |                        // parse params
 1333|       |                        'param_parsing: loop {
 1334|     39|                            let param_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                                                ^0
 1335|     39|                            match param_token.kind {
 1336|      0|                                PPTokenKind::RightParen => break,
 1337|     37|                                PPTokenKind::Identifier(sym) => {
 1338|     37|                                    if params.contains(&sym) {
 1339|      0|                                        return Err(PPError::InvalidMacroParameter {
 1340|      0|                                            span: SourceSpan::new(
 1341|      0|                                                self.get_current_location(),
 1342|      0|                                                self.get_current_location(),
 1343|      0|                                            ),
 1344|      0|                                        });
 1345|     37|                                    }
 1346|     37|                                    params.push(sym);
 1347|     37|                                    let sep = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                                                ^0
 1348|     37|                                    match sep.kind {
 1349|     13|                                        PPTokenKind::Comma => continue,
 1350|     24|                                        PPTokenKind::RightParen => break,
 1351|       |                                        PPTokenKind::Ellipsis => {
 1352|      0|                                            variadic = Some(sym);
 1353|      0|                                            flags |= MacroFlags::C99_VARARGS;
 1354|      0|                                            let rparen = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
 1355|      0|                                            if rparen.kind != PPTokenKind::RightParen {
 1356|      0|                                                return Err(PPError::InvalidMacroParameter {
 1357|      0|                                                    span: SourceSpan::new(
 1358|      0|                                                        self.get_current_location(),
 1359|      0|                                                        self.get_current_location(),
 1360|      0|                                                    ),
 1361|      0|                                                });
 1362|      0|                                            }
 1363|      0|                                            break;
 1364|       |                                        }
 1365|       |                                        _ => {
 1366|       |                                            // Check if this token could signal the end of parameter list
 1367|       |                                            // For object-like macros, any non-identifier token after the macro name
 1368|       |                                            // should be treated as the start of the macro body
 1369|      0|                                            self.pending_tokens.push_front(param_token);
 1370|       |                                            // This is an object-like macro, exit parameter parsing
 1371|      0|                                            break 'param_parsing;
 1372|       |                                        }
 1373|       |                                    }
 1374|       |                                }
 1375|       |                                PPTokenKind::Ellipsis => {
 1376|      2|                                    flags |= MacroFlags::GNU_VARARGS;
 1377|      2|                                    variadic = Some(StringId::new("__VA_ARGS__"));
 1378|      2|                                    let rparen = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                                                   ^0
 1379|      2|                                    if rparen.kind != PPTokenKind::RightParen {
 1380|      0|                                        return Err(PPError::InvalidMacroParameter {
 1381|      0|                                            span: SourceSpan::new(
 1382|      0|                                                self.get_current_location(),
 1383|      0|                                                self.get_current_location(),
 1384|      0|                                            ),
 1385|      0|                                        });
 1386|      2|                                    }
 1387|      2|                                    break;
 1388|       |                                }
 1389|       |                                _ => {
 1390|       |                                    // For problematic parameter tokens, emit a warning and continue
 1391|      0|                                    let diag = Diagnostic {
 1392|      0|                                        level: DiagnosticLevel::Warning,
 1393|      0|                                        message: format!(
 1394|      0|                                            "Invalid macro parameter token in #define '{}'",
 1395|      0|                                            name.as_str()
 1396|      0|                                        ),
 1397|      0|                                        span: SourceSpan::new(param_token.location, param_token.location),
 1398|      0|                                        code: Some("invalid_macro_parameter".to_string()),
 1399|      0|                                        hints: vec!["Macro parameters must be identifiers".to_string()],
 1400|      0|                                        related: Vec::new(),
 1401|      0|                                    };
 1402|      0|                                    self.diag.report_diagnostic(diag);
 1403|       |
 1404|       |                                    // Skip to the next comma or right paren
 1405|       |                                    loop {
 1406|      0|                                        let skip_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
 1407|      0|                                        match skip_token.kind {
 1408|       |                                            PPTokenKind::Comma | PPTokenKind::RightParen => {
 1409|      0|                                                self.pending_tokens.push_front(skip_token);
 1410|      0|                                                break;
 1411|       |                                            }
 1412|      0|                                            _ => continue,
 1413|       |                                        }
 1414|       |                                    }
 1415|       |                                }
 1416|       |                            }
 1417|       |                        }
 1418|      0|                    } else {
 1419|      0|                        self.pending_tokens.push_front(fp);
 1420|      0|                        self.pending_tokens.push_front(token);
 1421|      0|                    }
 1422|       |                } else {
 1423|      0|                    return Err(PPError::UnexpectedEndOfFile);
 1424|       |                }
 1425|     28|            } else {
 1426|     28|                self.pending_tokens.push_front(token);
 1427|     28|            }
 1428|      0|        }
 1429|     54|        let mut tokens = Vec::new();
 1430|    194|        while let Some(token) = self.lex_token() {
 1431|    194|            if token.kind == PPTokenKind::Eod {
 1432|     54|                break;
 1433|    140|            }
 1434|    140|            tokens.push(token);
 1435|       |        }
 1436|       |        // Store the macro
 1437|     54|        let macro_info = MacroInfo {
 1438|     54|            location: name_token.location,
 1439|     54|            flags,
 1440|     54|            tokens,
 1441|     54|            parameter_list: params,
 1442|     54|            variadic_arg: variadic,
 1443|     54|        };
 1444|       |
 1445|       |        // Check for macro redefinition
 1446|     54|        if let Some(existing) = self.macros.get(&name) {
                                  ^2
 1447|      2|            let is_builtin = existing.flags.contains(MacroFlags::BUILTIN);
 1448|       |
 1449|       |            // Check if definition is different
 1450|       |            // Two macro definitions are distinct if they have different parameter lists,
 1451|       |            // different variadic arguments, different flags, or different token sequences.
 1452|       |            // For token sequences, we check kind and flags (ignoring location).
 1453|      2|            let is_different = existing.flags != macro_info.flags
 1454|      2|                || existing.parameter_list != macro_info.parameter_list
 1455|      2|                || existing.variadic_arg != macro_info.variadic_arg
 1456|      2|                || existing.tokens.len() != macro_info.tokens.len()
 1457|      2|                || existing
 1458|      2|                    .tokens
 1459|      2|                    .iter()
 1460|      2|                    .zip(macro_info.tokens.iter())
 1461|      2|                    .any(|(a, b)| a.kind != b.kind || a.flags != b.flags);
                                                                    ^1
 1462|       |
 1463|      2|            if !is_builtin && is_different {
 1464|      1|                // Emit warning for redefinition
 1465|      1|                let diag = Diagnostic {
 1466|      1|                    level: DiagnosticLevel::Warning,
 1467|      1|                    message: format!("Redefinition of macro '{}'", name.as_str()),
 1468|      1|                    span: SourceSpan::new(name_token.location, name_token.location),
 1469|      1|                    code: Some("macro_redefinition".to_string()),
 1470|      1|                    hints: Vec::new(),
 1471|      1|                    related: vec![SourceSpan::new(existing.location, existing.location)],
 1472|      1|                };
 1473|      1|                self.diag.report_diagnostic(diag);
 1474|      1|            }
 1475|     52|        }
 1476|       |
 1477|     54|        self.macros.insert(name, macro_info);
 1478|     54|        Ok(())
 1479|     54|    }
 1480|       |
 1481|      2|    fn handle_undef(&mut self) -> Result<(), PPError> {
 1482|      2|        let name_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                           ^0
 1483|      2|        let name = match name_token.kind {
 1484|      2|            PPTokenKind::Identifier(sym) => sym,
 1485|      0|            _ => return Err(PPError::ExpectedIdentifier),
 1486|       |        };
 1487|       |        // Remove the macro from the table if it exists
 1488|      2|        self.macros.remove(&name);
 1489|       |
 1490|      2|        self.expect_eod()?;
                                       ^0
 1491|       |
 1492|      2|        Ok(())
 1493|      2|    }
 1494|       |
 1495|     27|    fn handle_include(&mut self) -> Result<(), PPError> {
 1496|       |        // Parse the include path
 1497|     27|        let token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                      ^0
 1498|     27|        let is_angled = matches!(token.kind, PPTokenKind::Less);
 1499|     27|        let path_str = match token.kind {
 1500|     27|            PPTokenKind::StringLiteral(symbol) => {
 1501|       |                // Remove quotes from string literal
 1502|     27|                let full_str = symbol.as_str();
 1503|     27|                if full_str.starts_with('"') && full_str.ends_with('"') {
 1504|     27|                    full_str[1..full_str.len() - 1].to_string()
 1505|       |                } else {
 1506|      0|                    return Err(PPError::InvalidIncludePath);
 1507|       |                }
 1508|       |            }
 1509|       |            PPTokenKind::Less => {
 1510|       |                // Angled include: collect tokens until >
 1511|      0|                let mut path_parts = Vec::new();
 1512|       |                loop {
 1513|      0|                    let part_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
 1514|      0|                    match part_token.kind {
 1515|      0|                        PPTokenKind::Greater => break,
 1516|      0|                        _ => path_parts.push(part_token),
 1517|       |                    }
 1518|       |                }
 1519|       |                // Bolt : Use a two-pass approach to build the path string efficiently.
 1520|       |                // This avoids multiple reallocations from push_str in a loop, a known
 1521|       |                // performance anti-pattern in this codebase.
 1522|       |                // 1. Calculate the total length of the path.
 1523|      0|                let total_len = path_parts.iter().map(|part| part.length as usize).sum();
 1524|       |
 1525|       |                // 2. Allocate the string with the exact capacity.
 1526|      0|                let mut path = String::with_capacity(total_len);
 1527|       |
 1528|       |                // 3. Populate the string.
 1529|      0|                for part in path_parts.iter() {
 1530|      0|                    let buffer = self.source_manager.get_buffer(part.location.source_id());
 1531|      0|                    let start = part.location.offset() as usize;
 1532|      0|                    let end = start + part.length as usize;
 1533|      0|                    if end <= buffer.len() {
 1534|      0|                        let text = unsafe { std::str::from_utf8_unchecked(&buffer[start..end]) };
 1535|      0|                        path.push_str(text);
 1536|      0|                    }
 1537|       |                }
 1538|      0|                path
 1539|       |            }
 1540|      0|            _ => return Err(PPError::InvalidIncludePath),
 1541|       |        };
 1542|       |
 1543|       |        // Check include depth
 1544|     27|        if self.include_depth >= self.max_include_depth {
 1545|       |            // Arbitrary limit
 1546|      2|            return Err(PPError::IncludeDepthExceeded);
 1547|     25|        }
 1548|       |
 1549|       |        // Check for built-in headers first for angled includes
 1550|     25|        let include_source_id = if is_angled {
                          ^24
 1551|       |            // Get current directory
 1552|      0|            let current_file_id = self.lexer_stack.last().unwrap().source_id;
 1553|       |            // It's possible that we are processing a macro expansion or something where source_id might be tricky,
 1554|       |            // but for include directive, we should be in a file.
 1555|       |            // Safety: We expect get_file_info to succeed for any file in the stack.
 1556|      0|            let current_file_info = self.source_manager.get_file_info(current_file_id).unwrap();
 1557|      0|            let current_dir = current_file_info.path.parent().unwrap_or(Path::new("."));
 1558|       |
 1559|       |            // Resolve the path first using header search (allows overriding built-ins)
 1560|      0|            let resolved_path = self.header_search.resolve_path(&path_str, is_angled, current_dir);
 1561|       |
 1562|      0|            if let Some(resolved_path) = resolved_path {
 1563|       |                // Load the file
 1564|      0|                self.source_manager
 1565|      0|                    .add_file_from_path(&resolved_path, Some(token.location))
 1566|      0|                    .map_err(|_| {
 1567|       |                        // Emit diagnostic for file not found
 1568|      0|                        let diag = Diagnostic {
 1569|      0|                            level: DiagnosticLevel::Error,
 1570|      0|                            message: format!("Include file '{}' not found", path_str),
 1571|      0|                            span: SourceSpan::new(token.location, token.location),
 1572|      0|                            code: Some("include_file_not_found".to_string()),
 1573|      0|                            hints: vec!["Check the include path and ensure the file exists".to_string()],
 1574|      0|                            related: Vec::new(),
 1575|      0|                        };
 1576|      0|                        self.diag.report_diagnostic(diag);
 1577|      0|                        PPError::FileNotFound
 1578|      0|                    })?
 1579|      0|            } else if let Some(&source_id) = self.built_in_file_ids.get(path_str.as_str()) {
 1580|      0|                source_id
 1581|       |            } else {
 1582|       |                // Emit diagnostic for file not found
 1583|      0|                let diag = Diagnostic {
 1584|      0|                    level: DiagnosticLevel::Error,
 1585|      0|                    message: format!("Include file '{}' not found", path_str),
 1586|      0|                    span: SourceSpan::new(token.location, token.location),
 1587|      0|                    code: Some("include_file_not_found".to_string()),
 1588|      0|                    hints: vec!["Check the include path and ensure the file exists".to_string()],
 1589|      0|                    related: Vec::new(),
 1590|      0|                };
 1591|      0|                self.diag.report_diagnostic(diag);
 1592|      0|                return Err(PPError::FileNotFound);
 1593|       |            }
 1594|       |        } else {
 1595|       |            // For quoted includes, resolve as before
 1596|     25|            let resolved_path = if is_angled {
 1597|      0|                self.header_search.resolve_path(&path_str, true, Path::new("."))
 1598|       |            } else {
 1599|     25|                let current_file_id = self.lexer_stack.last().unwrap().source_id;
 1600|     25|                let current_file_info = self.source_manager.get_file_info(current_file_id).unwrap();
 1601|     25|                let current_dir = current_file_info.path.parent().unwrap_or(Path::new("."));
 1602|     25|                self.header_search.resolve_path(&path_str, false, current_dir)
 1603|       |            };
 1604|       |
 1605|     25|            if let Some(resolved_path) = resolved_path {
                                      ^10
 1606|     10|                self.source_manager
 1607|     10|                    .add_file_from_path(&resolved_path, Some(token.location))
 1608|     10|                    .map_err(|_| {
                                               ^0
 1609|       |                        // Emit diagnostic for file not found
 1610|      0|                        let diag = Diagnostic {
 1611|      0|                            level: DiagnosticLevel::Error,
 1612|      0|                            message: format!("Include file '{}' not found", path_str),
 1613|      0|                            span: SourceSpan::new(token.location, token.location),
 1614|      0|                            code: Some("include_file_not_found".to_string()),
 1615|      0|                            hints: vec!["Check the include path and ensure the file exists".to_string()],
 1616|      0|                            related: Vec::new(),
 1617|      0|                        };
 1618|      0|                        self.diag.report_diagnostic(diag);
 1619|      0|                        PPError::FileNotFound
 1620|      0|                    })?
 1621|     15|            } else if let Some(file_id) = self.source_manager.get_file_id(&path_str) {
                                             ^14
 1622|     14|                file_id
 1623|       |            } else {
 1624|       |                // Emit diagnostic for file not found
 1625|      1|                let diag = Diagnostic {
 1626|      1|                    level: DiagnosticLevel::Error,
 1627|      1|                    message: format!("Include file '{}' not found", path_str),
 1628|      1|                    span: SourceSpan::new(token.location, token.location),
 1629|      1|                    code: Some("include_file_not_found".to_string()),
 1630|      1|                    hints: vec!["Check the include path and ensure the file exists".to_string()],
 1631|      1|                    related: Vec::new(),
 1632|      1|                };
 1633|      1|                self.diag.report_diagnostic(diag);
 1634|      1|                return Err(PPError::FileNotFound);
 1635|       |            }
 1636|       |        };
 1637|       |
 1638|       |        // Check if file has #pragma once
 1639|     24|        if self.once_included.contains(&include_source_id) {
 1640|       |            // Skip including this file again
 1641|      1|            return Ok(());
 1642|     23|        }
 1643|       |
 1644|       |        // Push to include stack
 1645|     23|        self.include_stack.push(IncludeStackInfo {
 1646|     23|            file_id: include_source_id,
 1647|     23|            // location: token.location,
 1648|     23|        });
 1649|       |
 1650|     23|        self.expect_eod()?;
                                       ^0
 1651|       |
 1652|       |        // Create lexer for the included file
 1653|     23|        let buffer = self.source_manager.get_buffer(include_source_id);
 1654|     23|        let lexer = PPLexer::new(include_source_id, buffer.to_vec());
 1655|     23|        self.lexer_stack.push(lexer);
 1656|       |
 1657|     23|        self.include_depth += 1;
 1658|       |
 1659|     23|        Ok(())
 1660|     27|    }
 1661|     23|    fn handle_if_directive(&mut self, condition: bool) -> Result<(), PPError> {
 1662|       |        // Push new conditional state
 1663|     23|        let info = PPConditionalInfo {
 1664|     23|            was_skipping: self.is_currently_skipping(),
 1665|     23|            found_else: false,
 1666|     23|            found_non_skipping: condition, // Set to true if condition is true
 1667|     23|        };
 1668|     23|        self.conditional_stack.push(info);
 1669|       |
 1670|       |        // Set skipping state for this conditional level
 1671|     23|        if !condition {
 1672|     17|            self.set_skipping(true);
 1673|     17|        }
                      ^6
 1674|       |
 1675|     23|        Ok(())
 1676|     23|    }
 1677|       |
 1678|      2|    fn handle_ifdef(&mut self) -> Result<(), PPError> {
 1679|      2|        let name_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                           ^0
 1680|      2|        let name = match name_token.kind {
 1681|      2|            PPTokenKind::Identifier(sym) => sym,
 1682|      0|            _ => return Err(PPError::ExpectedIdentifier),
 1683|       |        };
 1684|       |
 1685|      2|        let defined = self.macros.contains_key(&name);
 1686|      2|        let info = PPConditionalInfo {
 1687|      2|            was_skipping: self.is_currently_skipping(),
 1688|      2|            found_else: false,
 1689|      2|            found_non_skipping: defined,
 1690|      2|        };
 1691|      2|        self.conditional_stack.push(info);
 1692|       |
 1693|       |        // Set skipping state for this conditional level
 1694|      2|        if !defined {
 1695|      2|            self.set_skipping(true);
 1696|      2|        }
                      ^0
 1697|       |
 1698|      2|        self.expect_eod()?;
                                       ^0
 1699|       |
 1700|      2|        Ok(())
 1701|      2|    }
 1702|       |
 1703|      2|    fn handle_ifndef(&mut self) -> Result<(), PPError> {
 1704|      2|        let name_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                           ^0
 1705|      2|        let name = match name_token.kind {
 1706|      2|            PPTokenKind::Identifier(sym) => sym,
 1707|      0|            _ => return Err(PPError::ExpectedIdentifier),
 1708|       |        };
 1709|       |
 1710|      2|        let defined = self.macros.contains_key(&name);
 1711|      2|        let info = PPConditionalInfo {
 1712|      2|            was_skipping: self.is_currently_skipping(),
 1713|      2|            found_else: false,
 1714|      2|            found_non_skipping: !defined,
 1715|      2|        };
 1716|      2|        self.conditional_stack.push(info);
 1717|       |
 1718|       |        // Set skipping state for this conditional level
 1719|      2|        if defined {
 1720|      1|            self.set_skipping(true);
 1721|      1|        }
 1722|       |
 1723|      2|        self.expect_eod()?;
                                       ^0
 1724|       |
 1725|      2|        Ok(())
 1726|      2|    }
 1727|       |
 1728|      1|    fn handle_elif_directive(&mut self, condition: bool, location: SourceLoc) -> Result<(), PPError> {
 1729|      1|        if self.conditional_stack.is_empty() {
 1730|      0|            let diag = Diagnostic {
 1731|      0|                level: DiagnosticLevel::Error,
 1732|      0|                message: "#elif without #if".to_string(),
 1733|      0|                span: SourceSpan::new(location, location),
 1734|      0|                code: Some("elif_without_if".to_string()),
 1735|      0|                hints: vec!["#elif must be preceded by #if, #ifdef, or #ifndef".to_string()],
 1736|      0|                related: Vec::new(),
 1737|      0|            };
 1738|      0|            self.diag.report_diagnostic(diag);
 1739|      0|            return Err(PPError::ElifWithoutIf);
 1740|      1|        }
 1741|       |
 1742|      1|        let current = self.conditional_stack.last_mut().unwrap();
 1743|      1|        if current.found_else {
 1744|      0|            let diag = Diagnostic {
 1745|      0|                level: DiagnosticLevel::Error,
 1746|      0|                message: "#elif after #else".to_string(),
 1747|      0|                span: SourceSpan::new(location, location),
 1748|      0|                code: Some("elif_after_else".to_string()),
 1749|      0|                hints: vec!["#else must be the last directive in a conditional block".to_string()],
 1750|      0|                related: Vec::new(),
 1751|      0|            };
 1752|      0|            self.diag.report_diagnostic(diag);
 1753|      0|            return Err(PPError::UnmatchedElif);
 1754|      1|        }
 1755|       |
 1756|       |        // Determine if we should start processing
 1757|      1|        let should_process = !current.found_non_skipping && condition;
 1758|       |
 1759|      1|        if should_process {
 1760|      1|            current.found_non_skipping = true;
 1761|      1|            self.set_skipping(false);
 1762|      1|        } else {
 1763|      0|            self.set_skipping(true);
 1764|      0|        }
 1765|       |
 1766|      1|        Ok(())
 1767|      1|    }
 1768|       |
 1769|     15|    fn handle_else(&mut self, location: SourceLoc) -> Result<(), PPError> {
 1770|     15|        if self.conditional_stack.is_empty() {
 1771|      0|            let diag = Diagnostic {
 1772|      0|                level: DiagnosticLevel::Error,
 1773|      0|                message: "#else without #if".to_string(),
 1774|      0|                span: SourceSpan::new(location, location),
 1775|      0|                code: Some("else_without_if".to_string()),
 1776|      0|                hints: vec!["#else must be preceded by #if, #ifdef, or #ifndef".to_string()],
 1777|      0|                related: Vec::new(),
 1778|      0|            };
 1779|      0|            self.diag.report_diagnostic(diag);
 1780|      0|            return Err(PPError::ElseWithoutIf);
 1781|     15|        }
 1782|       |
 1783|     15|        let current = self.conditional_stack.last_mut().unwrap();
 1784|     15|        if current.found_else {
 1785|      0|            let diag = Diagnostic {
 1786|      0|                level: DiagnosticLevel::Error,
 1787|      0|                message: "Multiple #else directives".to_string(),
 1788|      0|                span: SourceSpan::new(location, location),
 1789|      0|                code: Some("multiple_else".to_string()),
 1790|      0|                hints: vec!["A conditional block can only have one #else".to_string()],
 1791|      0|                related: Vec::new(),
 1792|      0|            };
 1793|      0|            self.diag.report_diagnostic(diag);
 1794|      0|            return Err(PPError::UnmatchedElse);
 1795|     15|        }
 1796|     15|        current.found_else = true;
 1797|       |
 1798|       |        // Process else block if no previous branch was taken
 1799|     15|        let should_process = !current.found_non_skipping;
 1800|       |
 1801|       |        // Only change the skipping state for the current conditional level
 1802|     15|        current.was_skipping = !should_process;
 1803|       |
 1804|     15|        self.expect_eod()?;
                                       ^0
 1805|       |
 1806|     15|        Ok(())
 1807|     15|    }
 1808|       |
 1809|     26|    fn handle_endif(&mut self, location: SourceLoc) -> Result<(), PPError> {
 1810|     26|        if self.conditional_stack.is_empty() {
 1811|      0|            let diag = Diagnostic {
 1812|      0|                level: DiagnosticLevel::Error,
 1813|      0|                message: "Unmatched #endif".to_string(),
 1814|      0|                span: SourceSpan::new(location, location),
 1815|      0|                code: Some("unmatched_endif".to_string()),
 1816|      0|                hints: vec!["#endif must be preceded by #if, #ifdef, or #ifndef".to_string()],
 1817|      0|                related: Vec::new(),
 1818|      0|            };
 1819|      0|            self.diag.report_diagnostic(diag);
 1820|      0|            return Err(PPError::UnmatchedEndif);
 1821|     26|        }
 1822|       |
 1823|     26|        let _info = self.conditional_stack.pop().unwrap();
 1824|       |        // Restore previous skipping state - checking the stack implicitly restores it
 1825|       |
 1826|     26|        self.expect_eod()?;
                                       ^0
 1827|       |
 1828|     26|        Ok(())
 1829|     26|    }
 1830|      6|    fn handle_line(&mut self) -> Result<(), PPError> {
 1831|       |        // Collect tokens until end of line
 1832|      6|        let mut tokens = Vec::new();
 1833|      6|        let start_line = if let Some(lexer) = self.lexer_stack.last() {
 1834|      6|            lexer.get_current_line()
 1835|       |        } else {
 1836|      0|            0
 1837|       |        };
 1838|       |
 1839|     16|        while let Some(token) = self.lex_token() {
 1840|     16|            if token.kind == PPTokenKind::Eod {
 1841|      6|                break;
 1842|     10|            }
 1843|     10|            tokens.push(token);
 1844|       |        }
 1845|       |
 1846|      6|        if tokens.is_empty() {
 1847|      0|            return Err(PPError::InvalidLineDirective);
 1848|      6|        }
 1849|       |
 1850|       |        // Expand macros in tokens
 1851|      6|        self.expand_tokens(&mut tokens, false)?;
                                                            ^0
 1852|       |
 1853|      6|        if tokens.is_empty() {
 1854|      0|            return Err(PPError::InvalidLineDirective);
 1855|      6|        }
 1856|       |
 1857|       |        // Parse line number
 1858|      6|        let logical_line = match &tokens[0].kind {
                          ^5
 1859|      5|            PPTokenKind::Number(symbol) => {
 1860|      5|                let text = symbol.as_str();
 1861|      5|                text.parse::<u32>().map_err(|_| PPError::InvalidLineDirective)?
                                                                                            ^0
 1862|       |            }
 1863|      1|            _ => return Err(PPError::InvalidLineDirective),
 1864|       |        };
 1865|       |
 1866|       |        // Validate line number (should be positive)
 1867|      5|        if logical_line == 0 {
 1868|      1|            return Err(PPError::InvalidLineDirective);
 1869|      4|        }
 1870|       |
 1871|       |        // Optional filename
 1872|      4|        let logical_file = if tokens.len() > 1 {
                          ^3
 1873|      4|            match &tokens[1].kind {
 1874|      3|                PPTokenKind::StringLiteral(symbol) => {
 1875|      3|                    let full_str = symbol.as_str();
 1876|      3|                    if full_str.starts_with('"') && full_str.ends_with('"') {
 1877|      3|                        Some(full_str[1..full_str.len() - 1].to_string())
 1878|       |                    } else {
 1879|      0|                        return Err(PPError::InvalidLineDirective);
 1880|       |                    }
 1881|       |                }
 1882|      1|                _ => return Err(PPError::InvalidLineDirective), // Extra tokens that aren't filename
 1883|       |            }
 1884|       |        } else {
 1885|      0|            None
 1886|       |        };
 1887|       |
 1888|       |        // Check for too many tokens
 1889|      3|        if tokens.len() > 2 {
 1890|      0|            return Err(PPError::InvalidLineDirective);
 1891|      3|        }
 1892|       |
 1893|       |        // Get current physical line (where #line directive appears)
 1894|      3|        let physical_line = start_line;
 1895|       |
 1896|       |        // The #line directive sets the line number for the following line,
 1897|       |        // so we need to adjust the logical_line for the entry
 1898|      3|        let entry_logical_line = logical_line - 1;
 1899|       |
 1900|       |        // Add entry to LineMap
 1901|      3|        if let Some(lexer) = self.lexer_stack.last()
 1902|      3|            && let Some(line_map) = self.source_manager.get_line_map_mut(lexer.source_id)
 1903|      3|        {
 1904|      3|            let entry = crate::source_manager::LineDirective::new(physical_line, entry_logical_line, logical_file);
 1905|      3|            line_map.add_entry(entry);
 1906|      3|        }
                      ^0
 1907|       |
 1908|      3|        Ok(())
 1909|      6|    }
 1910|     17|    fn handle_pragma(&mut self) -> Result<(), PPError> {
 1911|       |        // Parse the pragma directive
 1912|     17|        let pragma_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                             ^0
 1913|     17|        match pragma_token.kind {
 1914|     17|            PPTokenKind::Identifier(symbol) => {
 1915|     17|                let pragma_name = symbol.as_str();
 1916|     17|                if pragma_name == "once" {
 1917|       |                    // Mark the current file as once-included
 1918|      2|                    if let Some(lexer) = self.lexer_stack.last() {
 1919|      2|                        self.once_included.insert(lexer.source_id);
 1920|      2|                    }
                                  ^0
 1921|     15|                } else if pragma_name == "push_macro" {
 1922|      3|                    self.handle_push_macro()?;
                                                          ^0
 1923|     12|                } else if pragma_name == "pop_macro" {
 1924|      3|                    self.handle_pop_macro()?;
                                                         ^0
 1925|      9|                } else if pragma_name == "message" {
 1926|      5|                    self.handle_pragma_message()?;
                                                              ^1
 1927|      4|                } else if pragma_name == "warning" {
 1928|      1|                    self.handle_pragma_warning()?;
                                                              ^0
 1929|      3|                } else if pragma_name == "error" {
 1930|      1|                    self.handle_pragma_error()?;
 1931|       |                } else {
 1932|      2|                    let diag = Diagnostic {
 1933|      2|                        level: DiagnosticLevel::Error,
 1934|      2|                        message: format!("Unknown pragma '{}'", pragma_name),
 1935|      2|                        span: SourceSpan::new(pragma_token.location, pragma_token.location),
 1936|      2|                        code: Some("unknown_pragma".to_string()),
 1937|      2|                        hints: vec![
 1938|      2|                            "Supported pragmas: once, push_macro, pop_macro, message, warning, error".to_string(),
 1939|      2|                        ],
 1940|      2|                        related: Vec::new(),
 1941|      2|                    };
 1942|      2|                    self.diag.report_diagnostic(diag);
 1943|      2|                    return Err(PPError::UnknownPragma(pragma_name.to_string()));
 1944|       |                }
 1945|       |            }
 1946|       |            _ => {
 1947|      0|                let diag = Diagnostic {
 1948|      0|                    level: DiagnosticLevel::Error,
 1949|      0|                    message: "Invalid pragma directive".to_string(),
 1950|      0|                    span: SourceSpan::new(pragma_token.location, pragma_token.location),
 1951|      0|                    code: Some("invalid_pragma".to_string()),
 1952|      0|                    hints: vec!["Pragma directive requires an identifier".to_string()],
 1953|      0|                    related: Vec::new(),
 1954|      0|                };
 1955|      0|                self.diag.report_diagnostic(diag);
 1956|      0|                return Err(PPError::InvalidDirective);
 1957|       |            }
 1958|       |        }
 1959|       |        // Skip to end of line
 1960|     13|        while let Some(token) = self.lex_token() {
 1961|     13|            if token.kind == PPTokenKind::Eod {
 1962|     13|                break;
 1963|      0|            }
 1964|       |        }
 1965|     13|        Ok(())
 1966|     17|    }
 1967|       |
 1968|      6|    fn parse_pragma_macro_name(&mut self) -> Result<StringId, PPError> {
 1969|       |        // Expect '('
 1970|      6|        if self.lex_token().is_none_or(|t| t.kind != PPTokenKind::LeftParen) {
 1971|      0|            return Err(PPError::InvalidDirective);
 1972|      6|        }
 1973|       |
 1974|       |        // Expect string literal
 1975|      6|        let string_token = self.lex_token().ok_or(PPError::UnexpectedEndOfFile)?;
                                                                                             ^0
 1976|      6|        let name_str = if let PPTokenKind::StringLiteral(symbol) = string_token.kind {
 1977|       |            // Remove quotes
 1978|      6|            let full_str = symbol.as_str();
 1979|      6|            if full_str.starts_with('"') && full_str.ends_with('"') {
 1980|      6|                full_str[1..full_str.len() - 1].to_string()
 1981|       |            } else {
 1982|      0|                return Err(PPError::InvalidDirective);
 1983|       |            }
 1984|       |        } else {
 1985|      0|            return Err(PPError::InvalidDirective);
 1986|       |        };
 1987|       |
 1988|       |        // Expect ')'
 1989|      6|        if self.lex_token().is_none_or(|t| t.kind != PPTokenKind::RightParen) {
 1990|      0|            return Err(PPError::InvalidDirective);
 1991|      6|        }
 1992|       |
 1993|      6|        Ok(StringId::new(&name_str))
 1994|      6|    }
 1995|       |
 1996|      3|    fn handle_push_macro(&mut self) -> Result<(), PPError> {
 1997|      3|        let name = self.parse_pragma_macro_name()?;
                                                               ^0
 1998|       |
 1999|      3|        let info = self.macros.get(&name).cloned();
 2000|       |
 2001|      3|        self.macro_stack.entry(name).or_default().push(info);
 2002|       |
 2003|      3|        Ok(())
 2004|      3|    }
 2005|       |
 2006|      3|    fn handle_pop_macro(&mut self) -> Result<(), PPError> {
 2007|      3|        let name = self.parse_pragma_macro_name()?;
                                                               ^0
 2008|       |
 2009|      3|        if let Some(stack) = self.macro_stack.get_mut(&name)
 2010|      3|            && let Some(info_opt) = stack.pop()
 2011|       |        {
 2012|      3|            if let Some(info) = info_opt {
                                      ^2
 2013|      2|                self.macros.insert(name, info);
 2014|      2|            } else {
 2015|      1|                self.macros.remove(&name);
 2016|      1|            }
 2017|      0|        }
 2018|       |
 2019|      3|        Ok(())
 2020|      3|    }
 2021|       |
 2022|      7|    fn parse_pragma_message_content(&mut self) -> Result<String, PPError> {
 2023|       |        // Expect '('
 2024|      7|        if self.lex_token().is_none_or(|t| t.kind != PPTokenKind::LeftParen) {
 2025|      1|            return Err(PPError::InvalidDirective);
 2026|      6|        }
 2027|       |
 2028|       |        // Collect tokens until matching ')'
 2029|      6|        let mut tokens = Vec::new();
 2030|      6|        let mut paren_depth = 1;
 2031|       |
 2032|     14|        while let Some(token) = self.lex_token() {
 2033|     14|            if token.kind == PPTokenKind::Eod {
 2034|      0|                return Err(PPError::UnexpectedEndOfFile);
 2035|     14|            }
 2036|       |
 2037|     14|            match token.kind {
 2038|      0|                PPTokenKind::LeftParen => paren_depth += 1,
 2039|       |                PPTokenKind::RightParen => {
 2040|      6|                    paren_depth -= 1;
 2041|      6|                    if paren_depth == 0 {
 2042|      6|                        break;
 2043|      0|                    }
 2044|       |                }
 2045|      8|                _ => {}
 2046|       |            }
 2047|      8|            tokens.push(token);
 2048|       |        }
 2049|       |
 2050|      6|        if paren_depth > 0 {
 2051|      0|            return Err(PPError::UnexpectedEndOfFile);
 2052|      6|        }
 2053|       |
 2054|       |        // Expand macros
 2055|      6|        self.expand_tokens(&mut tokens, false)?;
                                                            ^0
 2056|       |
 2057|      6|        let mut message = String::new();
 2058|     14|        for token in tokens {
                          ^8
 2059|      8|            if let PPTokenKind::StringLiteral(symbol) = token.kind {
 2060|      8|                let s = symbol.as_str();
 2061|      8|                if s.starts_with('"') && s.ends_with('"') {
 2062|      8|                    message.push_str(&self.destringize(s));
 2063|      8|                } else {
 2064|      0|                    return Err(PPError::InvalidDirective);
 2065|       |                }
 2066|       |            } else {
 2067|      0|                return Err(PPError::InvalidDirective);
 2068|       |            }
 2069|       |        }
 2070|       |
 2071|      6|        Ok(message)
 2072|      7|    }
 2073|       |
 2074|      5|    fn handle_pragma_message(&mut self) -> Result<(), PPError> {
 2075|      5|        let message = self.parse_pragma_message_content()?;
                          ^4                                           ^1
 2076|      4|        let loc = self.get_current_location();
 2077|      4|        let diag = Diagnostic {
 2078|      4|            level: DiagnosticLevel::Note,
 2079|      4|            message,
 2080|      4|            span: SourceSpan::new(loc, loc),
 2081|      4|            ..Default::default()
 2082|      4|        };
 2083|      4|        self.diag.report_diagnostic(diag);
 2084|      4|        Ok(())
 2085|      5|    }
 2086|       |
 2087|      1|    fn handle_pragma_warning(&mut self) -> Result<(), PPError> {
 2088|      1|        let message = self.parse_pragma_message_content()?;
                                                                       ^0
 2089|      1|        let loc = self.get_current_location();
 2090|      1|        let diag = Diagnostic {
 2091|      1|            level: DiagnosticLevel::Warning,
 2092|      1|            message,
 2093|      1|            span: SourceSpan::new(loc, loc),
 2094|      1|            ..Default::default()
 2095|      1|        };
 2096|      1|        self.diag.report_diagnostic(diag);
 2097|      1|        Ok(())
 2098|      1|    }
 2099|       |
 2100|      1|    fn handle_pragma_error(&mut self) -> Result<(), PPError> {
 2101|      1|        let message = self.parse_pragma_message_content()?;
                                                                       ^0
 2102|      1|        let loc = self.get_current_location();
 2103|      1|        let diag = Diagnostic {
 2104|      1|            level: DiagnosticLevel::Error,
 2105|      1|            message: message.clone(),
 2106|      1|            span: SourceSpan::new(loc, loc),
 2107|      1|            ..Default::default()
 2108|      1|        };
 2109|      1|        self.diag.report_diagnostic(diag);
 2110|      1|        Err(PPError::PragmaError(message))
 2111|      1|    }
 2112|       |
 2113|      1|    fn handle_error(&mut self) -> Result<(), PPError> {
 2114|       |        // Note: Skipping is handled by caller (check_skipping_and_execute)
 2115|       |
 2116|      1|        let directive_location = self.get_current_location();
 2117|      1|        let message = self.consume_rest_of_line_as_string();
 2118|       |
 2119|      1|        let diag = Diagnostic {
 2120|      1|            level: DiagnosticLevel::Error,
 2121|      1|            message: format!("#error directive: {}", message),
 2122|      1|            span: SourceSpan::new(directive_location, directive_location),
 2123|      1|            ..Default::default()
 2124|      1|        };
 2125|      1|        self.diag.report_diagnostic(diag);
 2126|      1|        Err(PPError::ErrorDirective(message))
 2127|      1|    }
 2128|       |
 2129|      0|    fn handle_warning(&mut self) -> Result<(), PPError> {
 2130|       |        // Note: Skipping is handled by caller (check_skipping_and_execute)
 2131|       |
 2132|      0|        let directive_location = self.get_current_location();
 2133|      0|        let message = self.consume_rest_of_line_as_string();
 2134|       |
 2135|       |        // For warning, we emit a diagnostic but don't stop compilation
 2136|      0|        let diag = Diagnostic {
 2137|      0|            level: DiagnosticLevel::Warning,
 2138|      0|            message,
 2139|      0|            span: SourceSpan::new(directive_location, directive_location),
 2140|      0|            code: None,
 2141|      0|            hints: Vec::new(),
 2142|      0|            related: Vec::new(),
 2143|      0|        };
 2144|      0|        self.diag.report_diagnostic(diag);
 2145|      0|        Ok(())
 2146|      0|    }
 2147|       |
 2148|      1|    fn consume_rest_of_line_as_string(&mut self) -> String {
 2149|       |        // Optimization: Avoid multiple small allocations by calculating final string size first.
 2150|       |        // This follows the two-pass approach:
 2151|       |        // 1. Collect tokens for the line.
 2152|       |        // 2. Calculate the total length required for the string.
 2153|       |        // 3. Allocate a single string with the required capacity.
 2154|       |        // 4. Populate the string in a second pass over the tokens.
 2155|      1|        let mut tokens = Vec::new();
 2156|      2|        while let Some(token) = self.lex_token() {
 2157|      2|            if token.kind == PPTokenKind::Eod {
 2158|      1|                break;
 2159|      1|            }
 2160|      1|            tokens.push(token);
 2161|       |        }
 2162|       |
 2163|      1|        if tokens.is_empty() {
 2164|      0|            return String::new();
 2165|      1|        }
 2166|       |
 2167|       |        // Calculate total length
 2168|      1|        let mut total_len = 0;
 2169|      1|        for (i, token) in tokens.iter().enumerate() {
 2170|      1|            total_len += token.length as usize;
 2171|      1|            if i > 0 {
 2172|      0|                total_len += 1; // For the space separator
 2173|      1|            }
 2174|       |        }
 2175|       |
 2176|       |        // Allocate and build the string
 2177|      1|        let mut result = String::with_capacity(total_len);
 2178|      1|        for (i, token) in tokens.iter().enumerate() {
 2179|      1|            if i > 0 {
 2180|      0|                result.push(' ');
 2181|      1|            }
 2182|      1|            let buffer = self.source_manager.get_buffer(token.location.source_id());
 2183|      1|            let start = token.location.offset() as usize;
 2184|      1|            let end = start + token.length as usize;
 2185|      1|            if end <= buffer.len() {
 2186|      1|                // This is safe because the lexer guarantees tokens are valid UTF-8.
 2187|      1|                let text = unsafe { std::str::from_utf8_unchecked(&buffer[start..end]) };
 2188|      1|                result.push_str(text);
 2189|      1|            }
                          ^0
 2190|       |        }
 2191|       |
 2192|      1|        result
 2193|      1|    }
 2194|       |
 2195|       |    /// Expand a macro if it exists
 2196|  4.05k|    fn expand_macro(&mut self, token: &PPToken) -> Result<Option<Vec<PPToken>>, PPError> {
 2197|  4.05k|        if let PPTokenKind::Identifier(symbol) = token.kind {
 2198|       |            // Check if macro exists and is not disabled
 2199|  4.05k|            let macro_info = match self.macros.get(&symbol) {
                              ^50
 2200|     50|                Some(m) if !m.flags.contains(MacroFlags::DISABLED) => m.clone(),
 2201|  4.00k|                _ => return Ok(None),
 2202|       |            };
 2203|       |
 2204|       |            // For function-like macros, check if followed by '('
 2205|     50|            if macro_info.flags.contains(MacroFlags::FUNCTION_LIKE) {
 2206|     24|                let next = self.lex_token();
 2207|     24|                match next {
 2208|     24|                    Some(t) if t.kind == PPTokenKind::LeftParen => {
                                       ^23                                  ^23
 2209|     23|                        self.pending_tokens.push_front(t);
 2210|     23|                    }
 2211|      1|                    Some(t) => {
 2212|      1|                        self.pending_tokens.push_front(t);
 2213|      1|                        return Ok(None);
 2214|       |                    }
 2215|      0|                    None => return Ok(None),
 2216|       |                }
 2217|     26|            }
 2218|       |
 2219|       |            // Check for recursion
 2220|     49|            if macro_info.flags.contains(MacroFlags::DISABLED) {
 2221|      0|                return Err(PPError::MacroRecursion);
 2222|     49|            }
 2223|       |
 2224|       |            // Mark as used
 2225|     49|            if let Some(m) = self.macros.get_mut(&symbol) {
 2226|     49|                m.flags |= MacroFlags::USED;
 2227|     49|            }
                          ^0
 2228|       |
 2229|       |            // Temporarily disable the macro to prevent infinite recursion
 2230|     49|            if let Some(m) = self.macros.get_mut(&symbol) {
 2231|     49|                m.flags |= MacroFlags::DISABLED;
 2232|     49|            }
                          ^0
 2233|       |
 2234|     49|            let result = if macro_info.flags.contains(MacroFlags::FUNCTION_LIKE) {
 2235|     23|                self.expand_function_macro(&macro_info, &symbol, token)
 2236|       |            } else {
 2237|     26|                self.expand_object_macro(&macro_info, &symbol, token)
 2238|       |            };
 2239|       |
 2240|       |            // Re-enable the macro
 2241|     49|            if let Some(m) = self.macros.get_mut(&symbol) {
 2242|     49|                m.flags.remove(MacroFlags::DISABLED);
 2243|     49|            }
                          ^0
 2244|       |
 2245|     49|            result.map(Some)
 2246|       |        } else {
 2247|      0|            Ok(None)
 2248|       |        }
 2249|  4.05k|    }
 2250|       |
 2251|       |    /// Helper to convert tokens to their string representation
 2252|     58|    fn tokens_to_string(&self, tokens: &[PPToken]) -> String {
 2253|     58|        let mut result = String::new();
 2254|    199|        for token in tokens {
                          ^141
 2255|    141|            result.push_str(token.get_text());
 2256|    141|        }
 2257|     58|        result
 2258|     58|    }
 2259|       |
 2260|       |    /// Expand an object-like macro
 2261|     26|    fn expand_object_macro(
 2262|     26|        &mut self,
 2263|     26|        macro_info: &MacroInfo,
 2264|     26|        symbol: &StringId,
 2265|     26|        token: &PPToken,
 2266|     26|    ) -> Result<Vec<PPToken>, PPError> {
 2267|       |        // For Level B: Create a virtual buffer containing the replacement text
 2268|     26|        let replacement_text = self.tokens_to_string(&macro_info.tokens);
 2269|     26|        let virtual_buffer = replacement_text.into_bytes();
 2270|     26|        let virtual_id = self.source_manager.add_virtual_buffer(
 2271|     26|            virtual_buffer,
 2272|     26|            &format!("macro_{}", symbol.as_str()),
 2273|     26|            Some(token.location),
 2274|       |        );
 2275|       |
 2276|       |        // Create tokens with locations in the virtual buffer
 2277|     26|        let mut expanded = Vec::new();
 2278|     26|        let mut offset = 0u32;
 2279|       |
 2280|     67|        for original_token in &macro_info.tokens {
                          ^41
 2281|     41|            let token_text = original_token.get_text();
 2282|     41|            let token_len = token_text.len() as u16;
 2283|       |
 2284|     41|            let mut is_pasted = false;
 2285|       |            // Check if token came from pasting
 2286|     41|            if let Some(file_info) = self.source_manager.get_file_info(original_token.location.source_id()) {
                                      ^40
 2287|     40|                let path = file_info.path.to_string_lossy();
 2288|     40|                if path == "<<pasted-tokens>>" || path == "<pasted-tokens>" {
 2289|      0|                    is_pasted = true;
 2290|     40|                }
 2291|      1|            }
 2292|       |
 2293|     41|            let new_token = if is_pasted {
 2294|       |                // Keep original location for pasted tokens so they don't inherit recursion history
 2295|      0|                PPToken::new(
 2296|      0|                    original_token.kind,
 2297|      0|                    original_token.flags | PPTokenFlags::MACRO_EXPANDED,
 2298|      0|                    original_token.location,
 2299|      0|                    token_len,
 2300|       |                )
 2301|       |            } else {
 2302|     41|                PPToken::new(
 2303|     41|                    original_token.kind,
 2304|     41|                    original_token.flags | PPTokenFlags::MACRO_EXPANDED,
 2305|     41|                    SourceLoc::new(virtual_id, offset),
 2306|     41|                    token_len,
 2307|       |                )
 2308|       |            };
 2309|       |
 2310|     41|            expanded.push(new_token);
 2311|     41|            offset += token_len as u32;
 2312|       |        }
 2313|       |
 2314|       |        // Recursively expand any macros in the replacement
 2315|     26|        self.expand_tokens(&mut expanded, false)?;
                                                              ^0
 2316|       |
 2317|     26|        Ok(expanded)
 2318|     26|    }
 2319|       |
 2320|       |    /// Expand a function-like macro
 2321|     23|    fn expand_function_macro(
 2322|     23|        &mut self,
 2323|     23|        macro_info: &MacroInfo,
 2324|     23|        symbol: &StringId,
 2325|     23|        token: &PPToken,
 2326|     23|    ) -> Result<Vec<PPToken>, PPError> {
 2327|       |        // Parse arguments from lexer
 2328|     23|        let args = self.parse_macro_args_from_lexer(macro_info)?;
                          ^22                                                ^1
 2329|       |
 2330|       |        // Pre-expand arguments (prescan)
 2331|     22|        let mut expanded_args = Vec::with_capacity(args.len());
 2332|     53|        for arg in &args {
                          ^31
 2333|     31|            let mut arg_clone = arg.clone();
 2334|     31|            self.expand_tokens(&mut arg_clone, false)?;
                                                                   ^0
 2335|     31|            expanded_args.push(arg_clone);
 2336|       |        }
 2337|       |
 2338|       |        // Substitute parameters in macro body
 2339|     22|        let substituted = self.substitute_macro(macro_info, &args, &expanded_args)?;
                                                                                                ^0
 2340|       |
 2341|       |        // For Level B: Create a virtual buffer containing the substituted text
 2342|     22|        let replacement_text = self.tokens_to_string(&substituted);
 2343|     22|        let virtual_buffer = replacement_text.into_bytes();
 2344|     22|        let virtual_id = self.source_manager.add_virtual_buffer(
 2345|     22|            virtual_buffer,
 2346|     22|            &format!("macro_{}", symbol.as_str()),
 2347|     22|            Some(token.location),
 2348|       |        );
 2349|       |
 2350|       |        // Create tokens with locations in the virtual buffer
 2351|     22|        let mut expanded = Vec::new();
 2352|     22|        let mut offset = 0u32;
 2353|       |
 2354|     97|        for original_token in &substituted {
                          ^75
 2355|     75|            let token_text = original_token.get_text();
 2356|     75|            let token_len = token_text.len() as u16;
 2357|       |
 2358|     75|            let mut is_pasted = false;
 2359|       |            // Check if token came from pasting
 2360|     75|            if let Some(file_info) = self.source_manager.get_file_info(original_token.location.source_id()) {
 2361|     75|                let path = file_info.path.to_string_lossy();
 2362|     75|                if path == "<<pasted-tokens>>" || path == "<pasted-tokens>" {
                                                                ^70
 2363|      5|                    is_pasted = true;
 2364|     70|                }
 2365|      0|            }
 2366|       |
 2367|     75|            let new_token = if is_pasted {
 2368|       |                // Keep original location for pasted tokens so they don't inherit recursion history
 2369|      5|                PPToken::new(
 2370|      5|                    original_token.kind,
 2371|      5|                    original_token.flags | PPTokenFlags::MACRO_EXPANDED,
 2372|      5|                    original_token.location,
 2373|      5|                    token_len,
 2374|       |                )
 2375|       |            } else {
 2376|     70|                PPToken::new(
 2377|     70|                    original_token.kind,
 2378|     70|                    original_token.flags | PPTokenFlags::MACRO_EXPANDED,
 2379|     70|                    SourceLoc::new(virtual_id, offset),
 2380|     70|                    token_len,
 2381|       |                )
 2382|       |            };
 2383|       |
 2384|     75|            expanded.push(new_token);
 2385|     75|            offset += token_len as u32;
 2386|       |        }
 2387|       |
 2388|       |        // Recursively expand any macros in the replacement
 2389|     22|        self.expand_tokens(&mut expanded, false)?;
                                                              ^0
 2390|       |
 2391|     22|        Ok(expanded)
 2392|     23|    }
 2393|       |
 2394|       |    /// Parse macro arguments from the current lexer
 2395|     23|    fn parse_macro_args_from_lexer(&mut self, macro_info: &MacroInfo) -> Result<Vec<Vec<PPToken>>, PPError> {
 2396|       |        // Skip whitespace and expect '('
 2397|     23|        let mut found_lparen = false;
 2398|     23|        while let Some(token) = self.lex_token() {
 2399|      0|            match token.kind {
 2400|       |                PPTokenKind::LeftParen => {
 2401|     23|                    found_lparen = true;
 2402|     23|                    break;
 2403|       |                }
 2404|      0|                PPTokenKind::Eof => return Err(PPError::UnexpectedEndOfFile),
 2405|      0|                _ if token.flags.contains(PPTokenFlags::LEADING_SPACE) => continue,
 2406|       |                _ => {
 2407|       |                    // Put back non-whitespace token
 2408|      0|                    self.pending_tokens.push_front(token);
 2409|      0|                    return Err(PPError::InvalidMacroParameter {
 2410|      0|                        span: SourceSpan::new(token.location, token.location),
 2411|      0|                    });
 2412|       |                }
 2413|       |            }
 2414|       |        }
 2415|       |
 2416|     23|        if !found_lparen {
 2417|      0|            return Err(PPError::UnexpectedEndOfFile);
 2418|     23|        }
 2419|       |
 2420|     23|        let mut args = Vec::new();
 2421|     23|        let mut current_arg = Vec::new();
 2422|     23|        let mut paren_depth = 0;
 2423|       |
 2424|     85|        while let Some(token) = self.lex_token() {
 2425|     12|            match token.kind {
 2426|      2|                PPTokenKind::LeftParen => {
 2427|      2|                    paren_depth += 1;
 2428|      2|                    current_arg.push(token);
 2429|      2|                }
 2430|       |                PPTokenKind::RightParen => {
 2431|     25|                    if paren_depth == 0 {
 2432|       |                        // End of arguments
 2433|     23|                        if !current_arg.is_empty() || !args.is_empty() {
                                                                    ^1
 2434|     23|                            args.push(current_arg);
 2435|     23|                        }
                                      ^0
 2436|     23|                        break;
 2437|      2|                    }
 2438|      2|                    paren_depth -= 1;
 2439|      2|                    current_arg.push(token);
 2440|       |                }
 2441|     12|                PPTokenKind::Comma if paren_depth == 0 => {
                                                                   ^10
 2442|     10|                    // Argument separator
 2443|     10|                    args.push(current_arg);
 2444|     10|                    current_arg = Vec::new();
 2445|     10|                }
 2446|     48|                _ => {
 2447|     48|                    current_arg.push(token);
 2448|     48|                }
 2449|       |            }
 2450|       |        }
 2451|       |
 2452|       |        // Validate argument count
 2453|     23|        let expected_args = macro_info.parameter_list.len();
 2454|     23|        let has_variadic = macro_info.variadic_arg.is_some();
 2455|       |
 2456|     23|        if has_variadic {
 2457|      3|            if args.len() < expected_args {
 2458|      0|                return Err(PPError::InvalidMacroParameter {
 2459|      0|                    span: SourceSpan::new(macro_info.location, macro_info.location),
 2460|      0|                });
 2461|      3|            }
 2462|     20|        } else if args.len() != expected_args {
 2463|      1|            return Err(PPError::InvalidMacroParameter {
 2464|      1|                span: SourceSpan::new(macro_info.location, macro_info.location),
 2465|      1|            });
 2466|     19|        }
 2467|       |
 2468|     22|        Ok(args)
 2469|     23|    }
 2470|       |
 2471|       |    /// Substitute parameters in macro body
 2472|     32|    fn substitute_macro(
 2473|     32|        &mut self,
 2474|     32|        macro_info: &MacroInfo,
 2475|     32|        args: &[Vec<PPToken>],
 2476|     32|        expanded_args: &[Vec<PPToken>],
 2477|     32|    ) -> Result<Vec<PPToken>, PPError> {
 2478|     32|        let mut result = Vec::new();
 2479|     32|        let mut i = 0;
 2480|       |
 2481|    136|        while i < macro_info.tokens.len() {
 2482|    104|            let token = &macro_info.tokens[i];
 2483|       |
 2484|    104|            match token.kind {
 2485|       |                PPTokenKind::Hash => {
 2486|       |                    // Stringification operator
 2487|      6|                    if i + 1 < macro_info.tokens.len() {
 2488|      6|                        let next_token = &macro_info.tokens[i + 1];
 2489|      6|                        if let PPTokenKind::Identifier(param_symbol) = next_token.kind {
 2490|      6|                            if let Some(param_index) = macro_info.parameter_list.iter().position(|&p| p == param_symbol)
 2491|       |                            {
 2492|       |                                // Argument is used with #, so use unexpanded tokens
 2493|      6|                                let arg_tokens = &args[param_index];
 2494|      6|                                let stringified = self.stringify_tokens(arg_tokens, token.location)?;
                                                                                                                 ^0
 2495|      6|                                result.push(stringified);
 2496|      6|                                i += 2;
 2497|      6|                                continue;
 2498|      0|                            } else if macro_info.variadic_arg == Some(param_symbol) {
 2499|       |                                // Handle variadic argument
 2500|      0|                                let start_index = macro_info.parameter_list.len();
 2501|      0|                                let variadic_args =
 2502|      0|                                    args.iter().skip(start_index).flatten().cloned().collect::<Vec<_>>();
 2503|      0|                                let stringified = self.stringify_tokens(&variadic_args, token.location)?;
 2504|      0|                                result.push(stringified);
 2505|      0|                                i += 2;
 2506|      0|                                continue;
 2507|      0|                            }
 2508|      0|                        }
 2509|      0|                    }
 2510|      0|                    result.push(*token);
 2511|       |                }
 2512|       |                PPTokenKind::HashHash => {
 2513|       |                    // Token pasting operator
 2514|      9|                    if i + 1 < macro_info.tokens.len() {
 2515|      9|                        let right_token = &macro_info.tokens[i + 1];
 2516|       |
 2517|       |                        // Determine the left operand for pasting
 2518|      9|                        let left_tokens = if !result.is_empty() {
 2519|      9|                            vec![result.pop().unwrap()]
 2520|       |                        } else {
 2521|      0|                            Vec::new()
 2522|       |                        };
 2523|       |
 2524|       |                        // Determine the right operand for pasting
 2525|      9|                        let right_tokens = if let PPTokenKind::Identifier(symbol) = right_token.kind {
 2526|     16|                            if let Some(param_index) = macro_info.parameter_list.iter().position(|&p| p == symbol) {
                                                      ^7             ^9                               ^9
 2527|       |                                // Argument is preceded by ##, so use unexpanded tokens
 2528|      7|                                args[param_index].clone()
 2529|      2|                            } else if macro_info.variadic_arg == Some(symbol) {
 2530|      2|                                let start_index = macro_info.parameter_list.len();
 2531|      2|                                args.iter().skip(start_index).flatten().cloned().collect()
 2532|       |                            } else {
 2533|      0|                                vec![*right_token]
 2534|       |                            }
 2535|       |                        } else {
 2536|      0|                            vec![*right_token]
 2537|       |                        };
 2538|       |
 2539|       |                        // If either side is empty, the ## operator has no effect on that side
 2540|      9|                        if left_tokens.is_empty() && !right_tokens.is_empty() {
                                                                   ^0
 2541|      0|                            result.extend(right_tokens);
 2542|      9|                        } else if !left_tokens.is_empty() && right_tokens.is_empty() {
 2543|       |                            // Check for GNU comma swallowing extension
 2544|       |                            // If ## is between a comma and an empty variadic argument, the comma is removed
 2545|      2|                            let is_comma = left_tokens.len() == 1 && left_tokens[0].kind == PPTokenKind::Comma;
 2546|      2|                            let is_variadic_arg = if let PPTokenKind::Identifier(symbol) = right_token.kind {
 2547|      2|                                macro_info.variadic_arg == Some(symbol)
 2548|       |                            } else {
 2549|      0|                                false
 2550|       |                            };
 2551|       |
 2552|      2|                            if is_comma && is_variadic_arg {
                                                         ^1
 2553|      1|                                // Swallow the comma (don't push left_tokens back)
 2554|      1|                            } else {
 2555|      1|                                result.extend(left_tokens);
 2556|      1|                            }
 2557|      7|                        } else if !left_tokens.is_empty() && !right_tokens.is_empty() {
 2558|       |                            // Both sides have tokens, perform the paste
 2559|      7|                            let pasted = self.paste_tokens(&left_tokens[0], &right_tokens[0])?;
                                                                                                           ^0
 2560|      7|                            result.extend(pasted);
 2561|       |                            // If there are more tokens on the right side, append them
 2562|      7|                            if right_tokens.len() > 1 {
 2563|      0|                                result.extend_from_slice(&right_tokens[1..]);
 2564|      7|                            }
 2565|      0|                        }
 2566|       |
 2567|      9|                        i += 2; // Consume ## and the right-hand token
 2568|      9|                        continue;
 2569|      0|                    }
 2570|       |                    // If ## is at the end of the macro, just push it (though this is invalid)
 2571|      0|                    result.push(*token);
 2572|       |                }
 2573|     43|                PPTokenKind::Identifier(symbol) => {
 2574|       |                    // Parameter substitution
 2575|     50|                    if let Some(param_index) = macro_info.parameter_list.iter().position(|&p| p == symbol) {
                                              ^28            ^43                              ^43
 2576|       |                        // Check if followed by ##
 2577|     28|                        let next_is_hashhash = if i + 1 < macro_info.tokens.len() {
 2578|     23|                            macro_info.tokens[i + 1].kind == PPTokenKind::HashHash
 2579|       |                        } else {
 2580|      5|                            false
 2581|       |                        };
 2582|       |
 2583|     28|                        if next_is_hashhash {
 2584|      7|                            // Argument is followed by ##, use unexpanded tokens
 2585|      7|                            result.extend(args[param_index].clone());
 2586|     21|                        } else {
 2587|     21|                            // Argument is not involved in # or ## (preceding check handled by ## logic), use expanded tokens
 2588|     21|                            result.extend(expanded_args[param_index].clone());
 2589|     21|                        }
 2590|     15|                    } else if macro_info.variadic_arg == Some(symbol) {
 2591|       |                        // Handle variadic argument
 2592|      1|                        let start_index = macro_info.parameter_list.len();
 2593|       |
 2594|       |                        // Check if followed by ##
 2595|      1|                        let next_is_hashhash = if i + 1 < macro_info.tokens.len() {
 2596|      1|                            macro_info.tokens[i + 1].kind == PPTokenKind::HashHash
 2597|       |                        } else {
 2598|      0|                            false
 2599|       |                        };
 2600|       |
 2601|       |                        // Decide which args to use (unexpanded or expanded)
 2602|       |                        // Note: For variadic, we need to collect slices of args
 2603|      1|                        let source_args = if next_is_hashhash { args } else { expanded_args };
                                                                              ^0
 2604|       |
 2605|      1|                        let mut first = true;
 2606|      1|                        for arg in source_args.iter().skip(start_index) {
 2607|      1|                            if !first {
 2608|      0|                                result.push(PPToken::new(
 2609|      0|                                    PPTokenKind::Comma,
 2610|      0|                                    PPTokenFlags::empty(),
 2611|      0|                                    token.location,
 2612|      0|                                    1,
 2613|      0|                                ));
 2614|      1|                            }
 2615|      1|                            result.extend(arg.clone());
 2616|      1|                            first = false;
 2617|       |                        }
 2618|     14|                    } else {
 2619|     14|                        result.push(*token);
 2620|     14|                    }
 2621|       |                }
 2622|     46|                _ => {
 2623|     46|                    result.push(*token);
 2624|     46|                }
 2625|       |            }
 2626|     89|            i += 1;
 2627|       |        }
 2628|       |
 2629|     32|        Ok(result)
 2630|     32|    }
 2631|       |
 2632|       |    /// Stringify tokens for # operator
 2633|      6|    fn stringify_tokens(&self, tokens: &[PPToken], location: SourceLoc) -> Result<PPToken, PPError> {
 2634|      6|        let mut result = String::new();
 2635|      6|        result.push('"');
 2636|       |
 2637|     15|        for (i, token) in tokens.iter().enumerate() {
                                        ^6     ^6     ^6
 2638|     15|            if i > 0 && token.flags.contains(PPTokenFlags::LEADING_SPACE) {
                                      ^9          ^9
 2639|      3|                // Add space between tokens only if the token had leading whitespace (C11 6.10.3.2)
 2640|      3|                result.push(' ');
 2641|     12|            }
 2642|       |
 2643|       |            // Get token text from source manager
 2644|     15|            let buffer = self.source_manager.get_buffer(token.location.source_id());
 2645|     15|            let start = token.location.offset() as usize;
 2646|     15|            let end = start + token.length as usize;
 2647|     15|            if end <= buffer.len() {
 2648|     15|                let text = unsafe { std::str::from_utf8_unchecked(&buffer[start..end]) };
 2649|       |                // Escape quotes and backslashes in the text
 2650|     29|                for ch in text.chars() {
                                        ^15  ^15
 2651|     29|                    match ch {
 2652|      0|                        '"' => result.push_str("\\\""),
 2653|      0|                        '\\' => result.push_str("\\\\"),
 2654|     29|                        _ => result.push(ch),
 2655|       |                    }
 2656|       |                }
 2657|       |            } else {
 2658|      0|                return Err(PPError::InvalidStringification);
 2659|       |            }
 2660|       |        }
 2661|       |
 2662|      6|        result.push('"');
 2663|       |
 2664|      6|        Ok(PPToken::new(
 2665|      6|            PPTokenKind::StringLiteral(StringId::new(&result)),
 2666|      6|            PPTokenFlags::empty(),
 2667|      6|            location,
 2668|      6|            result.len() as u16,
 2669|      6|        ))
 2670|      6|    }
 2671|       |
 2672|       |    /// Paste tokens for ## operator
 2673|      7|    fn paste_tokens(&mut self, left: &PPToken, right: &PPToken) -> Result<Vec<PPToken>, PPError> {
 2674|       |        // Get text of both tokens
 2675|      7|        let left_buffer = self.source_manager.get_buffer(left.location.source_id());
 2676|      7|        let left_start = left.location.offset() as usize;
 2677|      7|        let left_end = left_start + left.length as usize;
 2678|      7|        let left_text = if left_end <= left_buffer.len() {
 2679|      7|            unsafe { std::str::from_utf8_unchecked(&left_buffer[left_start..left_end]) }
 2680|       |        } else {
 2681|      0|            return Err(PPError::InvalidTokenPasting);
 2682|       |        };
 2683|       |
 2684|      7|        let right_buffer = self.source_manager.get_buffer(right.location.source_id());
 2685|      7|        let right_start = right.location.offset() as usize;
 2686|      7|        let right_end = right_start + right.length as usize;
 2687|      7|        let right_text = if right_end <= right_buffer.len() {
 2688|      7|            unsafe { std::str::from_utf8_unchecked(&right_buffer[right_start..right_end]) }
 2689|       |        } else {
 2690|      0|            return Err(PPError::InvalidTokenPasting);
 2691|       |        };
 2692|       |
 2693|      7|        let pasted_text = format!("{}{}", left_text, right_text);
 2694|       |
 2695|       |        // Create a virtual buffer containing the pasted text
 2696|      7|        let virtual_buffer = pasted_text.clone().into_bytes();
 2697|      7|        let virtual_id = self
 2698|      7|            .source_manager
 2699|      7|            .add_virtual_buffer(virtual_buffer, "<pasted-tokens>", None);
 2700|       |
 2701|       |        // Create a temporary lexer to lex the pasted text
 2702|      7|        let buffer = self.source_manager.get_buffer(virtual_id);
 2703|      7|        let mut lexer = PPLexer::new(virtual_id, buffer.to_vec());
 2704|       |
 2705|      7|        let mut tokens = Vec::new();
 2706|     15|        while let Some(token) = lexer.next_token() {
                                     ^8
 2707|      8|            if matches!(token.kind, PPTokenKind::Eod | PPTokenKind::Eof) {
 2708|      0|                continue;
 2709|      8|            }
 2710|      8|            tokens.push(token);
 2711|       |        }
 2712|       |
 2713|       |        // If the result is not a valid preprocessing token, the behavior is undefined.
 2714|       |        // We will return whatever tokens we got.
 2715|      7|        Ok(tokens)
 2716|      7|    }
 2717|       |
 2718|       |    /// Expand tokens by rescanning for further macro expansion
 2719|    128|    fn expand_tokens(&mut self, tokens: &mut Vec<PPToken>, in_conditional: bool) -> Result<(), PPError> {
 2720|    128|        let mut i = 0;
 2721|    128|        let max_expansions = 10000; // Safety limit to prevent infinite recursion
 2722|       |
 2723|    399|        while i < tokens.len() {
 2724|    271|            let token = &tokens[i];
 2725|     68|            match &token.kind {
 2726|     72|                PPTokenKind::Identifier(symbol) if symbol.as_str() == "__LINE__" => {
                                                                                             ^0
 2727|      0|                    let line = if let Some(presumed) = self.source_manager.get_presumed_location(token.location) {
 2728|      0|                        presumed.0
 2729|       |                    } else {
 2730|      0|                        1
 2731|       |                    };
 2732|      0|                    let line_str = line.to_string();
 2733|      0|                    let line_symbol = StringId::new(&line_str);
 2734|      0|                    let number_token = PPToken::new(
 2735|      0|                        PPTokenKind::Number(line_symbol),
 2736|      0|                        PPTokenFlags::empty(),
 2737|      0|                        token.location,
 2738|      0|                        line_str.len() as u16,
 2739|       |                    );
 2740|      0|                    tokens[i] = number_token;
 2741|      0|                    i += 1;
 2742|      0|                    continue;
 2743|       |                }
 2744|     72|                PPTokenKind::Identifier(symbol) if symbol.as_str() == "__COUNTER__" => {
                                                                                                ^4
 2745|      4|                    let val = self.get_next_counter();
 2746|      4|                    let val_str = val.to_string();
 2747|      4|                    let val_symbol = StringId::new(&val_str);
 2748|      4|                    let number_token = PPToken::new(
 2749|      4|                        PPTokenKind::Number(val_symbol),
 2750|      4|                        PPTokenFlags::empty(),
 2751|      4|                        token.location,
 2752|      4|                        val_str.len() as u16,
 2753|       |                    );
 2754|      4|                    tokens[i] = number_token;
 2755|      4|                    i += 1;
 2756|      4|                    continue;
 2757|       |                }
 2758|     68|                PPTokenKind::Identifier(symbol) if symbol.as_str() == "__FILE__" => {
                                                                                             ^0
 2759|      0|                    let filename = if let Some(presumed) = self.source_manager.get_presumed_location(token.location) {
 2760|      0|                        if let Some(name) = presumed.2 {
 2761|      0|                            format!("\"{}\"", name)
 2762|      0|                        } else if let Some(file_info) = self.source_manager.get_file_info(token.location.source_id()) {
 2763|      0|                            format!("\"{}\"", file_info.path.display())
 2764|       |                        } else {
 2765|      0|                            "\"<unknown>\"".to_string()
 2766|       |                        }
 2767|      0|                    } else if let Some(file_info) = self.source_manager.get_file_info(token.location.source_id()) {
 2768|      0|                        format!("\"{}\"", file_info.path.display())
 2769|       |                    } else {
 2770|      0|                        "\"<unknown>\"".to_string()
 2771|       |                    };
 2772|      0|                    let file_symbol = StringId::new(&filename);
 2773|      0|                    let string_token = PPToken::new(
 2774|      0|                        PPTokenKind::StringLiteral(file_symbol),
 2775|      0|                        PPTokenFlags::empty(),
 2776|      0|                        token.location,
 2777|      0|                        filename.len() as u16,
 2778|       |                    );
 2779|      0|                    tokens[i] = string_token;
 2780|      0|                    i += 1;
 2781|      0|                    continue;
 2782|       |                }
 2783|     68|                PPTokenKind::Identifier(symbol) if in_conditional && symbol == &self.directive_keywords.defined => {
                                                                                   ^14                                      ^0
 2784|       |                    // Skip 'defined'
 2785|      0|                    i += 1;
 2786|       |                    // Skip the next token(s) which is the macro name, possibly in parens
 2787|      0|                    if i < tokens.len() {
 2788|      0|                        if tokens[i].kind == PPTokenKind::LeftParen {
 2789|       |                            // defined(MACRO)
 2790|       |                            // Skip until matching RightParen
 2791|      0|                            let mut depth = 1;
 2792|      0|                            i += 1;
 2793|      0|                            while i < tokens.len() && depth > 0 {
 2794|      0|                                match tokens[i].kind {
 2795|      0|                                    PPTokenKind::LeftParen => depth += 1,
 2796|      0|                                    PPTokenKind::RightParen => depth -= 1,
 2797|      0|                                    _ => {}
 2798|       |                                }
 2799|      0|                                i += 1;
 2800|       |                            }
 2801|      0|                        } else {
 2802|      0|                            // defined MACRO
 2803|      0|                            i += 1;
 2804|      0|                        }
 2805|      0|                    }
 2806|      0|                    continue;
 2807|       |                }
 2808|     68|                PPTokenKind::Identifier(symbol) if in_conditional && symbol == &self.directive_keywords.has_include => {
                                                                                   ^14                                          ^7
 2809|       |                    // Skip '__has_include'
 2810|      7|                    i += 1;
 2811|       |                    // Skip arguments... handled similarly to defined, but it MUST have parentheses.
 2812|       |                    // __has_include ( "header" ) or __has_include ( <header> )
 2813|       |                    // Note: arguments are NOT expanded.
 2814|      7|                    if i < tokens.len() && tokens[i].kind == PPTokenKind::LeftParen {
 2815|       |                        // Skip until matching RightParen
 2816|      7|                        let mut depth = 1;
 2817|      7|                        i += 1;
 2818|     39|                        while i < tokens.len() && depth > 0 {
                                                                ^32
 2819|     32|                            match tokens[i].kind {
 2820|      0|                                PPTokenKind::LeftParen => depth += 1,
 2821|      7|                                PPTokenKind::RightParen => depth -= 1,
 2822|     25|                                _ => {}
 2823|       |                            }
 2824|     32|                            i += 1;
 2825|       |                        }
 2826|      0|                    }
 2827|      7|                    continue;
 2828|       |                }
 2829|    260|                _ => {}
 2830|       |            }
 2831|       |
 2832|    260|            let symbol = match tokens[i].kind {
                              ^61
 2833|     61|                PPTokenKind::Identifier(s) => s,
 2834|       |                _ => {
 2835|    199|                    i += 1;
 2836|    199|                    continue;
 2837|       |                }
 2838|       |            };
 2839|       |
 2840|       |            // Check for recursion before expanding
 2841|     61|            if self.is_recursive_expansion(tokens[i].location, symbol.as_str()) {
 2842|      5|                i += 1;
 2843|      5|                continue;
 2844|     56|            }
 2845|       |
 2846|     56|            if let Some(macro_info) = self.macros.get(&symbol).cloned()
                                      ^18
 2847|     18|                && macro_info.flags.contains(MacroFlags::FUNCTION_LIKE)
 2848|     10|                && !macro_info.flags.contains(MacroFlags::DISABLED)
 2849|     10|                && i + 1 < tokens.len()
 2850|     10|                && tokens[i + 1].kind == PPTokenKind::LeftParen
 2851|       |            {
 2852|       |                // Find the end of arguments
 2853|     10|                let mut paren_depth = 0;
 2854|     10|                let mut j = i + 1;
 2855|     10|                let mut end_j = None;
 2856|     51|                while j < tokens.len() {
 2857|     51|                    match tokens[j].kind {
 2858|     13|                        PPTokenKind::LeftParen => paren_depth += 1,
 2859|       |                        PPTokenKind::RightParen => {
 2860|     13|                            paren_depth -= 1;
 2861|     13|                            if paren_depth == 0 {
 2862|     10|                                end_j = Some(j);
 2863|     10|                                break;
 2864|      3|                            }
 2865|       |                        }
 2866|     25|                        _ => {}
 2867|       |                    }
 2868|     41|                    j += 1;
 2869|       |                }
 2870|     10|                if let Some(end_j) = end_j {
 2871|       |                    // Parse arguments using indices
 2872|     10|                    let mut args = Vec::new();
 2873|     10|                    let mut current_arg = Vec::new();
 2874|     10|                    let mut paren_depth = 0;
 2875|     10|                    let mut k = i + 2;
 2876|     41|                    while k < end_j {
 2877|     31|                        match tokens[k].kind {
 2878|      3|                            PPTokenKind::LeftParen => {
 2879|      3|                                paren_depth += 1;
 2880|      3|                                current_arg.push(tokens[k]);
 2881|      3|                            }
 2882|      3|                            PPTokenKind::RightParen => {
 2883|      3|                                paren_depth -= 1;
 2884|      3|                                current_arg.push(tokens[k]);
 2885|      3|                            }
 2886|      6|                            PPTokenKind::Comma if paren_depth == 0 => {
 2887|      6|                                args.push(current_arg);
 2888|      6|                                current_arg = Vec::new();
 2889|      6|                            }
 2890|     19|                            _ => {
 2891|     19|                                current_arg.push(tokens[k]);
 2892|     19|                            }
 2893|       |                        }
 2894|     31|                        k += 1;
 2895|       |                    }
 2896|     10|                    if !current_arg.is_empty() {
 2897|     10|                        args.push(current_arg);
 2898|     10|                    }
                                  ^0
 2899|       |                    // Validate argument count
 2900|     10|                    let expected_args = macro_info.parameter_list.len();
 2901|     10|                    if args.len() != expected_args {
 2902|       |                        // For conditional expressions, just skip problematic macro expansions
 2903|      0|                        i += 1;
 2904|      0|                        continue;
 2905|     10|                    }
 2906|       |                    // Pre-expand arguments (prescan)
 2907|     10|                    let mut expanded_args = Vec::with_capacity(args.len());
 2908|     26|                    for arg in &args {
                                      ^16
 2909|     16|                        let mut arg_clone = arg.clone();
 2910|       |                        // Handle potential error in argument expansion
 2911|     16|                        match self.expand_tokens(&mut arg_clone, in_conditional) {
 2912|     16|                            Ok(_) => expanded_args.push(arg_clone),
 2913|      0|                            Err(_) => expanded_args.push(arg.clone()), // Fallback to unexpanded
 2914|       |                        }
 2915|       |                    }
 2916|       |
 2917|       |                    // Substitute
 2918|     10|                    let substituted = match self.substitute_macro(&macro_info, &args, &expanded_args) {
 2919|     10|                        Ok(substituted) => substituted,
 2920|       |                        Err(_) => {
 2921|       |                            // For conditional expressions, skip problematic substitutions
 2922|      0|                            i += 1;
 2923|      0|                            continue;
 2924|       |                        }
 2925|       |                    };
 2926|       |
 2927|       |                    // Fix: Map substituted tokens to a virtual buffer to prevent leakage of internal locations
 2928|       |                    // (e.g. <pasted-tokens>) into the output stream.
 2929|     10|                    let replacement_text = self.tokens_to_string(&substituted);
 2930|     10|                    let virtual_buffer = replacement_text.into_bytes();
 2931|     10|                    let virtual_id = self.source_manager.add_virtual_buffer(
 2932|     10|                        virtual_buffer,
 2933|     10|                        &format!("macro_{}", symbol.as_str()),
 2934|     10|                        Some(token.location),
 2935|       |                    );
 2936|       |
 2937|     10|                    let mut remapped_tokens = Vec::with_capacity(substituted.len());
 2938|     10|                    let mut offset = 0u32;
 2939|       |
 2940|     35|                    for original_token in &substituted {
                                      ^25
 2941|     25|                        let token_text = original_token.get_text();
 2942|     25|                        let token_len = token_text.len() as u16;
 2943|       |
 2944|     25|                        let mut is_pasted = false;
 2945|       |                        // Check if token came from pasting
 2946|     25|                        if let Some(file_info) = self.source_manager.get_file_info(original_token.location.source_id())
 2947|       |                        {
 2948|     25|                            let path = file_info.path.to_string_lossy();
 2949|     25|                            if path == "<<pasted-tokens>>" || path == "<pasted-tokens>" {
                                                                            ^22
 2950|      3|                                is_pasted = true;
 2951|     22|                            }
 2952|      0|                        }
 2953|       |
 2954|     25|                        let new_token = if is_pasted {
 2955|       |                            // Keep original location for pasted tokens so they don't inherit recursion history
 2956|      3|                            PPToken::new(
 2957|      3|                                original_token.kind,
 2958|      3|                                original_token.flags | PPTokenFlags::MACRO_EXPANDED,
 2959|      3|                                original_token.location,
 2960|      3|                                token_len,
 2961|       |                            )
 2962|       |                        } else {
 2963|     22|                            PPToken::new(
 2964|     22|                                original_token.kind,
 2965|     22|                                original_token.flags | PPTokenFlags::MACRO_EXPANDED,
 2966|     22|                                SourceLoc::new(virtual_id, offset),
 2967|     22|                                token_len,
 2968|       |                            )
 2969|       |                        };
 2970|     25|                        remapped_tokens.push(new_token);
 2971|     25|                        offset += token_len as u32;
 2972|       |                    }
 2973|       |
 2974|       |                    // Use remapped tokens for subsequent processing
 2975|     10|                    let substituted = remapped_tokens;
 2976|       |
 2977|       |                    // Safety check for excessive expansions
 2978|     10|                    let expansion_count = substituted.len();
 2979|     10|                    if expansion_count > max_expansions {
 2980|       |                        // For conditional expressions, skip problematic expansions
 2981|      0|                        i += 1;
 2982|      0|                        continue;
 2983|     10|                    }
 2984|       |
 2985|       |                    // Replace i..end_j+1 with substituted
 2986|     10|                    tokens.splice(i..end_j + 1, substituted);
 2987|       |                    // Mark as used
 2988|     10|                    if let Some(m) = self.macros.get_mut(&symbol) {
 2989|     10|                        m.flags |= MacroFlags::USED;
 2990|     10|                    }
                                  ^0
 2991|       |
 2992|       |                    // We do not recurse on the whole vector here. Instead, we let the loop continue.
 2993|       |                    // The loop will rescan the substituted tokens starting at `i`.
 2994|       |                    // Recursion protection is handled by `is_recursive_expansion` check at the top of the loop.
 2995|     10|                    continue;
 2996|      0|                }
 2997|     46|            }
 2998|       |
 2999|       |            // For object macros
 3000|     46|            if let Some(expanded) = self.expand_macro(&tokens[i]).unwrap_or(None) {
                                      ^8
 3001|      8|                tokens.splice(i..i + 1, expanded);
 3002|      8|                continue;
 3003|     38|            }
 3004|       |
 3005|       |            // Check for _Pragma in the expanded stream
 3006|     38|            if let PPTokenKind::Identifier(symbol) = tokens[i].kind
 3007|     38|                && symbol.as_str() == "_Pragma"
 3008|       |            {
 3009|       |                // Need at least 3 more tokens: ( "string" )
 3010|      1|                if i + 3 < tokens.len()
 3011|      1|                    && tokens[i + 1].kind == PPTokenKind::LeftParen
 3012|      1|                    && matches!(tokens[i + 2].kind, PPTokenKind::StringLiteral(_))
                                     ^0
 3013|      1|                    && tokens[i + 3].kind == PPTokenKind::RightParen
 3014|      1|                    && let PPTokenKind::StringLiteral(sym) = tokens[i + 2].kind
 3015|       |                {
 3016|      1|                    let content = self.destringize(sym.as_str());
 3017|      1|                    self.perform_pragma(&content);
 3018|       |                    // Remove the 4 tokens
 3019|      1|                    tokens.drain(i..i + 4);
 3020|       |                    // Do not increment i, as we removed tokens
 3021|      1|                    continue;
 3022|      0|                }
 3023|     37|            }
 3024|       |
 3025|     37|            i += 1;
 3026|       |        }
 3027|       |
 3028|    128|        Ok(())
 3029|    128|    }
 3030|       |
 3031|       |    /// Skip current directive tokens until EOD
 3032|      8|    fn skip_directive(&mut self) -> Result<(), PPError> {
 3033|     16|        while let Some(token) = self.lex_token() {
 3034|     16|            if token.kind == PPTokenKind::Eod {
 3035|      8|                break;
 3036|      8|            }
 3037|       |        }
 3038|      8|        Ok(())
 3039|      8|    }
 3040|       |
 3041|       |    /// Push a conditional that is lazily skipped (nested in a skipped block)
 3042|      0|    fn push_skipped_conditional(&mut self) {
 3043|       |        // Equivalent to handle_if_directive(false)
 3044|      0|        let info = PPConditionalInfo {
 3045|      0|            was_skipping: self.is_currently_skipping(),
 3046|      0|            found_else: false,
 3047|      0|            found_non_skipping: false, // Condition treated as false
 3048|      0|        };
 3049|      0|        self.conditional_stack.push(info);
 3050|       |        // Force skipping for this level
 3051|      0|        self.set_skipping(true);
 3052|      0|    }
 3053|       |
 3054|       |    /// Check if we should evaluate conditional expression (e.g. for #elif)
 3055|      1|    fn should_evaluate_conditional(&self) -> bool {
 3056|       |        // We should evaluate ONLY if no parent is skipping
 3057|       |        // The current level (which we are about to replace with elif) is at index len()-1.
 3058|       |        // The parent is at index len()-2.
 3059|      1|        if self.conditional_stack.len() > 1 {
 3060|      0|            let parent_index = self.conditional_stack.len() - 2;
 3061|      0|            let parent_skipping = self.conditional_stack[parent_index].was_skipping;
 3062|      0|            if parent_skipping {
 3063|      0|                return false;
 3064|      0|            }
 3065|      1|        }
 3066|       |
 3067|       |        // And if we haven't found a true branch in this level yet
 3068|      1|        if let Some(current) = self.conditional_stack.last() {
 3069|      1|            !current.found_non_skipping
 3070|       |        } else {
 3071|      0|            false
 3072|       |        }
 3073|      1|    }
 3074|       |
 3075|       |    /// Check if expanding this macro would be recursive
 3076|  4.06k|    fn is_recursive_expansion(&self, location: SourceLoc, macro_name: &str) -> bool {
 3077|  4.06k|        let mut current_id = location.source_id();
 3078|  4.06k|        let mut depth = 0;
 3079|       |        const MAX_DEPTH: usize = 100;
 3080|       |
 3081|       |        // println!("Checking recursion for {} starting at {:?}", macro_name, current_id);
 3082|       |
 3083|  4.10k|        while depth < MAX_DEPTH {
 3084|  4.10k|            if let Some(file_info) = self.source_manager.get_file_info(current_id) {
 3085|       |                // println!("  Depth {}: Path {}", depth, file_info.path.display());
 3086|       |
 3087|       |                // Check if this file is a virtual buffer for the macro
 3088|       |                // Virtual buffers for macros are named "<macro_{name}>"
 3089|  4.10k|                let expected_name = format!("<macro_{}>", macro_name);
 3090|  4.10k|                let path_str = file_info.path.to_string_lossy();
 3091|  4.10k|                if path_str == expected_name {
 3092|       |                    // println!("  -> FOUND RECURSION");
 3093|      5|                    return true;
 3094|  4.10k|                }
 3095|       |
 3096|       |                // Move up the include chain
 3097|  4.10k|                if let Some(include_loc) = file_info.include_loc {
                                          ^42
 3098|     42|                    current_id = include_loc.source_id();
 3099|     42|                } else {
 3100|       |                    // Reached top-level file or built-in
 3101|       |                    // println!("  -> Top-level reached");
 3102|  4.06k|                    break;
 3103|       |                }
 3104|       |            } else {
 3105|      0|                break;
 3106|       |            }
 3107|     42|            depth += 1;
 3108|       |        }
 3109|       |
 3110|  4.06k|        false
 3111|  4.06k|    }
 3112|       |}
 3113|       |
 3114|       |#[cfg(test)]
 3115|       |mod tests {
 3116|       |    use super::*;
 3117|       |    use crate::diagnostic::DiagnosticEngine;
 3118|       |    use crate::source_manager::SourceManager;
 3119|       |
 3120|     18|    fn create_dummy_preprocessor<'a>(sm: &'a mut SourceManager, diag: &'a mut DiagnosticEngine) -> Preprocessor<'a> {
 3121|     18|        let config = PPConfig::default();
 3122|     18|        Preprocessor::new(sm, diag, &config)
 3123|     18|    }
 3124|       |
 3125|       |    #[test]
 3126|     18|    fn test_header_search_resolution() {
 3127|       |        use std::fs::File;
 3128|       |
 3129|       |        // Create temporary directories for search paths
 3130|     18|        let temp_dir = tempfile::tempdir().unwrap();
 3131|     18|        let system_dir = temp_dir.path().join("system");
 3132|     18|        let angled_dir = temp_dir.path().join("angled");
 3133|     18|        let framework_dir = temp_dir.path().join("framework");
 3134|     18|        let local_dir = temp_dir.path().join("local");
 3135|       |
 3136|     18|        std::fs::create_dir(&system_dir).unwrap();
 3137|     18|        std::fs::create_dir(&angled_dir).unwrap();
 3138|     18|        std::fs::create_dir(&framework_dir).unwrap();
 3139|     18|        std::fs::create_dir(&local_dir).unwrap();
 3140|       |
 3141|       |        // Create dummy headers
 3142|     18|        File::create(system_dir.join("sys.h")).unwrap();
 3143|     18|        File::create(angled_dir.join("ang.h")).unwrap();
 3144|     18|        File::create(framework_dir.join("frm.h")).unwrap();
 3145|     18|        File::create(local_dir.join("loc.h")).unwrap();
 3146|       |
 3147|     18|        let mut search = HeaderSearch {
 3148|     18|            system_path: Vec::new(),
 3149|     18|            framework_path: Vec::new(),
 3150|     18|            quoted_includes: Vec::new(),
 3151|     18|            angled_includes: Vec::new(),
 3152|     18|        };
 3153|       |
 3154|     18|        search.add_system_path(system_dir.clone());
 3155|     18|        search.add_angled_path(angled_dir.clone());
 3156|     18|        search.add_framework_path(framework_dir.clone());
 3157|       |
 3158|       |        // Test angled includes (<header.h>)
 3159|       |        // Should find in angled_path
 3160|     18|        let resolved = search.resolve_path("ang.h", true, &local_dir);
 3161|     18|        assert_eq!(resolved.unwrap(), angled_dir.join("ang.h"));
 3162|       |
 3163|       |        // Should find in system_path
 3164|     18|        let resolved = search.resolve_path("sys.h", true, &local_dir);
 3165|     18|        assert_eq!(resolved.unwrap(), system_dir.join("sys.h"));
 3166|       |
 3167|       |        // Should find in framework_path
 3168|     18|        let resolved = search.resolve_path("frm.h", true, &local_dir);
 3169|     18|        assert_eq!(resolved.unwrap(), framework_dir.join("frm.h"));
 3170|       |
 3171|       |        // Should NOT find local header for angled include (unless in search path)
 3172|     18|        let resolved = search.resolve_path("loc.h", true, &local_dir);
 3173|     18|        assert!(resolved.is_none());
 3174|       |
 3175|       |        // Test quoted includes ("header.h")
 3176|       |        // Should find in current dir first
 3177|     18|        let resolved = search.resolve_path("loc.h", false, &local_dir);
 3178|     18|        assert_eq!(resolved.unwrap(), local_dir.join("loc.h"));
 3179|       |
 3180|       |        // Should fallback to system/angled/framework
 3181|     18|        let resolved = search.resolve_path("sys.h", false, &local_dir);
 3182|     18|        assert_eq!(resolved.unwrap(), system_dir.join("sys.h"));
 3183|     18|    }
 3184|       |
 3185|       |    #[test]
 3186|     18|    fn test_destringize() {
 3187|     18|        let mut sm = SourceManager::new();
 3188|     18|        let mut diag = DiagnosticEngine::new();
 3189|     18|        let pp = create_dummy_preprocessor(&mut sm, &mut diag);
 3190|       |
 3191|       |        // Test case 1: No escape sequences
 3192|     18|        assert_eq!(pp.destringize("\"hello\""), "hello");
 3193|       |
 3194|       |        // Test case 2: Simple escape sequences
 3195|     18|        assert_eq!(pp.destringize("\"a\\nb\\tc\\r\\\\d\\\'e\\\"f\""), "a\nb\tc\r\\d\'e\"f");
 3196|       |
 3197|       |        // Test case 3: Octal escapes
 3198|     18|        assert_eq!(pp.destringize("\"\\123\""), "S");
 3199|     18|        assert_eq!(pp.destringize("\"\\0\""), "\0");
 3200|     18|        assert_eq!(pp.destringize("\"\\7\""), "\x07");
 3201|     18|        assert_eq!(pp.destringize("\"a\\123b\""), "aSb");
 3202|       |
 3203|       |        // Test case 4: Hexadecimal escapes
 3204|     18|        assert_eq!(pp.destringize("\"\\x41\""), "A");
 3205|     18|        assert_eq!(pp.destringize("\"\\x1b\""), "\x1b");
 3206|     18|        assert_eq!(pp.destringize("\"a\\x41g\""), "aAg");
 3207|     18|        assert_eq!(pp.destringize("\"\\x0a\""), "\n");
 3208|       |
 3209|       |        // Test case 5: Mixed and complex cases
 3210|     18|        assert_eq!(pp.destringize("\"a\\\\\\\"b\\tc\\123d\\x41g\""), "a\\\"b\tcSdAg");
 3211|       |
 3212|       |        // Test case 6: Empty string
 3213|     18|        assert_eq!(pp.destringize("\"\""), "");
 3214|     18|    }
 3215|       |}

/app/src/semantic/analyzer.rs:
    1|       |use crate::{
    2|       |    ast::{nodes::*, *},
    3|       |    diagnostic::{DiagnosticEngine, SemanticError},
    4|       |    semantic::{
    5|       |        ArraySizeType, QualType, StructMember, SymbolKind, SymbolTable, TypeKind, TypeQualifiers, TypeRef,
    6|       |        TypeRegistry,
    7|       |        conversions::{integer_promotion, usual_arithmetic_conversions},
    8|       |    },
    9|       |};
   10|       |
   11|       |use smallvec::SmallVec;
   12|       |use std::collections::HashSet;
   13|       |
   14|       |/// Side table containing semantic information for AST nodes.
   15|       |/// Parallel vectors indexed by node index (NodeRef.index()).
   16|       |#[derive(Debug, Clone)]
   17|       |pub struct SemanticInfo {
   18|       |    pub types: Vec<Option<QualType>>,
   19|       |    pub conversions: Vec<SmallVec<[ImplicitConversion; 1]>>,
   20|       |    pub value_categories: Vec<ValueCategory>,
   21|       |}
   22|       |
   23|       |impl SemanticInfo {
   24|    137|    pub(crate) fn with_capacity(n: usize) -> Self {
   25|    137|        Self {
   26|    137|            types: vec![None; n],
   27|    137|            conversions: vec![SmallVec::new(); n],
   28|    137|            value_categories: vec![ValueCategory::RValue; n],
   29|    137|        }
   30|    137|    }
   31|       |}
   32|       |
   33|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   34|       |pub enum ValueCategory {
   35|       |    LValue,
   36|       |    RValue,
   37|       |}
   38|       |
   39|       |#[derive(Debug, Clone, PartialEq, Eq)]
   40|       |pub enum ImplicitConversion {
   41|       |    /// LValue  RValue
   42|       |    LValueToRValue,
   43|       |
   44|       |    /// Array/function  pointer
   45|       |    PointerDecay { to: TypeRef },
   46|       |
   47|       |    /// char/short  int (store types as TypeRef)
   48|       |    IntegerPromotion { from: TypeRef, to: TypeRef },
   49|       |
   50|       |    /// int  long, unsigned  unsigned long, etc
   51|       |    IntegerCast { from: TypeRef, to: TypeRef },
   52|       |
   53|       |    /// void*  T*
   54|       |    PointerCast { from: TypeRef, to: TypeRef },
   55|       |
   56|       |    /// add/remove const/volatile
   57|       |    QualifierAdjust { from: TypeQualifiers, to: TypeQualifiers },
   58|       |
   59|       |    /// 0 / NULL  T*
   60|       |    NullPointerConstant,
   61|       |}
   62|       |
   63|       |/// Run Semantic Analyzer in our AST and return analysist result in SemanticInfo
   64|       |/// which contains resolved type, conversion table, and value category
   65|    137|pub(crate) fn run_semantic_analyzer(
   66|    137|    ast: &Ast,
   67|    137|    diag: &mut DiagnosticEngine,
   68|    137|    symbol_table: &SymbolTable,
   69|    137|    registry: &mut TypeRegistry,
   70|    137|) -> SemanticInfo {
   71|    137|    let mut semantic_info = SemanticInfo::with_capacity(ast.kinds.len());
   72|    137|    let mut resolver = SemanticAnalyzer {
   73|    137|        ast,
   74|    137|        diag,
   75|    137|        symbol_table,
   76|    137|        registry,
   77|    137|        semantic_info: &mut semantic_info,
   78|    137|        current_function_ret_type: None,
   79|    137|        current_function_name: None,
   80|    137|        current_function_is_noreturn: false,
   81|    137|        deferred_checks: Vec::new(),
   82|    137|        switch_depth: 0,
   83|    137|        switch_cases: Vec::new(),
   84|    137|        switch_default_seen: Vec::new(),
   85|    137|        checked_types: HashSet::new(),
   86|    137|    };
   87|    137|    let root = ast.get_root();
   88|    137|    resolver.visit_node(root);
   89|    137|    resolver.process_deferred_checks();
   90|    137|    semantic_info
   91|    137|}
   92|       |
   93|       |enum DeferredCheck {
   94|       |    StaticAssert(NodeRef),
   95|       |}
   96|       |
   97|       |struct SemanticAnalyzer<'a> {
   98|       |    ast: &'a Ast,
   99|       |    diag: &'a mut DiagnosticEngine,
  100|       |    symbol_table: &'a SymbolTable,
  101|       |    registry: &'a mut TypeRegistry,
  102|       |    semantic_info: &'a mut SemanticInfo,
  103|       |    current_function_ret_type: Option<QualType>,
  104|       |    current_function_name: Option<String>,
  105|       |    current_function_is_noreturn: bool,
  106|       |    deferred_checks: Vec<DeferredCheck>,
  107|       |    switch_depth: usize,
  108|       |    switch_cases: Vec<HashSet<i64>>,
  109|       |    switch_default_seen: Vec<bool>,
  110|       |    checked_types: HashSet<TypeRef>,
  111|       |}
  112|       |
  113|       |impl<'a> SemanticAnalyzer<'a> {
  114|     47|    fn report_error(&mut self, error: SemanticError) {
  115|     47|        self.diag.report(error);
  116|     47|    }
  117|       |
  118|       |    /// Recursively visit type to find any expressions (e.g. VLA sizes) and resolve them.
  119|    283|    fn visit_type_expressions(&mut self, qt: QualType) {
  120|    283|        let ty = qt.ty();
  121|    283|        if self.checked_types.contains(&ty) {
  122|     63|            return;
  123|    220|        }
  124|    220|        self.checked_types.insert(ty);
  125|       |
  126|       |        // To avoid infinite recursion on recursive types (e.g. struct A { struct A *next; }),
  127|       |        // we rely on checked_types.
  128|       |        // Note: We need to clone the kind to avoid borrowing self.registry while calling self methods
  129|    220|        let kind = self.registry.get(ty).kind.clone();
  130|       |
  131|    220|        match kind {
  132|     18|            TypeKind::Array { element_type, size } => {
  133|     18|                if let ArraySizeType::Variable(expr) = size {
                                                             ^2
  134|      2|                    self.visit_node(expr);
  135|     16|                }
  136|     18|                self.visit_type_expressions(QualType::unqualified(element_type));
  137|       |            }
  138|     35|            TypeKind::Pointer { pointee } => {
  139|     35|                self.visit_type_expressions(pointee);
  140|     35|            }
  141|       |            TypeKind::Function {
  142|      9|                return_type,
  143|      9|                parameters,
  144|       |                ..
  145|       |            } => {
  146|      9|                self.visit_type_expressions(QualType::unqualified(return_type));
  147|     17|                for param in parameters {
                                  ^8
  148|      8|                    self.visit_type_expressions(param.param_type);
  149|      8|                }
  150|       |            }
  151|      0|            TypeKind::Complex { base_type } => {
  152|      0|                self.visit_type_expressions(QualType::unqualified(base_type));
  153|      0|            }
  154|       |            // For Records and Enums, we don't need to traverse members because
  155|       |            // they cannot contain VLAs (C11 6.7.2.1).
  156|       |            // Even if they did, the members would be visited during their declaration processing.
  157|    158|            _ => {}
  158|       |        }
  159|    283|    }
  160|       |
  161|      4|    fn can_fall_through(&self, node_ref: NodeRef) -> bool {
  162|      4|        match self.ast.get_kind(node_ref) {
  163|      2|            NodeKind::Return(_) | NodeKind::Break | NodeKind::Continue | NodeKind::Goto(_, _) => false,
  164|      0|            NodeKind::If(if_stmt) => {
  165|      0|                let then_ft = self.can_fall_through(if_stmt.then_branch);
  166|      0|                let else_ft = if_stmt.else_branch.is_none_or(|e| self.can_fall_through(e));
  167|      0|                then_ft || else_ft
  168|       |            }
  169|      0|            NodeKind::ExpressionStatement(Some(expr_ref)) => {
  170|      0|                if let NodeKind::FunctionCall(call) = self.ast.get_kind(*expr_ref)
  171|      0|                    && let Some(callee_type) = self.semantic_info.types[call.callee.index()]
  172|      0|                    && let TypeKind::Function { is_noreturn, .. } = &self.registry.get(callee_type.ty()).kind
  173|       |                {
  174|      0|                    return !*is_noreturn;
  175|      0|                }
  176|      0|                true
  177|       |            }
  178|       |            NodeKind::While(_) => {
  179|       |                // While loop can only be exited via break, so it can fall through.
  180|      0|                true
  181|       |            }
  182|      0|            NodeKind::For(for_stmt) => {
  183|       |                // A for loop without a condition is infinite unless there's a break.
  184|      0|                for_stmt.condition.is_some()
  185|       |            }
  186|      2|            NodeKind::CompoundStatement(cs) => {
  187|      2|                if cs.stmt_len > 0 {
  188|      2|                    let last_item_idx = cs.stmt_start.get() + (cs.stmt_len - 1) as u32;
  189|      2|                    let last_item_ref = NodeRef::new(last_item_idx).unwrap();
  190|      2|                    self.can_fall_through(last_item_ref)
  191|       |                } else {
  192|      0|                    true
  193|       |                }
  194|       |            }
  195|      0|            _ => true,
  196|       |        }
  197|      4|    }
  198|       |
  199|  1.35k|    fn is_lvalue(&self, node_ref: NodeRef) -> bool {
  200|  1.35k|        let node_kind = self.ast.get_kind(node_ref);
  201|    426|        match node_kind {
  202|    376|            NodeKind::Ident(_, symbol_ref) => {
  203|    376|                let symbol = self.symbol_table.get_symbol(*symbol_ref);
  204|    376|                matches!(symbol.kind, SymbolKind::Variable { .. } | SymbolKind::Function { .. })
                              ^2
  205|       |            }
  206|     47|            NodeKind::UnaryOp(op, _) => matches!(*op, UnaryOp::Deref),
                                                      ^38
  207|     28|            NodeKind::IndexAccess(..) => true,
  208|     74|            NodeKind::MemberAccess(obj_ref, _, is_arrow) => *is_arrow || self.is_lvalue(*obj_ref),
                                                                                       ^60  ^60       ^60
  209|     15|            NodeKind::Literal(literal::Literal::String(_)) => true,
  210|      0|            NodeKind::CompoundLiteral(..) => true,
  211|    816|            _ => false,
  212|       |        }
  213|  1.35k|    }
  214|       |
  215|     80|    fn is_null_pointer_constant(&self, node_ref: NodeRef) -> bool {
  216|     80|        let node_kind = self.ast.get_kind(node_ref);
  217|     24|        match node_kind {
  218|     14|            NodeKind::Literal(literal::Literal::Int { val: 0, .. }) => true,
  219|      4|            NodeKind::Cast(ty, inner) if ty.ty() == self.registry.type_void_ptr => {
  220|      4|                self.is_null_pointer_constant(*inner)
  221|       |            }
  222|     62|            _ => false,
  223|       |        }
  224|     80|    }
  225|       |
  226|       |    /// Checks if the node is an LValue and is not const-qualified.
  227|       |    /// Reports errors if check fails.
  228|     89|    fn check_lvalue_and_modifiable(&mut self, node_ref: NodeRef, ty: QualType, span: SourceSpan) -> bool {
  229|     89|        if !self.is_lvalue(node_ref) {
  230|      7|            self.report_error(SemanticError::NotAnLvalue { span });
  231|      7|            false
  232|     82|        } else if self.registry.is_const_recursive(ty) {
  233|      8|            self.report_error(SemanticError::AssignmentToReadOnly { span });
  234|      8|            false
  235|       |        } else {
  236|     74|            true
  237|       |        }
  238|     89|    }
  239|       |
  240|       |    /// Validates assignment constraints and records implicit conversions.
  241|       |    /// Returns true if assignment is valid, false otherwise.
  242|     60|    fn validate_and_record_assignment(
  243|     60|        &mut self,
  244|     60|        lhs_ty: QualType,
  245|     60|        rhs_ty: QualType,
  246|     60|        rhs_ref: NodeRef,
  247|     60|        span: SourceSpan,
  248|     60|    ) -> bool {
  249|     60|        if self.check_assignment_constraints(lhs_ty, rhs_ty, rhs_ref) {
  250|     52|            self.record_implicit_conversions(lhs_ty, rhs_ty, rhs_ref);
  251|     52|            true
  252|       |        } else {
  253|      8|            let lhs_kind = &self.registry.get(lhs_ty.ty()).kind;
  254|      8|            let rhs_kind = &self.registry.get(rhs_ty.ty()).kind;
  255|      8|            self.report_error(SemanticError::TypeMismatch {
  256|      8|                expected: lhs_kind.to_string(),
  257|      8|                found: rhs_kind.to_string(),
  258|      8|                span,
  259|      8|            });
  260|      8|            false
  261|       |        }
  262|     60|    }
  263|       |
  264|     41|    fn check_scalar_condition(&mut self, condition: NodeRef) {
  265|     41|        if let Some(cond_ty) = self.visit_node(condition)
  266|     41|            && !cond_ty.is_scalar()
  267|      0|        {
  268|      0|            // report error
  269|     41|        }
  270|     41|    }
  271|       |
  272|     39|    fn visit_if_statement(&mut self, stmt: &IfStmt) {
  273|     39|        self.check_scalar_condition(stmt.condition);
  274|     39|        self.visit_node(stmt.then_branch);
  275|     39|        if let Some(else_branch) = stmt.else_branch {
                                  ^1
  276|      1|            self.visit_node(else_branch);
  277|     38|        }
  278|     39|    }
  279|       |
  280|      1|    fn visit_while_statement(&mut self, stmt: &WhileStmt) {
  281|      1|        self.check_scalar_condition(stmt.condition);
  282|      1|        self.visit_node(stmt.body);
  283|      1|    }
  284|       |
  285|      1|    fn visit_for_statement(&mut self, stmt: &ForStmt) {
  286|      1|        if let Some(init) = stmt.init {
                                  ^0
  287|      0|            self.visit_node(init);
  288|      1|        }
  289|      1|        if let Some(cond) = stmt.condition {
  290|      1|            self.check_scalar_condition(cond);
  291|      1|        }
                      ^0
  292|      1|        if let Some(inc) = stmt.increment {
                                  ^0
  293|      0|            self.visit_node(inc);
  294|      1|        }
  295|      1|        self.visit_node(stmt.body);
  296|      1|    }
  297|       |
  298|    163|    fn visit_return_statement(&mut self, expr: &Option<NodeRef>, _span: SourceSpan) {
  299|    163|        if self.current_function_is_noreturn {
  300|      2|            self.report_error(SemanticError::NoreturnFunctionReturns {
  301|      2|                name: self.current_function_name.clone().unwrap(),
  302|      2|                span: _span,
  303|      2|            });
  304|    161|        }
  305|       |
  306|    163|        let ret_ty = self.current_function_ret_type;
  307|    163|        let is_void_func = ret_ty.is_some_and(|ty| ty.is_void());
  308|    163|        let func_name = self
  309|    163|            .current_function_name
  310|    163|            .clone()
  311|    163|            .unwrap_or_else(|| "<unknown>".to_string());
                                             ^0          ^0
  312|       |
  313|    163|        if let Some(expr_ref) = expr {
                                  ^159
  314|    159|            if is_void_func {
  315|      1|                let err_span = self.ast.get_span(*expr_ref);
  316|      1|                self.report_error(SemanticError::VoidReturnWithValue {
  317|      1|                    name: func_name.clone(),
  318|      1|                    span: err_span,
  319|      1|                });
  320|    158|            }
  321|    159|            if let Some(expr_ty) = self.visit_node(*expr_ref)
  322|    159|                && let Some(target_ty) = ret_ty
  323|    159|            {
  324|    159|                self.record_implicit_conversions(target_ty, expr_ty, *expr_ref);
  325|    159|            }
                          ^0
  326|      4|        } else if !is_void_func {
  327|      0|            self.report_error(SemanticError::NonVoidReturnWithoutValue {
  328|      0|                name: func_name,
  329|      0|                span: _span,
  330|      0|            });
  331|      4|        }
  332|    163|    }
  333|       |
  334|     46|    fn visit_unary_op(&mut self, op: UnaryOp, operand_ref: NodeRef, full_span: SourceSpan) -> Option<QualType> {
  335|     46|        let operand_ty = self.visit_node(operand_ref)?;
                                                                   ^0
  336|       |
  337|     46|        match op {
  338|       |            UnaryOp::AddrOf => {
  339|     22|                if !self.is_lvalue(operand_ref) {
  340|      2|                    self.report_error(SemanticError::NotAnLvalue { span: full_span });
  341|      2|                    return None;
  342|     20|                }
  343|     20|                if operand_ty.is_array() || operand_ty.is_function() {
  344|      1|                    let decayed = self.registry.decay(operand_ty, TypeQualifiers::empty());
  345|      1|                    self.semantic_info.conversions[operand_ref.index()]
  346|      1|                        .push(ImplicitConversion::PointerDecay { to: decayed.ty() });
  347|      1|                    return Some(decayed);
  348|     19|                }
  349|     19|                Some(QualType::unqualified(self.registry.pointer_to(operand_ty)))
  350|       |            }
  351|       |            UnaryOp::Deref => {
  352|      5|                let actual_ty = if operand_ty.is_array() || operand_ty.is_function() {
  353|      0|                    let decayed = self.registry.decay(operand_ty, TypeQualifiers::empty());
  354|      0|                    self.semantic_info.conversions[operand_ref.index()]
  355|      0|                        .push(ImplicitConversion::PointerDecay { to: decayed.ty() });
  356|      0|                    decayed
  357|       |                } else {
  358|      5|                    operand_ty
  359|       |                };
  360|       |
  361|      5|                if actual_ty.is_pointer() {
  362|      5|                    self.registry.get_pointee(actual_ty.ty())
  363|       |                } else {
  364|      0|                    None
  365|       |                }
  366|       |            }
  367|       |            UnaryOp::PreIncrement | UnaryOp::PreDecrement => {
  368|      4|                self.check_lvalue_and_modifiable(operand_ref, operand_ty, full_span);
  369|      4|                if operand_ty.is_scalar() { Some(operand_ty) } else { None }
                                                                                    ^0
  370|       |            }
  371|       |            UnaryOp::Plus | UnaryOp::Minus => {
  372|      9|                if operand_ty.is_scalar() {
  373|       |                    // Strip all qualifiers for unary plus/minus operations
  374|      9|                    let stripped = self.registry.strip_all(operand_ty);
  375|      9|                    if stripped.qualifiers() != operand_ty.qualifiers() {
  376|      0|                        self.semantic_info.conversions[operand_ref.index()].push(ImplicitConversion::QualifierAdjust {
  377|      0|                            from: operand_ty.qualifiers(),
  378|      0|                            to: stripped.qualifiers(),
  379|      0|                        });
  380|      9|                    }
  381|      9|                    Some(stripped)
  382|       |                } else {
  383|      0|                    None
  384|       |                }
  385|       |            }
  386|       |            UnaryOp::LogicNot => {
  387|       |                // Logical NOT always returns bool type
  388|      4|                Some(QualType::unqualified(self.registry.type_bool))
  389|       |            }
  390|       |            UnaryOp::BitNot => {
  391|      2|                if operand_ty.is_integer() {
  392|      1|                    Some(self.apply_and_record_integer_promotion(operand_ref, operand_ty))
  393|       |                } else {
  394|      1|                    let type_kind = &self.registry.get(operand_ty.ty()).kind;
  395|      1|                    self.report_error(SemanticError::InvalidUnaryOperand {
  396|      1|                        ty: type_kind.to_string(),
  397|      1|                        span: full_span,
  398|      1|                    });
  399|      1|                    None
  400|       |                }
  401|       |            }
  402|       |        }
  403|     46|    }
  404|       |
  405|    181|    fn apply_and_record_integer_promotion(&mut self, node_ref: NodeRef, ty: QualType) -> QualType {
  406|    181|        let promoted = integer_promotion(self.registry, ty);
  407|    181|        if promoted.ty() != ty.ty() {
  408|     10|            let idx = node_ref.index();
  409|     10|            self.semantic_info.conversions[idx].push(ImplicitConversion::IntegerPromotion {
  410|     10|                from: ty.ty(),
  411|     10|                to: promoted.ty(),
  412|     10|            });
  413|    171|        }
  414|    181|        promoted
  415|    181|    }
  416|       |
  417|     89|    fn analyze_binary_operation_types(
  418|     89|        &mut self,
  419|     89|        op: BinaryOp,
  420|     89|        lhs_promoted: QualType,
  421|     89|        rhs_promoted: QualType,
  422|     89|        full_span: SourceSpan,
  423|     89|    ) -> Option<(QualType, QualType)> {
  424|     12|        match op {
  425|       |            // Pointer + integer = pointer
  426|     13|            BinaryOp::Add if lhs_promoted.is_pointer() && rhs_promoted.is_integer() => {
                                                                        ^1           ^1         ^1
  427|      1|                Some((lhs_promoted, lhs_promoted))
  428|       |            }
  429|     12|            BinaryOp::Add if lhs_promoted.is_integer() && rhs_promoted.is_pointer() => {
                                                                                                ^0
  430|      0|                Some((rhs_promoted, rhs_promoted))
  431|       |            }
  432|       |
  433|       |            // Pointer - integer = pointer
  434|     11|            BinaryOp::Sub if lhs_promoted.is_pointer() && rhs_promoted.is_integer() => {
                                                                        ^1           ^1         ^1
  435|      1|                Some((lhs_promoted, lhs_promoted))
  436|       |            }
  437|       |
  438|       |            // Pointer - pointer = integer (ptrdiff_t)
  439|     10|            BinaryOp::Sub if lhs_promoted.is_pointer() && rhs_promoted.is_pointer() => {
                                                                        ^0           ^0         ^0
  440|      0|                Some((QualType::unqualified(self.registry.type_int), lhs_promoted))
  441|       |            }
  442|       |
  443|       |            // Pointer/Integer comparisons
  444|       |            BinaryOp::Equal
  445|       |            | BinaryOp::NotEqual
  446|       |            | BinaryOp::Less
  447|       |            | BinaryOp::LessEqual
  448|       |            | BinaryOp::Greater
  449|       |            | BinaryOp::GreaterEqual => {
  450|     53|                let common = if lhs_promoted.is_pointer() && rhs_promoted.is_pointer() {
                                                                           ^3           ^3
  451|      3|                    let lhs_base = self.registry.get_pointee(lhs_promoted.ty()).unwrap();
  452|      3|                    let rhs_base = self.registry.get_pointee(rhs_promoted.ty()).unwrap();
  453|       |
  454|      3|                    if lhs_base.ty() == self.registry.type_void || rhs_base.ty() == self.registry.type_void {
  455|      0|                        QualType::unqualified(self.registry.type_void_ptr)
  456|      3|                    } else if lhs_base == rhs_base {
  457|      2|                        lhs_promoted
  458|       |                    } else {
  459|      1|                        let lhs_str = self.registry.display_type(lhs_promoted.ty());
  460|      1|                        let rhs_str = self.registry.display_type(rhs_promoted.ty());
  461|      1|                        self.report_error(SemanticError::IncompatiblePointerComparison {
  462|      1|                            lhs: lhs_str,
  463|      1|                            rhs: rhs_str,
  464|      1|                            span: full_span,
  465|      1|                        });
  466|      1|                        lhs_promoted
  467|       |                    }
  468|     50|                } else if lhs_promoted.is_pointer() {
  469|      0|                    lhs_promoted
  470|     50|                } else if rhs_promoted.is_pointer() {
  471|      0|                    rhs_promoted
  472|       |                } else {
  473|     50|                    usual_arithmetic_conversions(self.registry, lhs_promoted, rhs_promoted)?
                                                                                                         ^0
  474|       |                };
  475|     53|                Some((QualType::unqualified(self.registry.type_int), common))
  476|       |            }
  477|       |
  478|       |            // Logical operations
  479|       |            BinaryOp::LogicAnd | BinaryOp::LogicOr => {
  480|      7|                Some((QualType::unqualified(self.registry.type_bool), lhs_promoted))
  481|       |            }
  482|       |
  483|       |            // For other operations, use usual arithmetic conversions
  484|       |            _ => {
  485|     27|                let ty = usual_arithmetic_conversions(self.registry, lhs_promoted, rhs_promoted)?;
                                                                                                              ^0
  486|     27|                Some((ty, ty))
  487|       |            }
  488|       |        }
  489|     89|    }
  490|       |
  491|     81|    fn visit_binary_op(
  492|     81|        &mut self,
  493|     81|        op: BinaryOp,
  494|     81|        lhs_ref: NodeRef,
  495|     81|        rhs_ref: NodeRef,
  496|     81|        full_span: SourceSpan,
  497|     81|    ) -> Option<QualType> {
  498|     81|        debug_assert!(
  499|     81|            !op.is_assignment(),
  500|      0|            "visit_binary_op called with assignment operator: {:?}",
  501|       |            op
  502|       |        );
  503|     81|        let lhs_ty = self.visit_node(lhs_ref)?;
                                                           ^0
  504|     81|        let rhs_ty = self.visit_node(rhs_ref)?;
                                                           ^0
  505|       |
  506|       |        // Perform integer promotions and record them
  507|     81|        let lhs_promoted = self.apply_and_record_integer_promotion(lhs_ref, lhs_ty);
  508|     81|        let rhs_promoted = self.apply_and_record_integer_promotion(rhs_ref, rhs_ty);
  509|       |
  510|     81|        if op == BinaryOp::Mod && (!lhs_promoted.is_integer() || !rhs_promoted.is_integer()) {
                                                 ^2                            ^1
  511|      1|            let lhs_kind = &self.registry.get(lhs_promoted.ty()).kind;
  512|      1|            let rhs_kind = &self.registry.get(rhs_promoted.ty()).kind;
  513|      1|            self.report_error(SemanticError::InvalidBinaryOperands {
  514|      1|                left_ty: lhs_kind.to_string(),
  515|      1|                right_ty: rhs_kind.to_string(),
  516|      1|                span: full_span,
  517|      1|            });
  518|      1|            return None;
  519|     80|        }
  520|       |
  521|     80|        let (result_ty, common_ty) = self.analyze_binary_operation_types(op, lhs_promoted, rhs_promoted, full_span)?;
                                                                                                                                 ^0
  522|       |
  523|       |        // For arithmetic/comparison operations, operands should be converted to a common type.
  524|     80|        let lhs_kind = self.ast.get_kind(lhs_ref);
  525|     80|        let rhs_kind = self.ast.get_kind(rhs_ref);
  526|       |
  527|    144|        let is_literal = |kind: &NodeKind| {
                          ^80
  528|     88|            matches!(
  529|     56|                kind,
  530|       |                NodeKind::Literal(literal::Literal::Int { .. })
  531|       |                    | NodeKind::Literal(literal::Literal::Char(_))
  532|       |                    | NodeKind::Literal(literal::Literal::Float(_))
  533|       |            )
  534|    144|        };
  535|       |
  536|     80|        if lhs_promoted.ty() != common_ty.ty() || is_literal(lhs_kind) {
                                                                ^78
  537|     13|            let idx = lhs_ref.index();
  538|     13|            self.semantic_info.conversions[idx].push(ImplicitConversion::IntegerCast {
  539|     13|                from: lhs_promoted.ty(),
  540|     13|                to: common_ty.ty(),
  541|     13|            });
  542|     67|        }
  543|     80|        if rhs_promoted.ty() != common_ty.ty() || is_literal(rhs_kind) {
                                                                ^66
  544|     59|            let idx = rhs_ref.index();
  545|     59|            self.semantic_info.conversions[idx].push(ImplicitConversion::IntegerCast {
  546|     59|                from: rhs_promoted.ty(),
  547|     59|                to: common_ty.ty(),
  548|     59|            });
  549|     59|        }
                      ^21
  550|       |
  551|     80|        Some(result_ty)
  552|     81|    }
  553|       |
  554|     80|    fn visit_assignment(
  555|     80|        &mut self,
  556|     80|        node_ref: NodeRef,
  557|     80|        op: BinaryOp,
  558|     80|        lhs_ref: NodeRef,
  559|     80|        rhs_ref: NodeRef,
  560|     80|        full_span: SourceSpan,
  561|     80|    ) -> Option<QualType> {
  562|     80|        debug_assert!(
  563|     80|            op.is_assignment(),
  564|      0|            "visit_assignment called with non-assignment operator: {:?}",
  565|       |            op
  566|       |        );
  567|       |
  568|     80|        let lhs_ty = self.visit_node(lhs_ref)?;
                          ^79                              ^1
  569|     79|        let rhs_ty = self.visit_node(rhs_ref)?;
                                                           ^0
  570|       |
  571|     79|        if !self.check_lvalue_and_modifiable(lhs_ref, lhs_ty, full_span) {
  572|     10|            return None;
  573|     69|        }
  574|       |
  575|       |        // For compound assignments like +=, we need to check if the underlying arithmetic is valid.
  576|     69|        let (effective_rhs_ty, final_assignment_cast_target) = if let Some(arithmetic_op) = op.without_assignment() {
                                                                                         ^9
  577|       |            // Reuse visit_binary_op logic conceptually, but for compound assignment operands.
  578|       |            // For p += 1, LHS is pointer, RHS is integer.
  579|      9|            let lhs_promoted = self.apply_and_record_integer_promotion(lhs_ref, lhs_ty);
  580|      9|            let rhs_promoted = self.apply_and_record_integer_promotion(rhs_ref, rhs_ty);
  581|       |
  582|      9|            if let Some((_, common_ty)) =
  583|      9|                self.analyze_binary_operation_types(arithmetic_op, lhs_promoted, rhs_promoted, full_span)
  584|       |            {
  585|       |                // Record conversions from promoted operands to the common type.
  586|       |                // This is what the binary operation will actually work with.
  587|      9|                if lhs_promoted.ty() != common_ty.ty() {
  588|      1|                    self.semantic_info.conversions[lhs_ref.index()].push(ImplicitConversion::IntegerCast {
  589|      1|                        from: lhs_promoted.ty(),
  590|      1|                        to: common_ty.ty(),
  591|      1|                    });
  592|      8|                }
  593|      9|                if rhs_promoted.ty() != common_ty.ty() {
  594|      2|                    self.semantic_info.conversions[rhs_ref.index()].push(ImplicitConversion::IntegerCast {
  595|      2|                        from: rhs_promoted.ty(),
  596|      2|                        to: common_ty.ty(),
  597|      2|                    });
  598|      7|                }
  599|       |
  600|       |                // For compound assignment, the result of (lhs op rhs) is converted back to lhs type.
  601|       |                // We record this conversion on the assignment node itself.
  602|      9|                (common_ty, Some(lhs_ty))
  603|       |            } else {
  604|      0|                let lhs_kind = &self.registry.get(lhs_promoted.ty()).kind;
  605|      0|                let rhs_kind = &self.registry.get(rhs_promoted.ty()).kind;
  606|      0|                self.report_error(SemanticError::InvalidBinaryOperands {
  607|      0|                    left_ty: lhs_kind.to_string(),
  608|      0|                    right_ty: rhs_kind.to_string(),
  609|      0|                    span: full_span,
  610|      0|                });
  611|      0|                return None;
  612|       |            }
  613|       |        } else {
  614|     60|            (rhs_ty, None)
  615|       |        };
  616|       |
  617|       |        // For compound assignment, we record the final cast on the assignment node.
  618|     69|        if let Some(target_ty) = final_assignment_cast_target {
                                  ^9
  619|       |            // Check assignment constraints (C11 6.5.16.1)
  620|      9|            if !self.check_assignment_constraints(lhs_ty, effective_rhs_ty, rhs_ref) {
  621|      0|                let lhs_kind = &self.registry.get(lhs_ty.ty()).kind;
  622|      0|                let rhs_kind = &self.registry.get(effective_rhs_ty.ty()).kind;
  623|       |
  624|      0|                self.report_error(SemanticError::TypeMismatch {
  625|      0|                    expected: lhs_kind.to_string(),
  626|      0|                    found: rhs_kind.to_string(),
  627|      0|                    span: full_span,
  628|      0|                });
  629|      0|                return None;
  630|      9|            }
  631|       |
  632|      9|            if target_ty.ty() != effective_rhs_ty.ty() {
  633|      2|                self.semantic_info.conversions[node_ref.index()].push(ImplicitConversion::IntegerCast {
  634|      2|                    from: effective_rhs_ty.ty(),
  635|      2|                    to: target_ty.ty(),
  636|      2|                });
  637|      7|            }
  638|       |        } else {
  639|       |            // Simple assignment
  640|     60|            if !self.validate_and_record_assignment(lhs_ty, effective_rhs_ty, rhs_ref, full_span) {
  641|      8|                return None;
  642|     52|            }
  643|       |        }
  644|       |
  645|     61|        Some(lhs_ty)
  646|     80|    }
  647|       |
  648|    151|    fn check_assignment_constraints(&self, lhs_ty: QualType, rhs_ty: QualType, rhs_ref: NodeRef) -> bool {
  649|       |        // 1. Arithmetic types
  650|    151|        if lhs_ty.is_arithmetic() && rhs_ty.is_arithmetic() {
                                                   ^117   ^117
  651|    112|            return true;
  652|     39|        }
  653|       |
  654|       |        // 2. Structure or Union types
  655|     39|        if lhs_ty.is_record() || rhs_ty.is_record() {
                                               ^36    ^36
  656|      4|            return lhs_ty.is_record() && rhs_ty.is_record() && lhs_ty.ty() == rhs_ty.ty();
                                                       ^3     ^3             ^2
  657|     35|        }
  658|       |
  659|       |        // 3. Pointers
  660|     35|        if lhs_ty.is_pointer() {
  661|     31|            if self.is_null_pointer_constant(rhs_ref) {
  662|      2|                return true;
  663|     29|            }
  664|       |
  665|       |            // Resolve implicit decay for RHS to check compatibility
  666|     29|            let rhs_pointer_base = if rhs_ty.is_array() {
  667|      2|                match &self.registry.get(rhs_ty.ty()).kind {
  668|      2|                    TypeKind::Array { element_type, .. } => Some(*element_type),
  669|      0|                    _ => None,
  670|       |                }
  671|     27|            } else if rhs_ty.is_function() {
  672|      2|                Some(rhs_ty.ty()) // Function decays to pointer
  673|     25|            } else if rhs_ty.is_pointer() {
  674|     24|                self.registry.get_pointee(rhs_ty.ty()).map(|qt| qt.ty())
  675|       |            } else {
  676|      1|                None
  677|       |            };
  678|       |
  679|     29|            if let Some(rhs_base) = rhs_pointer_base {
                                      ^28
  680|       |                // Check compatibility
  681|     28|                let lhs_base = self.registry.get_pointee(lhs_ty.ty()).unwrap();
  682|       |
  683|       |                // void* wildcard
  684|     28|                if lhs_base.ty() == self.registry.type_void || rhs_base == self.registry.type_void {
                                                                             ^24
  685|      5|                    return true;
  686|     23|                }
  687|       |
  688|     23|                return lhs_base.ty() == rhs_base;
  689|      1|            }
  690|       |
  691|      1|            return false;
  692|      4|        }
  693|       |
  694|       |        // 4. _Bool = Pointer
  695|      4|        if lhs_ty.ty() == self.registry.type_bool && (rhs_ty.is_pointer() || rhs_ty.is_array() || rhs_ty.is_function())
                                                                    ^1     ^1              ^0     ^0            ^0     ^0
  696|       |        {
  697|      1|            return true;
  698|      3|        }
  699|       |
  700|      3|        false
  701|    151|    }
  702|       |
  703|    314|    fn record_implicit_conversions(&mut self, lhs_ty: QualType, rhs_ty: QualType, rhs_ref: NodeRef) {
  704|    314|        let idx = rhs_ref.index();
  705|    314|        let mut current_rhs_ty = rhs_ty;
  706|       |
  707|       |        // Null pointer constant conversion (0 or (void*)0 -> T*)
  708|    314|        if lhs_ty.is_pointer() && self.is_null_pointer_constant(rhs_ref) {
                                                ^41  ^41                      ^41
  709|      8|            self.semantic_info.conversions[idx].push(ImplicitConversion::NullPointerConstant);
  710|       |            // If it's still not the same type, we might need a PointerCast after NullPointerConstant desugaring?
  711|       |            // Actually NullPointerConstant desugars to (T*)0 in many cases.
  712|      8|            if lhs_ty.ty() != self.registry.type_void_ptr {
  713|      4|                self.semantic_info.conversions[idx].push(ImplicitConversion::PointerCast {
  714|      4|                    from: self.registry.type_void_ptr,
  715|      4|                    to: lhs_ty.ty(),
  716|      4|                });
  717|      4|            }
  718|      8|            return;
  719|    306|        }
  720|       |
  721|       |        // Array/Function-to-pointer decay
  722|    306|        if lhs_ty.is_pointer() && (current_rhs_ty.is_array() || current_rhs_ty.is_function()) {
                                                 ^33            ^33           ^27            ^27
  723|      8|            let decayed = self.registry.decay(current_rhs_ty, TypeQualifiers::empty());
  724|      8|            self.semantic_info.conversions[idx].push(ImplicitConversion::PointerDecay { to: decayed.ty() });
  725|      8|            current_rhs_ty = decayed; // Update current type for subsequent checks
  726|    298|        }
  727|       |
  728|       |        // Qualifier adjustment
  729|    306|        if lhs_ty.ty() == current_rhs_ty.ty() && lhs_ty.qualifiers() != current_rhs_ty.qualifiers() {
                                                               ^255
  730|     11|            self.semantic_info.conversions[idx].push(ImplicitConversion::QualifierAdjust {
  731|     11|                from: current_rhs_ty.qualifiers(),
  732|     11|                to: lhs_ty.qualifiers(),
  733|     11|            });
  734|    295|        }
  735|       |
  736|       |        // Integer casts
  737|    306|        let is_literal = matches!(
                                       ^95
  738|    306|            self.ast.get_kind(rhs_ref),
  739|       |            NodeKind::Literal(literal::Literal::Int { .. })
  740|       |                | NodeKind::Literal(literal::Literal::Char(_))
  741|       |                | NodeKind::Literal(literal::Literal::Float(_))
  742|       |        );
  743|       |
  744|    306|        if ((lhs_ty.is_arithmetic() && current_rhs_ty.is_arithmetic())
                                                     ^264           ^264
  745|     43|            || (lhs_ty.is_pointer() && current_rhs_ty.is_pointer()))
                                                     ^33            ^33
  746|    296|            && (lhs_ty.ty() != current_rhs_ty.ty() || is_literal)
                                                                    ^250
  747|       |        {
  748|       |            // For pointers, it's pointer cast. For arithmetic, integer/float cast.
  749|    230|            if lhs_ty.is_pointer() && current_rhs_ty.is_pointer() {
                                                    ^8             ^8
  750|      8|                self.semantic_info.conversions[idx].push(ImplicitConversion::PointerCast {
  751|      8|                    from: current_rhs_ty.ty(),
  752|      8|                    to: lhs_ty.ty(),
  753|      8|                });
  754|    222|            } else if lhs_ty.is_arithmetic() && current_rhs_ty.is_arithmetic() {
  755|    222|                self.semantic_info.conversions[idx].push(ImplicitConversion::IntegerCast {
  756|    222|                    from: current_rhs_ty.ty(),
  757|    222|                    to: lhs_ty.ty(),
  758|    222|                });
  759|    222|            }
                          ^0
  760|     76|        }
  761|    314|    }
  762|       |
  763|     82|    fn check_assignment_and_record(&mut self, target_ty: QualType, init_ty: QualType, init_ref: NodeRef) {
  764|     82|        if !self.check_assignment_constraints(target_ty, init_ty, init_ref) {
  765|      1|            let lhs_kind = &self.registry.get(target_ty.ty()).kind;
  766|      1|            let rhs_kind = &self.registry.get(init_ty.ty()).kind;
  767|      1|            let span = self.ast.get_span(init_ref);
  768|      1|
  769|      1|            self.report_error(SemanticError::TypeMismatch {
  770|      1|                expected: lhs_kind.to_string(),
  771|      1|                found: rhs_kind.to_string(),
  772|      1|                span,
  773|      1|            });
  774|     81|        } else {
  775|     81|            self.record_implicit_conversions(target_ty, init_ty, init_ref);
  776|     81|        }
  777|     82|    }
  778|       |
  779|    105|    fn check_initializer(&mut self, init_ref: NodeRef, target_ty: QualType) {
  780|    105|        let node_kind = self.ast.get_kind(init_ref);
  781|     65|        match node_kind {
  782|     16|            NodeKind::InitializerList(list) => {
  783|     16|                self.semantic_info.types[init_ref.index()] = Some(target_ty);
  784|     16|                let list = *list; // Clone to avoid borrow check issues
  785|     16|                self.check_initializer_list(&list, target_ty);
  786|     16|            }
  787|       |            NodeKind::Literal(literal::Literal::String(_)) => {
  788|       |                // Visit to resolve type
  789|      7|                if let Some(init_ty) = self.visit_node(init_ref) {
  790|       |                    // Check if array string init
  791|      7|                    let is_array_string_init = target_ty.is_array() && init_ty.is_array();
  792|      7|                    if is_array_string_init {
  793|       |                        // Check element compatibility
  794|      7|                        let lhs_elem = match &self.registry.get(target_ty.ty()).kind {
  795|      7|                            TypeKind::Array { element_type, .. } => *element_type,
  796|      0|                            _ => unreachable!(),
  797|       |                        };
  798|      7|                        let is_char_type = lhs_elem == self.registry.type_char
  799|      2|                            || lhs_elem == self.registry.type_schar
  800|      1|                            || lhs_elem == self.registry.type_char_unsigned;
  801|       |
  802|      7|                        if is_char_type {
  803|      7|                            self.record_implicit_conversions(target_ty, init_ty, init_ref);
  804|      7|                        } else {
  805|      0|                            let lhs_kind = &self.registry.get(target_ty.ty()).kind;
  806|      0|                            let rhs_kind = &self.registry.get(init_ty.ty()).kind;
  807|      0|                            let span = self.ast.get_span(init_ref);
  808|      0|                            self.report_error(SemanticError::TypeMismatch {
  809|      0|                                expected: lhs_kind.to_string(),
  810|      0|                                found: rhs_kind.to_string(),
  811|      0|                                span,
  812|      0|                            });
  813|      0|                        }
  814|      0|                    } else {
  815|      0|                        // Normal assignment check
  816|      0|                        self.check_assignment_and_record(target_ty, init_ty, init_ref);
  817|      0|                    }
  818|      0|                }
  819|       |            }
  820|       |            _ => {
  821|     82|                if let Some(init_ty) = self.visit_node(init_ref) {
                                          ^81
  822|     81|                    self.check_assignment_and_record(target_ty, init_ty, init_ref);
  823|     81|                }
                              ^1
  824|       |            }
  825|       |        }
  826|    105|    }
  827|       |
  828|     16|    fn check_initializer_list(&mut self, list: &InitializerListData, target_ty: QualType) {
  829|     16|        if target_ty.is_scalar() {
  830|      1|            if list.init_len > 1 {
  831|      1|                let second_idx = list.init_start.get() + 1;
  832|      1|                let second_ref = NodeRef::new(second_idx).unwrap();
  833|      1|                let span = self.ast.get_span(second_ref);
  834|      1|                self.report_error(SemanticError::ExcessElements {
  835|      1|                    kind: "scalar".to_string(),
  836|      1|                    span,
  837|      1|                });
  838|      1|            }
                          ^0
  839|       |
  840|      1|            if list.init_len > 0 {
  841|      1|                let first_item_ref = list.init_start;
  842|      1|                let first_item_kind = self.ast.get_kind(first_item_ref);
  843|       |
  844|      1|                if let NodeKind::InitializerItem(item) = first_item_kind {
  845|      1|                    let expr = item.initializer;
  846|      1|                    if let Some(init_ty) = self.visit_node(expr) {
  847|      1|                        self.check_assignment_and_record(target_ty, init_ty, expr);
  848|      1|                    }
                                  ^0
  849|      0|                } else if let Some(init_ty) = self.visit_node(first_item_ref) {
  850|      0|                    self.check_assignment_and_record(target_ty, init_ty, first_item_ref);
  851|      0|                }
  852|      0|            }
  853|       |
  854|       |            // Visit remaining elements to resolve symbols
  855|      1|            if list.init_len > 1 {
  856|      1|                for i in 1..list.init_len {
  857|      1|                    let item_ref = NodeRef::new(list.init_start.get() + i as u32).unwrap();
  858|      1|                    let item_kind = self.ast.get_kind(item_ref);
  859|      1|                    if let NodeKind::InitializerItem(item) = item_kind {
  860|      1|                        self.visit_node(item.initializer);
  861|      1|                    } else {
  862|      0|                        self.visit_node(item_ref);
  863|      0|                    }
  864|       |                }
  865|      0|            }
  866|      1|            return;
  867|     15|        }
  868|       |
  869|     15|        let target_type = self.registry.get(target_ty.ty()).clone();
  870|     15|        match target_type.kind {
  871|       |            TypeKind::Record { .. } => {
  872|       |                // Flatten members for initialization, handling anonymous structs/unions
  873|      9|                let mut flat_members = Vec::new();
  874|      9|                target_type.flatten_members(self.registry, &mut flat_members);
  875|       |
  876|     21|                for item_ref in list.init_start.range(list.init_len) {
                                              ^9              ^9    ^9
  877|     21|                    self.check_initializer_item_record(item_ref, &flat_members, target_ty);
  878|     21|                }
  879|       |            }
  880|       |            _ => {
  881|       |                // Fallback: just visit children to resolve symbols/types
  882|     14|                for item_ref in list.init_start.range(list.init_len) {
                                              ^6              ^6    ^6
  883|     14|                    let kind = self.ast.get_kind(item_ref);
  884|     14|                    if let NodeKind::InitializerItem(init) = kind {
  885|     14|                        let init = *init;
  886|     14|                        for designator_ref in init.designator_start.range(init.designator_len) {
                                          ^8
  887|      8|                            if let NodeKind::Designator(d) = self.ast.get_kind(designator_ref) {
  888|      8|                                match d {
  889|      8|                                    Designator::ArrayIndex(e) => {
  890|      8|                                        self.visit_node(*e);
  891|      8|                                    }
  892|      0|                                    Designator::GnuArrayRange(s, e) => {
  893|      0|                                        self.visit_node(*s);
  894|      0|                                        self.visit_node(*e);
  895|      0|                                    }
  896|      0|                                    Designator::FieldName(_) => {}
  897|       |                                }
  898|      0|                            }
  899|       |                        }
  900|     14|                        self.visit_node(init.initializer);
  901|      0|                    } else {
  902|      0|                        self.visit_node(item_ref);
  903|      0|                    }
  904|       |                }
  905|       |            }
  906|       |        }
  907|     16|    }
  908|       |
  909|     21|    fn check_initializer_item_record(&mut self, item_ref: NodeRef, members: &[StructMember], record_ty: QualType) {
  910|     21|        let node_kind = self.ast.get_kind(item_ref);
  911|     21|        if let NodeKind::InitializerItem(init) = node_kind {
  912|       |            // 1. Validate designators
  913|     21|            if init.designator_len > 0 {
  914|      9|                let first_des_ref = init.designator_start;
  915|      9|                if let NodeKind::Designator(Designator::FieldName(name)) = self.ast.get_kind(first_des_ref) {
  916|       |                    // Check if member exists
  917|       |                    // TODO: recursive search for anonymous members if not found directly
  918|     13|                    let found = members.iter().any(|m| m.name == Some(*name));
                                      ^9      ^9             ^9
  919|       |
  920|      9|                    if !found {
  921|      1|                        let ty_str = self.registry.display_type(record_ty.ty());
  922|      1|                        let span = self.ast.get_span(first_des_ref);
  923|      1|                        self.report_error(SemanticError::MemberNotFound {
  924|      1|                            name: *name,
  925|      1|                            ty: ty_str,
  926|      1|                            span,
  927|      1|                        });
  928|      8|                    }
  929|      0|                }
  930|     12|            }
  931|       |
  932|       |            // 2. Visit children (initializer and designators)
  933|     21|            for designator_ref in init.designator_start.range(init.designator_len) {
                              ^9
  934|      9|                if let NodeKind::Designator(d) = self.ast.get_kind(designator_ref) {
  935|      9|                    match d {
  936|      0|                        Designator::ArrayIndex(e) => {
  937|      0|                            self.visit_node(*e);
  938|      0|                        }
  939|      0|                        Designator::GnuArrayRange(s, e) => {
  940|      0|                            self.visit_node(*s);
  941|      0|                            self.visit_node(*e);
  942|      0|                        }
  943|      9|                        Designator::FieldName(_) => {}
  944|       |                    }
  945|      0|                }
  946|       |            }
  947|       |            // Visit initializer value
  948|       |            // Ideally we would recurse with correct member type, but for now just visit
  949|     21|            self.visit_node(init.initializer);
  950|      0|        }
  951|     21|    }
  952|       |
  953|     25|    fn visit_function_call(&mut self, call_expr: &crate::ast::nodes::CallExpr) -> Option<QualType> {
  954|     25|        let func_ty = self.visit_node(call_expr.callee)?;
                                                                     ^0
  955|       |
  956|     25|        let func_ty_ref = func_ty.ty();
  957|       |        // Resolve function type (might be pointer to function)
  958|     25|        let actual_func_ty_ref = if func_ty.is_pointer() {
  959|       |            // Check if it's pointer to function
  960|      2|            self.registry
  961|      2|                .get_pointee(func_ty_ref)
  962|      2|                .map(|qt| qt.ty())
  963|      2|                .unwrap_or(func_ty_ref)
  964|       |        } else {
  965|     23|            func_ty_ref
  966|       |        };
  967|       |
  968|       |        // Get function kind
  969|     25|        let func_kind = self.registry.get(actual_func_ty_ref).kind.clone();
  970|       |
  971|     25|        if let TypeKind::Function { .. } = &func_kind {
  972|       |            if let TypeKind::Function {
  973|     24|                parameters,
  974|     24|                is_variadic,
  975|       |                ..
  976|     24|            } = &func_kind
  977|       |            {
  978|     24|                let is_variadic = *is_variadic;
  979|     24|                for (i, arg_node_ref) in call_expr.arg_start.range(call_expr.arg_len).enumerate() {
                                   ^11^11
  980|       |                    // Visit the argument expression directly
  981|     11|                    let arg_ty = self.visit_node(arg_node_ref);
  982|       |
  983|     11|                    if i < parameters.len() {
  984|      7|                        let param_ty = parameters[i].param_type;
  985|      7|                        if let Some(actual_arg_ty) = arg_ty {
  986|      7|                            // Record implicit conversion on the argument node
  987|      7|                            self.record_implicit_conversions(param_ty, actual_arg_ty, arg_node_ref);
  988|      7|                        }
                                      ^0
  989|      4|                    } else if is_variadic {
  990|       |                        // C11 6.5.2.2: "If the expression that denotes the called function has a type that
  991|       |                        // includes a prototype, the arguments are implicitly converted, as if by assignment,
  992|       |                        // to the types of the corresponding parameters... The ellipsis notation in a function
  993|       |                        // prototype declarator causes argument type conversion to stop after the last declared
  994|       |                        // parameter. The default argument promotions are performed on trailing arguments."
  995|      4|                        if let Some(mut actual_arg_ty) = arg_ty {
  996|       |                            // Explicitly handle array/function decay for variadic arguments first
  997|      4|                            if actual_arg_ty.is_array() || actual_arg_ty.is_function() {
                                                                         ^3            ^3
  998|      1|                                let decayed = self.registry.decay(actual_arg_ty, TypeQualifiers::empty());
  999|      1|                                self.semantic_info.conversions[arg_node_ref.index()]
 1000|      1|                                    .push(ImplicitConversion::PointerDecay { to: decayed.ty() });
 1001|      1|                                actual_arg_ty = decayed;
 1002|      3|                            }
 1003|       |
 1004|      4|                            let promoted_ty =
 1005|      4|                                crate::semantic::conversions::default_argument_promotions(self.registry, actual_arg_ty);
 1006|       |
 1007|       |                            // Only record additional conversions if promotion actually changed the type
 1008|       |                            // (Note: record_implicit_conversions handles IntegerCast/PointerCast etc)
 1009|      4|                            if promoted_ty.ty() != actual_arg_ty.ty() {
 1010|      0|                                self.record_implicit_conversions(promoted_ty, actual_arg_ty, arg_node_ref);
 1011|      4|                            }
 1012|      0|                        }
 1013|      0|                    }
 1014|       |                }
 1015|      0|            }
 1016|       |        } else {
 1017|       |            // This is not a function or function pointer, report an error.
 1018|      1|            let ty_str = self.registry.display_type(actual_func_ty_ref);
 1019|      1|            let span = self.ast.get_span(call_expr.callee);
 1020|      1|            self.report_error(SemanticError::CalledNonFunctionType { ty: ty_str, span });
 1021|       |
 1022|       |            // Still visit arguments to catch other potential errors within them.
 1023|      1|            for arg_node_ref in call_expr.arg_start.range(call_expr.arg_len) {
                              ^0
 1024|      0|                self.visit_node(arg_node_ref);
 1025|      0|            }
 1026|      1|            return None; // Return None as the call is invalid
 1027|       |        }
 1028|       |
 1029|     24|        match func_kind {
 1030|     24|            TypeKind::Function { return_type, .. } => Some(QualType::unqualified(return_type)),
 1031|      0|            _ => None,
 1032|       |        }
 1033|     25|    }
 1034|       |
 1035|     50|    fn visit_member_access(
 1036|     50|        &mut self,
 1037|     50|        obj_ref: NodeRef,
 1038|     50|        field_name: NameId,
 1039|     50|        is_arrow: bool,
 1040|     50|        span: SourceSpan,
 1041|     50|    ) -> Option<QualType> {
 1042|     50|        let obj_ty = self.visit_node(obj_ref)?;
                                                           ^0
 1043|       |
 1044|     50|        let record_ty_ref = if is_arrow {
 1045|     14|            self.registry.get_pointee(obj_ty.ty()).map(|qt| qt.ty())?
                                                                                  ^0
 1046|       |        } else {
 1047|     36|            obj_ty.ty()
 1048|       |        };
 1049|       |
 1050|       |        // Ensure layout is computed for the record type
 1051|     50|        let _ = self.registry.ensure_layout(record_ty_ref);
 1052|       |
 1053|       |        // Recursive helper to find member (handling anonymous structs/unions)
 1054|     63|        fn find_member(registry: &TypeRegistry, record_ty: crate::semantic::TypeRef, name: NameId) -> Option<QualType> {
 1055|     63|            if !record_ty.is_record() {
 1056|      0|                return None;
 1057|     63|            }
 1058|       |
 1059|     63|            if let TypeKind::Record { members, .. } = &registry.get(record_ty).kind {
 1060|       |                // 1. Check direct members
 1061|     97|                if let Some(member) = members.iter().find(|m| m.name == Some(name)) {
                                          ^49       ^63            ^63
 1062|     49|                    return Some(member.member_type);
 1063|     14|                }
 1064|       |
 1065|       |                // 2. Check anonymous members
 1066|     31|                for member in members {
                                  ^26
 1067|     26|                    if member.name.is_none() {
 1068|     14|                        let member_ty = member.member_type.ty();
 1069|     14|                        if member_ty.is_record()
 1070|     14|                            && let Some(found_ty) = find_member(registry, member_ty, name)
                                                      ^9
 1071|       |                        {
 1072|      9|                            return Some(found_ty);
 1073|      5|                        }
 1074|     12|                    }
 1075|       |                }
 1076|      0|            }
 1077|      5|            None
 1078|     63|        }
 1079|       |
 1080|     50|        if !record_ty_ref.is_record() {
 1081|      0|            let ty_str = self.registry.get(record_ty_ref).kind.to_string();
 1082|      0|            self.report_error(SemanticError::MemberAccessOnNonRecord { ty: ty_str, span });
 1083|      0|            return None;
 1084|     50|        }
 1085|       |
 1086|       |        // Check if record is complete
 1087|     50|        if let TypeKind::Record { is_complete: false, .. } = &self.registry.get(record_ty_ref).kind {
 1088|      1|            let ty_str = self.registry.get(record_ty_ref).kind.to_string();
 1089|      1|            self.report_error(SemanticError::IncompleteType { ty: ty_str, span });
 1090|      1|            return None;
 1091|     49|        }
 1092|       |
 1093|     49|        if let Some(ty) = find_member(self.registry, record_ty_ref, field_name) {
 1094|     49|            return Some(ty);
 1095|      0|        }
 1096|       |
 1097|      0|        let ty_str = self.registry.get(record_ty_ref).kind.to_string();
 1098|      0|        self.report_error(SemanticError::MemberNotFound {
 1099|      0|            name: field_name,
 1100|      0|            ty: ty_str,
 1101|      0|            span,
 1102|      0|        });
 1103|      0|        None
 1104|     50|    }
 1105|       |
 1106|     20|    fn visit_index_access(&mut self, arr_ref: NodeRef, idx_ref: NodeRef) -> Option<QualType> {
 1107|     20|        self.visit_node(idx_ref);
 1108|     20|        let arr_ty = self.visit_node(arr_ref)?;
                                                           ^0
 1109|       |
 1110|     20|        if arr_ty.is_array() {
 1111|       |            // Ensure layout is computed for array type
 1112|     20|            let _ = self.registry.ensure_layout(arr_ty.ty());
 1113|     20|            match &self.registry.get(arr_ty.ty()).kind {
 1114|     20|                TypeKind::Array { element_type, .. } => Some(QualType::new(*element_type, arr_ty.qualifiers())),
 1115|      0|                _ => unreachable!(),
 1116|       |            }
 1117|       |        } else {
 1118|      0|            self.registry.get_pointee(arr_ty.ty())
 1119|       |        }
 1120|     20|    }
 1121|       |
 1122|    516|    fn visit_declaration_node(&mut self, _node_ref: NodeRef, kind: &NodeKind) -> Option<QualType> {
 1123|    516|        match kind {
 1124|    137|            NodeKind::TranslationUnit(tu_data) => {
 1125|    255|                for decl_ref in tu_data.decl_start.range(tu_data.decl_len) {
                                              ^137               ^137  ^137
 1126|    255|                    self.visit_node(decl_ref);
 1127|    255|                }
 1128|    137|                None
 1129|       |            }
 1130|    157|            NodeKind::Function(data) => {
 1131|    157|                let func_ty = self.registry.get(data.ty).kind.clone();
 1132|    157|                if let TypeKind::Function { return_type, .. } = func_ty {
 1133|    157|                    self.current_function_ret_type = Some(QualType::unqualified(return_type));
 1134|    157|                    self.current_function_is_noreturn = data.is_noreturn;
 1135|    157|                };
                              ^0
 1136|       |
 1137|    157|                let symbol = self.symbol_table.get_symbol(data.symbol);
 1138|    157|                let prev_func_name = self.current_function_name.take();
 1139|    157|                self.current_function_name = Some(symbol.name.to_string());
 1140|       |
 1141|    157|                for param_ref in data.param_start.range(data.param_len) {
                                  ^3
 1142|      3|                    self.visit_node(param_ref);
 1143|      3|                }
 1144|       |
 1145|    157|                self.visit_node(data.body);
 1146|       |
 1147|    157|                if self.current_function_is_noreturn && self.can_fall_through(data.body) {
                                                                      ^2   ^2               ^2
 1148|      0|                    let span = self.ast.get_span(_node_ref);
 1149|      0|                    self.report_error(SemanticError::NoreturnFunctionReturns {
 1150|      0|                        name: self.current_function_name.clone().unwrap(),
 1151|      0|                        span,
 1152|      0|                    });
 1153|    157|                }
 1154|       |
 1155|    157|                self.current_function_ret_type = None;
 1156|    157|                self.current_function_name = prev_func_name;
 1157|    157|                self.current_function_is_noreturn = false;
 1158|    157|                None
 1159|       |            }
 1160|      3|            NodeKind::Param(data) => {
 1161|      3|                self.visit_type_expressions(data.ty);
 1162|      3|                Some(data.ty)
 1163|       |            }
 1164|    177|            NodeKind::VarDecl(data) => {
 1165|    177|                if data.ty.ty() == self.registry.type_void {
 1166|      1|                    let span = self.ast.get_span(_node_ref);
 1167|      1|                    self.report_error(SemanticError::VariableOfVoidType { span });
 1168|    176|                }
 1169|    177|                self.visit_type_expressions(data.ty);
 1170|    177|                let _ = self.registry.ensure_layout(data.ty.ty());
 1171|    177|                if data.init.is_some()
 1172|    104|                    && matches!(data.storage, Some(StorageClass::Extern))
                                              ^1
 1173|      1|                    && self.current_function_name.is_some()
 1174|      1|                {
 1175|      1|                    let span = self.ast.get_span(_node_ref);
 1176|      1|                    self.report_error(SemanticError::InvalidInitializer { span });
 1177|    176|                }
 1178|       |
 1179|    177|                if let Some(init_ref) = data.init {
                                          ^105
 1180|    105|                    self.check_initializer(init_ref, data.ty);
 1181|    105|                }
                              ^72
 1182|    177|                Some(data.ty)
 1183|       |            }
 1184|      0|            NodeKind::EnumConstant(_, value_expr) => {
 1185|      0|                if let Some(expr) = value_expr {
 1186|      0|                    self.visit_node(*expr);
 1187|      0|                }
 1188|      0|                Some(QualType::unqualified(self.registry.type_int))
 1189|       |            }
 1190|     27|            NodeKind::RecordDecl(_) | NodeKind::EnumDecl(_) | NodeKind::EnumMember(_) => None,
 1191|      0|            NodeKind::FieldDecl(data) => {
 1192|      0|                self.visit_type_expressions(data.ty);
 1193|      0|                None
 1194|       |            }
 1195|      8|            NodeKind::TypedefDecl(data) => {
 1196|      8|                self.visit_type_expressions(data.ty);
 1197|      8|                None
 1198|       |            }
 1199|      7|            NodeKind::FunctionDecl(data) => {
 1200|      7|                self.visit_type_expressions(QualType::unqualified(data.ty));
 1201|      7|                let func_type = self.registry.get(data.ty).kind.clone();
 1202|      7|                if let TypeKind::Function { parameters, .. } = func_type {
 1203|     14|                    for param in parameters {
                                      ^7
 1204|      7|                        let _ = self.registry.ensure_layout(param.param_type.ty());
 1205|      7|                    }
 1206|      0|                }
 1207|      7|                None
 1208|       |            }
 1209|      0|            _ => None,
 1210|       |        }
 1211|    516|    }
 1212|       |
 1213|    513|    fn visit_statement_node(&mut self, node_ref: NodeRef, kind: &NodeKind) -> Option<QualType> {
 1214|       |        // let node = self.ast.get_node(node_ref); // For span access if needed
 1215|    513|        match kind {
 1216|    166|            NodeKind::CompoundStatement(cs) => {
 1217|    425|                for item_ref in cs.stmt_start.range(cs.stmt_len) {
                                              ^166          ^166  ^166
 1218|    425|                    self.visit_node(item_ref);
 1219|    425|                }
 1220|    166|                self.process_deferred_checks();
 1221|    166|                None
 1222|       |            }
 1223|       |
 1224|     39|            NodeKind::If(stmt) => {
 1225|     39|                self.visit_if_statement(stmt);
 1226|     39|                None
 1227|       |            }
 1228|      1|            NodeKind::While(stmt) => {
 1229|      1|                self.visit_while_statement(stmt);
 1230|      1|                None
 1231|       |            }
 1232|      1|            NodeKind::For(stmt) => {
 1233|      1|                self.visit_for_statement(stmt);
 1234|      1|                None
 1235|       |            }
 1236|      0|            NodeKind::DoWhile(body, condition) => {
 1237|      0|                self.visit_node(*body);
 1238|      0|                self.visit_node(*condition);
 1239|      0|                None
 1240|       |            }
 1241|      1|            NodeKind::Switch(cond, body) => {
 1242|      1|                self.visit_node(*cond);
 1243|      1|                self.switch_depth += 1;
 1244|      1|                self.switch_cases.push(HashSet::new());
 1245|      1|                self.switch_default_seen.push(false);
 1246|      1|                self.visit_node(*body);
 1247|      1|                self.switch_default_seen.pop();
 1248|      1|                self.switch_cases.pop();
 1249|      1|                self.switch_depth -= 1;
 1250|      1|                None
 1251|       |            }
 1252|      3|            NodeKind::Case(expr, stmt) => {
 1253|      3|                if self.switch_depth == 0 {
 1254|      1|                    let span = self.ast.get_span(node_ref);
 1255|      1|                    self.report_error(SemanticError::CaseNotInSwitch { span });
 1256|      1|                } else {
 1257|      2|                    let ctx = crate::semantic::const_eval::ConstEvalCtx {
 1258|      2|                        ast: self.ast,
 1259|      2|                        symbol_table: self.symbol_table,
 1260|      2|                    };
 1261|      2|                    if let Some(val) = crate::semantic::const_eval::eval_const_expr(&ctx, *expr) {
 1262|      2|                        let is_duplicate = if let Some(cases) = self.switch_cases.last_mut() {
 1263|      2|                            !cases.insert(val)
 1264|       |                        } else {
 1265|      0|                            false
 1266|       |                        };
 1267|       |
 1268|      2|                        if is_duplicate {
 1269|      1|                            let span = self.ast.get_span(node_ref);
 1270|      1|                            self.report_error(SemanticError::DuplicateCase {
 1271|      1|                                value: val.to_string(),
 1272|      1|                                span,
 1273|      1|                            });
 1274|      1|                        }
 1275|      0|                    }
 1276|       |                }
 1277|      3|                self.visit_node(*expr);
 1278|      3|                self.visit_node(*stmt);
 1279|      3|                None
 1280|       |            }
 1281|      0|            NodeKind::CaseRange(start, end, stmt) => {
 1282|      0|                if self.switch_depth == 0 {
 1283|      0|                    let span = self.ast.get_span(node_ref);
 1284|      0|                    self.report_error(SemanticError::CaseNotInSwitch { span });
 1285|      0|                } else {
 1286|      0|                    let ctx = crate::semantic::const_eval::ConstEvalCtx {
 1287|      0|                        ast: self.ast,
 1288|      0|                        symbol_table: self.symbol_table,
 1289|      0|                    };
 1290|      0|                    if let (Some(start_val), Some(end_val)) = (
 1291|      0|                        crate::semantic::const_eval::eval_const_expr(&ctx, *start),
 1292|      0|                        crate::semantic::const_eval::eval_const_expr(&ctx, *end),
 1293|       |                    ) {
 1294|      0|                        let mut duplicate_val = None;
 1295|      0|                        if let Some(cases) = self.switch_cases.last_mut() {
 1296|      0|                            for val in start_val..=end_val {
 1297|      0|                                if !cases.insert(val) {
 1298|      0|                                    duplicate_val = Some(val);
 1299|      0|                                    break;
 1300|      0|                                }
 1301|       |                            }
 1302|      0|                        }
 1303|       |
 1304|      0|                        if let Some(val) = duplicate_val {
 1305|      0|                            let span = self.ast.get_span(node_ref);
 1306|      0|                            self.report_error(SemanticError::DuplicateCase {
 1307|      0|                                value: val.to_string(),
 1308|      0|                                span,
 1309|      0|                            });
 1310|      0|                        }
 1311|      0|                    }
 1312|       |                }
 1313|      0|                self.visit_node(*start);
 1314|      0|                self.visit_node(*end);
 1315|      0|                self.visit_node(*stmt);
 1316|      0|                None
 1317|       |            }
 1318|      0|            NodeKind::Default(stmt) => {
 1319|      0|                if self.switch_depth == 0 {
 1320|      0|                    let span = self.ast.get_span(node_ref);
 1321|      0|                    self.report_error(SemanticError::CaseNotInSwitch { span });
 1322|      0|                } else {
 1323|      0|                    let is_duplicate = if let Some(seen) = self.switch_default_seen.last_mut() {
 1324|      0|                        let was_seen = *seen;
 1325|      0|                        *seen = true;
 1326|      0|                        was_seen
 1327|       |                    } else {
 1328|      0|                        false
 1329|       |                    };
 1330|       |
 1331|      0|                    if is_duplicate {
 1332|      0|                        let span = self.ast.get_span(node_ref);
 1333|      0|                        self.report_error(SemanticError::MultipleDefaultLabels { span });
 1334|      0|                    }
 1335|       |                }
 1336|      0|                self.visit_node(*stmt);
 1337|      0|                None
 1338|       |            }
 1339|    163|            NodeKind::Return(expr) => {
 1340|    163|                let span = self.ast.get_span(node_ref);
 1341|    163|                self.visit_return_statement(expr, span);
 1342|    163|                None
 1343|       |            }
 1344|    108|            NodeKind::ExpressionStatement(expr) => {
 1345|    108|                if let Some(expr_ref) = expr {
 1346|    108|                    self.visit_node(*expr_ref);
 1347|    108|                }
                              ^0
 1348|    108|                None
 1349|       |            }
 1350|       |            NodeKind::StaticAssert(..) => {
 1351|     19|                self.deferred_checks.push(DeferredCheck::StaticAssert(node_ref));
 1352|     19|                None
 1353|       |            }
 1354|      6|            NodeKind::Break | NodeKind::Continue | NodeKind::Goto(_, _) => None,
 1355|      6|            NodeKind::Label(_, stmt, _) => {
 1356|      6|                self.visit_node(*stmt);
 1357|      6|                None
 1358|       |            }
 1359|      0|            _ => None,
 1360|       |        }
 1361|    513|    }
 1362|       |
 1363|  1.03k|    fn visit_expression_node(&mut self, node_ref: NodeRef, kind: &NodeKind) -> Option<QualType> {
 1364|  1.03k|        match kind {
 1365|    423|            NodeKind::Literal(literal) => match literal {
 1366|    390|                literal::Literal::Int { val, suffix } => {
 1367|       |                    // C11 6.4.4.1: Determine type based on value and suffix.
 1368|       |                    // This is a simplified heuristic. A full implementation would check hex/octal.
 1369|    390|                    let ty = match suffix {
                                                 ^0
 1370|      0|                        Some(literal::IntegerSuffix::L) => self.registry.type_long,
 1371|      0|                        Some(literal::IntegerSuffix::LL) => self.registry.type_long_long,
 1372|      0|                        Some(literal::IntegerSuffix::U) => self.registry.type_int_unsigned,
 1373|      0|                        Some(literal::IntegerSuffix::UL) => self.registry.type_long_unsigned,
 1374|      0|                        Some(literal::IntegerSuffix::ULL) => self.registry.type_long_long_unsigned,
 1375|       |                        None => {
 1376|    390|                            if *val >= i32::MIN as i64 && *val <= i32::MAX as i64 {
 1377|    384|                                self.registry.type_int
 1378|      6|                            } else if *val >= 0 && *val <= u32::MAX as i64 {
 1379|      6|                                self.registry.type_int_unsigned
 1380|       |                            } else {
 1381|      0|                                self.registry.type_long
 1382|       |                            }
 1383|       |                        }
 1384|       |                    };
 1385|    390|                    Some(QualType::unqualified(ty))
 1386|       |                }
 1387|     10|                literal::Literal::Float(_) => Some(QualType::unqualified(self.registry.type_double)),
 1388|      8|                literal::Literal::Char(_) => Some(QualType::unqualified(self.registry.type_int)),
 1389|     15|                literal::Literal::String(name) => {
 1390|     15|                    let char_type = self.registry.type_char;
 1391|     15|                    let array_size = name.as_str().len() + 1;
 1392|     15|                    let array_type = self.registry.array_of(char_type, ArraySizeType::Constant(array_size));
 1393|     15|                    let _ = self.registry.ensure_layout(array_type);
 1394|     15|                    Some(QualType::new(array_type, TypeQualifiers::CONST))
 1395|       |                }
 1396|       |            },
 1397|    254|            NodeKind::Ident(_, symbol_ref) => {
 1398|    254|                let symbol = self.symbol_table.get_symbol(*symbol_ref);
 1399|    254|                match &symbol.kind {
 1400|      2|                    SymbolKind::EnumConstant { .. } => Some(QualType::unqualified(self.registry.type_int)),
 1401|    252|                    _ => Some(symbol.type_info),
 1402|       |                }
 1403|       |            }
 1404|     46|            NodeKind::UnaryOp(op, operand) => {
 1405|     46|                let span = self.ast.get_span(node_ref);
 1406|     46|                self.visit_unary_op(*op, *operand, span)
 1407|       |            }
 1408|     81|            NodeKind::BinaryOp(op, lhs, rhs) => {
 1409|     81|                let span = self.ast.get_span(node_ref);
 1410|     81|                self.visit_binary_op(*op, *lhs, *rhs, span)
 1411|       |            }
 1412|      4|            NodeKind::TernaryOp(cond, then, else_expr) => {
 1413|      4|                self.visit_node(*cond);
 1414|      4|                let then_ty = self.visit_node(*then);
 1415|      4|                let else_ty = self.visit_node(*else_expr);
 1416|       |
 1417|      4|                if let (Some(t), Some(e)) = (then_ty, else_ty) {
 1418|      4|                    let result_ty = match (t, e) {
 1419|      4|                        (t, e) if t.is_arithmetic() && e.is_arithmetic() => {
                                       ^0 ^0                         ^2^2
 1420|      0|                            usual_arithmetic_conversions(self.registry, t, e)
 1421|       |                        }
 1422|      4|                        (t, e) if t.ty() == e.ty() => Some(t),
                                       ^0 ^0                        ^0
 1423|      4|                        (t, _) if t.is_pointer() && self.is_null_pointer_constant(*else_expr) => Some(t),
                                       ^2                         ^2   ^2                       ^2             ^2
 1424|      2|                        (_, e) if e.is_pointer() && self.is_null_pointer_constant(*then) => Some(e),
 1425|      0|                        (t, e) if t.is_pointer() && e.is_pointer() => {
 1426|       |                            // C11 6.5.15: pointer to void and pointer to object -> pointer to void
 1427|      0|                            if t.ty() == self.registry.type_void_ptr || e.ty() == self.registry.type_void_ptr {
 1428|      0|                                Some(QualType::unqualified(self.registry.type_void_ptr))
 1429|       |                            } else {
 1430|       |                                // Should check compatibility, for now just use one or common
 1431|      0|                                Some(t)
 1432|       |                            }
 1433|       |                        }
 1434|      0|                        _ => usual_arithmetic_conversions(self.registry, t, e),
 1435|       |                    };
 1436|       |
 1437|      4|                    if let Some(res) = result_ty {
 1438|      4|                        self.record_implicit_conversions(res, t, *then);
 1439|      4|                        self.record_implicit_conversions(res, e, *else_expr);
 1440|      4|                        return Some(res);
 1441|      0|                    }
 1442|      0|                    None
 1443|       |                } else {
 1444|      0|                    None
 1445|       |                }
 1446|       |            }
 1447|      0|            NodeKind::GnuStatementExpression(stmt, _) => {
 1448|      0|                if let NodeKind::CompoundStatement(cs) = self.ast.get_kind(*stmt) {
 1449|      0|                    self.visit_node(*stmt);
 1450|      0|                    if cs.stmt_len > 0 {
 1451|      0|                        let last_item_idx = cs.stmt_start.get() + (cs.stmt_len - 1) as u32;
 1452|      0|                        let last_item_ref = NodeRef::new(last_item_idx).unwrap();
 1453|      0|                        if let NodeKind::ExpressionStatement(Some(expr)) = self.ast.get_kind(last_item_ref).clone() {
 1454|      0|                            return self.visit_node(expr);
 1455|      0|                        }
 1456|      0|                    }
 1457|      0|                }
 1458|      0|                None
 1459|       |            }
 1460|      3|            NodeKind::PostIncrement(expr) | NodeKind::PostDecrement(expr) => {
 1461|      6|                let ty = self.visit_node(*expr);
 1462|      6|                if self.check_lvalue_and_modifiable(*expr, ty.unwrap(), self.ast.get_span(node_ref)) {
 1463|      3|                    // ok
 1464|      3|                }
 1465|      6|                ty
 1466|       |            }
 1467|     80|            NodeKind::Assignment(op, lhs, rhs) => {
 1468|     80|                let span = self.ast.get_span(node_ref);
 1469|     80|                self.visit_assignment(node_ref, *op, *lhs, *rhs, span)
 1470|       |            }
 1471|     25|            NodeKind::FunctionCall(call_expr) => self.visit_function_call(call_expr),
 1472|     50|            NodeKind::MemberAccess(obj, field_name, is_arrow) => {
 1473|     50|                let span = self.ast.get_span(node_ref);
 1474|     50|                self.visit_member_access(*obj, *field_name, *is_arrow, span)
 1475|       |            }
 1476|     20|            NodeKind::IndexAccess(arr, idx) => self.visit_index_access(*arr, *idx),
 1477|      6|            NodeKind::Cast(ty, expr) => {
 1478|      6|                self.visit_type_expressions(*ty);
 1479|      6|                self.visit_node(*expr);
 1480|      6|                Some(*ty)
 1481|       |            }
 1482|     13|            NodeKind::SizeOfExpr(expr) => {
 1483|     13|                if let Some(ty) = self.visit_node(*expr) {
 1484|     13|                    if ty.is_function() {
 1485|      1|                        let span = self.ast.get_span(node_ref);
 1486|      1|                        self.report_error(SemanticError::SizeOfFunctionType { span });
 1487|      1|                    } else {
 1488|     12|                        let type_ref = ty.ty();
 1489|     12|                        if !self.registry.is_complete(type_ref) {
 1490|      1|                            let span = self.ast.get_span(node_ref);
 1491|      1|                            self.report_error(SemanticError::SizeOfIncompleteType { ty: type_ref, span });
 1492|     11|                        } else {
 1493|     11|                            let _ = self.registry.ensure_layout(type_ref);
 1494|     11|                        }
 1495|       |                    }
 1496|      0|                }
 1497|     13|                Some(QualType::unqualified(self.registry.type_long_unsigned))
 1498|       |            }
 1499|      4|            NodeKind::SizeOfType(ty) | NodeKind::AlignOf(ty) => {
                                                                       ^0
 1500|      4|                self.visit_type_expressions(*ty);
 1501|      4|                let type_ref = ty.ty();
 1502|      4|                if !self.registry.is_complete(type_ref) {
 1503|      1|                    let span = self.ast.get_span(node_ref);
 1504|      1|                    self.report_error(SemanticError::SizeOfIncompleteType { ty: type_ref, span });
 1505|      3|                } else {
 1506|      3|                    let _ = self.registry.ensure_layout(type_ref);
 1507|      3|                }
 1508|      4|                Some(QualType::unqualified(self.registry.type_long_unsigned))
 1509|       |            }
 1510|      0|            NodeKind::CompoundLiteral(ty, init) => {
 1511|      0|                self.visit_type_expressions(*ty);
 1512|      0|                let _ = self.registry.ensure_layout(ty.ty());
 1513|      0|                self.check_initializer(*init, *ty);
 1514|      0|                Some(*ty)
 1515|       |            }
 1516|      6|            NodeKind::GenericSelection(gs) => self.visit_generic_selection(gs),
 1517|     13|            NodeKind::GenericAssociation(ga) => {
 1518|     13|                if let Some(ty) = ga.ty {
                                          ^8
 1519|      8|                    self.visit_type_expressions(ty);
 1520|      8|                }
                              ^5
 1521|     13|                self.visit_node(ga.result_expr)
 1522|       |            }
 1523|      2|            NodeKind::InitializerList(list) => {
 1524|      3|                for item_ref in list.init_start.range(list.init_len) {
                                              ^2              ^2    ^2
 1525|      3|                    self.visit_node(item_ref);
 1526|      3|                }
 1527|      2|                None
 1528|       |            }
 1529|      3|            NodeKind::InitializerItem(init) => {
 1530|      3|                for designator_ref in init.designator_start.range(init.designator_len) {
                                  ^1
 1531|      1|                    if let NodeKind::Designator(d) = self.ast.get_kind(designator_ref) {
 1532|      1|                        match d {
 1533|      1|                            Designator::ArrayIndex(expr_ref) => {
 1534|      1|                                self.visit_node(*expr_ref);
 1535|      1|                            }
 1536|      0|                            Designator::GnuArrayRange(start_ref, end_ref) => {
 1537|      0|                                self.visit_node(*start_ref);
 1538|      0|                                self.visit_node(*end_ref);
 1539|      0|                            }
 1540|      0|                            Designator::FieldName(_) => {}
 1541|       |                        }
 1542|      0|                    }
 1543|       |                }
 1544|      3|                self.visit_node(init.initializer);
 1545|      3|                None
 1546|       |            }
 1547|      0|            NodeKind::BuiltinVaArg(ty, expr) => {
 1548|      0|                self.visit_type_expressions(*ty);
 1549|      0|                self.visit_node(*expr);
 1550|      0|                Some(*ty)
 1551|       |            }
 1552|      0|            NodeKind::BuiltinVaStart(ap, last) => {
 1553|      0|                self.visit_node(*ap);
 1554|      0|                self.visit_node(*last);
 1555|      0|                Some(QualType::unqualified(self.registry.type_void))
 1556|       |            }
 1557|      0|            NodeKind::BuiltinVaEnd(ap) => {
 1558|      0|                self.visit_node(*ap);
 1559|      0|                Some(QualType::unqualified(self.registry.type_void))
 1560|       |            }
 1561|      0|            NodeKind::BuiltinVaCopy(dst, src) => {
 1562|      0|                self.visit_node(*dst);
 1563|      0|                self.visit_node(*src);
 1564|      0|                Some(QualType::unqualified(self.registry.type_void))
 1565|       |            }
 1566|      0|            _ => None,
 1567|       |        }
 1568|  1.03k|    }
 1569|       |
 1570|  2.06k|    fn visit_node(&mut self, node_ref: NodeRef) -> Option<QualType> {
 1571|  2.06k|        let node_kind = self.ast.get_kind(node_ref);
 1572|  2.06k|        let result_type = match node_kind {
 1573|       |            // Declarations
 1574|       |            NodeKind::TranslationUnit(_)
 1575|       |            | NodeKind::Function(_)
 1576|       |            | NodeKind::VarDecl(_)
 1577|       |            | NodeKind::RecordDecl(_)
 1578|       |            | NodeKind::FieldDecl(_)
 1579|       |            | NodeKind::EnumDecl(_)
 1580|       |            | NodeKind::EnumMember(_)
 1581|       |            | NodeKind::TypedefDecl(_)
 1582|       |            | NodeKind::EnumConstant(..)
 1583|       |            | NodeKind::Param(_)
 1584|    516|            | NodeKind::FunctionDecl(_) => self.visit_declaration_node(node_ref, node_kind),
 1585|       |
 1586|       |            // Statements
 1587|       |            NodeKind::CompoundStatement(_)
 1588|       |            | NodeKind::If(_)
 1589|       |            | NodeKind::While(_)
 1590|       |            | NodeKind::DoWhile(..)
 1591|       |            | NodeKind::For(_)
 1592|       |            | NodeKind::Return(_)
 1593|       |            | NodeKind::ExpressionStatement(_)
 1594|       |            | NodeKind::StaticAssert(..)
 1595|       |            | NodeKind::Switch(..)
 1596|       |            | NodeKind::Case(..)
 1597|       |            | NodeKind::CaseRange(..)
 1598|       |            | NodeKind::Default(_)
 1599|       |            | NodeKind::Break
 1600|       |            | NodeKind::Continue
 1601|       |            | NodeKind::Goto(..)
 1602|    513|            | NodeKind::Label(..) => self.visit_statement_node(node_ref, node_kind),
 1603|       |
 1604|       |            // Expressions (Catch-all)
 1605|  1.03k|            _ => self.visit_expression_node(node_ref, node_kind),
 1606|       |        };
 1607|       |
 1608|  2.06k|        if let Some(ty) = result_type {
                                  ^1.18k
 1609|       |            // set resolved type and value category for this node
 1610|  1.18k|            let idx = node_ref.index();
 1611|  1.18k|            self.semantic_info.types[idx] = Some(ty);
 1612|  1.18k|            let vc = if self.is_lvalue(node_ref) {
 1613|    338|                ValueCategory::LValue
 1614|       |            } else {
 1615|    847|                ValueCategory::RValue
 1616|       |            };
 1617|  1.18k|            self.semantic_info.value_categories[idx] = vc;
 1618|    880|        }
 1619|  2.06k|        result_type
 1620|  2.06k|    }
 1621|       |
 1622|    303|    fn process_deferred_checks(&mut self) {
 1623|    303|        for check in self.deferred_checks.drain(..).collect::<Vec<_>>() {
                          ^19
 1624|     19|            match check {
 1625|     19|                DeferredCheck::StaticAssert(node_ref) => self.visit_static_assert(node_ref),
 1626|       |            }
 1627|       |        }
 1628|    303|    }
 1629|       |
 1630|     19|    fn visit_static_assert(&mut self, node_ref: NodeRef) {
 1631|     19|        let node_kind = self.ast.get_kind(node_ref).clone();
 1632|     19|        if let NodeKind::StaticAssert(cond, msg) = node_kind {
 1633|     19|            self.visit_node(cond);
 1634|     19|            let ctx = crate::semantic::const_eval::ConstEvalCtx {
 1635|     19|                ast: self.ast,
 1636|     19|                symbol_table: self.symbol_table,
 1637|     19|            };
 1638|     19|            match crate::semantic::const_eval::eval_const_expr(&ctx, cond) {
 1639|      2|                Some(0) => {
 1640|      2|                    self.report_error(SemanticError::StaticAssertFailed {
 1641|      2|                        message: msg.as_str().to_string(),
 1642|      2|                        span: self.ast.get_span(node_ref),
 1643|      2|                    });
 1644|      2|                }
 1645|      1|                None => {
 1646|      1|                    self.report_error(SemanticError::StaticAssertNotConstant {
 1647|      1|                        span: self.ast.get_span(node_ref),
 1648|      1|                    });
 1649|      1|                }
 1650|     16|                _ => {}
 1651|       |            }
 1652|      0|        }
 1653|     19|    }
 1654|       |
 1655|      6|    fn visit_generic_selection(&mut self, gs: &GenericSelectionData) -> Option<QualType> {
 1656|       |        // First, visit the controlling expression to determine its type.
 1657|      6|        let ctrl_ty = self.visit_node(gs.control)?;
                                                               ^0
 1658|       |
 1659|       |        // C11 6.5.1.1p3: The controlling expression of a generic selection is not evaluated.
 1660|       |        // C11 6.5.1.1p2: The type of the controlling expression is compared with the type name of each generic
 1661|       |        // association. Before comparison, array and function types decay to pointers.
 1662|      6|        let decayed_ctrl_ty = if ctrl_ty.is_array() || ctrl_ty.is_function() {
                                                                     ^5      ^5
 1663|       |            // Qualifiers on the array/function type itself are discarded during decay.
 1664|      2|            self.registry.decay(ctrl_ty, TypeQualifiers::empty())
 1665|       |        } else {
 1666|      4|            ctrl_ty
 1667|       |        };
 1668|       |
 1669|       |        // After decay, top-level qualifiers are removed for the compatibility check.
 1670|      6|        let unqualified_ctrl_ty = self.registry.strip_all(decayed_ctrl_ty);
 1671|       |
 1672|       |        // It's crucial to visit *all* result expressions to ensure they are
 1673|       |        // fully type-checked, even if they are not the selected branch.
 1674|       |        // This resolves all identifier types within them.
 1675|      6|        let mut selected_expr_ref = None;
 1676|      6|        let mut default_expr_ref = None;
 1677|       |
 1678|     13|        for assoc_node_ref in gs.assoc_start.range(gs.assoc_len) {
                                            ^6             ^6    ^6
 1679|     13|            if let NodeKind::GenericAssociation(ga) = self.ast.get_kind(assoc_node_ref).clone() {
 1680|     13|                self.visit_node(assoc_node_ref);
 1681|       |
 1682|     13|                if let Some(assoc_ty) = ga.ty {
                                          ^8
 1683|       |                    // C11 6.5.1.1p2: For the purpose of this comparison, qualifiers are stripped from both the
 1684|       |                    // controlling expression's type and the generic association's type.
 1685|      8|                    let unqualified_assoc_ty = self.registry.strip_all(assoc_ty);
 1686|      8|                    if self.registry.is_compatible(unqualified_ctrl_ty, unqualified_assoc_ty) {
 1687|      4|                        selected_expr_ref = Some(ga.result_expr);
 1688|      4|                    }
 1689|      5|                } else {
 1690|      5|                    // This is the 'default' association.
 1691|      5|                    default_expr_ref = Some(ga.result_expr);
 1692|      5|                }
 1693|      0|            }
 1694|       |        }
 1695|       |
 1696|       |        // If no specific type matches, use the default association if it exists.
 1697|      6|        if selected_expr_ref.is_none() {
 1698|      2|            selected_expr_ref = default_expr_ref;
 1699|      4|        }
 1700|       |
 1701|       |        // The type of the _Generic expression is the type of the selected result expression.
 1702|      6|        if let Some(expr_ref) = selected_expr_ref {
                                  ^5
 1703|       |            // The type should already be resolved from the earlier pass.
 1704|      5|            let idx = expr_ref.index();
 1705|      5|            self.semantic_info.types.get(idx).and_then(|t| *t)
 1706|       |        } else {
 1707|       |            // If no match is found and there's no default, it's a semantic error.
 1708|      1|            self.report_error(SemanticError::GenericNoMatch {
 1709|      1|                span: self.ast.get_span(gs.control),
 1710|      1|            });
 1711|      1|            None
 1712|       |        }
 1713|      6|    }
 1714|       |}

/app/src/semantic/ast_to_mir.rs:
    1|       |use crate::ast::BinaryOp;
    2|       |use crate::ast::nodes;
    3|       |use crate::ast::*;
    4|       |use crate::mir::MirArrayLayout;
    5|       |use crate::mir::MirProgram;
    6|       |use crate::mir::MirRecordLayout;
    7|       |use crate::mir::{
    8|       |    self, BinaryFloatOp, BinaryIntOp, ConstValueId, ConstValueKind, LocalId, MirBlockId, MirBuilder, MirFunctionId,
    9|       |    MirStmt, MirType, Operand, Place, Rvalue, Terminator, TypeId, UnaryFloatOp, UnaryIntOp,
   10|       |};
   11|       |use crate::semantic::ArraySizeType;
   12|       |use crate::semantic::BuiltinType;
   13|       |use crate::semantic::QualType;
   14|       |use crate::semantic::StructMember;
   15|       |use crate::semantic::SymbolKind;
   16|       |use crate::semantic::SymbolRef;
   17|       |use crate::semantic::SymbolTable;
   18|       |use crate::semantic::TypeKind;
   19|       |
   20|       |use crate::semantic::{DefinitionState, TypeRef, TypeRegistry};
   21|       |use crate::semantic::{ImplicitConversion, Namespace, ScopeId};
   22|       |use hashbrown::{HashMap, HashSet};
   23|       |use log::debug;
   24|       |
   25|       |use crate::mir::GlobalId;
   26|       |
   27|       |pub(crate) struct AstToMirLowerer<'a> {
   28|       |    pub(crate) ast: &'a Ast,
   29|       |    pub(crate) symbol_table: &'a SymbolTable, // Now immutable
   30|       |    pub(crate) mir_builder: MirBuilder,
   31|       |    pub(crate) current_function: Option<MirFunctionId>,
   32|       |    pub(crate) current_block: Option<MirBlockId>,
   33|       |    pub(crate) current_scope_id: ScopeId,
   34|       |    pub(crate) registry: &'a mut TypeRegistry,
   35|       |    pub(crate) local_map: HashMap<SymbolRef, LocalId>,
   36|       |    pub(crate) global_map: HashMap<SymbolRef, GlobalId>,
   37|       |    pub(crate) label_map: HashMap<NameId, MirBlockId>,
   38|       |    pub(crate) type_cache: HashMap<TypeRef, TypeId>,
   39|       |    pub(crate) type_conversion_in_progress: HashSet<TypeRef>,
   40|       |    pub(crate) break_target: Option<MirBlockId>,
   41|       |    pub(crate) continue_target: Option<MirBlockId>,
   42|       |    pub(crate) switch_case_map: HashMap<NodeRef, MirBlockId>,
   43|       |}
   44|       |
   45|       |impl<'a> AstToMirLowerer<'a> {
   46|     92|    pub(crate) fn new(ast: &'a Ast, symbol_table: &'a SymbolTable, registry: &'a mut TypeRegistry) -> Self {
   47|     92|        let mir_builder = MirBuilder::new(mir::MirModuleId::new(1).unwrap(), 8);
   48|     92|        Self {
   49|     92|            ast,
   50|     92|            symbol_table,
   51|     92|            mir_builder,
   52|     92|            current_function: None,
   53|     92|            current_block: None,
   54|     92|            current_scope_id: ScopeId::GLOBAL,
   55|     92|            local_map: HashMap::new(),
   56|     92|            global_map: HashMap::new(),
   57|     92|            label_map: HashMap::new(),
   58|     92|            registry,
   59|     92|            type_cache: HashMap::new(),
   60|     92|            type_conversion_in_progress: HashSet::new(),
   61|     92|            break_target: None,
   62|     92|            continue_target: None,
   63|     92|            switch_case_map: HashMap::new(),
   64|     92|        }
   65|     92|    }
   66|       |
   67|       |    // create dummy operand
   68|     15|    pub(crate) fn create_dummy_operand(&mut self) -> Operand {
   69|     15|        self.create_int_operand(9999)
   70|     15|    }
   71|       |
   72|     92|    pub(crate) fn lower_module_complete(&mut self) -> MirProgram {
   73|     92|        debug!("Starting semantic analysis and MIR construction (complete)");
                             ^0
   74|     92|        let root = self.ast.get_root();
   75|     92|        self.lower_node_ref(root);
   76|     92|        debug!("Semantic analysis complete");
                             ^0
   77|       |
   78|       |        // Take ownership of the builder to consume it, replacing it with a dummy.
   79|     92|        let builder = std::mem::replace(
   80|     92|            &mut self.mir_builder,
   81|     92|            MirBuilder::new(mir::MirModuleId::new(1).unwrap(), 8),
   82|       |        );
   83|     92|        let output = builder.consume();
   84|       |
   85|     92|        MirProgram {
   86|     92|            module: output.module,
   87|     92|            functions: output.functions,
   88|     92|            blocks: output.blocks,
   89|     92|            locals: output.locals,
   90|     92|            globals: output.globals,
   91|     92|            types: output.types,
   92|     92|            constants: output.constants,
   93|     92|            statements: output.statements,
   94|     92|            pointer_width: 8,
   95|     92|        }
   96|     92|    }
   97|       |
   98|    768|    fn lower_node_ref(&mut self, node_ref: NodeRef) {
   99|    768|        let old_scope = self.current_scope_id;
  100|    768|        let node_kind = self.ast.get_kind(node_ref).clone();
  101|       |
  102|    768|        match node_kind {
  103|     92|            NodeKind::TranslationUnit(tu_data) => {
  104|     92|                self.current_scope_id = self.ast.scope_of(node_ref);
  105|     92|                self.lower_translation_unit(&tu_data)
  106|       |            }
  107|    110|            NodeKind::Function(function_data) => {
  108|    110|                self.current_scope_id = self.ast.scope_of(node_ref);
  109|    110|                self.lower_function(&function_data)
  110|       |            }
  111|      1|            NodeKind::For(for_stmt) => {
  112|      1|                self.current_scope_id = self.ast.scope_of(node_ref);
  113|      1|                self.lower_for_statement(&for_stmt)
  114|       |            }
  115|    128|            NodeKind::VarDecl(var_decl) => self.lower_var(&var_decl),
  116|    118|            NodeKind::CompoundStatement(cs) => {
  117|    118|                self.current_scope_id = self.ast.scope_of(node_ref);
  118|    118|                self.lower_compound_statement(&cs)
  119|       |            }
  120|       |
  121|    319|            _ => self.try_lower_as_statement(node_ref),
  122|       |        }
  123|       |
  124|    768|        self.current_scope_id = old_scope;
  125|    768|    }
  126|       |
  127|     92|    fn lower_translation_unit(&mut self, tu_data: &nodes::TranslationUnitData) {
  128|     92|        self.predeclare_global_functions();
  129|    190|        for child_ref in tu_data.decl_start.range(tu_data.decl_len) {
                                       ^92                ^92   ^92
  130|    190|            self.lower_node_ref(child_ref);
  131|    190|        }
  132|     92|    }
  133|       |
  134|     92|    fn predeclare_global_functions(&mut self) {
  135|       |        // Ensure all global functions (including declarations) have a MIR representation.
  136|       |        // This is done before traversing the AST to ensure that function calls
  137|       |        // can be resolved even if the function is defined later in the file or is external.
  138|     92|        let global_scope = self.symbol_table.get_scope(ScopeId::GLOBAL);
  139|     92|        let mut global_symbols: Vec<_> = global_scope.symbols.values().copied().collect();
  140|       |
  141|       |        // Sort by symbol name to ensure deterministic order for snapshot tests
  142|    250|        global_symbols.sort_by_key(|s| self.symbol_table.get_symbol(*s).name);
                      ^92            ^92
  143|       |
  144|    246|        for sym_ref in global_symbols {
                          ^154
  145|    154|            let (symbol_name, symbol_type_info, is_function, has_definition) = {
  146|    154|                let symbol = self.symbol_table.get_symbol(sym_ref);
  147|       |                (
  148|    154|                    symbol.name,
  149|    154|                    symbol.type_info,
  150|    154|                    matches!(symbol.kind, SymbolKind::Function { .. }),
                                  ^39
  151|    154|                    symbol.def_state == DefinitionState::Defined,
  152|       |                )
  153|       |            };
  154|       |
  155|    154|            if is_function {
  156|    115|                if self
  157|    115|                    .mir_builder
  158|    115|                    .get_functions()
  159|    115|                    .iter()
  160|    115|                    .any(|(_, f)| f.name == symbol_name)
                                                ^102      ^102
  161|       |                {
  162|      0|                    continue;
  163|    115|                }
  164|       |
  165|    115|                let func_type_kind = self.registry.get(symbol_type_info.ty()).kind.clone();
  166|       |                if let TypeKind::Function {
  167|    115|                    return_type,
  168|    115|                    parameters,
  169|    115|                    is_variadic,
  170|       |                    ..
  171|    115|                } = &func_type_kind
  172|       |                {
  173|    115|                    let return_mir_type = self.lower_type(*return_type);
  174|    115|                    let param_mir_types = parameters.iter().map(|p| self.lower_qual_type(p.param_type)).collect();
                                                                                  ^9   ^9              ^9
  175|       |
  176|    115|                    self.define_or_declare_function(
  177|    115|                        symbol_name,
  178|    115|                        param_mir_types,
  179|    115|                        return_mir_type,
  180|    115|                        *is_variadic,
  181|    115|                        has_definition,
  182|       |                    );
  183|      0|                } else {
  184|      0|                    // This case should ideally not be reached for a SymbolKind::Function
  185|      0|                    let return_mir_type = self.get_int_type();
  186|      0|                    self.define_or_declare_function(symbol_name, vec![], return_mir_type, false, has_definition);
  187|      0|                }
  188|     39|            }
  189|       |        }
  190|     92|    }
  191|       |
  192|     40|    pub(crate) fn operand_to_const_id_strict(&mut self, op: Operand, msg: &str) -> ConstValueId {
  193|     40|        self.operand_to_const_id(op).expect(msg)
  194|     40|    }
  195|       |
  196|    319|    fn try_lower_as_statement(&mut self, node_ref: NodeRef) {
  197|    319|        let node_kind = self.ast.get_kind(node_ref);
  198|    319|        match node_kind.clone() {
  199|    143|            NodeKind::Return(expr) => self.lower_return_statement(&expr),
  200|     39|            NodeKind::If(if_stmt) => self.lower_if_statement(&if_stmt),
  201|      1|            NodeKind::While(while_stmt) => self.lower_while_statement(&while_stmt),
  202|      0|            NodeKind::DoWhile(body, condition) => self.lower_do_while_statement(body, condition),
  203|     78|            NodeKind::ExpressionStatement(Some(expr_ref)) => {
  204|     78|                // Expression statement: value not needed, only side-effects
  205|     78|                self.lower_expression(expr_ref, false);
  206|     78|            }
  207|      0|            NodeKind::Break => {
  208|      0|                let target = self.break_target.unwrap();
  209|      0|                self.mir_builder.set_terminator(Terminator::Goto(target));
  210|      0|            }
  211|      0|            NodeKind::Continue => {
  212|      0|                let target = self.continue_target.unwrap();
  213|      0|                self.mir_builder.set_terminator(Terminator::Goto(target));
  214|      0|            }
  215|      3|            NodeKind::Goto(label_name, _) => self.lower_goto_statement(&label_name),
  216|      6|            NodeKind::Label(label_name, statement, _) => self.lower_label_statement(&label_name, statement),
  217|      0|            NodeKind::Switch(cond, body) => self.lower_switch_statement(cond, body),
  218|      0|            NodeKind::Case(_, stmt) => self.lower_case_default_statement(node_ref, stmt),
  219|      0|            NodeKind::Default(stmt) => self.lower_case_default_statement(node_ref, stmt),
  220|     49|            _ => {}
  221|       |        }
  222|    319|    }
  223|       |
  224|     49|    pub(crate) fn lower_condition(&mut self, condition: NodeRef) -> Operand {
  225|     49|        let cond_operand = self.lower_expression(condition, true);
  226|       |        // Apply conversions for condition (should be boolean)
  227|     49|        let cond_ty = self.ast.get_resolved_type(condition).unwrap();
  228|     49|        let cond_mir_ty = self.lower_qual_type(cond_ty);
  229|     49|        self.apply_conversions(cond_operand, condition, cond_mir_ty)
  230|     49|    }
  231|       |
  232|    118|    fn lower_compound_statement(&mut self, cs: &nodes::CompoundStmtData) {
  233|    329|        for stmt_ref in cs.stmt_start.range(cs.stmt_len) {
                                      ^118          ^118  ^118
  234|    329|            let node_kind = self.ast.get_kind(stmt_ref);
  235|    329|            if self.mir_builder.current_block_has_terminator() {
  236|      4|                if let NodeKind::Label(..) = node_kind {
  237|      3|                    // This is a label, which is a valid entry point.
  238|      3|                    // Let lower_node_ref handle it, it will switch to a new block.
  239|      3|                } else {
  240|       |                    // This statement is unreachable. Skip it.
  241|      1|                    continue;
  242|       |                }
  243|    325|            }
  244|    328|            self.lower_node_ref(stmt_ref)
  245|       |        }
  246|    118|    }
  247|       |
  248|    110|    fn lower_function(&mut self, function_data: &FunctionData) {
  249|    110|        let symbol_entry = self.symbol_table.get_symbol(function_data.symbol);
  250|    110|        let func_name = symbol_entry.name;
  251|       |
  252|       |        // Find the existing function in the MIR builder. It should have been created by the pre-pass.
  253|    110|        let func_id = self
  254|    110|            .mir_builder
  255|    110|            .get_functions()
  256|    110|            .iter()
  257|    208|            .find(|(_, f)| f.name == func_name)
                           ^110
  258|    110|            .map(|(id, _)| *id)
  259|    110|            .expect("Function not found in MIR builder, pre-pass failed?");
  260|       |
  261|    110|        self.current_function = Some(func_id);
  262|    110|        self.mir_builder.set_current_function(func_id);
  263|       |
  264|       |        // Since we use define_function for functions with bodies, we should always have a body here
  265|    110|        let entry_block_id = self.mir_builder.create_block();
  266|    110|        self.mir_builder.set_function_entry_block(func_id, entry_block_id);
  267|    110|        self.current_block = Some(entry_block_id);
  268|    110|        self.mir_builder.set_current_block(entry_block_id);
  269|       |
  270|       |        // Pre-scan for all labels in the function body to create their MIR blocks upfront.
  271|    110|        self.label_map.clear();
  272|    110|        self.scan_for_labels(function_data.body);
  273|       |
  274|       |        // Parameter locals are now created in `define_function`. We just need to
  275|       |        // map the SymbolRef to the LocalId.
  276|    110|        self.local_map.clear();
  277|    110|        let mir_function = self.mir_builder.get_functions().get(&func_id).unwrap().clone();
  278|       |
  279|    110|        for (i, param_ref) in function_data.param_start.range(function_data.param_len).enumerate() {
                           ^3 ^3
  280|      3|            if let NodeKind::Param(param_data) = self.ast.get_kind(param_ref) {
  281|      3|                let local_id = mir_function.params[i];
  282|      3|                self.local_map.insert(param_data.symbol, local_id);
  283|      3|            }
                          ^0
  284|       |        }
  285|       |
  286|    110|        self.lower_node_ref(function_data.body);
  287|       |
  288|    110|        self.current_function = None;
  289|    110|        self.current_block = None;
  290|    110|    }
  291|       |
  292|    128|    fn lower_var(&mut self, var_decl: &VarDeclData) {
  293|    128|        let mir_type_id = self.lower_qual_type(var_decl.ty);
  294|    128|        let (entry_ref, _) = self
  295|    128|            .symbol_table
  296|    128|            .lookup(var_decl.name, self.current_scope_id, Namespace::Ordinary)
  297|    128|            .unwrap();
  298|       |
  299|    128|        let is_global = self.current_function.is_none();
  300|       |
  301|    128|        if is_global {
  302|     32|            self.lower_global(var_decl, entry_ref, mir_type_id);
  303|     96|        } else {
  304|     96|            self.lower_local(var_decl, entry_ref, mir_type_id);
  305|     96|        }
  306|    128|    }
  307|       |
  308|     32|    fn lower_global(&mut self, var_decl: &VarDeclData, entry_ref: SymbolRef, mir_type_id: TypeId) {
  309|     32|        let initial_value_id = var_decl
  310|     32|            .init
  311|     32|            .and_then(|init_ref| self.lower_initializer_to_const(init_ref, var_decl.ty));
                                               ^26  ^26                        ^26       ^26
  312|       |
  313|     32|        let symbol = self.symbol_table.get_symbol(entry_ref);
  314|     32|        let final_init = initial_value_id.or_else(|| {
                                                                   ^6
  315|      6|            if symbol.def_state == DefinitionState::Tentative {
  316|      3|                Some(self.create_constant(mir_type_id, ConstValueKind::Zero))
  317|       |            } else {
  318|      3|                None
  319|       |            }
  320|      6|        });
  321|       |
  322|     32|        if let Some(global_id) = self.global_map.get(&entry_ref).copied() {
                                  ^3
  323|      3|            if let Some(init_id) = final_init {
                                      ^2
  324|      2|                self.mir_builder.set_global_initializer(global_id, init_id);
  325|      2|            }
                          ^1
  326|       |        } else {
  327|     29|            let global_id = self
  328|     29|                .mir_builder
  329|     29|                .create_global_with_init(var_decl.name, mir_type_id, false, final_init);
  330|       |
  331|     29|            if let Some(alignment) = var_decl.alignment {
                                      ^0
  332|      0|                self.mir_builder.set_global_alignment(global_id, alignment as u32);
  333|     29|            }
  334|       |
  335|     29|            self.global_map.insert(entry_ref, global_id);
  336|       |        }
  337|     32|    }
  338|       |
  339|     96|    fn lower_local(&mut self, var_decl: &VarDeclData, entry_ref: SymbolRef, mir_type_id: TypeId) {
  340|     96|        let local_id = self.mir_builder.create_local(Some(var_decl.name), mir_type_id, false);
  341|       |
  342|     96|        if let Some(alignment) = var_decl.alignment {
                                  ^0
  343|      0|            self.mir_builder.set_local_alignment(local_id, alignment as u32);
  344|     96|        }
  345|       |
  346|     96|        self.local_map.insert(entry_ref, local_id);
  347|       |
  348|     96|        if let Some(initializer) = var_decl.init {
                                  ^52
  349|     52|            let init_operand = self.lower_initializer(initializer, var_decl.ty, Some(Place::Local(local_id)));
  350|     52|            // If lower_initializer used the destination, it returns Operand::Copy(destination)
  351|     52|            // emit_assignment will then emit Place::Local(local_id) = Place::Local(local_id), which is fine or can be skipped.
  352|     52|            self.emit_assignment(Place::Local(local_id), init_operand);
  353|     52|        }
                      ^44
  354|     96|    }
  355|       |
  356|    143|    fn lower_return_statement(&mut self, expr: &Option<NodeRef>) {
  357|    143|        let operand = expr.map(|expr_ref| {
                                                        ^141
  358|    141|            let expr_operand = self.lower_expression(expr_ref, true);
  359|       |            // Apply conversions for return value if needed
  360|    141|            if let Some(func_id) = self.current_function {
  361|    141|                let func = self.mir_builder.get_functions().get(&func_id).unwrap();
  362|    141|                let return_mir_ty = func.return_type;
  363|    141|                self.apply_conversions(expr_operand, expr_ref, return_mir_ty)
  364|       |            } else {
  365|      0|                expr_operand
  366|       |            }
  367|    141|        });
  368|    143|        self.mir_builder.set_terminator(Terminator::Return(operand));
  369|    143|    }
  370|       |
  371|     39|    fn lower_if_statement(&mut self, if_stmt: &IfStmt) {
  372|     39|        let then_block = self.mir_builder.create_block();
  373|     39|        let else_block = self.mir_builder.create_block();
  374|     39|        let merge_block = self.mir_builder.create_block();
  375|       |
  376|     39|        let cond_converted = self.lower_condition(if_stmt.condition);
  377|     39|        self.mir_builder
  378|     39|            .set_terminator(Terminator::If(cond_converted, then_block, else_block));
  379|       |
  380|     39|        self.mir_builder.set_current_block(then_block);
  381|     39|        self.lower_node_ref(if_stmt.then_branch);
  382|     39|        if !self.mir_builder.current_block_has_terminator() {
  383|      2|            self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  384|     37|        }
  385|       |
  386|     39|        self.mir_builder.set_current_block(else_block);
  387|     39|        if let Some(else_branch) = &if_stmt.else_branch {
                                  ^1
  388|      1|            self.lower_node_ref(*else_branch);
  389|     38|        }
  390|     39|        if !self.mir_builder.current_block_has_terminator() {
  391|     38|            self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  392|     38|        }
                      ^1
  393|       |
  394|     39|        self.mir_builder.set_current_block(merge_block);
  395|     39|        self.current_block = Some(merge_block);
  396|     39|    }
  397|       |
  398|      2|    fn lower_loop_generic<I, C, B, Inc>(
  399|      2|        &mut self,
  400|      2|        init_fn: Option<I>,
  401|      2|        cond_fn: Option<C>,
  402|      2|        body_fn: B,
  403|      2|        inc_fn: Option<Inc>,
  404|      2|        is_do_while: bool,
  405|      2|    ) where
  406|      2|        I: FnOnce(&mut Self),
  407|      2|        C: FnOnce(&mut Self) -> Operand,
  408|      2|        B: FnOnce(&mut Self),
  409|      2|        Inc: FnOnce(&mut Self),
  410|       |    {
  411|      2|        let cond_block = self.mir_builder.create_block();
  412|      2|        let body_block = self.mir_builder.create_block();
  413|      2|        let increment_block = if inc_fn.is_some() {
  414|      0|            self.mir_builder.create_block()
  415|       |        } else {
  416|       |            // If there's no increment block (e.g. while/do-while), "continue" goes to condition
  417|      2|            cond_block
  418|       |        };
  419|      2|        let exit_block = self.mir_builder.create_block();
  420|       |
  421|       |        // Continue target depends on whether we have an increment step
  422|      2|        let continue_target = increment_block;
  423|       |
  424|      2|        self.with_loop_targets(exit_block, continue_target, |this| {
  425|      2|            if let Some(init) = init_fn {
                                      ^0
  426|      0|                init(this);
  427|      2|            }
  428|       |
  429|      2|            if is_do_while {
  430|      0|                // do-while: jump straight to body
  431|      0|                this.mir_builder.set_terminator(Terminator::Goto(body_block));
  432|      2|            } else {
  433|      2|                // for/while: jump to condition
  434|      2|                this.mir_builder.set_terminator(Terminator::Goto(cond_block));
  435|      2|            }
  436|       |
  437|       |            // Condition block
  438|      2|            this.mir_builder.set_current_block(cond_block);
  439|      2|            if let Some(cond) = cond_fn {
  440|      2|                let cond_val = cond(this);
  441|      2|                this.mir_builder
  442|      2|                    .set_terminator(Terminator::If(cond_val, body_block, exit_block));
  443|      2|            } else {
  444|      0|                // No condition (e.g. for(;;)) -> infinite loop
  445|      0|                this.mir_builder.set_terminator(Terminator::Goto(body_block));
  446|      0|            }
  447|       |
  448|       |            // Body block
  449|      2|            this.mir_builder.set_current_block(body_block);
  450|      2|            body_fn(this);
  451|       |
  452|       |            // After body, jump to increment (or condition if no increment)
  453|      2|            if !this.mir_builder.current_block_has_terminator() {
  454|      2|                this.mir_builder.set_terminator(Terminator::Goto(increment_block));
  455|      2|            }
                          ^0
  456|       |
  457|       |            // Increment block (only if it exists and is distinct from cond_block)
  458|      2|            if let Some(inc) = inc_fn {
                                      ^0
  459|      0|                this.mir_builder.set_current_block(increment_block);
  460|      0|                inc(this);
  461|      0|                this.mir_builder.set_terminator(Terminator::Goto(cond_block));
  462|      2|            }
  463|      2|        });
  464|       |
  465|      2|        self.mir_builder.set_current_block(exit_block);
  466|      2|        self.current_block = Some(exit_block);
  467|      2|    }
  468|       |
  469|      1|    fn lower_while_statement(&mut self, while_stmt: &WhileStmt) {
  470|      1|        self.lower_loop_generic(
  471|      1|            None::<fn(&mut Self)>,
  472|      1|            Some(|this: &mut Self| this.lower_condition(while_stmt.condition)),
  473|      1|            |this| this.lower_node_ref(while_stmt.body),
  474|      1|            None::<fn(&mut Self)>,
  475|       |            false,
  476|       |        );
  477|      1|    }
  478|       |
  479|      0|    fn lower_do_while_statement(&mut self, body: NodeRef, condition: NodeRef) {
  480|      0|        self.lower_loop_generic(
  481|      0|            None::<fn(&mut Self)>,
  482|      0|            Some(|this: &mut Self| this.lower_condition(condition)),
  483|      0|            |this| this.lower_node_ref(body),
  484|      0|            None::<fn(&mut Self)>,
  485|       |            true,
  486|       |        );
  487|      0|    }
  488|       |
  489|      1|    fn lower_for_statement(&mut self, for_stmt: &ForStmt) {
  490|      1|        let init_fn = for_stmt
  491|      1|            .init
  492|      1|            .map(|init| move |this: &mut Self| this.lower_node_ref(init));
                                                             ^0   ^0             ^0
  493|       |
  494|      1|        let cond_fn = for_stmt
  495|      1|            .condition
  496|      1|            .map(|cond| move |this: &mut Self| this.lower_condition(cond));
  497|       |
  498|      1|        let inc_fn = for_stmt.increment.map(|inc| {
                                                                ^0
  499|      0|            move |this: &mut Self| {
  500|      0|                this.lower_expression(inc, false);
  501|      0|            }
  502|      0|        });
  503|       |
  504|      1|        self.lower_loop_generic(
  505|      1|            init_fn,
  506|      1|            cond_fn,
  507|      1|            |this| this.lower_node_ref(for_stmt.body),
  508|      1|            inc_fn,
  509|       |            false,
  510|       |        );
  511|      1|    }
  512|       |
  513|      0|    fn lower_switch_statement(&mut self, cond: NodeRef, body: NodeRef) {
  514|      0|        let cond_op = self.lower_expression(cond, true);
  515|       |
  516|       |        // Integer promotions on controlling expression are handled by lower_expression if sema did it?
  517|       |        // Semantic analysis should have inserted implicit conversions.
  518|       |        // But we might need to cast case values to this type.
  519|      0|        let cond_ty_id = self.get_operand_type(&cond_op);
  520|       |
  521|      0|        let merge_block = self.mir_builder.create_block();
  522|       |
  523|      0|        let saved_break = self.break_target;
  524|      0|        self.break_target = Some(merge_block);
  525|       |
  526|       |        // Collect cases
  527|      0|        let cases = self.collect_switch_cases(body);
  528|       |
  529|       |        // Create blocks for cases
  530|      0|        let mut case_blocks = Vec::new();
  531|      0|        let mut default_block = None;
  532|       |
  533|      0|        for (node, val_opt) in cases {
  534|      0|            let block = self.mir_builder.create_block();
  535|      0|            self.switch_case_map.insert(node, block);
  536|       |
  537|      0|            if let Some(val) = val_opt {
  538|      0|                case_blocks.push((val, block));
  539|      0|            } else {
  540|      0|                default_block = Some(block);
  541|      0|            }
  542|       |        }
  543|       |
  544|       |        // Generate dispatch
  545|      0|        let fallback_block = default_block.unwrap_or(merge_block);
  546|       |
  547|      0|        for (val_id, target_block) in case_blocks {
  548|      0|            let next_test_block = self.mir_builder.create_block();
  549|      0|            let val_const = self.mir_builder.get_constants().get(&val_id).unwrap().clone();
  550|       |
  551|       |            // Re-create constant with the same type as condition to ensure safe comparison
  552|       |            // This assumes the values are compatible (integral).
  553|       |            // Sema should ensure they are compatible.
  554|       |            // We just cast the constant value to the condition type for the comparison operand.
  555|       |            // Note: `val_const` is already lowered to some type.
  556|       |
  557|      0|            let val_op = Operand::Constant(val_id);
  558|      0|            let cast_val_op = if val_const.ty != cond_ty_id {
  559|      0|                Operand::Cast(cond_ty_id, Box::new(val_op))
  560|       |            } else {
  561|      0|                val_op
  562|       |            };
  563|       |
  564|       |            // Use Eq comparison
  565|       |            // If condition is float (illegal in C switch), we panic?
  566|       |            // Switch only works on integers.
  567|      0|            let cmp_rvalue = Rvalue::BinaryIntOp(BinaryIntOp::Eq, cond_op.clone(), cast_val_op);
  568|      0|            let bool_type_id = self.lower_type(self.registry.type_bool);
  569|      0|            let (_cmp_local, cmp_place) = self.create_temp_local_with_assignment(cmp_rvalue, bool_type_id);
  570|      0|            let cmp_op = Operand::Copy(Box::new(cmp_place));
  571|       |
  572|      0|            self.mir_builder
  573|      0|                .set_terminator(Terminator::If(cmp_op, target_block, next_test_block));
  574|       |
  575|      0|            self.mir_builder.set_current_block(next_test_block);
  576|      0|            self.current_block = Some(next_test_block);
  577|       |        }
  578|       |
  579|       |        // Final jump to default or merge
  580|      0|        self.mir_builder.set_terminator(Terminator::Goto(fallback_block));
  581|       |
  582|       |        // Lower body
  583|       |        // Start a dummy unreachable block for the body entry (to catch unreachable statements)
  584|      0|        let body_entry_dummy = self.mir_builder.create_block();
  585|       |        // Do not jump to it. It is unreachable.
  586|       |
  587|      0|        self.mir_builder.set_current_block(body_entry_dummy);
  588|      0|        self.current_block = Some(body_entry_dummy);
  589|       |
  590|      0|        self.lower_node_ref(body);
  591|       |
  592|       |        // If body falls through, go to merge
  593|      0|        if self.mir_builder.current_block_has_terminator() == false {
  594|      0|            // Check if terminator is Unreachable (default) - if so, we can replace it or just leave it?
  595|      0|            // `current_block_has_terminator` returns false if it is Unreachable.
  596|      0|            // But if we are in body_entry_dummy and it's empty, we shouldn't jump to merge.
  597|      0|            // Actually, if execution falls through the body, it should hit merge.
  598|      0|            // But valid C code falling through end of switch goes to next stmt (merge).
  599|      0|            self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  600|      0|        }
  601|       |
  602|      0|        self.break_target = saved_break;
  603|      0|        self.mir_builder.set_current_block(merge_block);
  604|      0|        self.current_block = Some(merge_block);
  605|      0|    }
  606|       |
  607|      0|    fn lower_case_default_statement(&mut self, node: NodeRef, stmt: NodeRef) {
  608|      0|        let target_block = *self.switch_case_map.get(&node).expect("Case/Default not mapped");
  609|       |
  610|       |        // Fallthrough from previous block
  611|      0|        if !self.mir_builder.current_block_has_terminator() {
  612|      0|            self.mir_builder.set_terminator(Terminator::Goto(target_block));
  613|      0|        }
  614|       |
  615|      0|        self.mir_builder.set_current_block(target_block);
  616|      0|        self.current_block = Some(target_block);
  617|       |
  618|      0|        self.lower_node_ref(stmt);
  619|      0|    }
  620|       |
  621|      0|    fn collect_switch_cases(&mut self, node: NodeRef) -> Vec<(NodeRef, Option<ConstValueId>)> {
  622|      0|        let mut cases = Vec::new();
  623|      0|        self.collect_switch_cases_recursive(node, &mut cases);
  624|      0|        cases
  625|      0|    }
  626|       |
  627|      0|    fn collect_switch_cases_recursive(&mut self, node: NodeRef, cases: &mut Vec<(NodeRef, Option<ConstValueId>)>) {
  628|      0|        let kind = self.ast.get_kind(node).clone();
  629|      0|        match kind {
  630|      0|            NodeKind::Case(expr, stmt) => {
  631|      0|                let op = self.lower_expression(expr, true);
  632|      0|                let val = self.operand_to_const_id_strict(op, "Case label must be constant");
  633|      0|                cases.push((node, Some(val)));
  634|      0|                self.collect_switch_cases_recursive(stmt, cases);
  635|      0|            }
  636|      0|            NodeKind::Default(stmt) => {
  637|      0|                cases.push((node, None));
  638|      0|                self.collect_switch_cases_recursive(stmt, cases);
  639|      0|            }
  640|      0|            NodeKind::Switch(..) => {
  641|      0|                // Do not recurse into nested switch
  642|      0|            }
  643|       |            _ => {
  644|      0|                kind.visit_children(|child| self.collect_switch_cases_recursive(child, cases));
  645|       |            }
  646|       |        }
  647|      0|    }
  648|       |
  649|    125|    pub(crate) fn emit_assignment(&mut self, place: Place, operand: Operand) {
  650|    125|        if self.mir_builder.current_block_has_terminator() {
  651|      0|            return;
  652|    125|        }
  653|       |
  654|       |        // Avoid identity assignments like %x = %x
  655|    125|        if let Operand::Copy(box_place) = &operand
                                           ^32
  656|     32|            && **box_place == place
  657|       |        {
  658|      3|            return;
  659|    122|        }
  660|       |
  661|    122|        let rvalue = Rvalue::Use(operand);
  662|    122|        let stmt = MirStmt::Assign(place, rvalue);
  663|    122|        self.mir_builder.add_statement(stmt);
  664|    125|    }
  665|       |
  666|  1.58k|    pub(crate) fn lower_qual_type(&mut self, ty: QualType) -> TypeId {
  667|  1.58k|        self.lower_type(ty.ty())
  668|  1.58k|    }
  669|       |
  670|  2.13k|    pub(crate) fn lower_type(&mut self, type_ref: TypeRef) -> TypeId {
  671|  2.13k|        if let Some(type_id) = self.type_cache.get(&type_ref) {
                                  ^1.86k
  672|  1.86k|            return *type_id;
  673|    263|        }
  674|       |
  675|       |        // If this type is already being converted, return the placeholder we've inserted earlier
  676|    263|        if self.type_conversion_in_progress.contains(&type_ref) {
  677|      0|            return *self
  678|      0|                .type_cache
  679|      0|                .get(&type_ref)
  680|      0|                .expect("Placeholder must exist for recursive type");
  681|    263|        }
  682|       |
  683|    263|        let ast_type_kind = self.registry.get(type_ref).kind.clone();
  684|       |
  685|    263|        if let TypeKind::Record { .. } = &ast_type_kind {
  686|       |            // Begin conversion: reserve a placeholder TypeId so recursive references can point to it.
  687|     34|            self.type_conversion_in_progress.insert(type_ref);
  688|     34|            let placeholder_name = NameId::new(format!("__recursive_placeholder_{}", type_ref.get()));
  689|     34|            let placeholder_type = MirType::Record {
  690|     34|                name: placeholder_name,
  691|     34|                field_types: Vec::new(),
  692|     34|                field_names: Vec::new(),
  693|     34|                is_union: false,
  694|     34|                layout: MirRecordLayout {
  695|     34|                    size: 0,
  696|     34|                    alignment: 0,
  697|     34|                    field_offsets: Vec::new(),
  698|     34|                },
  699|     34|            };
  700|     34|            let placeholder_id = self.mir_builder.add_type(placeholder_type);
  701|     34|            self.type_cache.insert(type_ref, placeholder_id);
  702|       |
  703|     34|            let mir_type = if let TypeKind::Record {
  704|     34|                tag,
  705|     34|                members,
  706|     34|                is_union,
  707|     34|                is_complete,
  708|     34|            } = &ast_type_kind
  709|       |            {
  710|     34|                self.lower_record_type(type_ref, tag, members, *is_union, *is_complete)
  711|       |            } else {
  712|      0|                unreachable!()
  713|       |            };
  714|       |
  715|       |            // Remove from in-progress set
  716|     34|            self.type_conversion_in_progress.remove(&type_ref);
  717|       |
  718|       |            // Replace the placeholder entry with the real type
  719|     34|            self.mir_builder.update_type(placeholder_id, mir_type);
  720|     34|            placeholder_id
  721|       |        } else {
  722|    229|            let mir_type = match &ast_type_kind {
  723|    148|                TypeKind::Builtin(b) => self.lower_builtin_type(b),
  724|     32|                TypeKind::Pointer { pointee } => self.lower_pointer_type(*pointee),
  725|     24|                TypeKind::Array { element_type, size } => self.lower_array_type(type_ref, *element_type, size),
  726|       |                TypeKind::Function {
  727|     22|                    return_type,
  728|     22|                    parameters,
  729|     22|                    is_variadic,
  730|       |                    ..
  731|     22|                } => self.lower_function_type(return_type, parameters, *is_variadic),
  732|      0|                TypeKind::Record { .. } => unreachable!(),
  733|      3|                _ => MirType::I32,
  734|       |            };
  735|       |
  736|    229|            let type_id = self.mir_builder.add_type(mir_type);
  737|    229|            self.type_cache.insert(type_ref, type_id);
  738|    229|            type_id
  739|       |        }
  740|  2.13k|    }
  741|       |
  742|    148|    fn lower_builtin_type(&self, b: &BuiltinType) -> MirType {
  743|    148|        match b {
  744|      9|            BuiltinType::Void => MirType::Void,
  745|      4|            BuiltinType::Bool => MirType::Bool,
  746|     13|            BuiltinType::Char | BuiltinType::SChar => MirType::I8,
  747|      3|            BuiltinType::UChar => MirType::U8,
  748|      3|            BuiltinType::Short => MirType::I16,
  749|      1|            BuiltinType::UShort => MirType::U16,
  750|     91|            BuiltinType::Int => MirType::I32,
  751|      3|            BuiltinType::UInt => MirType::U32,
  752|      7|            BuiltinType::Long | BuiltinType::LongLong => MirType::I64,
  753|      6|            BuiltinType::ULong | BuiltinType::ULongLong => MirType::U64,
  754|      3|            BuiltinType::Float => MirType::F32,
  755|      5|            BuiltinType::Double | BuiltinType::LongDouble => MirType::F64,
  756|      0|            BuiltinType::Signed => MirType::I32,
  757|       |        }
  758|    148|    }
  759|       |
  760|     32|    fn lower_pointer_type(&mut self, pointee: QualType) -> MirType {
  761|     32|        MirType::Pointer {
  762|     32|            pointee: self.lower_type(pointee.ty()),
  763|     32|        }
  764|     32|    }
  765|       |
  766|     24|    fn lower_array_type(&mut self, type_ref: TypeRef, element_type: TypeRef, size: &ArraySizeType) -> MirType {
  767|     24|        let element = self.lower_type(element_type);
  768|       |
  769|     24|        match size {
  770|     22|            ArraySizeType::Constant(s) => {
  771|     22|                let (layout_size, layout_align, element_ref, _) = self.registry.get_array_layout(type_ref);
  772|     22|                let element_layout = self.registry.get_layout(element_ref);
  773|       |
  774|     22|                MirType::Array {
  775|     22|                    element,
  776|     22|                    size: *s,
  777|     22|                    layout: MirArrayLayout {
  778|     22|                        size: layout_size,
  779|     22|                        align: layout_align,
  780|     22|                        stride: element_layout.size,
  781|     22|                    },
  782|     22|                }
  783|       |            }
  784|       |            _ => {
  785|       |                // For VLA or incomplete array, layout is not computed in registry.
  786|       |                // We use dummy layout (size 0) but try to preserve alignment/stride from element type.
  787|      2|                let (align, stride) = if element_type.is_inline_array()
  788|      2|                    || element_type.is_inline_pointer()
  789|      2|                    || self.registry.types[element_type.index()].layout.is_some()
  790|       |                {
  791|      1|                    let layout = self.registry.get_layout(element_type);
  792|      1|                    (layout.alignment, layout.size)
  793|       |                } else {
  794|       |                    // Element layout also unknown (e.g. nested VLA or incomplete)
  795|      1|                    (1, 0)
  796|       |                };
  797|       |
  798|      2|                MirType::Array {
  799|      2|                    element,
  800|      2|                    size: 0,
  801|      2|                    layout: MirArrayLayout { size: 0, align, stride },
  802|      2|                }
  803|       |            }
  804|       |        }
  805|     24|    }
  806|       |
  807|     22|    fn lower_function_type(
  808|     22|        &mut self,
  809|     22|        return_type: &TypeRef,
  810|     22|        parameters: &[crate::semantic::FunctionParameter],
  811|     22|        is_variadic: bool,
  812|     22|    ) -> MirType {
  813|     22|        let return_type = self.lower_type(*return_type);
  814|     22|        let mut params = Vec::new();
  815|     29|        for p in parameters {
                          ^7
  816|      7|            params.push(self.lower_qual_type(p.param_type));
  817|      7|        }
  818|     22|        MirType::Function {
  819|     22|            return_type,
  820|     22|            params,
  821|     22|            is_variadic,
  822|     22|        }
  823|     22|    }
  824|       |
  825|     34|    fn lower_record_type(
  826|     34|        &mut self,
  827|     34|        type_ref: TypeRef,
  828|     34|        tag: &Option<NameId>,
  829|     34|        members: &[StructMember],
  830|     34|        is_union: bool,
  831|     34|        is_complete: bool,
  832|     34|    ) -> MirType {
  833|     34|        let name = tag.unwrap_or_else(|| NameId::new("anonymous"));
                                                       ^10
  834|       |
  835|     34|        let (size, alignment, field_offsets, field_names, field_types) = if is_complete {
  836|     33|            let (size, alignment, field_layouts, _) = self.registry.get_record_layout(type_ref);
  837|     33|            let field_offsets = field_layouts.iter().map(|f| f.offset).collect();
  838|       |
  839|     33|            let mut field_names = Vec::new();
  840|     33|            let mut field_types = Vec::new();
  841|       |
  842|     60|            for (idx, m) in members.iter().enumerate() {
                                          ^33     ^33    ^33
  843|     60|                let name = m.name.unwrap_or_else(|| NameId::new(format!("__anon_{}", idx)));
                                                                  ^8          ^8      ^8
  844|     60|                field_names.push(name);
  845|     60|                field_types.push(self.lower_qual_type(m.member_type));
  846|       |            }
  847|     33|            (size, alignment, field_offsets, field_names, field_types)
  848|       |        } else {
  849|      1|            (0, 1, Vec::new(), Vec::new(), Vec::new())
  850|       |        };
  851|       |
  852|     34|        MirType::Record {
  853|     34|            name,
  854|     34|            field_types,
  855|     34|            field_names,
  856|     34|            is_union,
  857|     34|            layout: MirRecordLayout {
  858|     34|                size,
  859|     34|                alignment,
  860|     34|                field_offsets,
  861|     34|            },
  862|     34|        }
  863|     34|    }
  864|       |
  865|    527|    pub(crate) fn create_constant(&mut self, ty: TypeId, kind: ConstValueKind) -> ConstValueId {
  866|    527|        self.mir_builder.create_constant(ty, kind)
  867|    527|    }
  868|       |
  869|     49|    pub(crate) fn create_int_operand(&mut self, val: i64) -> Operand {
  870|     49|        let ty_id = self.get_int_type();
  871|     49|        Operand::Constant(self.create_constant(ty_id, ConstValueKind::Int(val)))
  872|     49|    }
  873|       |
  874|      6|    pub(crate) fn create_float_operand(&mut self, val: f64) -> Operand {
  875|      6|        let ty_id = self.lower_type(self.registry.type_double);
  876|      6|        Operand::Constant(self.create_constant(ty_id, ConstValueKind::Float(val)))
  877|      6|    }
  878|       |
  879|    277|    fn emit_conversion(&mut self, operand: Operand, conv: &ImplicitConversion, target_type_id: TypeId) -> Operand {
  880|    277|        let to_mir_type = match conv {
  881|    237|            ImplicitConversion::IntegerCast { to, .. }
  882|     10|            | ImplicitConversion::IntegerPromotion { to, .. }
  883|    258|            | ImplicitConversion::PointerCast { to, .. } => self.lower_type(*to),
                                                              ^11
  884|       |            ImplicitConversion::NullPointerConstant => {
  885|       |                // Null pointer constant usually converts to void* first.
  886|       |                // However, we can use target_type_id if it's already a pointer.
  887|      8|                let void_ptr_mir = self.lower_type(self.registry.type_void_ptr);
  888|      8|                if self.mir_builder.get_type(target_type_id).is_pointer() {
  889|      8|                    target_type_id
  890|       |                } else {
  891|      0|                    void_ptr_mir
  892|       |                }
  893|       |            }
  894|      9|            ImplicitConversion::PointerDecay { to } => self.lower_type(*to),
  895|      0|            ImplicitConversion::LValueToRValue => target_type_id,
  896|      2|            ImplicitConversion::QualifierAdjust { .. } => target_type_id,
  897|       |        };
  898|       |
  899|       |        // Optimization: skip if already same type
  900|    277|        let current_ty = self.get_operand_type(&operand);
  901|    277|        if current_ty == to_mir_type && !matches!(conv, ImplicitConversion::PointerDecay { .. }) {
                                                       ^199     ^199
  902|    199|            return operand;
  903|     78|        }
  904|       |
  905|     78|        match conv {
  906|       |            ImplicitConversion::IntegerCast { .. }
  907|       |            | ImplicitConversion::IntegerPromotion { .. }
  908|     63|            | ImplicitConversion::PointerCast { .. } => Operand::Cast(to_mir_type, Box::new(operand)),
  909|       |            ImplicitConversion::NullPointerConstant => {
  910|      6|                let ty_id = self.lower_type(self.registry.type_int);
  911|      6|                Operand::Cast(
  912|      6|                    to_mir_type,
  913|      6|                    Box::new(Operand::Constant(self.create_constant(ty_id, ConstValueKind::Int(0)))),
  914|      6|                )
  915|       |            }
  916|       |            ImplicitConversion::PointerDecay { .. } => {
  917|      9|                if let Operand::Copy(place) = &operand {
                                                   ^1
  918|      1|                    let addr_of_array = Operand::AddressOf(place.clone());
  919|      1|                    Operand::Cast(to_mir_type, Box::new(addr_of_array))
  920|       |                } else {
  921|       |                    // If it's not a place (e.g. String Literal might be lowered to Constant directly?)
  922|       |                    // String literals usually LValue, so Copy(Place::Global/Local).
  923|      8|                    Operand::Cast(to_mir_type, Box::new(operand))
  924|       |                }
  925|       |            }
  926|      0|            _ => Operand::Cast(target_type_id, Box::new(operand)),
  927|       |        }
  928|    277|    }
  929|       |
  930|    494|    pub(crate) fn get_operand_type(&mut self, operand: &Operand) -> TypeId {
  931|    494|        match operand {
  932|     81|            Operand::Copy(place) => self.get_place_type(place),
  933|    354|            Operand::Constant(const_id) => {
  934|    354|                let const_val = self.mir_builder.get_constants().get(const_id).unwrap();
  935|    354|                const_val.ty
  936|       |            }
  937|     10|            Operand::AddressOf(place) => {
  938|     10|                let pointee = self.get_place_type(place);
  939|     10|                self.mir_builder.add_type(MirType::Pointer { pointee })
  940|       |            }
  941|     49|            Operand::Cast(ty, _) => *ty,
  942|       |        }
  943|    494|    }
  944|       |
  945|    117|    pub(crate) fn get_place_type(&mut self, place: &Place) -> TypeId {
  946|    117|        match place {
  947|     76|            Place::Local(local_id) => self.mir_builder.get_locals().get(local_id).unwrap().type_id,
  948|     12|            Place::Global(global_id) => self.get_global_type(*global_id),
  949|      3|            Place::Deref(operand) => {
  950|      3|                let ptr_ty = self.get_operand_type(operand);
  951|      3|                match self.mir_builder.get_type(ptr_ty) {
  952|      3|                    MirType::Pointer { pointee } => *pointee,
  953|      0|                    _ => panic!("Deref of non-pointer type"),
  954|       |                }
  955|       |            }
  956|     10|            Place::StructField(base, field_idx) => {
  957|     10|                let struct_ty = self.get_place_type(base);
  958|     10|                match self.mir_builder.get_type(struct_ty) {
  959|     10|                    MirType::Record { field_types, .. } => field_types[*field_idx],
  960|      0|                    _ => panic!("StructField access on non-struct type"),
  961|       |                }
  962|       |            }
  963|     16|            Place::ArrayIndex(base, _) => {
  964|     16|                let base_ty = self.get_place_type(base);
  965|     16|                match self.mir_builder.get_type(base_ty) {
  966|     16|                    MirType::Array { element, .. } => *element,
  967|      0|                    MirType::Pointer { pointee, .. } => *pointee,
  968|      0|                    _ => panic!("ArrayIndex access on non-array, non-pointer type"),
  969|       |                }
  970|       |            }
  971|       |        }
  972|    117|    }
  973|       |
  974|     13|    fn get_global_type(&self, global_id: GlobalId) -> TypeId {
  975|     13|        self.mir_builder.get_globals().get(&global_id).unwrap().type_id
  976|     13|    }
  977|       |
  978|     22|    pub(crate) fn get_function_type(&mut self, func_id: MirFunctionId) -> TypeId {
  979|     22|        let func = self.mir_builder.get_functions().get(&func_id).unwrap();
  980|     22|        let ret_ty = func.return_type;
  981|     22|        let mut param_types = Vec::new();
  982|     29|        for &param_id in &func.params {
                           ^7
  983|      7|            param_types.push(self.mir_builder.get_locals().get(&param_id).unwrap().type_id);
  984|      7|        }
  985|     22|        self.mir_builder.add_type(MirType::Function {
  986|     22|            return_type: ret_ty,
  987|     22|            params: param_types,
  988|     22|            is_variadic: func.is_variadic,
  989|     22|        })
  990|     22|    }
  991|       |
  992|    488|    pub(crate) fn apply_conversions(&mut self, operand: Operand, node_ref: NodeRef, target_type_id: TypeId) -> Operand {
  993|       |        // Look up conversions for this node in semantic_info
  994|    488|        if let Some(semantic_info) = &self.ast.semantic_info {
  995|    488|            let idx = node_ref.index();
  996|    488|            if idx < semantic_info.conversions.len() {
  997|    488|                let mut result = operand;
  998|    488|                for conv in &semantic_info.conversions[idx] {
                                  ^277
  999|    277|                    result = self.emit_conversion(result, conv, target_type_id);
 1000|    277|                }
 1001|    488|                return result;
 1002|      0|            }
 1003|      0|        }
 1004|      0|        operand
 1005|    488|    }
 1006|       |
 1007|     49|    pub(crate) fn get_int_type(&mut self) -> TypeId {
 1008|     49|        self.lower_type(self.registry.type_int)
 1009|     49|    }
 1010|       |
 1011|     13|    pub(crate) fn get_char_type(&mut self) -> TypeId {
 1012|     13|        self.lower_type(self.registry.type_char)
 1013|     13|    }
 1014|       |
 1015|     85|    pub(crate) fn create_temp_local(&mut self, type_id: TypeId) -> (LocalId, Place) {
 1016|     85|        let local_id = self.mir_builder.create_local(None, type_id, false);
 1017|     85|        let place = Place::Local(local_id);
 1018|     85|        (local_id, place)
 1019|     85|    }
 1020|       |
 1021|     75|    pub(crate) fn create_temp_local_with_assignment(&mut self, rvalue: Rvalue, type_id: TypeId) -> (LocalId, Place) {
 1022|     75|        let (local_id, place) = self.create_temp_local(type_id);
 1023|     75|        let assign_stmt = MirStmt::Assign(place.clone(), rvalue);
 1024|     75|        self.mir_builder.add_statement(assign_stmt);
 1025|     75|        (local_id, place)
 1026|     75|    }
 1027|       |
 1028|     67|    pub(crate) fn ensure_place(&mut self, operand: Operand, type_id: TypeId) -> Place {
 1029|     67|        if let Operand::Copy(place) = operand {
 1030|     67|            *place
 1031|       |        } else {
 1032|      0|            let (_, temp_place) = self.create_temp_local_with_assignment(Rvalue::Use(operand), type_id);
 1033|      0|            temp_place
 1034|       |        }
 1035|     67|    }
 1036|       |
 1037|     67|    pub(crate) fn emit_rvalue_to_operand(&mut self, rvalue: Rvalue, type_id: TypeId) -> Operand {
 1038|     67|        let (_, place) = self.create_temp_local_with_assignment(rvalue, type_id);
 1039|     67|        Operand::Copy(Box::new(place))
 1040|     67|    }
 1041|       |
 1042|     62|    pub(crate) fn emit_binary_rvalue(&self, op: &BinaryOp, lhs: Operand, rhs: Operand, is_float: bool) -> Rvalue {
 1043|     62|        if is_float {
 1044|      0|            let mir_op = self.map_ast_binary_op_to_mir_float(op);
 1045|      0|            Rvalue::BinaryFloatOp(mir_op, lhs, rhs)
 1046|       |        } else {
 1047|     62|            let mir_op = self.map_ast_binary_op_to_mir_int(op);
 1048|     62|            Rvalue::BinaryIntOp(mir_op, lhs, rhs)
 1049|       |        }
 1050|     62|    }
 1051|       |
 1052|      3|    pub(crate) fn emit_unary_rvalue(&self, op: &UnaryOp, operand: Operand, is_float: bool) -> Rvalue {
 1053|      3|        if is_float {
 1054|      0|            let mir_op = self.map_ast_unary_op_to_mir_float(op);
 1055|      0|            Rvalue::UnaryFloatOp(mir_op, operand)
 1056|       |        } else {
 1057|      3|            let mir_op = self.map_ast_unary_op_to_mir_int(op);
 1058|      3|            Rvalue::UnaryIntOp(mir_op, operand)
 1059|       |        }
 1060|      3|    }
 1061|       |
 1062|     80|    pub(crate) fn operand_to_const_id(&mut self, operand: Operand) -> Option<ConstValueId> {
 1063|     80|        match operand {
 1064|     74|            Operand::Constant(id) => Some(id),
 1065|      5|            Operand::Cast(ty, inner) => {
 1066|       |                // Recursively try to get constant from inner operand
 1067|      5|                if let Some(inner_const_id) = self.operand_to_const_id(*inner) {
 1068|      5|                    let inner_const = self.mir_builder.get_constants().get(&inner_const_id).unwrap();
 1069|       |                    // Create a new constant with the target type but same kind
 1070|      5|                    Some(self.create_constant(ty, inner_const.kind.clone()))
 1071|       |                } else {
 1072|      0|                    None
 1073|       |                }
 1074|       |            }
 1075|      1|            Operand::AddressOf(place) => {
 1076|      1|                if let Place::Global(global_id) = *place {
 1077|      1|                    let global_type = self.get_global_type(global_id);
 1078|      1|                    let ptr_ty = self.mir_builder.add_type(MirType::Pointer { pointee: global_type });
 1079|      1|                    Some(self.create_constant(ptr_ty, ConstValueKind::GlobalAddress(global_id)))
 1080|       |                } else {
 1081|      0|                    None
 1082|       |                }
 1083|       |            }
 1084|      0|            Operand::Copy(place) => {
 1085|      0|                if let Place::Global(global_id) = *place {
 1086|       |                    // In some contexts, a global might be referred to by copy (like array-to-pointer decay)
 1087|       |                    // but for initializers we usually expect AddressOf or Constant.
 1088|       |                    // However, let's be safe.
 1089|      0|                    let global_type = self.get_global_type(global_id);
 1090|      0|                    let ptr_ty = self.mir_builder.add_type(MirType::Pointer { pointee: global_type });
 1091|      0|                    Some(self.create_constant(ptr_ty, ConstValueKind::GlobalAddress(global_id)))
 1092|       |                } else {
 1093|      0|                    None
 1094|       |                }
 1095|       |            }
 1096|       |        }
 1097|     80|    }
 1098|       |
 1099|     62|    fn map_ast_binary_op_to_mir_int(&self, ast_op: &BinaryOp) -> BinaryIntOp {
 1100|     62|        let op = ast_op.without_assignment().unwrap_or(*ast_op);
 1101|     62|        match op {
 1102|      6|            BinaryOp::Add => BinaryIntOp::Add,
 1103|      9|            BinaryOp::Sub => BinaryIntOp::Sub,
 1104|      2|            BinaryOp::Mul => BinaryIntOp::Mul,
 1105|      1|            BinaryOp::Div => BinaryIntOp::Div,
 1106|      2|            BinaryOp::Mod => BinaryIntOp::Mod,
 1107|      0|            BinaryOp::BitAnd => BinaryIntOp::BitAnd,
 1108|      0|            BinaryOp::BitOr => BinaryIntOp::BitOr,
 1109|      0|            BinaryOp::BitXor => BinaryIntOp::BitXor,
 1110|      0|            BinaryOp::LShift => BinaryIntOp::LShift,
 1111|      0|            BinaryOp::RShift => BinaryIntOp::RShift,
 1112|      4|            BinaryOp::Equal => BinaryIntOp::Eq,
 1113|     33|            BinaryOp::NotEqual => BinaryIntOp::Ne,
 1114|      4|            BinaryOp::Less => BinaryIntOp::Lt,
 1115|      0|            BinaryOp::LessEqual => BinaryIntOp::Le,
 1116|      1|            BinaryOp::Greater => BinaryIntOp::Gt,
 1117|      0|            BinaryOp::GreaterEqual => BinaryIntOp::Ge,
 1118|       |            // Logic ops are handled separately (short-circuit)
 1119|      0|            BinaryOp::LogicAnd | BinaryOp::LogicOr => panic!("Logic ops should be handled separately"),
 1120|      0|            BinaryOp::Comma => panic!("Comma op should be handled separately"), // Comma usually handled in expression lowering
 1121|      0|            _ => panic!("Unsupported integer binary operator: {:?}", ast_op),
 1122|       |        }
 1123|     62|    }
 1124|       |
 1125|      0|    fn map_ast_binary_op_to_mir_float(&self, ast_op: &BinaryOp) -> BinaryFloatOp {
 1126|      0|        let op = ast_op.without_assignment().unwrap_or(*ast_op);
 1127|      0|        match op {
 1128|      0|            BinaryOp::Add => BinaryFloatOp::Add,
 1129|      0|            BinaryOp::Sub => BinaryFloatOp::Sub,
 1130|      0|            BinaryOp::Mul => BinaryFloatOp::Mul,
 1131|      0|            BinaryOp::Div => BinaryFloatOp::Div,
 1132|      0|            BinaryOp::Equal => BinaryFloatOp::Eq,
 1133|      0|            BinaryOp::NotEqual => BinaryFloatOp::Ne,
 1134|      0|            BinaryOp::Less => BinaryFloatOp::Lt,
 1135|      0|            BinaryOp::LessEqual => BinaryFloatOp::Le,
 1136|      0|            BinaryOp::Greater => BinaryFloatOp::Gt,
 1137|      0|            BinaryOp::GreaterEqual => BinaryFloatOp::Ge,
 1138|      0|            _ => panic!("Unsupported float binary operator: {:?}", ast_op),
 1139|       |        }
 1140|      0|    }
 1141|       |
 1142|      3|    fn map_ast_unary_op_to_mir_int(&self, ast_op: &UnaryOp) -> UnaryIntOp {
 1143|      3|        match ast_op {
 1144|      0|            UnaryOp::Minus => UnaryIntOp::Neg,
 1145|      0|            UnaryOp::BitNot => UnaryIntOp::BitwiseNot,
 1146|      3|            UnaryOp::LogicNot => UnaryIntOp::LogicalNot,
 1147|      0|            _ => panic!("Unsupported integer unary operator: {:?}", ast_op),
 1148|       |        }
 1149|      3|    }
 1150|       |
 1151|      0|    fn map_ast_unary_op_to_mir_float(&self, ast_op: &UnaryOp) -> UnaryFloatOp {
 1152|      0|        match ast_op {
 1153|      0|            UnaryOp::Minus => UnaryFloatOp::Neg,
 1154|      0|            _ => panic!("Unsupported float unary operator: {:?}", ast_op),
 1155|       |        }
 1156|      0|    }
 1157|       |
 1158|      2|    fn with_loop_targets<F>(&mut self, break_target: MirBlockId, continue_target: MirBlockId, f: F)
 1159|      2|    where
 1160|      2|        F: FnOnce(&mut Self),
 1161|       |    {
 1162|      2|        let old_break = self.break_target.replace(break_target);
 1163|      2|        let old_continue = self.continue_target.replace(continue_target);
 1164|       |
 1165|      2|        f(self);
 1166|       |
 1167|      2|        self.break_target = old_break;
 1168|      2|        self.continue_target = old_continue;
 1169|      2|    }
 1170|       |
 1171|  1.25k|    fn scan_for_labels(&mut self, node_ref: NodeRef) {
 1172|  1.25k|        let node_kind = self.ast.get_kind(node_ref).clone();
 1173|  1.25k|        if let NodeKind::Label(name, _, _) = node_kind
                                             ^6
 1174|      6|            && !self.label_map.contains_key(&name)
 1175|      6|        {
 1176|      6|            let block_id = self.mir_builder.create_block();
 1177|      6|            self.label_map.insert(name, block_id);
 1178|  1.24k|        }
 1179|  1.25k|        node_kind.visit_children(|child| self.scan_for_labels(child));
                                                       ^1.14k^1.14k          ^1.14k
 1180|  1.25k|    }
 1181|       |
 1182|      3|    fn lower_goto_statement(&mut self, label_name: &NameId) {
 1183|      3|        if let Some(target_block) = self.label_map.get(label_name).copied() {
 1184|      3|            self.mir_builder.set_terminator(Terminator::Goto(target_block));
 1185|      3|        } else {
 1186|       |            // This should be caught by semantic analysis, but we panic as a safeguard
 1187|      0|            panic!("Goto to undefined label '{}'", label_name.as_str());
 1188|       |        }
 1189|      3|    }
 1190|       |
 1191|      6|    fn lower_label_statement(&mut self, label_name: &NameId, statement: NodeRef) {
 1192|      6|        if let Some(label_block) = self.label_map.get(label_name).copied() {
 1193|       |            // Make sure the current block is terminated before switching
 1194|      6|            if !self.mir_builder.current_block_has_terminator() {
 1195|      3|                self.mir_builder.set_terminator(Terminator::Goto(label_block));
 1196|      3|            }
 1197|       |
 1198|      6|            self.mir_builder.set_current_block(label_block);
 1199|      6|            self.current_block = Some(label_block);
 1200|       |
 1201|       |            // Now, lower the statement that follows the label
 1202|      6|            self.lower_node_ref(statement);
 1203|       |        } else {
 1204|      0|            panic!("Label '{}' was not pre-scanned", label_name.as_str());
 1205|       |        }
 1206|      6|    }
 1207|       |
 1208|    115|    fn define_or_declare_function(
 1209|    115|        &mut self,
 1210|    115|        name: NameId,
 1211|    115|        params: Vec<TypeId>,
 1212|    115|        ret: TypeId,
 1213|    115|        variadic: bool,
 1214|    115|        is_def: bool,
 1215|    115|    ) {
 1216|    115|        if is_def {
 1217|    110|            self.mir_builder.define_function(name, params, ret, variadic);
 1218|    110|        } else {
 1219|      5|            self.mir_builder.declare_function(name, params, ret, variadic);
 1220|      5|        }
 1221|    115|    }
 1222|       |}

/app/src/semantic/const_eval.rs:
    1|       |//! Constant expression evaluation
    2|       |//!
    3|       |//! This module provides the functionality to evaluate constant expressions
    4|       |//! at compile time, as required by the C11 standard for contexts like
    5|       |//! static assertions and array sizes.
    6|       |
    7|       |use crate::ast::{Ast, BinaryOp, NodeKind, NodeRef, UnaryOp, literal};
    8|       |use crate::semantic::{SymbolKind, SymbolTable};
    9|       |
   10|       |/// Context for constant expression evaluation
   11|       |pub(crate) struct ConstEvalCtx<'a> {
   12|       |    pub(crate) ast: &'a Ast,
   13|       |    pub(crate) symbol_table: &'a SymbolTable,
   14|       |}
   15|       |
   16|       |/// Evaluate a constant expression node to an i64 value
   17|    299|pub(crate) fn eval_const_expr(ctx: &ConstEvalCtx, expr_node_ref: NodeRef) -> Option<i64> {
   18|    299|    let node_kind = ctx.ast.get_kind(expr_node_ref);
   19|     87|    match node_kind {
   20|     87|        NodeKind::Literal(literal::Literal::Int { val, .. }) => Some(*val),
   21|      0|        NodeKind::Literal(literal::Literal::Char(val)) => Some(*val as i64),
   22|     37|        NodeKind::Ident(_, sym_ref) => {
   23|     37|            let symbol = ctx.symbol_table.get_symbol(*sym_ref);
   24|     37|            if let SymbolKind::EnumConstant { value } = &symbol.kind {
                                                            ^1
   25|      1|                Some(*value)
   26|       |            } else {
   27|     36|                None
   28|       |            }
   29|       |        }
   30|     88|        NodeKind::BinaryOp(op, left_ref, right_ref) => {
   31|     88|            let left_val = eval_const_expr(ctx, *left_ref)?;
                              ^19                                       ^69
   32|     19|            let right_val = eval_const_expr(ctx, *right_ref)?;
                              ^18                                         ^1
   33|     18|            match op {
   34|      2|                BinaryOp::Add => Some(left_val.wrapping_add(right_val)),
   35|      1|                BinaryOp::Sub => Some(left_val.wrapping_sub(right_val)),
   36|      1|                BinaryOp::Mul => Some(left_val.wrapping_mul(right_val)),
   37|       |                BinaryOp::Div => {
   38|      0|                    if right_val != 0 {
   39|      0|                        Some(left_val.wrapping_div(right_val))
   40|       |                    } else {
   41|      0|                        None
   42|       |                    }
   43|       |                }
   44|      5|                BinaryOp::Equal => Some((left_val == right_val) as i64),
   45|      1|                BinaryOp::NotEqual => Some((left_val != right_val) as i64),
   46|      2|                BinaryOp::Less => Some((left_val < right_val) as i64),
   47|      1|                BinaryOp::LessEqual => Some((left_val <= right_val) as i64),
   48|      1|                BinaryOp::Greater => Some((left_val > right_val) as i64),
   49|      1|                BinaryOp::GreaterEqual => Some((left_val >= right_val) as i64),
   50|      1|                BinaryOp::LogicAnd => Some(((left_val != 0) && (right_val != 0)) as i64),
   51|      2|                BinaryOp::LogicOr => Some(((left_val != 0) || (right_val != 0)) as i64),
                                                                            ^1
   52|      0|                _ => None,
   53|       |            }
   54|       |        }
   55|     37|        NodeKind::UnaryOp(op, operand_ref) => {
   56|     37|            let operand_val = eval_const_expr(ctx, *operand_ref)?;
                              ^12                                             ^25
   57|     12|            match op {
   58|      1|                UnaryOp::LogicNot => Some((operand_val == 0) as i64),
   59|      1|                UnaryOp::Plus => Some(operand_val),
   60|      9|                UnaryOp::Minus => Some(operand_val.wrapping_neg()),
   61|      1|                UnaryOp::BitNot => Some(!operand_val),
   62|      0|                _ => None,
   63|       |            }
   64|       |        }
   65|     50|        _ => None,
   66|       |    }
   67|    299|}

/app/src/semantic/conversions.rs:
    1|       |//! Implements C11 semantic conversions, such as usual arithmetic conversions
    2|       |//! and integer promotions.
    3|       |
    4|       |use crate::semantic::{BuiltinType, QualType, TypeRegistry};
    5|       |
    6|       |/// Performs the "usual arithmetic conversions" as specified in C11 6.3.1.8.
    7|     77|pub(crate) fn usual_arithmetic_conversions(ctx: &TypeRegistry, lhs: QualType, rhs: QualType) -> Option<QualType> {
    8|       |    // Floating point conversions
    9|     77|    if lhs.ty().builtin() == Some(BuiltinType::LongDouble) || rhs.ty().builtin() == Some(BuiltinType::LongDouble) {
   10|      0|        return Some(QualType::unqualified(ctx.type_long_double));
   11|     77|    }
   12|     77|    if lhs.ty().builtin() == Some(BuiltinType::Double) || rhs.ty().builtin() == Some(BuiltinType::Double) {
   13|      0|        return Some(QualType::unqualified(ctx.type_double));
   14|     77|    }
   15|     77|    if lhs.ty().builtin() == Some(BuiltinType::Float) || rhs.ty().builtin() == Some(BuiltinType::Float) {
   16|      0|        return Some(QualType::unqualified(ctx.type_float));
   17|     77|    }
   18|       |
   19|       |    // Integer conversions
   20|     77|    let lhs_promoted = integer_promotion(ctx, lhs);
   21|     77|    let rhs_promoted = integer_promotion(ctx, rhs);
   22|       |
   23|     77|    if lhs_promoted.ty() == rhs_promoted.ty() {
   24|     61|        return Some(lhs_promoted);
   25|     16|    }
   26|       |
   27|     16|    let (lhs_signed, lhs_rank) = get_int_type_details(lhs_promoted.ty().builtin());
   28|     16|    let (rhs_signed, rhs_rank) = get_int_type_details(rhs_promoted.ty().builtin());
   29|       |
   30|     16|    if lhs_signed == rhs_signed {
   31|      3|        return Some(if lhs_rank >= rhs_rank {
   32|      2|            lhs_promoted
   33|       |        } else {
   34|      1|            rhs_promoted
   35|       |        });
   36|     13|    }
   37|       |
   38|     13|    if !lhs_signed && lhs_rank >= rhs_rank {
                                    ^11
   39|     11|        return Some(lhs_promoted);
   40|      2|    }
   41|      2|    if !rhs_signed && rhs_rank >= lhs_rank {
   42|      2|        return Some(rhs_promoted);
   43|      0|    }
   44|       |
   45|      0|    if lhs_signed {
   46|      0|        if lhs_rank > rhs_rank {
   47|      0|            return Some(lhs_promoted);
   48|      0|        }
   49|      0|    } else if rhs_rank > lhs_rank {
   50|      0|        return Some(rhs_promoted);
   51|      0|    }
   52|       |
   53|      0|    None
   54|     77|}
   55|       |
   56|       |/// Performs integer promotions as specified in C11 6.3.1.1.
   57|    338|pub(crate) fn integer_promotion(ctx: &TypeRegistry, ty: QualType) -> QualType {
   58|    338|    if let Some(builtin) = ty.ty().builtin() {
                              ^330
   59|    330|        match builtin {
   60|       |            BuiltinType::Bool
   61|       |            | BuiltinType::Char
   62|       |            | BuiltinType::SChar
   63|       |            | BuiltinType::UChar
   64|       |            | BuiltinType::Short
   65|     10|            | BuiltinType::UShort => QualType::unqualified(ctx.type_int),
   66|    320|            _ => ty,
   67|       |        }
   68|       |    } else {
   69|      8|        ty
   70|       |    }
   71|    338|}
   72|       |
   73|       |/// Performs default argument promotions as specified in C11 6.5.2.2.
   74|      4|pub(crate) fn default_argument_promotions(ctx: &TypeRegistry, ty: QualType) -> QualType {
   75|      4|    if let Some(builtin) = ty.ty().builtin() {
                              ^3
   76|      3|        match builtin {
   77|      0|            BuiltinType::Float => QualType::unqualified(ctx.type_double),
   78|      3|            _ => integer_promotion(ctx, ty),
   79|       |        }
   80|       |    } else {
   81|      1|        ty
   82|       |    }
   83|      4|}
   84|       |
   85|     32|fn get_int_type_details(builtin: Option<BuiltinType>) -> (bool, u8) {
   86|       |    // (is_signed, rank)
   87|       |    // Rank: Bool=1, Char=2, Short=3, Int=4, Long=5, LongLong=6
   88|     32|    match builtin {
   89|      0|        Some(BuiltinType::Bool) => (false, 1), // _Bool is unsigned
   90|      0|        Some(BuiltinType::Char) => (true, 2),  // Assuming char is signed
   91|      0|        Some(BuiltinType::SChar) => (true, 2),
   92|      0|        Some(BuiltinType::UChar) => (false, 2),
   93|      0|        Some(BuiltinType::Short) => (true, 3),
   94|      0|        Some(BuiltinType::UShort) => (false, 3),
   95|     16|        Some(BuiltinType::Int) => (true, 4),
   96|      1|        Some(BuiltinType::UInt) => (false, 4),
   97|      1|        Some(BuiltinType::Long) => (true, 5),
   98|     12|        Some(BuiltinType::ULong) => (false, 5),
   99|      2|        Some(BuiltinType::LongLong) => (true, 6),
  100|      0|        Some(BuiltinType::ULongLong) => (false, 6),
  101|      0|        _ => (false, 0),
  102|       |    }
  103|     32|}

/app/src/semantic/lower_expression.rs:
    1|       |use crate::ast::{BinaryOp, NodeKind, NodeRef, UnaryOp};
    2|       |use crate::mir::{
    3|       |    BinaryIntOp, CallTarget, ConstValue, ConstValueKind, MirStmt, Operand, Place, Rvalue, Terminator, TypeId,
    4|       |};
    5|       |use crate::semantic::ast_to_mir::AstToMirLowerer;
    6|       |use crate::semantic::const_eval::{ConstEvalCtx, eval_const_expr};
    7|       |use crate::semantic::{QualType, SymbolKind, SymbolRef, TypeKind, ValueCategory};
    8|       |use crate::{ast, semantic};
    9|       |
   10|       |impl<'a> AstToMirLowerer<'a> {
   11|     67|    pub(crate) fn lower_expression_as_place(&mut self, expr_ref: NodeRef) -> Place {
   12|     67|        let op = self.lower_expression(expr_ref, true);
   13|     67|        let ty = self.ast.get_resolved_type(expr_ref).unwrap();
   14|     67|        let mir_ty = self.lower_qual_type(ty);
   15|     67|        self.ensure_place(op, mir_ty)
   16|     67|    }
   17|       |
   18|    765|    pub(crate) fn lower_expression(&mut self, expr_ref: NodeRef, need_value: bool) -> Operand {
   19|    765|        let ty = self.ast.get_resolved_type(expr_ref).unwrap_or_else(|| {
                                                                                      ^0
   20|      0|            let node_kind = self.ast.get_kind(expr_ref);
   21|      0|            let node_span = self.ast.get_span(expr_ref);
   22|      0|            panic!("Type not resolved for node {:?} at {:?}", node_kind, node_span);
   23|       |        });
   24|    765|        let node_kind = self.ast.get_kind(expr_ref).clone();
   25|       |
   26|    765|        let mir_ty = self.lower_qual_type(ty);
   27|       |
   28|       |        // Attempt constant folding for arithmetic/logical operations that are not simple literals
   29|    679|        if matches!(
   30|    765|            node_kind,
   31|       |            NodeKind::BinaryOp(..) | NodeKind::UnaryOp(..) | NodeKind::TernaryOp(..)
   32|       |        ) {
   33|     86|            let ctx = ConstEvalCtx {
   34|     86|                ast: self.ast,
   35|     86|                symbol_table: self.symbol_table,
   36|     86|            };
   37|     86|            if let Some(val) = eval_const_expr(&ctx, expr_ref) {
                                      ^3
   38|      3|                let ty_id = self.lower_qual_type(ty);
   39|      3|                return Operand::Constant(self.create_constant(ty_id, ConstValueKind::Int(val)));
   40|     83|            }
   41|    679|        }
   42|       |
   43|    762|        match &node_kind {
   44|    314|            NodeKind::Literal(_) => self.lower_literal(&node_kind, ty).expect("Failed to lower literal"),
   45|    189|            NodeKind::Ident(_, symbol_ref) => self.lower_ident(*symbol_ref),
   46|     20|            NodeKind::UnaryOp(op, operand_ref) => self.lower_unary_op_expr(op, *operand_ref, mir_ty),
   47|      1|            NodeKind::PostIncrement(operand_ref) => self.lower_post_incdec(*operand_ref, true, need_value),
   48|      2|            NodeKind::PostDecrement(operand_ref) => self.lower_post_incdec(*operand_ref, false, need_value),
   49|     59|            NodeKind::BinaryOp(op, left_ref, right_ref) => self.lower_binary_op_expr(op, *left_ref, *right_ref, mir_ty),
   50|     60|            NodeKind::Assignment(op, left_ref, right_ref) => {
   51|     60|                self.lower_assignment_expr(expr_ref, op, *left_ref, *right_ref, mir_ty)
   52|       |            }
   53|     21|            NodeKind::FunctionCall(call_expr) => {
   54|     21|                let temp_place = if need_value {
   55|      6|                    let (_, temp_place) = self.create_temp_local(mir_ty);
   56|      6|                    Some(temp_place)
   57|       |                } else {
   58|     15|                    None
   59|       |                };
   60|       |
   61|     21|                self.lower_function_call(call_expr, temp_place.clone());
   62|       |
   63|     21|                if need_value {
   64|      6|                    Operand::Copy(Box::new(temp_place.unwrap()))
   65|       |                } else {
   66|       |                    // dummy
   67|     15|                    self.create_dummy_operand()
   68|       |                }
   69|       |            }
   70|     48|            NodeKind::MemberAccess(obj_ref, field_name, is_arrow) => {
   71|     48|                self.lower_member_access(*obj_ref, field_name, *is_arrow)
   72|       |            }
   73|     19|            NodeKind::IndexAccess(arr_ref, idx_ref) => self.lower_index_access(*arr_ref, *idx_ref),
   74|      4|            NodeKind::TernaryOp(cond, then, else_expr) => self.lower_ternary_op(*cond, *then, *else_expr, mir_ty),
   75|     11|            NodeKind::SizeOfExpr(expr) => self.lower_sizeof_expr(*expr),
   76|      3|            NodeKind::SizeOfType(ty) => self.lower_sizeof_type(ty),
   77|      0|            NodeKind::AlignOf(ty) => self.lower_alignof_type(ty),
   78|      5|            NodeKind::GenericSelection(gs) => self.lower_generic_selection(gs, need_value),
   79|      0|            NodeKind::GnuStatementExpression(_stmt, _) => {
   80|      0|                panic!("GnuStatementExpression not implemented");
   81|       |            }
   82|      6|            NodeKind::Cast(_ty, operand_ref) => self.lower_cast(*operand_ref, mir_ty),
   83|      0|            NodeKind::CompoundLiteral(ty, init_ref) => self.lower_compound_literal(*ty, *init_ref),
   84|      0|            NodeKind::BuiltinVaArg(ty, expr) => self.lower_builtin_va_arg(*ty, *expr),
   85|      0|            NodeKind::BuiltinVaStart(ap, last) => self.lower_builtin_va_start(*ap, *last),
   86|      0|            NodeKind::BuiltinVaEnd(ap) => self.lower_builtin_va_end(*ap),
   87|      0|            NodeKind::BuiltinVaCopy(dst, src) => self.lower_builtin_va_copy(*dst, *src),
   88|       |            NodeKind::InitializerList(_) | NodeKind::InitializerItem(_) => {
   89|       |                // Should be lowered in context of assignment usually.
   90|      0|                panic!("InitializerList or InitializerItem not implemented");
   91|       |            }
   92|      0|            _ => unreachable!(),
   93|       |        }
   94|    765|    }
   95|       |
   96|      4|    pub(crate) fn lower_ternary_op(
   97|      4|        &mut self,
   98|      4|        cond: NodeRef,
   99|      4|        then_expr: NodeRef,
  100|      4|        else_expr: NodeRef,
  101|      4|        mir_ty: TypeId,
  102|      4|    ) -> Operand {
  103|      4|        let cond_op = self.lower_expression(cond, true);
  104|       |
  105|      4|        let then_block = self.mir_builder.create_block();
  106|      4|        let else_block = self.mir_builder.create_block();
  107|      4|        let exit_block = self.mir_builder.create_block();
  108|       |
  109|      4|        self.mir_builder
  110|      4|            .set_terminator(Terminator::If(cond_op, then_block, else_block));
  111|       |
  112|       |        // Result local
  113|      4|        let result_local = self.mir_builder.create_local(None, mir_ty, false);
  114|       |
  115|       |        // Then
  116|      4|        self.mir_builder.set_current_block(then_block);
  117|      4|        let then_val = self.lower_expression(then_expr, true);
  118|      4|        let then_val_conv = self.apply_conversions(then_val, then_expr, mir_ty);
  119|      4|        self.emit_assignment(Place::Local(result_local), then_val_conv);
  120|      4|        self.mir_builder.set_terminator(Terminator::Goto(exit_block));
  121|       |
  122|       |        // Else
  123|      4|        self.mir_builder.set_current_block(else_block);
  124|      4|        let else_val = self.lower_expression(else_expr, true);
  125|      4|        let else_val_conv = self.apply_conversions(else_val, else_expr, mir_ty);
  126|      4|        self.emit_assignment(Place::Local(result_local), else_val_conv);
  127|      4|        self.mir_builder.set_terminator(Terminator::Goto(exit_block));
  128|       |
  129|      4|        self.mir_builder.set_current_block(exit_block);
  130|       |
  131|      4|        Operand::Copy(Box::new(Place::Local(result_local)))
  132|      4|    }
  133|       |
  134|     11|    pub(crate) fn lower_sizeof_expr(&mut self, expr: NodeRef) -> Operand {
  135|     11|        let operand_ty = self
  136|     11|            .ast
  137|     11|            .get_resolved_type(expr)
  138|     11|            .expect("SizeOf operand type missing")
  139|     11|            .ty();
  140|     11|        self.lower_type_query(operand_ty, true)
  141|     11|    }
  142|       |
  143|      3|    pub(crate) fn lower_sizeof_type(&mut self, ty: &QualType) -> Operand {
  144|      3|        self.lower_type_query(ty.ty(), true)
  145|      3|    }
  146|       |
  147|      0|    pub(crate) fn lower_alignof_type(&mut self, ty: &QualType) -> Operand {
  148|      0|        self.lower_type_query(ty.ty(), false)
  149|      0|    }
  150|       |
  151|     14|    pub(crate) fn lower_type_query(&mut self, ty: semantic::TypeRef, is_size: bool) -> Operand {
  152|     14|        let layout = self.registry.get_layout(ty);
  153|     14|        let val = if is_size { layout.size } else { layout.alignment };
                                                                  ^0
  154|     14|        self.create_int_operand(val as i64)
  155|     14|    }
  156|       |
  157|      5|    pub(crate) fn lower_generic_selection(
  158|      5|        &mut self,
  159|      5|        gs: &ast::nodes::GenericSelectionData,
  160|      5|        need_value: bool,
  161|      5|    ) -> Operand {
  162|      5|        let ctrl_ty = self
  163|      5|            .ast
  164|      5|            .get_resolved_type(gs.control)
  165|      5|            .expect("Controlling expr type missing")
  166|      5|            .ty();
  167|       |        // Apply decay to array/function types before matching.
  168|      5|        let decayed_ctrl_ty = if ctrl_ty.is_array() || ctrl_ty.is_function() {
                                                                     ^4      ^4
  169|      2|            self.registry
  170|      2|                .decay(QualType::unqualified(ctrl_ty), Default::default())
  171|      2|                .ty()
  172|       |        } else {
  173|      3|            ctrl_ty
  174|       |        };
  175|      5|        let unqualified_ctrl = self.registry.strip_all(QualType::unqualified(decayed_ctrl_ty));
  176|       |
  177|      5|        let mut selected_expr = None;
  178|      5|        let mut default_expr = None;
  179|       |
  180|      8|        for assoc_node_ref in gs.assoc_start.range(gs.assoc_len) {
                                            ^5             ^5    ^5
  181|      8|            if let NodeKind::GenericAssociation(ga) = self.ast.get_kind(assoc_node_ref) {
  182|      8|                if let Some(ty) = ga.ty {
                                          ^6
  183|      6|                    if self.registry.is_compatible(unqualified_ctrl, ty) {
  184|      4|                        selected_expr = Some(ga.result_expr);
  185|      4|                        break;
  186|      2|                    }
  187|      2|                } else {
  188|      2|                    default_expr = Some(ga.result_expr);
  189|      2|                }
  190|      0|            }
  191|       |        }
  192|       |
  193|      5|        let expr_to_lower = selected_expr
  194|      5|            .or(default_expr)
  195|      5|            .expect("Generic selection failed (should be caught by Analyzer)");
  196|      5|        self.lower_expression(expr_to_lower, need_value)
  197|      5|    }
  198|       |
  199|      6|    pub(crate) fn lower_cast(&mut self, operand_ref: NodeRef, mir_ty: TypeId) -> Operand {
  200|      6|        let operand = self.lower_expression(operand_ref, true);
  201|      6|        Operand::Cast(mir_ty, Box::new(operand))
  202|      6|    }
  203|       |
  204|    314|    pub(crate) fn lower_literal(&mut self, node_kind: &NodeKind, ty: QualType) -> Option<Operand> {
  205|    314|        let mir_ty = self.lower_qual_type(ty);
  206|    314|        match node_kind {
  207|    314|            NodeKind::Literal(literal) => match literal {
  208|    293|                crate::ast::literal::Literal::Int { val, .. } => Some(Operand::Constant(
  209|    293|                    self.create_constant(mir_ty, ConstValueKind::Int(*val)),
  210|    293|                )),
  211|      6|                crate::ast::literal::Literal::Float(val) => Some(self.create_float_operand(*val)),
  212|      7|                crate::ast::literal::Literal::Char(val) => Some(Operand::Constant(
  213|      7|                    self.create_constant(mir_ty, ConstValueKind::Int(*val as i64)),
  214|      7|                )),
  215|      8|                crate::ast::literal::Literal::String(val) => Some(self.lower_literal_string(val, ty)),
  216|       |            },
  217|      0|            _ => None,
  218|       |        }
  219|    314|    }
  220|       |
  221|     20|    pub(crate) fn lower_unary_op_expr(&mut self, op: &UnaryOp, operand_ref: NodeRef, mir_ty: TypeId) -> Operand {
  222|     20|        match op {
  223|      2|            UnaryOp::PreIncrement | UnaryOp::PreDecrement => self.lower_pre_incdec(op, operand_ref),
  224|     14|            UnaryOp::AddrOf => self.lower_unary_addrof(operand_ref),
  225|      1|            UnaryOp::Deref => self.lower_unary_deref(operand_ref),
  226|      0|            UnaryOp::Plus => self.lower_expression(operand_ref, true),
  227|       |            _ => {
  228|      3|                let operand = self.lower_expression(operand_ref, true);
  229|      3|                let operand_ty = self.get_operand_type(&operand);
  230|      3|                let mir_type_info = self.mir_builder.get_type(operand_ty);
  231|       |
  232|      3|                let rval = self.emit_unary_rvalue(op, operand, mir_type_info.is_float());
  233|      3|                self.emit_rvalue_to_operand(rval, mir_ty)
  234|       |            }
  235|       |        }
  236|     20|    }
  237|       |
  238|     14|    pub(crate) fn lower_unary_addrof(&mut self, operand_ref: NodeRef) -> Operand {
  239|     14|        let operand = self.lower_expression(operand_ref, true);
  240|     14|        if let Operand::Copy(place) = operand {
                                           ^13
  241|     13|            Operand::AddressOf(place)
  242|      1|        } else if let Operand::Constant(const_id) = operand
  243|      1|            && self.ast.get_value_category(operand_ref) == Some(ValueCategory::LValue)
  244|      0|            && matches!(
  245|      1|                self.mir_builder.get_constants().get(&const_id),
  246|       |                Some(ConstValue {
  247|       |                    kind: ConstValueKind::FunctionAddress(_),
  248|       |                    ..
  249|       |                })
  250|       |            )
  251|       |        {
  252|      1|            Operand::Constant(const_id)
  253|       |        } else {
  254|      0|            panic!("Cannot take address of a non-lvalue");
  255|       |        }
  256|     14|    }
  257|       |
  258|      1|    pub(crate) fn lower_unary_deref(&mut self, operand_ref: NodeRef) -> Operand {
  259|      1|        let operand = self.lower_expression(operand_ref, true);
  260|      1|        let operand_ty = self.ast.get_resolved_type(operand_ref).unwrap();
  261|      1|        let target_mir_ty = self.lower_qual_type(operand_ty);
  262|      1|        let operand_converted = self.apply_conversions(operand, operand_ref, target_mir_ty);
  263|       |
  264|      1|        let place = Place::Deref(Box::new(operand_converted));
  265|      1|        Operand::Copy(Box::new(place))
  266|      1|    }
  267|       |
  268|    189|    pub(crate) fn lower_ident(&mut self, resolved_ref: SymbolRef) -> Operand {
  269|    189|        let entry = self.symbol_table.get_symbol(resolved_ref);
  270|       |
  271|    189|        match &entry.kind {
  272|    165|            SymbolKind::Variable { is_global, .. } => {
  273|    165|                if *is_global {
  274|       |                    // Global variables should have been lowered already if we are visiting in order.
  275|     18|                    let global_id = match self.global_map.get(&resolved_ref) {
  276|     18|                        Some(id) => id,
  277|       |                        None => {
  278|      0|                            panic!(
  279|      0|                                "Global variable '{}' not found in MIR map. Visited? {:?}",
  280|       |                                entry.name,
  281|      0|                                self.global_map.keys()
  282|       |                            );
  283|       |                        }
  284|       |                    };
  285|     18|                    Operand::Copy(Box::new(Place::Global(*global_id)))
  286|       |                } else {
  287|    147|                    let local_id = self.local_map.get(&resolved_ref).unwrap();
  288|    147|                    Operand::Copy(Box::new(Place::Local(*local_id)))
  289|       |                }
  290|       |            }
  291|       |            SymbolKind::Function { .. } => {
  292|     22|                let func_id = self
  293|     22|                    .mir_builder
  294|     22|                    .get_functions()
  295|     22|                    .iter()
  296|    111|                    .find(|(_, f)| f.name == entry.name)
                                   ^22
  297|     22|                    .map(|(id, _)| *id)
  298|     22|                    .unwrap();
  299|     22|                let func_type = self.get_function_type(func_id);
  300|     22|                Operand::Constant(self.create_constant(func_type, ConstValueKind::FunctionAddress(func_id)))
  301|       |            }
  302|      2|            SymbolKind::EnumConstant { value } => self.create_int_operand(*value),
  303|      0|            _ => panic!("Unexpected symbol kind"),
  304|       |        }
  305|    189|    }
  306|       |
  307|     55|    pub(crate) fn unify_binary_operands(
  308|     55|        &mut self,
  309|     55|        mut lhs: Operand,
  310|     55|        mut rhs: Operand,
  311|     55|        lhs_mir_ty: TypeId,
  312|     55|        rhs_mir_ty: TypeId,
  313|     55|    ) -> (Operand, Operand) {
  314|     55|        if lhs_mir_ty != rhs_mir_ty {
  315|     12|            let lhs_mir = self.mir_builder.get_type(lhs_mir_ty);
  316|     12|            let rhs_mir = self.mir_builder.get_type(rhs_mir_ty);
  317|       |
  318|     12|            if lhs_mir.is_int() && rhs_mir.is_int() {
  319|     12|                let w1 = lhs_mir.width();
  320|     12|                let w2 = rhs_mir.width();
  321|     12|                if w1 > w2 {
  322|      1|                    rhs = Operand::Cast(lhs_mir_ty, Box::new(rhs));
  323|     11|                } else if w2 > w1 {
  324|     11|                    lhs = Operand::Cast(rhs_mir_ty, Box::new(lhs));
  325|     11|                }
                              ^0
  326|      0|            } else if lhs_mir.is_pointer() && rhs_mir.is_int() {
  327|      0|                rhs = Operand::Cast(lhs_mir_ty, Box::new(rhs));
  328|      0|            } else if lhs_mir.is_int() && rhs_mir.is_pointer() {
  329|      0|                lhs = Operand::Cast(rhs_mir_ty, Box::new(lhs));
  330|      0|            }
  331|     43|        }
  332|     55|        (lhs, rhs)
  333|     55|    }
  334|       |
  335|     59|    pub(crate) fn lower_binary_op_expr(
  336|     59|        &mut self,
  337|     59|        op: &BinaryOp,
  338|     59|        left_ref: NodeRef,
  339|     59|        right_ref: NodeRef,
  340|     59|        mir_ty: TypeId,
  341|     59|    ) -> Operand {
  342|     59|        debug_assert!(
  343|     59|            !op.is_assignment(),
  344|      0|            "lower_binary_op_expr called with assignment operator: {:?}",
  345|       |            op
  346|       |        );
  347|     59|        if matches!(op, BinaryOp::LogicAnd | BinaryOp::LogicOr) {
                         ^55
  348|      4|            return self.lower_logical_op(op, left_ref, right_ref, mir_ty);
  349|     55|        }
  350|       |
  351|     55|        let lhs = self.lower_expression(left_ref, true);
  352|     55|        let rhs = self.lower_expression(right_ref, true);
  353|       |
  354|       |        // Handle pointer arithmetic
  355|       |
  356|     55|        if let Some(rval) = self.lower_pointer_arithmetic(op, lhs.clone(), rhs.clone(), left_ref, right_ref) {
                                  ^0
  357|      0|            return self.emit_rvalue_to_operand(rval, mir_ty);
  358|     55|        }
  359|       |
  360|       |        // Apply implicit conversions from semantic info first to match AST
  361|     55|        let lhs_converted = self.apply_conversions(lhs, left_ref, mir_ty);
  362|     55|        let rhs_converted = self.apply_conversions(rhs, right_ref, mir_ty);
  363|       |
  364|       |        // Ensure both operands have the same type for MIR operations.
  365|     55|        let lhs_mir_ty = self.get_operand_type(&lhs_converted);
  366|     55|        let rhs_mir_ty = self.get_operand_type(&rhs_converted);
  367|       |
  368|     55|        let (lhs_converted, rhs_converted) =
  369|     55|            self.unify_binary_operands(lhs_converted, rhs_converted, lhs_mir_ty, rhs_mir_ty);
  370|       |
  371|     55|        let lhs_final = self.ensure_explicit_cast(lhs_converted, left_ref);
  372|     55|        let rhs_final = self.ensure_explicit_cast(rhs_converted, right_ref);
  373|       |
  374|       |        // Check types for correct MIR op
  375|     55|        let lhs_mir = self.mir_builder.get_type(lhs_mir_ty);
  376|       |
  377|     55|        if matches!(op, BinaryOp::Comma) {
  378|      0|            return rhs_final;
  379|     55|        }
  380|       |
  381|     55|        let rval = self.emit_binary_rvalue(op, lhs_final, rhs_final, lhs_mir.is_float());
  382|     55|        self.emit_rvalue_to_operand(rval, mir_ty)
  383|     59|    }
  384|       |
  385|    110|    pub(crate) fn ensure_explicit_cast(&mut self, operand: Operand, node_ref: NodeRef) -> Operand {
  386|    110|        match operand {
  387|       |            Operand::Constant(_) => {
  388|     32|                if let Some(ty) = self.ast.get_resolved_type(node_ref) {
  389|     32|                    let mir_type_id = self.lower_qual_type(ty);
  390|     32|                    Operand::Cast(mir_type_id, Box::new(operand))
  391|       |                } else {
  392|      0|                    operand
  393|       |                }
  394|       |            }
  395|     78|            _ => operand,
  396|       |        }
  397|    110|    }
  398|       |
  399|      4|    pub(crate) fn lower_logical_op(
  400|      4|        &mut self,
  401|      4|        op: &BinaryOp,
  402|      4|        left_ref: NodeRef,
  403|      4|        right_ref: NodeRef,
  404|      4|        mir_ty: TypeId,
  405|      4|    ) -> Operand {
  406|       |        // Short-circuiting logic for && and ||
  407|      4|        let (_res_local, res_place) = self.create_temp_local(mir_ty);
  408|       |
  409|      4|        let eval_rhs_block = self.mir_builder.create_block();
  410|      4|        let merge_block = self.mir_builder.create_block();
  411|      4|        let short_circuit_block = self.mir_builder.create_block();
  412|       |
  413|       |        // 1. Evaluate LHS
  414|      4|        let lhs_op = self.lower_condition(left_ref);
  415|       |
  416|       |        // Pre-create constants to avoid double borrow
  417|      4|        let zero_op = self.create_int_operand(0);
  418|      4|        let one_op = self.create_int_operand(1);
  419|       |
  420|      4|        let (short_circuit_val, true_target, false_target) = match op {
  421|      0|            BinaryOp::LogicAnd => (zero_op.clone(), eval_rhs_block, short_circuit_block),
  422|      4|            BinaryOp::LogicOr => (one_op.clone(), short_circuit_block, eval_rhs_block),
  423|      0|            _ => unreachable!(),
  424|       |        };
  425|       |
  426|       |        // if lhs { goto true_target } else { goto false_target }
  427|      4|        self.mir_builder
  428|      4|            .set_terminator(Terminator::If(lhs_op, true_target, false_target));
  429|       |
  430|       |        // Short circuit case
  431|      4|        self.mir_builder.set_current_block(short_circuit_block);
  432|      4|        self.mir_builder
  433|      4|            .add_statement(MirStmt::Assign(res_place.clone(), Rvalue::Use(short_circuit_val)));
  434|      4|        self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  435|       |
  436|       |        // 2. Evaluate RHS
  437|      4|        self.mir_builder.set_current_block(eval_rhs_block);
  438|      4|        let rhs_val = self.lower_condition(right_ref);
  439|       |
  440|      4|        let rhs_true_block = self.mir_builder.create_block();
  441|      4|        let rhs_false_block = self.mir_builder.create_block();
  442|       |
  443|      4|        self.mir_builder
  444|      4|            .set_terminator(Terminator::If(rhs_val, rhs_true_block, rhs_false_block));
  445|       |
  446|      4|        self.mir_builder.set_current_block(rhs_true_block);
  447|      4|        self.mir_builder
  448|      4|            .add_statement(MirStmt::Assign(res_place.clone(), Rvalue::Use(one_op)));
  449|      4|        self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  450|       |
  451|      4|        self.mir_builder.set_current_block(rhs_false_block);
  452|      4|        self.mir_builder
  453|      4|            .add_statement(MirStmt::Assign(res_place.clone(), Rvalue::Use(zero_op)));
  454|      4|        self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  455|       |
  456|       |        // Merge
  457|      4|        self.mir_builder.set_current_block(merge_block);
  458|      4|        self.current_block = Some(merge_block);
  459|       |
  460|      4|        Operand::Copy(Box::new(res_place))
  461|      4|    }
  462|       |
  463|     64|    pub(crate) fn lower_pointer_arithmetic(
  464|     64|        &mut self,
  465|     64|        op: &BinaryOp,
  466|     64|        lhs: Operand,
  467|     64|        rhs: Operand,
  468|     64|        left_ref: NodeRef,
  469|     64|        right_ref: NodeRef,
  470|     64|    ) -> Option<Rvalue> {
  471|     64|        let lhs_type = self.ast.get_resolved_type(left_ref).unwrap();
  472|     64|        let rhs_type = self.ast.get_resolved_type(right_ref).unwrap();
  473|       |
  474|     64|        match op {
  475|       |            BinaryOp::Add => {
  476|      7|                if lhs_type.is_pointer() {
  477|      1|                    let rhs_mir_ty = self.lower_qual_type(rhs_type);
  478|      1|                    let rhs_converted = self.apply_conversions(rhs, right_ref, rhs_mir_ty);
  479|      1|                    Some(Rvalue::PtrAdd(lhs, rhs_converted))
  480|      6|                } else if rhs_type.is_pointer() {
  481|      0|                    let lhs_mir_ty = self.lower_qual_type(lhs_type);
  482|      0|                    let lhs_converted = self.apply_conversions(lhs, left_ref, lhs_mir_ty);
  483|      0|                    Some(Rvalue::PtrAdd(rhs, lhs_converted))
  484|       |                } else {
  485|      6|                    None
  486|       |                }
  487|       |            }
  488|       |            BinaryOp::Sub => {
  489|     10|                if lhs_type.is_pointer() {
  490|      1|                    if rhs_type.is_pointer() {
  491|      0|                        Some(Rvalue::PtrDiff(lhs, rhs))
  492|      1|                    } else if rhs_type.is_integer() {
  493|      1|                        let rhs_mir_ty = self.lower_qual_type(rhs_type);
  494|      1|                        let rhs_converted = self.apply_conversions(rhs, right_ref, rhs_mir_ty);
  495|      1|                        Some(Rvalue::PtrSub(lhs, rhs_converted))
  496|       |                    } else {
  497|      0|                        None
  498|       |                    }
  499|       |                } else {
  500|      9|                    None
  501|       |                }
  502|       |            }
  503|     47|            _ => None,
  504|       |        }
  505|     64|    }
  506|       |
  507|     60|    pub(crate) fn lower_assignment_expr(
  508|     60|        &mut self,
  509|     60|        node_ref: NodeRef,
  510|     60|        op: &BinaryOp,
  511|     60|        left_ref: NodeRef,
  512|     60|        right_ref: NodeRef,
  513|     60|        mir_ty: TypeId,
  514|     60|    ) -> Operand {
  515|     60|        debug_assert!(
  516|     60|            op.is_assignment(),
  517|      0|            "lower_assignment_expr called with non-assignment operator: {:?}",
  518|       |            op
  519|       |        );
  520|     60|        let lhs_op = self.lower_expression(left_ref, true);
  521|       |
  522|       |        // Ensure the LHS is a place. If not, this is a semantic error.
  523|     60|        if self.ast.get_value_category(left_ref) != Some(ValueCategory::LValue) {
  524|      0|            panic!("LHS of assignment must be an lvalue");
  525|     60|        }
  526|       |
  527|     60|        let place = if let Operand::Copy(place) = lhs_op {
  528|     60|            *place
  529|       |        } else {
  530|      0|            panic!("LHS of assignment lowered to non-place operand despite being LValue");
  531|       |        };
  532|       |
  533|     60|        let rhs_op = self.lower_expression(right_ref, true);
  534|       |
  535|     60|        let final_rhs = if let Some(compound_op) = op.without_assignment() {
                                                  ^9
  536|       |            // This is a compound assignment, e.g., a += b
  537|       |            // Use the already-evaluated place to read the current value.
  538|      9|            let lhs_copy = Operand::Copy(Box::new(place.clone()));
  539|       |
  540|      2|            if let Some(rval) =
  541|      9|                self.lower_pointer_arithmetic(&compound_op, lhs_copy.clone(), rhs_op.clone(), left_ref, right_ref)
  542|       |            {
  543|      2|                self.emit_rvalue_to_operand(rval, mir_ty)
  544|       |            } else {
  545|      7|                let lhs_converted_for_op = self.apply_conversions(lhs_copy, left_ref, mir_ty);
  546|      7|                let rhs_converted_for_op = self.apply_conversions(rhs_op, right_ref, mir_ty);
  547|       |
  548|      7|                let lhs_ty_for_op = self.get_operand_type(&lhs_converted_for_op);
  549|      7|                let mir_type_info = self.mir_builder.get_type(lhs_ty_for_op);
  550|       |
  551|      7|                let rval = self.emit_binary_rvalue(
  552|      7|                    &compound_op,
  553|      7|                    lhs_converted_for_op,
  554|      7|                    rhs_converted_for_op,
  555|      7|                    mir_type_info.is_float(),
  556|       |                );
  557|      7|                let result_of_op = self.emit_rvalue_to_operand(rval, lhs_ty_for_op);
  558|      7|                self.apply_conversions(result_of_op, node_ref, mir_ty)
  559|       |            }
  560|       |        } else {
  561|       |            // Simple assignment, just use the RHS
  562|     51|            self.apply_conversions(rhs_op, right_ref, mir_ty)
  563|       |        };
  564|       |
  565|     60|        self.emit_assignment(place, final_rhs.clone());
  566|     60|        final_rhs // C assignment expressions evaluate to the assigned value
  567|     60|    }
  568|       |
  569|     21|    pub(crate) fn lower_function_call(&mut self, call_expr: &ast::nodes::CallExpr, dest_place: Option<Place>) {
  570|     21|        let callee = self.lower_expression(call_expr.callee, true);
  571|       |
  572|     21|        let mut arg_operands = Vec::new();
  573|       |
  574|       |        // Get the function type to determine parameter types for conversions
  575|     21|        let func_node_kind = self.ast.get_kind(call_expr.callee);
  576|     21|        let func_type_kind = if let NodeKind::Ident(_, symbol_ref) = func_node_kind {
                                                                     ^20
  577|     20|            let resolved_symbol = *symbol_ref;
  578|     20|            let func_entry = self.symbol_table.get_symbol(resolved_symbol);
  579|     20|            Some(self.registry.get(func_entry.type_info.ty()).kind.clone())
  580|       |        } else {
  581|      1|            None
  582|       |        };
  583|       |
  584|     21|        let param_types = if let Some(func_type_kind) = func_type_kind {
                                                    ^20
  585|     20|            if let TypeKind::Function { parameters, .. } = &func_type_kind {
                                                      ^19
  586|       |                Some(
  587|     19|                    parameters
  588|     19|                        .iter()
  589|     19|                        .map(|param| self.lower_qual_type(param.param_type))
                                                   ^6   ^6              ^6
  590|     19|                        .collect::<Vec<_>>(),
  591|       |                )
  592|       |            } else {
  593|      1|                None
  594|       |            }
  595|       |        } else {
  596|      1|            None
  597|       |        };
  598|       |
  599|     21|        for (i, arg_ref) in call_expr.arg_start.range(call_expr.arg_len).enumerate() {
                           ^11^11
  600|       |            // Note: lower_expression(CallArg) will just lower the inner expression.
  601|       |            // But we use arg_ref (the CallArg node) for implicit conversion lookup.
  602|     11|            let arg_operand = self.lower_expression(arg_ref, true);
  603|       |
  604|       |            // Apply conversions for function arguments if needed
  605|       |            // The resolved type of CallArg is same as inner expr.
  606|     11|            let arg_ty = self.ast.get_resolved_type(arg_ref).unwrap();
  607|     11|            let arg_mir_ty = self.lower_qual_type(arg_ty);
  608|       |
  609|       |            // Use the parameter type as the target type for conversions, if available
  610|     11|            let target_mir_ty = if let Some(ref param_types_vec) = param_types {
                                                          ^8
  611|      8|                if i < param_types_vec.len() {
  612|      6|                    param_types_vec[i]
  613|       |                } else {
  614|       |                    // Variadic argument: Logic handled by implicit conversions (Promotion/Decay) calculated in analyzer.rs
  615|       |                    // We just need a placeholder type, or the promoted type if we could calculate it.
  616|       |                    // Since semantic analysis has inserted promoted type casts/conversions, we can start with the argument's own type.
  617|      2|                    arg_mir_ty
  618|       |                }
  619|       |            } else {
  620|       |                // Unprototyped function: Logic handled by implicit conversions
  621|      3|                arg_mir_ty
  622|       |            };
  623|       |
  624|     11|            let converted_arg = self.apply_conversions(arg_operand, arg_ref, target_mir_ty);
  625|       |
  626|     11|            arg_operands.push(converted_arg);
  627|       |        }
  628|       |
  629|     21|        let call_target = if let Operand::Constant(const_id) = callee {
                                                                 ^19
  630|       |            if let ConstValue {
  631|     19|                kind: ConstValueKind::FunctionAddress(func_id),
  632|       |                ..
  633|     19|            } = self.mir_builder.get_constants().get(&const_id).unwrap()
  634|       |            {
  635|     19|                CallTarget::Direct(*func_id)
  636|       |            } else {
  637|      0|                panic!("Expected function address");
  638|       |            }
  639|       |        } else {
  640|      2|            CallTarget::Indirect(callee)
  641|       |        };
  642|       |
  643|     21|        let stmt = MirStmt::Call {
  644|     21|            target: call_target,
  645|     21|            args: arg_operands,
  646|     21|            dest: dest_place,
  647|     21|        };
  648|     21|        self.mir_builder.add_statement(stmt);
  649|     21|    }
  650|       |
  651|     62|    pub(crate) fn find_member_path(&self, record_ty: semantic::TypeRef, field_name: ast::NameId) -> Option<Vec<usize>> {
  652|     62|        let ty = self.registry.get(record_ty);
  653|     62|        if let TypeKind::Record { members, .. } = &ty.kind {
  654|       |            // 1. Check direct members
  655|     96|            if let Some(idx) = members.iter().position(|m| m.name == Some(field_name)) {
                                      ^48    ^62            ^62
  656|     48|                return Some(vec![idx]);
  657|     14|            }
  658|       |
  659|       |            // 2. Check anonymous members
  660|     26|            for (idx, member) in members.iter().enumerate() {
                                               ^14            ^14
  661|     26|                if member.name.is_none() {
  662|     14|                    let member_ty = member.member_type.ty();
  663|       |                    // Only recurse if it's a record
  664|     14|                    if matches!(self.registry.get(member_ty).kind, TypeKind::Record { .. })
                                     ^0
  665|     14|                        && let Some(mut sub_path) = self.find_member_path(member_ty, field_name)
                                                  ^9
  666|       |                    {
  667|      9|                        let mut full_path = vec![idx];
  668|      9|                        full_path.append(&mut sub_path);
  669|      9|                        return Some(full_path);
  670|      5|                    }
  671|     12|                }
  672|       |            }
  673|      0|        }
  674|      5|        None
  675|     62|    }
  676|       |
  677|     48|    pub(crate) fn lower_member_access(
  678|     48|        &mut self,
  679|     48|        obj_ref: NodeRef,
  680|     48|        field_name: &ast::NameId,
  681|     48|        is_arrow: bool,
  682|     48|    ) -> Operand {
  683|     48|        let obj_ty = self.ast.get_resolved_type(obj_ref).unwrap();
  684|     48|        let record_ty = if is_arrow {
  685|     13|            self.registry
  686|     13|                .get_pointee(obj_ty.ty())
  687|     13|                .expect("Arrow access on non-pointer type")
  688|     13|                .ty()
  689|       |        } else {
  690|     35|            obj_ty.ty()
  691|       |        };
  692|       |
  693|     48|        if record_ty.is_record() {
  694|       |            // Validate that the field exists and get its layout information
  695|     48|            let path = self
  696|     48|                .find_member_path(record_ty, *field_name)
  697|     48|                .expect("Field not found - should be caught by semantic analysis");
  698|       |
  699|       |            // Apply the chain of field accesses
  700|       |
  701|       |            // Resolve base place
  702|     48|            let mut current_place = self.lower_expression_as_place(obj_ref);
  703|       |
  704|     48|            if is_arrow {
  705|     13|                // Dereference: *ptr
  706|     13|                let deref_op = Operand::Copy(Box::new(current_place));
  707|     13|                current_place = Place::Deref(Box::new(deref_op));
  708|     35|            }
  709|       |
  710|    105|            for field_idx in path {
                              ^57
  711|     57|                current_place = Place::StructField(Box::new(current_place), field_idx);
  712|     57|            }
  713|       |
  714|     48|            Operand::Copy(Box::new(current_place))
  715|       |        } else {
  716|      0|            panic!("Member access on non-record type");
  717|       |        }
  718|     48|    }
  719|       |
  720|     19|    pub(crate) fn lower_index_access(&mut self, arr_ref: NodeRef, idx_ref: NodeRef) -> Operand {
  721|     19|        let arr_ty = self.ast.get_resolved_type(arr_ref).unwrap();
  722|       |
  723|       |        // Handle both array and pointer types for index access
  724|       |        // In C, arr[idx] is equivalent to *(arr + idx)
  725|     19|        if arr_ty.is_array() || arr_ty.is_pointer() {
                                              ^0     ^0
  726|     19|            let arr_place = self.lower_expression_as_place(arr_ref);
  727|     19|            let idx_operand = self.lower_expression(idx_ref, true);
  728|       |
  729|     19|            Operand::Copy(Box::new(Place::ArrayIndex(Box::new(arr_place), Box::new(idx_operand))))
  730|       |        } else {
  731|      0|            panic!("Index access on non-array, non-pointer type");
  732|       |        }
  733|     19|    }
  734|       |
  735|      5|    pub(crate) fn lower_inc_dec_common(
  736|      5|        &mut self,
  737|      5|        operand_ref: NodeRef,
  738|      5|        is_inc: bool,
  739|      5|        is_post: bool,
  740|      5|        need_value: bool,
  741|      5|    ) -> Operand {
  742|      5|        let operand = self.lower_expression(operand_ref, true);
  743|      5|        let operand_ty = self.ast.get_resolved_type(operand_ref).unwrap();
  744|      5|        let mir_ty = self.lower_qual_type(operand_ty);
  745|       |
  746|      5|        if self.ast.get_value_category(operand_ref) != Some(ValueCategory::LValue) {
  747|      0|            panic!("Inc/Dec operand must be an lvalue");
  748|      5|        }
  749|       |
  750|      5|        if let Operand::Copy(place) = operand.clone() {
  751|       |            // If it's post-inc/dec and we need the value, save the old value
  752|      5|            let old_value = if is_post && need_value {
                                                        ^3
  753|      3|                let rval = Rvalue::Use(operand.clone());
  754|      3|                let (_, temp_place) = self.create_temp_local_with_assignment(rval, mir_ty);
  755|      3|                Some(Operand::Copy(Box::new(temp_place)))
  756|       |            } else {
  757|      2|                None
  758|       |            };
  759|       |
  760|       |            // Determine MIR operation and Rvalue
  761|      5|            let rval = self.create_inc_dec_rvalue(operand.clone(), operand_ty, is_inc);
  762|       |
  763|       |            // Perform the assignment
  764|      5|            if is_post && !need_value {
                                        ^3
  765|      0|                // Optimization: assign directly to place if old value not needed
  766|      0|                self.mir_builder.add_statement(MirStmt::Assign(*place.clone(), rval));
  767|      0|            } else {
  768|       |                // If we needed old value (is_post), or if it is pre-inc (need new value),
  769|       |                // we compute to a temp first to ensure correctness and return the right value.
  770|      5|                let (_, new_place) = self.create_temp_local_with_assignment(rval, mir_ty);
  771|      5|                self.emit_assignment(*place.clone(), Operand::Copy(Box::new(new_place.clone())));
  772|       |
  773|      5|                if !is_post {
  774|       |                    // Pre-inc: return the new value
  775|      2|                    return Operand::Copy(Box::new(new_place));
  776|      3|                }
  777|       |            }
  778|       |
  779|      3|            if is_post {
  780|      3|                if need_value {
  781|      3|                    old_value.unwrap()
  782|       |                } else {
  783|      0|                    self.create_int_operand(0)
  784|       |                }
  785|       |            } else {
  786|       |                // Pre-inc: we already returned inside the block above.
  787|       |                // RE-FETCH from place as a fallback (should not be reached)
  788|      0|                Operand::Copy(place)
  789|       |            }
  790|       |        } else {
  791|      0|            panic!("Inc/Dec operand is not a place");
  792|       |        }
  793|      5|    }
  794|       |
  795|      5|    pub(crate) fn create_inc_dec_rvalue(&mut self, operand: Operand, operand_ty: QualType, is_inc: bool) -> Rvalue {
  796|      5|        let one_const = self.create_int_operand(1);
  797|      5|        let minus_one_const = self.create_int_operand(-1);
  798|       |
  799|      5|        if operand_ty.is_pointer() {
  800|      0|            if is_inc {
  801|      0|                Rvalue::PtrAdd(operand, one_const)
  802|       |            } else {
  803|      0|                Rvalue::PtrSub(operand, one_const)
  804|       |            }
  805|       |        } else {
  806|       |            // For Integers: Add(delta) (Note: we use Add with negative delta for decrement
  807|       |            // to support proper wrapping arithmetic and fix previous bugs)
  808|      5|            let rhs = if is_inc { one_const } else { minus_one_const };
                                                ^2                 ^3
  809|      5|            Rvalue::BinaryIntOp(BinaryIntOp::Add, operand, rhs)
  810|       |        }
  811|      5|    }
  812|       |
  813|      2|    pub(crate) fn lower_pre_incdec(&mut self, op: &UnaryOp, lhs_ref: NodeRef) -> Operand {
  814|      2|        let is_inc = matches!(op, UnaryOp::PreIncrement);
                                   ^1
  815|      2|        self.lower_inc_dec_common(lhs_ref, is_inc, false, true)
  816|      2|    }
  817|       |
  818|      3|    pub(crate) fn lower_post_incdec(&mut self, operand_ref: NodeRef, is_inc: bool, need_value: bool) -> Operand {
  819|      3|        self.lower_inc_dec_common(operand_ref, is_inc, true, need_value)
  820|      3|    }
  821|       |
  822|      0|    pub(crate) fn lower_builtin_va_arg(&mut self, ty: QualType, expr_ref: NodeRef) -> Operand {
  823|      0|        let ap = self.lower_expression_as_place(expr_ref);
  824|      0|        let mir_ty = self.lower_qual_type(ty);
  825|      0|        let rval = Rvalue::BuiltinVaArg(ap, mir_ty);
  826|      0|        self.emit_rvalue_to_operand(rval, mir_ty)
  827|      0|    }
  828|       |
  829|      0|    pub(crate) fn lower_builtin_va_start(&mut self, ap_ref: NodeRef, last_ref: NodeRef) -> Operand {
  830|      0|        let ap = self.lower_expression_as_place(ap_ref);
  831|      0|        let last = self.lower_expression(last_ref, true);
  832|      0|        self.mir_builder.add_statement(MirStmt::BuiltinVaStart(ap, last));
  833|      0|        self.create_int_operand(0)
  834|      0|    }
  835|       |
  836|      0|    pub(crate) fn lower_builtin_va_end(&mut self, ap_ref: NodeRef) -> Operand {
  837|      0|        let ap = self.lower_expression_as_place(ap_ref);
  838|      0|        self.mir_builder.add_statement(MirStmt::BuiltinVaEnd(ap));
  839|      0|        self.create_int_operand(0)
  840|      0|    }
  841|       |
  842|      0|    pub(crate) fn lower_builtin_va_copy(&mut self, dst_ref: NodeRef, src_ref: NodeRef) -> Operand {
  843|      0|        let dst = self.lower_expression_as_place(dst_ref);
  844|      0|        let src = self.lower_expression_as_place(src_ref);
  845|       |
  846|      0|        self.mir_builder.add_statement(MirStmt::BuiltinVaCopy(dst, src));
  847|      0|        self.create_int_operand(0)
  848|      0|    }
  849|       |}

/app/src/semantic/lower_initializer.rs:
    1|       |use crate::ast;
    2|       |use crate::ast::{Designator, NameId, NodeKind, NodeRef, literal};
    3|       |use crate::mir::{ConstValueId, ConstValueKind, MirArrayLayout, MirType, Operand, Place, Rvalue};
    4|       |use crate::semantic::ast_to_mir::AstToMirLowerer;
    5|       |use crate::semantic::{ArraySizeType, BuiltinType, QualType, StructMember, TypeKind};
    6|       |
    7|       |impl<'a> AstToMirLowerer<'a> {
    8|      9|    pub(crate) fn lower_initializer_list(
    9|      9|        &mut self,
   10|      9|        list_data: &ast::nodes::InitializerListData,
   11|      9|        members: &[StructMember],
   12|      9|        target_ty: QualType,
   13|      9|        destination: Option<Place>,
   14|      9|    ) -> Operand {
   15|      9|        let mut field_operands = Vec::new();
   16|      9|        let mut current_field_idx = 0;
   17|      9|        let (_rec_size, _rec_align, field_layouts, _) = self.registry.get_record_layout(target_ty.ty());
   18|       |
   19|     22|        for item_ref in list_data.init_start.range(list_data.init_len) {
                                      ^9                   ^9    ^9
   20|     22|            let NodeKind::InitializerItem(init) = self.ast.get_kind(item_ref) else {
   21|      0|                continue;
   22|       |            };
   23|     22|            let init = *init;
   24|     22|            let field_idx = if init.designator_len > 0 {
   25|      8|                let designator_ref = init.designator_start;
   26|      8|                if let NodeKind::Designator(Designator::FieldName(name)) = self.ast.get_kind(designator_ref) {
   27|     12|                    members.iter().position(|m| m.name == Some(*name)).unwrap()
                                  ^8             ^8                                  ^8
   28|       |                } else {
   29|      0|                    panic!("Array designator for struct initializer");
   30|       |                }
   31|       |            } else {
   32|     14|                let idx = current_field_idx;
   33|     14|                let init_node_kind = self.ast.get_kind(init.initializer);
   34|     14|                if let NodeKind::InitializerList(_) = init_node_kind {
   35|       |                    // Search for the next record field to initialize with a list
   36|      1|                    if let Some(found_idx) = members.iter().enumerate().skip(idx).find_map(|(j, item)| {
   37|      1|                        if matches!(self.registry.get(item.member_type.ty()).kind, TypeKind::Record { .. }) {
                                         ^0
   38|      1|                            Some(j)
   39|       |                        } else {
   40|      0|                            None
   41|       |                        }
   42|      1|                    }) {
   43|      1|                        current_field_idx = found_idx + 1;
   44|      1|                        found_idx
   45|       |                    } else {
   46|      0|                        current_field_idx += 1;
   47|      0|                        idx
   48|       |                    }
   49|       |                } else {
   50|     13|                    current_field_idx += 1;
   51|     13|                    idx
   52|       |                }
   53|       |            };
   54|       |
   55|     22|            let member_ty = members[field_idx].member_type;
   56|       |
   57|     22|            let operand = self.lower_initializer(init.initializer, member_ty, None);
   58|     22|            field_operands.push((field_idx, operand));
   59|     22|            if field_idx < field_layouts.len() {
   60|     21|                let base_offset = field_layouts[field_idx].offset;
   61|     21|                let mut next_idx = field_idx + 1;
   62|     21|                while next_idx < field_layouts.len() && field_layouts[next_idx].offset == base_offset {
                                                                      ^12
   63|      0|                    next_idx += 1;
   64|      0|                }
   65|     21|                current_field_idx = next_idx;
   66|      1|            }
   67|       |        }
   68|       |
   69|      9|        self.finalize_struct_initializer(field_operands, target_ty, destination)
   70|      9|    }
   71|       |
   72|      7|    pub(crate) fn lower_array_initializer(
   73|      7|        &mut self,
   74|      7|        list_data: &ast::nodes::InitializerListData,
   75|      7|        element_ty: QualType,
   76|      7|        size: usize,
   77|      7|        target_ty: QualType,
   78|      7|        destination: Option<Place>,
   79|      7|    ) -> Operand {
   80|      7|        let mut elements: Vec<Option<Operand>> = vec![None; size];
   81|      7|        let mut current_idx = 0;
   82|       |
   83|     15|        for item_ref in list_data.init_start.range(list_data.init_len) {
                                      ^7                   ^7    ^7
   84|     15|            let NodeKind::InitializerItem(init) = self.ast.get_kind(item_ref) else {
   85|      0|                continue;
   86|       |            };
   87|       |
   88|       |            // Handle designator
   89|     15|            if init.designator_len > 0 {
   90|      9|                let designator_ref = init.designator_start;
   91|       |                // We only look at the first designator for the array index.
   92|       |                // Nested designators would need to be handled by constructing
   93|       |                // partial initializers, but for now we assume 1D array or first level.
   94|      9|                match self.ast.get_kind(designator_ref) {
   95|      9|                    NodeKind::Designator(Designator::ArrayIndex(idx_expr)) => {
   96|      9|                        let idx_operand = self.lower_expression(*idx_expr, true);
   97|      9|                        if let Some(const_id) = self.operand_to_const_id(idx_operand) {
   98|      9|                            let const_val = self.mir_builder.get_constants().get(&const_id).unwrap();
   99|      9|                            if let ConstValueKind::Int(val) = const_val.kind {
  100|      9|                                current_idx = val as usize;
  101|      9|                            } else {
  102|      0|                                panic!("Array designator must be an integer constant");
  103|       |                            }
  104|       |                        } else {
  105|      0|                            panic!("Array designator must be a constant expression");
  106|       |                        }
  107|       |                    }
  108|       |                    // Struct field designators are invalid for arrays
  109|       |                    NodeKind::Designator(Designator::FieldName(_)) => {
  110|      0|                        panic!("Field designator for array initializer");
  111|       |                    }
  112|       |                    _ => {
  113|       |                        // Other designators (e.g. ranges) not supported yet
  114|      0|                        panic!("Unsupported designator for array initializer");
  115|       |                    }
  116|       |                }
  117|      6|            }
  118|       |
  119|       |            // Ensure elements vector is large enough
  120|     15|            if current_idx >= elements.len() {
  121|      0|                elements.resize(current_idx + 1, None);
  122|     15|            }
  123|       |
  124|     15|            let operand = self.lower_initializer(init.initializer, element_ty, None);
  125|     15|            elements[current_idx] = Some(operand);
  126|       |
  127|       |            // Advance index for next positional initializer
  128|     15|            current_idx += 1;
  129|       |        }
  130|       |
  131|       |        // Fill gaps with zero
  132|      7|        let final_elements = elements
  133|      7|            .into_iter()
  134|     26|            .map(|op| {
                           ^7
  135|     26|                op.unwrap_or_else(|| {
                                                   ^12
  136|     12|                    let mir_ty = self.lower_qual_type(element_ty);
  137|     12|                    Operand::Constant(self.create_constant(mir_ty, ConstValueKind::Zero))
  138|     12|                })
  139|     26|            })
  140|      7|            .collect();
  141|       |
  142|      7|        self.finalize_array_initializer(final_elements, target_ty, destination)
  143|      7|    }
  144|       |
  145|     16|    pub(crate) fn finalize_initializer_generic<T, C, R>(
  146|     16|        &mut self,
  147|     16|        target_ty: QualType,
  148|     16|        data: T,
  149|     16|        create_const: C,
  150|     16|        create_rvalue: R,
  151|     16|        destination: Option<Place>,
  152|     16|    ) -> Operand
  153|     16|    where
  154|     16|        C: FnOnce(&mut Self, T) -> ConstValueKind,
  155|     16|        R: FnOnce(T) -> Rvalue,
  156|       |    {
  157|     16|        if self.current_function.is_none() {
  158|     13|            let mir_ty = self.lower_qual_type(target_ty);
  159|     13|            let const_kind = create_const(self, data);
  160|     13|            Operand::Constant(self.create_constant(mir_ty, const_kind))
  161|       |        } else {
  162|      3|            let rval = create_rvalue(data);
  163|      3|            let mir_ty = self.lower_qual_type(target_ty);
  164|      3|            if let Some(place) = destination {
  165|      3|                let stmt = crate::mir::MirStmt::Assign(place.clone(), rval);
  166|      3|                self.mir_builder.add_statement(stmt);
  167|      3|                Operand::Copy(Box::new(place))
  168|       |            } else {
  169|      0|                self.emit_rvalue_to_operand(rval, mir_ty)
  170|       |            }
  171|       |        }
  172|     16|    }
  173|       |
  174|      9|    pub(crate) fn finalize_struct_initializer(
  175|      9|        &mut self,
  176|      9|        field_operands: Vec<(usize, Operand)>,
  177|      9|        target_ty: QualType,
  178|      9|        destination: Option<Place>,
  179|      9|    ) -> Operand {
  180|      9|        self.finalize_initializer_generic(
  181|      9|            target_ty,
  182|      9|            field_operands,
  183|      7|            |this, ops| {
  184|      7|                let const_fields = ops
  185|      7|                    .into_iter()
  186|     16|                    .map(|(idx, op)| {
                                   ^7
  187|     16|                        let const_id =
  188|     16|                            this.operand_to_const_id_strict(op, "Global initializer is not a constant expression");
  189|     16|                        (idx, const_id)
  190|     16|                    })
  191|      7|                    .collect();
  192|      7|                ConstValueKind::StructLiteral(const_fields)
  193|      7|            },
  194|       |            Rvalue::StructLiteral,
  195|      9|            destination,
  196|       |        )
  197|      9|    }
  198|       |
  199|      7|    pub(crate) fn finalize_array_initializer(
  200|      7|        &mut self,
  201|      7|        elements: Vec<Operand>,
  202|      7|        target_ty: QualType,
  203|      7|        destination: Option<Place>,
  204|      7|    ) -> Operand {
  205|      7|        self.finalize_initializer_generic(
  206|      7|            target_ty,
  207|      7|            elements,
  208|      6|            |this, elems| {
  209|      6|                let const_elements = elems
  210|      6|                    .into_iter()
  211|     24|                    .map(|op| {
                                   ^6
  212|     24|                        this.operand_to_const_id_strict(op, "Global array initializer must be a constant expression")
  213|     24|                    })
  214|      6|                    .collect();
  215|      6|                ConstValueKind::ArrayLiteral(const_elements)
  216|      6|            },
  217|       |            Rvalue::ArrayLiteral,
  218|      7|            destination,
  219|       |        )
  220|      7|    }
  221|       |
  222|     26|    pub(crate) fn lower_initializer_to_const(&mut self, init_ref: NodeRef, ty: QualType) -> Option<ConstValueId> {
  223|     26|        let operand = self.lower_initializer(init_ref, ty, None);
  224|     26|        self.operand_to_const_id(operand)
  225|     26|    }
  226|       |
  227|    115|    pub(crate) fn lower_initializer(
  228|    115|        &mut self,
  229|    115|        init_ref: NodeRef,
  230|    115|        target_ty: QualType,
  231|    115|        destination: Option<Place>,
  232|    115|    ) -> Operand {
  233|    115|        let init_node_kind = self.ast.get_kind(init_ref).clone();
  234|    115|        let target_type = self.registry.get(target_ty.ty()).clone();
  235|       |
  236|    115|        match (init_node_kind, &target_type.kind) {
  237|      9|            (NodeKind::InitializerList(list), TypeKind::Record { .. }) => {
  238|      9|                let mut flat_members = Vec::new();
  239|      9|                target_type.flatten_members(self.registry, &mut flat_members);
  240|      9|                self.lower_initializer_list(&list, &flat_members, target_ty, destination)
  241|       |            }
  242|      7|            (NodeKind::InitializerList(list), TypeKind::Array { element_type, size }) => {
  243|      7|                let element_ty = QualType::unqualified(*element_type);
  244|      7|                let array_size = if let ArraySizeType::Constant(s) = size { *s } else { 0 };
                                                                                                      ^0
  245|      7|                self.lower_array_initializer(&list, element_ty, array_size, target_ty, destination)
  246|       |            }
  247|      7|            (NodeKind::Literal(literal::Literal::String(val)), TypeKind::Array { element_type, size })
                                                                      ^5
  248|      2|                if matches!(
  249|      7|                    self.registry.get(*element_type).kind,
  250|       |                    TypeKind::Builtin(BuiltinType::Char)
  251|       |                ) =>
  252|       |            {
  253|      5|                let fixed_size = if let ArraySizeType::Constant(s) = size {
  254|      5|                    Some(*s)
  255|       |                } else {
  256|      0|                    None
  257|       |                };
  258|      5|                let array_const_id = self.create_string_array_const(&val, fixed_size);
  259|      5|                Operand::Constant(array_const_id)
  260|       |            }
  261|       |            _ => {
  262|     94|                let operand = self.lower_expression(init_ref, true);
  263|     94|                let mir_target_ty = self.lower_qual_type(target_ty);
  264|     94|                let operand = self.apply_conversions(operand, init_ref, mir_target_ty);
  265|       |
  266|       |                // Ensure type match by inserting a cast if necessary
  267|     94|                let current_ty = self.get_operand_type(&operand);
  268|     94|                if current_ty != mir_target_ty {
  269|      1|                    Operand::Cast(mir_target_ty, Box::new(operand))
  270|       |                } else {
  271|     93|                    operand
  272|       |                }
  273|       |            }
  274|       |        }
  275|    115|    }
  276|       |
  277|     13|    pub(crate) fn create_string_array_const(&mut self, val: &NameId, fixed_size: Option<usize>) -> ConstValueId {
  278|     13|        let string_content = val.as_str();
  279|     13|        let bytes = string_content.as_bytes();
  280|     13|        let size = fixed_size.unwrap_or(bytes.len() + 1);
  281|       |
  282|     13|        let char_ty = self.get_char_type();
  283|       |
  284|     13|        let char_constants = (0..size)
  285|     86|            .map(|i| {
                           ^13
  286|     86|                let byte_val = if i < bytes.len() { bytes[i] } else { 0 };
                                                                  ^69               ^17
  287|     86|                self.create_constant(char_ty, ConstValueKind::Int(byte_val as i64))
  288|     86|            })
  289|     13|            .collect();
  290|       |
  291|     13|        let array_ty = self.mir_builder.add_type(MirType::Array {
  292|     13|            element: char_ty,
  293|     13|            size,
  294|     13|            layout: MirArrayLayout {
  295|     13|                size: 0,
  296|     13|                align: 1,
  297|     13|                stride: 1,
  298|     13|            },
  299|     13|        });
  300|       |
  301|     13|        self.create_constant(array_ty, ConstValueKind::ArrayLiteral(char_constants))
  302|     13|    }
  303|       |
  304|      8|    pub(crate) fn lower_literal_string(&mut self, val: &NameId, ty: QualType) -> Operand {
  305|      8|        let string_type = self.lower_qual_type(ty);
  306|      8|        let array_const_id = self.create_string_array_const(val, None);
  307|       |
  308|      8|        let global_name = self.mir_builder.get_next_anonymous_global_name();
  309|      8|        let global_id = self
  310|      8|            .mir_builder
  311|      8|            .create_global_with_init(global_name, string_type, true, Some(array_const_id));
  312|       |
  313|      8|        Operand::Constant(self.create_constant(string_type, ConstValueKind::GlobalAddress(global_id)))
  314|      8|    }
  315|       |
  316|      0|    pub(crate) fn lower_compound_literal(&mut self, ty: QualType, init_ref: NodeRef) -> Operand {
  317|      0|        let mir_ty = self.lower_qual_type(ty);
  318|       |
  319|      0|        if self.current_function.is_none() {
  320|      0|            let global_name = self.mir_builder.get_next_anonymous_global_name();
  321|      0|            let init_const_id = self
  322|      0|                .lower_initializer_to_const(init_ref, ty)
  323|      0|                .expect("Global compound literal initializer must be constant");
  324|       |
  325|      0|            let global_id = self
  326|      0|                .mir_builder
  327|      0|                .create_global_with_init(global_name, mir_ty, false, Some(init_const_id));
  328|       |
  329|      0|            Operand::Copy(Box::new(Place::Global(global_id)))
  330|       |        } else {
  331|      0|            let (_, place) = self.create_temp_local(mir_ty);
  332|      0|            let init_operand = self.lower_initializer(init_ref, ty, Some(place.clone()));
  333|      0|            self.emit_assignment(place.clone(), init_operand);
  334|      0|            Operand::Copy(Box::new(place))
  335|       |        }
  336|      0|    }
  337|       |}

/app/src/semantic/lowering.rs:
    1|       |//! SemanticLowering
    2|       |//!
    3|       |//! Responsibility
    4|       |//! - Declaration Lowering (Declaration -> VarDecl/RecordDecl/EnumDecl/TypedefDecl, FunctionDef -> Function)
    5|       |//! - Scope Construction
    6|       |//! - Symbol Insertion to Symbol Table
    7|       |//! - Name lookup
    8|       |//! - Making Sure Struct with body is is_complete = true
    9|       |//!
   10|       |//! This module implements the semantic lowering phase that bridges the gap between the
   11|       |//! grammar-oriented parser AST and the type-resolved semantic AST (HIR). The lowering
   12|       |//! phase handles all C-style declaration forms
   13|       |
   14|       |use hashbrown::HashMap;
   15|       |use smallvec::{SmallVec, smallvec};
   16|       |use std::num::NonZeroU16;
   17|       |
   18|       |use crate::ast::parsed::{
   19|       |    ParsedDeclarationData, ParsedDeclarator, ParsedFunctionDefData, ParsedNodeKind, ParsedNodeRef, ParsedTypeSpecifier,
   20|       |};
   21|       |use crate::ast::*;
   22|       |use crate::diagnostic::{DiagnosticEngine, SemanticError};
   23|       |use crate::semantic::const_eval::{self, ConstEvalCtx};
   24|       |use crate::semantic::symbol_table::{DefinitionState, SymbolTableError};
   25|       |use crate::semantic::{
   26|       |    ArraySizeType, BuiltinType, EnumConstant, ScopeId, StructMember, SymbolKind, SymbolRef, SymbolTable, TypeKind,
   27|       |    TypeQualifiers, TypeRef, TypeRegistry,
   28|       |};
   29|       |use crate::semantic::{FunctionParameter, QualType};
   30|       |use crate::source_manager::SourceSpan;
   31|       |
   32|       |/// Recursively apply parsed declarator to base type
   33|     29|fn apply_parsed_declarator_recursive(
   34|     29|    current_type: QualType,
   35|     29|    declarator_ref: ParsedDeclRef,
   36|     29|    ctx: &mut LowerCtx,
   37|     29|    span: SourceSpan,
   38|     29|) -> QualType {
   39|     29|    let declarator_node = ctx.parsed_ast.parsed_types.get_decl(declarator_ref);
   40|       |
   41|     29|    match declarator_node {
   42|     22|        ParsedDeclaratorNode::Identifier { .. } => current_type,
   43|      6|        ParsedDeclaratorNode::Pointer { qualifiers, inner } => {
   44|       |            // Pointer
   45|       |            // Apply Pointer modifier to the current type first (Top-Down)
   46|      6|            let pointer_type = ctx.registry.pointer_to(current_type);
   47|       |            // Pointer type is always compatible with restrict, but we use checked merge anyway for consistency
   48|      6|            let modified_current =
   49|      6|                ctx.merge_qualifiers_with_check(QualType::unqualified(pointer_type), qualifiers, span);
   50|      6|            apply_parsed_declarator_recursive(modified_current, inner, ctx, span)
   51|       |        }
   52|      0|        ParsedDeclaratorNode::Array { size, inner } => {
   53|       |            // Array
   54|       |            // Apply Array modifier to the current type
   55|       |            // Propagate qualifiers from the element type to the array type (C11 6.7.3)
   56|      0|            let array_size = convert_parsed_array_size(&size, ctx);
   57|      0|            let array_type_ref = ctx.registry.array_of(current_type.ty(), array_size);
   58|      0|            let qualified_array = ctx
   59|      0|                .registry
   60|      0|                .merge_qualifiers(QualType::unqualified(array_type_ref), current_type.qualifiers());
   61|      0|            apply_parsed_declarator_recursive(qualified_array, inner, ctx, span)
   62|       |        }
   63|      1|        ParsedDeclaratorNode::Function { params, flags, inner } => {
   64|       |            // Function
   65|       |            // Process parameters separately
   66|      1|            let parsed_params: Vec<_> = ctx.parsed_ast.parsed_types.get_params(params).to_vec();
   67|      1|            let mut processed_params = Vec::new();
   68|      1|            for param in parsed_params {
                              ^0
   69|      0|                let param_type = convert_to_qual_type(ctx, param.ty, param.span).unwrap_or_else(|_| {
   70|       |                    // Create an error type if conversion fails
   71|      0|                    QualType::unqualified(ctx.registry.type_int)
   72|      0|                });
   73|       |
   74|       |                // Apply array-to-pointer decay for function parameters
   75|      0|                let ptr_quals = extract_array_param_qualifiers_from_ref(param.ty.declarator, ctx);
   76|      0|                let decayed_param_type = ctx.registry.decay(param_type, ptr_quals);
   77|       |
   78|      0|                processed_params.push(FunctionParameter {
   79|      0|                    param_type: decayed_param_type,
   80|      0|                    name: param.name,
   81|      0|                });
   82|       |            }
   83|       |
   84|       |            // Apply Function modifier to the current type
   85|      1|            let function_type_ref = ctx.registry.function_type(
   86|      1|                current_type.ty(),
   87|      1|                processed_params,
   88|      1|                flags.is_variadic,
   89|       |                false, // `_Noreturn` is a specifier, not part of declarator
   90|       |            );
   91|      1|            apply_parsed_declarator_recursive(QualType::unqualified(function_type_ref), inner, ctx, span)
   92|       |        }
   93|       |    }
   94|     29|}
   95|       |
   96|      0|fn extract_array_param_qualifiers_from_ref(decl_ref: ParsedDeclRef, ctx: &LowerCtx) -> TypeQualifiers {
   97|      0|    let decl = ctx.parsed_ast.parsed_types.get_decl(decl_ref);
   98|      0|    match decl {
   99|      0|        ParsedDeclaratorNode::Identifier { .. } => TypeQualifiers::empty(),
  100|      0|        ParsedDeclaratorNode::Pointer { inner, .. } => extract_array_param_qualifiers_from_ref(inner, ctx),
  101|      0|        ParsedDeclaratorNode::Function { inner, .. } => extract_array_param_qualifiers_from_ref(inner, ctx),
  102|      0|        ParsedDeclaratorNode::Array { size, inner } => {
  103|      0|            let inner_quals = extract_array_param_qualifiers_from_ref(inner, ctx);
  104|      0|            if !inner_quals.is_empty() {
  105|      0|                return inner_quals;
  106|      0|            }
  107|      0|            match size {
  108|      0|                ParsedArraySize::Expression { qualifiers, .. } => qualifiers,
  109|      0|                ParsedArraySize::Star { qualifiers } => qualifiers,
  110|      0|                ParsedArraySize::VlaSpecifier { qualifiers, .. } => qualifiers,
  111|      0|                ParsedArraySize::Incomplete => TypeQualifiers::empty(),
  112|       |            }
  113|       |        }
  114|       |    }
  115|      0|}
  116|       |
  117|     72|fn extract_array_param_qualifiers(decl: &ParsedDeclarator) -> TypeQualifiers {
  118|     72|    match decl {
  119|     49|        ParsedDeclarator::Identifier(..) | ParsedDeclarator::Abstract => TypeQualifiers::empty(),
  120|     13|        ParsedDeclarator::Pointer(_, inner) => {
  121|     13|            if let Some(inner_decl) = inner {
  122|     13|                extract_array_param_qualifiers(inner_decl)
  123|       |            } else {
  124|      0|                TypeQualifiers::empty()
  125|       |            }
  126|       |        }
  127|     10|        ParsedDeclarator::Array(inner, size) => {
  128|     10|            let inner_quals = extract_array_param_qualifiers(inner);
  129|     10|            if !inner_quals.is_empty() {
  130|      1|                return inner_quals;
  131|      9|            }
  132|      9|            match size {
  133|      2|                ParsedArraySize::Expression { qualifiers, .. } => *qualifiers,
  134|      0|                ParsedArraySize::Star { qualifiers } => *qualifiers,
  135|      7|                ParsedArraySize::VlaSpecifier { qualifiers, .. } => *qualifiers,
  136|      0|                ParsedArraySize::Incomplete => TypeQualifiers::empty(),
  137|       |            }
  138|       |        }
  139|      0|        ParsedDeclarator::Function { inner, .. } => extract_array_param_qualifiers(inner),
  140|      0|        ParsedDeclarator::BitField(inner, _) => extract_array_param_qualifiers(inner),
  141|      0|        ParsedDeclarator::AnonymousRecord(..) => TypeQualifiers::empty(),
  142|       |    }
  143|     72|}
  144|       |
  145|       |/// Convert ParsedArraySize to ArraySizeType
  146|      0|fn convert_parsed_array_size(size: &ParsedArraySize, ctx: &mut LowerCtx) -> ArraySizeType {
  147|      0|    match size {
  148|      0|        ParsedArraySize::Expression { expr, .. } => resolve_array_size(Some(*expr), ctx),
  149|      0|        ParsedArraySize::Star { .. } => ArraySizeType::Star,
  150|      0|        ParsedArraySize::Incomplete => ArraySizeType::Incomplete,
  151|      0|        ParsedArraySize::VlaSpecifier { size, .. } => resolve_array_size(*size, ctx),
  152|       |    }
  153|      0|}
  154|       |
  155|       |/// Helper function to resolve array size logic
  156|     36|fn resolve_array_size(size: Option<ParsedNodeRef>, ctx: &mut LowerCtx) -> ArraySizeType {
  157|     36|    if let Some(parsed_ref) = size {
  158|     36|        let expr_ref = ctx.lower_expression(parsed_ref);
  159|     36|        let const_ctx = ConstEvalCtx {
  160|     36|            ast: ctx.ast,
  161|     36|            symbol_table: ctx.symbol_table,
  162|     36|        };
  163|     36|        if let Some(val) = const_eval::eval_const_expr(&const_ctx, expr_ref) {
                                  ^34
  164|     34|            if val < 0 {
  165|      1|                ctx.report_error(SemanticError::InvalidArraySize {
  166|      1|                    span: ctx.ast.get_span(expr_ref),
  167|      1|                });
  168|      1|                return ArraySizeType::Incomplete;
  169|     33|            }
  170|     33|            return ArraySizeType::Constant(val as usize);
  171|       |        } else {
  172|       |            // For now, we only support constant sizes (VLA support is future)
  173|       |            // Or maybe we should return Variable(expr_ref) and let ensure_layout fail?
  174|       |            // But verify what Variable does.
  175|       |            // ensure_layout returns "incomplete/VLA array layout" error.
  176|      2|            return ArraySizeType::Variable(expr_ref);
  177|       |        }
  178|      0|    }
  179|      0|    ArraySizeType::Incomplete
  180|     36|}
  181|       |
  182|       |/// Context for the semantic lowering phase
  183|       |pub(crate) struct LowerCtx<'a, 'src> {
  184|       |    pub(crate) parsed_ast: &'a ParsedAst,
  185|       |    pub(crate) ast: &'a mut Ast,
  186|       |    pub(crate) diag: &'src mut DiagnosticEngine,
  187|       |    pub(crate) symbol_table: &'a mut SymbolTable,
  188|       |    pub(crate) has_errors: bool,
  189|       |    pub(crate) registry: &'a mut TypeRegistry,
  190|       |}
  191|       |
  192|       |impl<'a, 'src> LowerCtx<'a, 'src> {
  193|       |    /// Create a new lowering context
  194|    205|    pub(crate) fn new(
  195|    205|        parsed_ast: &'a ParsedAst,
  196|    205|        ast: &'a mut Ast,
  197|    205|        diag: &'src mut DiagnosticEngine,
  198|    205|        symbol_table: &'a mut SymbolTable,
  199|    205|        registry: &'a mut TypeRegistry,
  200|    205|    ) -> Self {
  201|    205|        Self {
  202|    205|            parsed_ast,
  203|    205|            ast,
  204|    205|            diag,
  205|    205|            symbol_table,
  206|    205|            has_errors: false,
  207|    205|            registry,
  208|    205|        }
  209|    205|    }
  210|       |
  211|       |    /// Report a semantic error and mark context as having errors
  212|     23|    pub(crate) fn report_error(&mut self, error: SemanticError) {
  213|     23|        self.has_errors = true;
  214|     23|        self.diag.report(error);
  215|     23|    }
  216|       |
  217|  1.28k|    pub(crate) fn merge_qualifiers_with_check(
  218|  1.28k|        &mut self,
  219|  1.28k|        base: QualType,
  220|  1.28k|        add: TypeQualifiers,
  221|  1.28k|        span: SourceSpan,
  222|  1.28k|    ) -> QualType {
  223|  1.28k|        if add.contains(TypeQualifiers::RESTRICT) && !base.is_pointer() {
                                                                   ^3
  224|      1|            self.report_error(SemanticError::InvalidRestrict { span });
  225|  1.28k|        }
  226|  1.28k|        self.registry.merge_qualifiers(base, add)
  227|  1.28k|    }
  228|       |
  229|  2.86k|    fn set_scope(&mut self, _node_ref: NodeRef, _scope_id: ScopeId) {
  230|       |        // scope_map removed.
  231|       |        // Nodes that need scope now store it directly.
  232|  2.86k|    }
  233|       |
  234|  1.84k|    fn push_dummy(&mut self, span: SourceSpan) -> NodeRef {
  235|  1.84k|        let node_ref = self.ast.push_dummy(span);
  236|  1.84k|        self.set_scope(node_ref, self.symbol_table.current_scope());
  237|  1.84k|        node_ref
  238|  1.84k|    }
  239|       |
  240|       |    /// Get the first slot from target_slots if available, otherwise push a new dummy node.
  241|       |    /// Also ensures scope is set on the node.
  242|    966|    fn get_or_push_slot(&mut self, target_slots: Option<&[NodeRef]>, span: SourceSpan) -> NodeRef {
  243|    966|        if let Some(target) = target_slots.and_then(|t| t.first()) {
                                  ^320                                ^320^320
  244|    320|            self.set_scope(*target, self.symbol_table.current_scope());
  245|    320|            *target
  246|       |        } else {
  247|    646|            self.push_dummy(span)
  248|       |        }
  249|    966|    }
  250|       |
  251|    976|    fn count_semantic_nodes(&self, node_ref: ParsedNodeRef) -> usize {
  252|    976|        let node = self.parsed_ast.get_node(node_ref);
  253|    976|        match &node.kind {
  254|    330|            ParsedNodeKind::Declaration(decl) => {
  255|    330|                if decl.init_declarators.is_empty() {
  256|      0|                    1
  257|       |                } else {
  258|    330|                    decl.init_declarators.len()
  259|       |                }
  260|       |            }
  261|      0|            ParsedNodeKind::TranslationUnit(decls) => decls.len(),
  262|    646|            _ => 1,
  263|       |        }
  264|    976|    }
  265|       |}
  266|       |
  267|       |/// Information about declaration specifiers after processing
  268|       |#[derive(Debug, Clone, Default)]
  269|       |pub(crate) struct DeclSpecInfo {
  270|       |    pub(crate) storage: Option<StorageClass>,
  271|       |    pub(crate) is_thread_local: bool,
  272|       |    pub(crate) qualifiers: TypeQualifiers,
  273|       |    pub(crate) base_type: Option<QualType>,
  274|       |    pub(crate) is_typedef: bool,
  275|       |    pub(crate) is_inline: bool,
  276|       |    pub(crate) is_noreturn: bool,
  277|       |    pub(crate) alignment: Option<u32>,
  278|       |}
  279|       |
  280|       |/// Convert a ParsedBaseTypeNode to a QualType
  281|     22|fn convert_parsed_base_type_to_qual_type(
  282|     22|    ctx: &mut LowerCtx,
  283|     22|    parsed_base: &ParsedBaseTypeNode,
  284|     22|    span: SourceSpan,
  285|     22|) -> Result<QualType, SemanticError> {
  286|     22|    match parsed_base {
  287|     20|        ParsedBaseTypeNode::Builtin(ts) => resolve_type_specifier(ts, ctx, span),
  288|      2|        ParsedBaseTypeNode::Record { tag, members, is_union } => {
  289|       |            // Handle struct/union from parsed types
  290|      2|            let is_definition = members.is_some();
  291|      2|            let type_ref = resolve_record_tag(ctx, *tag, *is_union, is_definition, span)?;
                                                                                                      ^0
  292|       |
  293|       |            // Now handle members if it's a definition
  294|      2|            if let Some(members_range) = members {
                                      ^0
  295|       |                // Get the parsed members first to avoid borrowing conflicts
  296|      0|                let parsed_members: Vec<_> = ctx.parsed_ast.parsed_types.get_struct_members(*members_range).to_vec();
  297|       |
  298|       |                // Process member types separately to avoid borrowing conflicts
  299|      0|                let mut member_types = Vec::new();
  300|      0|                for parsed_member in &parsed_members {
  301|      0|                    let member_type_ref = convert_to_qual_type(ctx, parsed_member.ty, span)?;
  302|      0|                    member_types.push(member_type_ref);
  303|       |                }
  304|       |
  305|       |                // Now create struct members with the processed types
  306|      0|                let mut struct_members = Vec::new();
  307|      0|                let mut seen_names = HashMap::new();
  308|       |
  309|      0|                for (i, parsed_member) in parsed_members.iter().enumerate() {
  310|      0|                    if let Some(name) = parsed_member.name {
  311|      0|                        if let Some(&first_def) = seen_names.get(&name) {
  312|      0|                            ctx.report_error(SemanticError::DuplicateMember {
  313|      0|                                name,
  314|      0|                                span: parsed_member.span,
  315|      0|                                first_def,
  316|      0|                            });
  317|      0|                        } else {
  318|      0|                            seen_names.insert(name, parsed_member.span);
  319|      0|                        }
  320|      0|                    }
  321|       |
  322|      0|                    struct_members.push(StructMember {
  323|      0|                        name: parsed_member.name,
  324|      0|                        member_type: member_types[i],
  325|      0|                        bit_field_size: parsed_member.bit_field_size,
  326|      0|                        span: parsed_member.span,
  327|      0|                    });
  328|       |                }
  329|       |
  330|      0|                complete_record_symbol(ctx, *tag, type_ref, struct_members)?;
  331|      2|            }
  332|       |
  333|      2|            Ok(QualType::unqualified(type_ref))
  334|       |        }
  335|      0|        ParsedBaseTypeNode::Enum { tag, enumerators } => {
  336|       |            // Handle enum from parsed types
  337|      0|            let is_definition = enumerators.is_some();
  338|      0|            let type_ref = resolve_enum_tag(ctx, *tag, is_definition, span)?;
  339|       |
  340|       |            // Process enumerators if it's a definition
  341|      0|            if let Some(enum_range) = enumerators {
  342|      0|                let parsed_enums = ctx.parsed_ast.parsed_types.get_enum_constants(*enum_range);
  343|      0|                let mut next_value = 0i64;
  344|      0|                let mut enumerators_list = Vec::new();
  345|       |
  346|      0|                for parsed_enum in parsed_enums {
  347|      0|                    let value = parsed_enum.value.unwrap_or(next_value);
  348|      0|                    next_value = value + 1;
  349|      0|
  350|      0|                    let enum_constant = EnumConstant {
  351|      0|                        name: parsed_enum.name,
  352|      0|                        value,
  353|      0|                        span: parsed_enum.span,
  354|      0|                    };
  355|      0|                    enumerators_list.push(enum_constant);
  356|      0|
  357|      0|                    // Register constant in symbol table
  358|      0|                    let _ = ctx
  359|      0|                        .symbol_table
  360|      0|                        .define_enum_constant(parsed_enum.name, value, type_ref, parsed_enum.span);
  361|      0|                }
  362|       |
  363|      0|                complete_enum_symbol(ctx, *tag, type_ref, enumerators_list)?;
  364|      0|            }
  365|       |
  366|      0|            Ok(QualType::unqualified(type_ref))
  367|       |        }
  368|      0|        ParsedBaseTypeNode::Typedef(name) => {
  369|       |            // Lookup typedef in symbol table
  370|      0|            if let Some((entry_ref, _scope_id)) = ctx.symbol_table.lookup_symbol(*name) {
  371|      0|                let entry = ctx.symbol_table.get_symbol(entry_ref);
  372|      0|                if let SymbolKind::Typedef { aliased_type } = entry.kind {
  373|      0|                    Ok(aliased_type)
  374|       |                } else {
  375|       |                    // Get the kind of the symbol as a string for the error message
  376|      0|                    let kind_string = format!("{:?}", entry.kind);
  377|      0|                    let found_kind_str = kind_string.split_whitespace().next().unwrap_or("symbol");
  378|      0|                    Err(SemanticError::TypeMismatch {
  379|      0|                        expected: "a typedef name".to_string(),
  380|      0|                        found: format!("a {}", found_kind_str.to_lowercase()),
  381|      0|                        span,
  382|      0|                    })
  383|       |                }
  384|       |            } else {
  385|       |                // Typedef not found during semantic lowering - this is expected
  386|       |                // when typedefs are defined later in the same scope.
  387|      0|                Ok(QualType::unqualified(ctx.registry.declare_record(Some(*name), false)))
  388|       |            }
  389|       |        }
  390|       |        ParsedBaseTypeNode::Error => {
  391|       |            // Create an error type
  392|      0|            Ok(QualType::unqualified(ctx.registry.type_error))
  393|       |        }
  394|       |    }
  395|     22|}
  396|       |
  397|       |/// Convert a ParsedType to a TypeRef
  398|     22|fn convert_to_qual_type(
  399|     22|    ctx: &mut LowerCtx,
  400|     22|    parsed_type: ParsedType,
  401|     22|    span: SourceSpan,
  402|     22|) -> Result<QualType, SemanticError> {
  403|     22|    let base_type_node = {
  404|       |        // borrow immutable hanya di dalam block ini
  405|     22|        let parsed_types = &ctx.parsed_ast.parsed_types;
  406|     22|        parsed_types.get_base_type(parsed_type.base)
  407|       |    };
  408|       |
  409|     22|    let declarator_ref = parsed_type.declarator;
  410|     22|    let qualifiers = parsed_type.qualifiers;
  411|       |
  412|     22|    let base_type_ref = convert_parsed_base_type_to_qual_type(ctx, &base_type_node, span)?;
                                                                                                       ^0
  413|       |
  414|     22|    let final_type = apply_parsed_declarator_recursive(base_type_ref, declarator_ref, ctx, span);
  415|     22|    Ok(ctx.merge_qualifiers_with_check(final_type, qualifiers, span))
  416|     22|}
  417|       |
  418|       |/// Helper to resolve struct/union tags (lookup, forward decl, or definition validation)
  419|    101|fn resolve_record_tag(
  420|    101|    ctx: &mut LowerCtx,
  421|    101|    tag: Option<NameId>,
  422|    101|    is_union: bool,
  423|    101|    is_definition: bool,
  424|    101|    span: SourceSpan,
  425|    101|) -> Result<TypeRef, SemanticError> {
  426|    101|    let existing_entry = tag.and_then(|tag_name| ctx.symbol_table.lookup_tag(tag_name));
                                                               ^89              ^89        ^89
  427|       |
  428|    101|    if let Some(tag_name) = tag {
                              ^89
  429|       |        // Named struct/union
  430|     89|        if is_definition {
  431|       |            // This is a DEFINITION: struct T { ... }
  432|     46|            let in_current_scope =
  433|     46|                existing_entry.is_some_and(|(_, scope_id)| scope_id == ctx.symbol_table.current_scope());
                                                                         ^2          ^2
  434|       |
  435|     46|            if in_current_scope {
  436|      1|                let (entry_ref, _) = existing_entry.unwrap();
  437|      1|                let (is_completed, first_def, ty) = {
  438|      1|                    let entry = ctx.symbol_table.get_symbol(entry_ref);
  439|      1|                    (entry.is_completed, entry.def_span, entry.type_info.ty())
  440|      1|                };
  441|       |
  442|      1|                if is_completed {
  443|       |                    // Redeclaration error
  444|      0|                    ctx.report_error(SemanticError::Redefinition {
  445|      0|                        name: tag_name,
  446|      0|                        first_def,
  447|      0|                        span,
  448|      0|                    });
  449|      0|                    Ok(ty)
  450|       |                } else {
  451|       |                    // Completing a forward declaration in current scope
  452|      1|                    Ok(ty)
  453|       |                }
  454|       |            } else {
  455|       |                // Not in current scope (either not found or shadowing outer)
  456|       |                // Create a new record type
  457|     45|                let new_type_ref = ctx.registry.declare_record(Some(tag_name), is_union);
  458|       |
  459|       |                // Add it to the symbol table in the current scope
  460|     45|                ctx.symbol_table.define_record(tag_name, new_type_ref, false, span);
  461|     45|                Ok(new_type_ref)
  462|       |            }
  463|       |        } else {
  464|       |            // This is a USAGE or FORWARD DECL: struct T; or struct T s;
  465|     43|            if let Some((entry_ref, _)) = existing_entry {
                                       ^38
  466|       |                // Found existing (either in current or outer scope)
  467|     38|                let entry = ctx.symbol_table.get_symbol(entry_ref);
  468|     38|                Ok(entry.type_info.ty())
  469|       |            } else {
  470|       |                // Not found anywhere, create an implicit forward declaration in current scope
  471|      5|                let forward_ref = ctx.registry.declare_record(Some(tag_name), is_union);
  472|       |
  473|      5|                ctx.symbol_table.define_record(tag_name, forward_ref, false, span);
  474|      5|                Ok(forward_ref)
  475|       |            }
  476|       |        }
  477|       |    } else {
  478|       |        // Anonymous struct/union definition
  479|     12|        Ok(ctx.registry.declare_record(None, is_union))
  480|       |    }
  481|    101|}
  482|       |
  483|       |/// Helper to resolve enum tags
  484|     11|fn resolve_enum_tag(
  485|     11|    ctx: &mut LowerCtx,
  486|     11|    tag: Option<NameId>,
  487|     11|    is_definition: bool,
  488|     11|    span: SourceSpan,
  489|     11|) -> Result<TypeRef, SemanticError> {
  490|     11|    let existing_entry = tag.and_then(|tag_name| ctx.symbol_table.lookup_tag(tag_name));
  491|       |
  492|     11|    if let Some(tag_name) = tag {
  493|     11|        if is_definition {
  494|       |            // This is a DEFINITION: enum T { ... };
  495|      8|            if let Some((entry_ref, scope_id)) = existing_entry
                                       ^0         ^0
  496|      0|                && scope_id == ctx.symbol_table.current_scope()
  497|       |            {
  498|       |                // Found in current scope, check if completed
  499|      0|                let (is_completed, first_def, type_info) = {
  500|      0|                    let entry = ctx.symbol_table.get_symbol(entry_ref);
  501|      0|                    (entry.is_completed, entry.def_span, entry.type_info)
  502|      0|                };
  503|      0|                if is_completed {
  504|      0|                    ctx.report_error(SemanticError::Redefinition {
  505|      0|                        name: tag_name,
  506|      0|                        first_def,
  507|      0|                        span,
  508|      0|                    });
  509|      0|                }
  510|      0|                Ok(type_info.ty())
  511|       |            } else {
  512|       |                // Not found in current scope, create new entry
  513|      8|                let new_type_ref = ctx.registry.declare_enum(Some(tag_name), ctx.registry.type_int);
  514|      8|                ctx.symbol_table.define_enum(tag_name, new_type_ref, span);
  515|      8|                Ok(new_type_ref)
  516|       |            }
  517|       |        } else {
  518|       |            // This is a USAGE or FORWARD DECL: enum T; or enum T e;
  519|      3|            if let Some((entry_ref, _)) = existing_entry {
  520|      3|                let entry = ctx.symbol_table.get_symbol(entry_ref);
  521|      3|                Ok(entry.type_info.ty())
  522|       |            } else {
  523|       |                // Implicit forward declaration
  524|      0|                let forward_ref = ctx.registry.declare_enum(Some(tag_name), ctx.registry.type_int);
  525|       |
  526|      0|                ctx.symbol_table.define_enum(tag_name, forward_ref, span);
  527|      0|                Ok(forward_ref)
  528|       |            }
  529|       |        }
  530|       |    } else {
  531|       |        // Anonymous enum definition
  532|      0|        Ok(ctx.registry.declare_enum(None, ctx.registry.type_int))
  533|       |    }
  534|     11|}
  535|       |
  536|       |/// Recursively validates that there are no duplicate member names, descending into anonymous records.
  537|       |///
  538|       |///  Bolt: This function is optimized to avoid heap allocations.
  539|       |/// Instead of taking a mutable `LowerCtx` and cloning member lists to satisfy the
  540|       |/// borrow checker, it now takes an immutable `&TypeRegistry` and returns a `Vec`
  541|       |/// of diagnostics. This avoids expensive `members.clone()` operations, especially
  542|       |/// in deeply nested anonymous structs/unions.
  543|     71|fn validate_record_members(
  544|     71|    registry: &TypeRegistry,
  545|     71|    members: &[StructMember],
  546|     71|    seen_names: &mut HashMap<NameId, SourceSpan>,
  547|     71|) -> Vec<SemanticError> {
  548|     71|    let mut errors = Vec::new();
  549|       |
  550|    193|    for member in members {
                      ^122
  551|    122|        if let Some(name) = member.name {
                                  ^109
  552|    109|            if let Some(&first_def) = seen_names.get(&name) {
                                       ^3
  553|      3|                errors.push(SemanticError::DuplicateMember {
  554|      3|                    name,
  555|      3|                    span: member.span,
  556|      3|                    first_def,
  557|      3|                });
  558|    106|            } else {
  559|    106|                seen_names.insert(name, member.span);
  560|    106|            }
  561|       |        } else {
  562|       |            // Anonymous member, recurse
  563|     13|            let member_ty = member.member_type;
  564|     13|            if member_ty.is_record()
  565|       |                && let TypeKind::Record {
  566|     13|                    members: inner_members, ..
  567|     13|                } = &registry.get(member_ty.ty()).kind
  568|     13|            {
  569|     13|                errors.extend(validate_record_members(registry, inner_members, seen_names));
  570|     13|            }
                          ^0
  571|       |        }
  572|       |    }
  573|     71|    errors
  574|     71|}
  575|       |
  576|     58|fn complete_record_symbol(
  577|     58|    ctx: &mut LowerCtx,
  578|     58|    tag: Option<NameId>,
  579|     58|    type_ref: TypeRef,
  580|     58|    members: Vec<StructMember>,
  581|     58|) -> Result<(), SemanticError> {
  582|       |    // New: Validate for name conflicts across anonymous members
  583|     58|    let mut seen_names = HashMap::new();
  584|     58|    let validation_errors = validate_record_members(ctx.registry, &members, &mut seen_names);
  585|     61|    for error in validation_errors {
                      ^3
  586|      3|        ctx.report_error(error);
  587|      3|    }
  588|       |
  589|       |    // Update the type in AST and SymbolTable
  590|     58|    ctx.registry.complete_record(type_ref, members.clone());
  591|     58|    ctx.registry.ensure_layout(type_ref)?;
                                                      ^2
  592|       |
  593|     56|    if let Some(tag_name) = tag
                              ^44
  594|     44|        && let Some((entry_ref, _)) = ctx.symbol_table.lookup_tag(tag_name)
  595|       |    {
  596|     44|        let entry = ctx.symbol_table.get_symbol_mut(entry_ref);
  597|     44|        entry.is_completed = true;
  598|       |        if let SymbolKind::Record {
  599|     44|            is_complete,
  600|     44|            members: entry_members,
  601|       |            ..
  602|     44|        } = &mut entry.kind
  603|     44|        {
  604|     44|            *is_complete = true;
  605|     44|            *entry_members = members; // This is now the original value
  606|     44|        }
                      ^0
  607|     12|    }
  608|     56|    Ok(())
  609|     58|}
  610|       |
  611|      8|fn complete_enum_symbol(
  612|      8|    ctx: &mut LowerCtx,
  613|      8|    tag: Option<NameId>,
  614|      8|    type_ref: TypeRef,
  615|      8|    enumerators: Vec<EnumConstant>,
  616|      8|) -> Result<(), SemanticError> {
  617|       |    // Update the type in AST and SymbolTable using the proper completion function
  618|      8|    ctx.registry.complete_enum(type_ref, enumerators);
  619|      8|    ctx.registry.ensure_layout(type_ref)?;
                                                      ^0
  620|       |
  621|      8|    if let Some(tag_name) = tag
  622|      8|        && let Some((entry_ref, _)) = ctx.symbol_table.lookup_tag(tag_name)
  623|       |    {
  624|      8|        let entry = ctx.symbol_table.get_symbol_mut(entry_ref);
  625|      8|        entry.is_completed = true;
  626|      8|        if let SymbolKind::EnumTag { is_complete } = &mut entry.kind {
  627|      8|            *is_complete = true;
  628|      8|        }
                      ^0
  629|      0|    }
  630|      8|    Ok(())
  631|      8|}
  632|       |
  633|       |/// Resolve a type specifier to a QualType
  634|    706|fn resolve_type_specifier(
  635|    706|    ts: &ParsedTypeSpecifier,
  636|    706|    ctx: &mut LowerCtx,
  637|    706|    span: SourceSpan,
  638|    706|) -> Result<QualType, SemanticError> {
  639|    706|    match ts {
  640|     38|        ParsedTypeSpecifier::Void => Ok(QualType::unqualified(ctx.registry.type_void)),
  641|     25|        ParsedTypeSpecifier::Char => Ok(QualType::unqualified(ctx.registry.type_char)),
  642|      6|        ParsedTypeSpecifier::Short => Ok(QualType::unqualified(ctx.registry.type_short)),
  643|    461|        ParsedTypeSpecifier::Int => Ok(QualType::unqualified(ctx.registry.type_int)),
  644|     15|        ParsedTypeSpecifier::Long => Ok(QualType::unqualified(ctx.registry.type_long)),
  645|      5|        ParsedTypeSpecifier::LongLong => Ok(QualType::unqualified(ctx.registry.type_long_long)),
  646|     14|        ParsedTypeSpecifier::Float => Ok(QualType::unqualified(ctx.registry.type_float)),
  647|      8|        ParsedTypeSpecifier::Double => Ok(QualType::unqualified(ctx.registry.type_double)),
  648|      1|        ParsedTypeSpecifier::LongDouble => Ok(QualType::unqualified(ctx.registry.type_long_double)),
  649|       |        ParsedTypeSpecifier::Signed => {
  650|       |            // Signed modifier
  651|      4|            Ok(QualType::unqualified(ctx.registry.type_signed))
  652|       |        }
  653|       |        ParsedTypeSpecifier::Unsigned => {
  654|       |            // Unsigned modifier - return a special marker type that will be handled in merge_base_type
  655|     14|            Ok(QualType::unqualified(ctx.registry.type_int_unsigned))
  656|       |        }
  657|      1|        ParsedTypeSpecifier::Bool => Ok(QualType::unqualified(ctx.registry.type_bool)),
  658|       |        ParsedTypeSpecifier::Complex => {
  659|       |            // Complex types need a base type
  660|       |            // For now, default to complex double
  661|      0|            let complex_type = ctx.registry.complex_type(ctx.registry.type_double);
  662|      0|            Ok(QualType::unqualified(complex_type))
  663|       |        }
  664|      0|        ParsedTypeSpecifier::Atomic(parsed_type) => {
  665|       |            // Convert the ParsedType to a TypeRef by applying the declarator to the base type
  666|      0|            convert_to_qual_type(ctx, *parsed_type, span)
  667|       |        }
  668|     99|        ParsedTypeSpecifier::Record(is_union, tag, definition) => {
  669|       |            // ... resolve_record_tag works same args ...
  670|     99|            let is_definition = definition.is_some();
  671|     99|            let type_ref = resolve_record_tag(ctx, *tag, *is_union, is_definition, span)?;
                                                                                                      ^0
  672|       |
  673|       |            // Now handle members if it's a definition
  674|     99|            if let Some(def) = definition {
                                      ^58
  675|       |                // def is ParsedRecordDefData. members is Option<Vec<ParsedDeclarationData>>.
  676|       |                // lower_struct_members expects Vec<ParsedDeclarationData>?
  677|       |                // It expects &[DeclarationData] before.
  678|       |                // I need to update lower_struct_members as well.
  679|     58|                let members = def
  680|     58|                    .members
  681|     58|                    .as_ref()
  682|     58|                    .map(|decls| lower_struct_members(decls, ctx, span))
  683|     58|                    .unwrap_or_default();
  684|       |
  685|     58|                complete_record_symbol(ctx, *tag, type_ref, members)?;
                                                                                  ^2
  686|     41|            }
  687|       |
  688|     97|            Ok(QualType::unqualified(type_ref))
  689|       |        }
  690|     11|        ParsedTypeSpecifier::Enum(tag, enumerators) => {
  691|     11|            let is_definition = enumerators.is_some();
  692|     11|            let type_ref_to_use = resolve_enum_tag(ctx, *tag, is_definition, span)?;
                                                                                                ^0
  693|       |
  694|       |            // 2. Process enumerators if it's a definition
  695|     11|            if let Some(enums) = enumerators {
                                      ^8
  696|      8|                let mut next_value = 0i64;
  697|      8|                let mut enumerators_list = Vec::new();
  698|       |
  699|     24|                for &enum_ref in enums {
                                   ^16
  700|       |                    // Get node from PARSED ast
  701|     16|                    let enum_node = ctx.parsed_ast.get_node(enum_ref);
  702|     16|                    if let ParsedNodeKind::EnumConstant(name, value_expr_ref) = &enum_node.kind {
  703|     16|                        let value = if let Some(v_ref) = value_expr_ref {
                                                              ^5
  704|      5|                            let expr_ref = ctx.lower_expression(*v_ref);
  705|      5|                            let const_ctx = ConstEvalCtx {
  706|      5|                                ast: ctx.ast,
  707|      5|                                symbol_table: ctx.symbol_table,
  708|      5|                            };
  709|      5|                            if let Some(val) = const_eval::eval_const_expr(&const_ctx, expr_ref) {
  710|      5|                                val
  711|       |                            } else {
  712|      0|                                ctx.report_error(SemanticError::NonConstantInitializer { span: enum_node.span });
  713|      0|                                0
  714|       |                            }
  715|       |                        } else {
  716|     11|                            next_value
  717|       |                        };
  718|     16|                        next_value = value + 1;
  719|       |
  720|     16|                        let enum_constant = EnumConstant {
  721|     16|                            name: *name,
  722|     16|                            value,
  723|     16|                            span: enum_node.span,
  724|     16|                        };
  725|     16|                        enumerators_list.push(enum_constant);
  726|       |
  727|       |                        // Register constant in symbol table
  728|     16|                        if let Err(SymbolTableError::InvalidRedefinition { existing, .. }) = ctx
                                                                                         ^1
  729|     16|                            .symbol_table
  730|     16|                            .define_enum_constant(*name, value, type_ref_to_use, enum_node.span)
  731|      1|                        {
  732|      1|                            let first_def = ctx.symbol_table.get_symbol(existing).def_span;
  733|      1|                            ctx.report_error(SemanticError::Redefinition {
  734|      1|                                name: *name,
  735|      1|                                first_def,
  736|      1|                                span: enum_node.span,
  737|      1|                            });
  738|     15|                        }
  739|      0|                    }
  740|       |                }
  741|       |
  742|      8|                complete_enum_symbol(ctx, *tag, type_ref_to_use, enumerators_list)?;
                                                                                                ^0
  743|      3|            }
  744|       |
  745|     11|            Ok(QualType::unqualified(type_ref_to_use))
  746|       |        }
  747|      4|        ParsedTypeSpecifier::TypedefName(name) => {
  748|       |            // Lookup typedef in symbol table
  749|      4|            if let Some((entry_ref, _scope_id)) = ctx.symbol_table.lookup_symbol(*name) {
  750|      4|                let entry = ctx.symbol_table.get_symbol(entry_ref);
  751|      4|                if let SymbolKind::Typedef { aliased_type } = entry.kind {
  752|      4|                    Ok(aliased_type)
  753|       |                } else {
  754|      0|                    let kind_string = format!("{:?}", entry.kind);
  755|      0|                    let found_kind_str = kind_string.split_whitespace().next().unwrap_or("symbol");
  756|      0|                    Err(SemanticError::ExpectedTypedefName {
  757|      0|                        found: format!("a {}", found_kind_str.to_lowercase()),
  758|      0|                        span,
  759|      0|                    })
  760|       |                }
  761|       |            } else {
  762|      0|                Ok(QualType::unqualified(ctx.registry.declare_record(Some(*name), false)))
  763|       |            }
  764|       |        }
  765|       |    }
  766|    706|}
  767|       |
  768|       |/// Merge base types according to C type combination rules
  769|    686|fn merge_base_type(
  770|    686|    existing: Option<QualType>,
  771|    686|    new_type: QualType,
  772|    686|    ctx: &mut LowerCtx,
  773|    686|    span: SourceSpan,
  774|    686|) -> Option<QualType> {
  775|    686|    match existing {
  776|    659|        None => Some(new_type),
  777|     27|        Some(existing_ref) => {
  778|     27|            let existing_type = ctx.registry.get(existing_ref.ty());
  779|     27|            let new_type_info = ctx.registry.get(new_type.ty());
  780|       |
  781|     27|            match (&existing_type.kind, &new_type_info.kind) {
  782|     27|                (TypeKind::Builtin(existing_builtin), TypeKind::Builtin(new_builtin)) => {
  783|     27|                    match (existing_builtin, new_builtin) {
  784|       |                        // 1. Same types (redundancy)
  785|     27|                        (a, b) if a == b => {
                                       ^1 ^1         ^1
  786|       |                            // C99/C11: int int is NOT allowed, but long long is.
  787|       |                            // However, many compilers allow redundant specifiers.
  788|       |                            // In Cendol, we'll allow it if they are identical,
  789|       |                            // EXCEPT for types that already have a combined form (like long long).
  790|      1|                            if *a == BuiltinType::Long {
  791|      1|                                Some(QualType::unqualified(ctx.registry.type_long_long))
  792|       |                            } else {
  793|      0|                                Some(existing_ref)
  794|       |                            }
  795|       |                        }
  796|       |
  797|       |                        // 2. Handle Signed as a modifier
  798|      1|                        (BuiltinType::Signed, BuiltinType::Int) => Some(new_type),
  799|      0|                        (BuiltinType::Int, BuiltinType::Signed) => Some(existing_ref),
  800|       |
  801|       |                        (BuiltinType::Signed, BuiltinType::Char) => {
  802|      2|                            Some(QualType::unqualified(ctx.registry.type_schar))
  803|       |                        }
  804|       |                        (BuiltinType::Char, BuiltinType::Signed) => {
  805|      0|                            Some(QualType::unqualified(ctx.registry.type_schar))
  806|       |                        }
  807|       |
  808|      0|                        (BuiltinType::Signed, BuiltinType::Short) => Some(new_type),
  809|      0|                        (BuiltinType::Short, BuiltinType::Signed) => Some(existing_ref),
  810|       |
  811|      1|                        (BuiltinType::Signed, BuiltinType::Long) => Some(new_type),
  812|      0|                        (BuiltinType::Long, BuiltinType::Signed) => Some(existing_ref),
  813|       |
  814|      0|                        (BuiltinType::Signed, BuiltinType::LongLong) => Some(new_type),
  815|      0|                        (BuiltinType::LongLong, BuiltinType::Signed) => Some(existing_ref),
  816|       |
  817|       |                        // 3. Unsigned overrides signed/marker
  818|      0|                        (BuiltinType::Int, BuiltinType::UInt) => Some(new_type),
  819|      3|                        (BuiltinType::UInt, BuiltinType::Int) => Some(existing_ref),
  820|       |
  821|      0|                        (BuiltinType::Signed, BuiltinType::UInt) => Some(new_type),
  822|      0|                        (BuiltinType::UInt, BuiltinType::Signed) => Some(existing_ref),
  823|       |
  824|       |                        // Char + Unsigned -> UChar
  825|       |                        (BuiltinType::Char, BuiltinType::UInt) => {
  826|      0|                            Some(QualType::unqualified(ctx.registry.type_char_unsigned))
  827|       |                        }
  828|       |                        (BuiltinType::UInt, BuiltinType::Char) => {
  829|      3|                            Some(QualType::unqualified(ctx.registry.type_char_unsigned))
  830|       |                        }
  831|       |
  832|       |                        // Short + Unsigned -> UShort
  833|       |                        (BuiltinType::Short, BuiltinType::UInt) => {
  834|      0|                            Some(QualType::unqualified(ctx.registry.type_short_unsigned))
  835|       |                        }
  836|       |                        (BuiltinType::UInt, BuiltinType::Short) => {
  837|      2|                            Some(QualType::unqualified(ctx.registry.type_short_unsigned))
  838|       |                        }
  839|       |
  840|       |                        // Long + Unsigned -> ULong
  841|       |                        (BuiltinType::Long, BuiltinType::UInt) => {
  842|      1|                            Some(QualType::unqualified(ctx.registry.type_long_unsigned))
  843|       |                        }
  844|       |                        (BuiltinType::UInt, BuiltinType::Long) => {
  845|      3|                            Some(QualType::unqualified(ctx.registry.type_long_unsigned))
  846|       |                        }
  847|       |
  848|       |                        // LongLong + Unsigned -> ULongLong
  849|       |                        (BuiltinType::LongLong, BuiltinType::UInt) => {
  850|      0|                            Some(QualType::unqualified(ctx.registry.type_long_long_unsigned))
  851|       |                        }
  852|       |                        (BuiltinType::UInt, BuiltinType::LongLong) => {
  853|      2|                            Some(QualType::unqualified(ctx.registry.type_long_long_unsigned))
  854|       |                        }
  855|       |
  856|       |                        // 4. Redundant 'int' combined with other specifiers
  857|      1|                        (BuiltinType::Short, BuiltinType::Int) => Some(existing_ref),
  858|      0|                        (BuiltinType::Int, BuiltinType::Short) => Some(new_type),
  859|      1|                        (BuiltinType::UShort, BuiltinType::Int) => Some(existing_ref),
  860|      0|                        (BuiltinType::Int, BuiltinType::UShort) => Some(new_type),
  861|       |
  862|      1|                        (BuiltinType::Long, BuiltinType::Int) => Some(existing_ref),
  863|      0|                        (BuiltinType::Int, BuiltinType::Long) => Some(new_type),
  864|      2|                        (BuiltinType::ULong, BuiltinType::Int) => Some(existing_ref),
  865|      0|                        (BuiltinType::Int, BuiltinType::ULong) => Some(new_type),
  866|       |
  867|      1|                        (BuiltinType::LongLong, BuiltinType::Int) => Some(existing_ref),
  868|      0|                        (BuiltinType::Int, BuiltinType::LongLong) => Some(new_type),
  869|      1|                        (BuiltinType::ULongLong, BuiltinType::Int) => Some(existing_ref),
  870|      0|                        (BuiltinType::Int, BuiltinType::ULongLong) => Some(new_type),
  871|       |
  872|       |                        // 5. Long + Long -> LongLong (handled by case 1 above partially, but let's be explicit if needed)
  873|       |                        // (BuiltinType::Long, BuiltinType::Long) is already handled in case 1.
  874|       |
  875|       |                        // Long + LongLong -> LongLong
  876|      0|                        (BuiltinType::Long, BuiltinType::LongLong) => Some(new_type),
  877|      0|                        (BuiltinType::LongLong, BuiltinType::Long) => Some(existing_ref),
  878|       |
  879|       |                        // ULong + Long -> ULongLong
  880|       |                        (BuiltinType::ULong, BuiltinType::Long) => {
  881|      1|                            Some(QualType::unqualified(ctx.registry.type_long_long_unsigned))
  882|       |                        }
  883|       |                        (BuiltinType::Long, BuiltinType::ULong) => {
  884|      0|                            Some(QualType::unqualified(ctx.registry.type_long_long_unsigned))
  885|       |                        }
  886|       |
  887|       |                        // Long + ULongLong -> ULongLong
  888|      0|                        (BuiltinType::Long, BuiltinType::ULongLong) => Some(new_type),
  889|      0|                        (BuiltinType::ULongLong, BuiltinType::Long) => Some(existing_ref),
  890|       |
  891|       |                        // Long + Double -> LongDouble
  892|       |                        (BuiltinType::Double, BuiltinType::Long) => {
  893|      0|                            Some(QualType::unqualified(ctx.registry.type_long_double))
  894|       |                        }
  895|       |                        (BuiltinType::Long, BuiltinType::Double) => {
  896|      0|                            Some(QualType::unqualified(ctx.registry.type_long_double))
  897|       |                        }
  898|       |
  899|       |                        // Error for other combinations (e.g. double int)
  900|       |                        _ => {
  901|      0|                            ctx.report_error(SemanticError::ConflictingTypeSpecifiers {
  902|      0|                                prev: ctx.registry.display_qual_type(existing_ref),
  903|      0|                                span,
  904|      0|                            });
  905|      0|                            Some(QualType::unqualified(ctx.registry.type_error))
  906|       |                        }
  907|       |                    }
  908|       |                }
  909|       |                _ => {
  910|      0|                    ctx.report_error(SemanticError::ConflictingTypeSpecifiers {
  911|      0|                        prev: ctx.registry.display_qual_type(existing_ref),
  912|      0|                        span,
  913|      0|                    });
  914|      0|                    Some(QualType::unqualified(ctx.registry.type_error))
  915|       |                }
  916|       |            }
  917|       |        }
  918|       |    }
  919|    686|}
  920|       |
  921|       |/// Validate specifier combinations for semantic correctness
  922|    659|fn validate_specifier_combinations(info: &DeclSpecInfo, ctx: &mut LowerCtx, span: SourceSpan) {
  923|       |    // Check typedef with other storage classes
  924|    659|    if info.is_typedef && (info.storage.is_some_and(|s| s != StorageClass::Typedef) || info.is_thread_local) {
                                         ^12          ^12             ^12  ^12                       ^11
  925|      1|        ctx.report_error(SemanticError::ConflictingStorageClasses { span });
  926|    658|    }
  927|       |
  928|       |    // _Thread_local constraints (C11 6.7.1p3)
  929|    659|    if info.is_thread_local {
  930|       |        // Can only be used alone or with static/extern
  931|      0|        if let Some(s) = info.storage
  932|      0|            && s != StorageClass::Static
  933|      0|            && s != StorageClass::Extern
  934|      0|        {
  935|      0|            ctx.report_error(SemanticError::ConflictingStorageClasses { span });
  936|      0|        }
  937|    659|    }
  938|       |
  939|       |    // Check for missing required specifiers (type specifier)
  940|    659|    if info.base_type.is_none() {
  941|      0|        ctx.report_error(SemanticError::MissingTypeSpecifier { span });
  942|    659|    }
  943|    659|}
  944|       |
  945|       |/// Parse and validate declaration specifiers
  946|    659|fn lower_decl_specifiers(specs: &[ParsedDeclSpecifier], ctx: &mut LowerCtx, span: SourceSpan) -> DeclSpecInfo {
  947|    659|    let mut info = DeclSpecInfo::default();
  948|       |
  949|  1.39k|    for spec in specs {
                      ^735
  950|    735|        match spec {
  951|     19|            ParsedDeclSpecifier::StorageClass(sc) => {
  952|     19|                if *sc == StorageClass::ThreadLocal {
  953|      0|                    if info.is_thread_local {
  954|      0|                        // duplicate _Thread_local
  955|      0|                        ctx.report_error(SemanticError::ConflictingStorageClasses { span });
  956|      0|                    }
  957|      0|                    info.is_thread_local = true;
  958|       |                } else {
  959|     19|                    if info.storage.is_some() {
  960|      2|                        ctx.report_error(SemanticError::ConflictingStorageClasses { span });
  961|     17|                    }
  962|     19|                    if *sc == StorageClass::Typedef {
  963|     12|                        info.is_typedef = true;
  964|     12|                    }
                                  ^7
  965|     19|                    info.storage = Some(*sc);
  966|       |                }
  967|       |            }
  968|     22|            ParsedDeclSpecifier::TypeQualifier(tq) => {
  969|     22|                let mask = match tq {
  970|     20|                    TypeQualifier::Const => TypeQualifiers::CONST,
  971|      1|                    TypeQualifier::Volatile => TypeQualifiers::VOLATILE,
  972|      1|                    TypeQualifier::Restrict => TypeQualifiers::RESTRICT,
  973|      0|                    TypeQualifier::Atomic => TypeQualifiers::ATOMIC,
  974|       |                };
  975|     22|                info.qualifiers.insert(mask);
  976|       |            }
  977|    686|            ParsedDeclSpecifier::TypeSpecifier(ts) => {
  978|    686|                let ty = resolve_type_specifier(ts, ctx, span).unwrap_or_else(|e| {
                                                                                                ^2
  979|      2|                    ctx.report_error(e);
  980|      2|                    QualType::unqualified(ctx.registry.type_error)
  981|      2|                });
  982|    686|                info.base_type = merge_base_type(info.base_type, ty, ctx, span);
  983|       |            }
  984|      6|            ParsedDeclSpecifier::AlignmentSpecifier(align) => {
  985|      6|                let align_val: Option<u32> = match align {
  986|      1|                    crate::ast::parsed::ParsedAlignmentSpecifier::Type(parsed_ty) => {
  987|      1|                        let qt = convert_to_qual_type(ctx, *parsed_ty, span)
  988|      1|                            .unwrap_or(QualType::unqualified(ctx.registry.type_error));
  989|      1|                        match ctx.registry.ensure_layout(qt.ty()) {
  990|      1|                            Ok(layout) => Some(layout.alignment as u32),
  991|      0|                            Err(e) => {
  992|      0|                                ctx.report_error(e);
  993|      0|                                None
  994|       |                            }
  995|       |                        }
  996|       |                    }
  997|      5|                    crate::ast::parsed::ParsedAlignmentSpecifier::Expr(expr_ref) => {
  998|      5|                        let lowered_expr = ctx.lower_expression(*expr_ref);
  999|      5|                        let const_ctx = ConstEvalCtx {
 1000|      5|                            ast: ctx.ast,
 1001|      5|                            symbol_table: ctx.symbol_table,
 1002|      5|                        };
 1003|      5|                        if let Some(val) = const_eval::eval_const_expr(&const_ctx, lowered_expr) {
 1004|      5|                            if val > 0 && (val as u64).is_power_of_two() {
                                                        ^4           ^4
 1005|      3|                                Some(val as u32)
 1006|       |                            } else {
 1007|      2|                                ctx.report_error(SemanticError::InvalidAlignment { value: val, span });
 1008|      2|                                None
 1009|       |                            }
 1010|       |                        } else {
 1011|      0|                            ctx.report_error(SemanticError::NonConstantAlignment { span });
 1012|      0|                            None
 1013|       |                        }
 1014|       |                    }
 1015|       |                };
 1016|       |
 1017|      6|                if let Some(val) = align_val {
                                          ^4
 1018|      4|                    info.alignment = Some(std::cmp::max(info.alignment.unwrap_or(0), val));
 1019|      4|                }
                              ^2
 1020|       |            }
 1021|      2|            ParsedDeclSpecifier::FunctionSpecifier(fs) => match fs {
 1022|      0|                FunctionSpecifier::Inline => info.is_inline = true,
 1023|      2|                FunctionSpecifier::Noreturn => info.is_noreturn = true,
 1024|       |            },
 1025|      0|            ParsedDeclSpecifier::Attribute => {
 1026|      0|                // Ignore attributes for now
 1027|      0|            }
 1028|       |        }
 1029|       |    }
 1030|       |
 1031|       |    // Finalize base type: 'signed' without anything else defaults to 'int'
 1032|    659|    if let Some(base) = info.base_type
 1033|    659|        && base.ty() == ctx.registry.type_signed
 1034|      0|    {
 1035|      0|        info.base_type = Some(QualType::unqualified(ctx.registry.type_int));
 1036|    659|    }
 1037|       |
 1038|    659|    validate_specifier_combinations(&info, ctx, span);
 1039|    659|    info
 1040|    659|}
 1041|       |
 1042|    417|fn lower_function_parameters(params: &[ParsedParamData], ctx: &mut LowerCtx) -> Vec<FunctionParameter> {
 1043|    417|    params
 1044|    417|        .iter()
 1045|    417|        .map(|param| {
                                   ^51
 1046|     51|            let span = param.span;
 1047|     51|            let spec_info = lower_decl_specifiers(&param.specifiers, ctx, span);
 1048|       |
 1049|       |            // C standard: if type specifier is missing in a parameter, it defaults to int.
 1050|     51|            let mut base_ty = spec_info
 1051|     51|                .base_type
 1052|     51|                .unwrap_or_else(|| QualType::unqualified(ctx.registry.type_int));
                                                 ^0                    ^0
 1053|     51|            base_ty = ctx.registry.merge_qualifiers(base_ty, spec_info.qualifiers);
 1054|       |
 1055|     51|            let final_ty = if let Some(declarator) = &param.declarator {
                                                     ^49
 1056|     49|                apply_declarator(base_ty, declarator, ctx, span, &spec_info)
 1057|       |            } else {
 1058|      2|                base_ty
 1059|       |            };
 1060|       |
 1061|       |            // Apply array-to-pointer decay for function parameters (C11 6.7.6.3)
 1062|     51|            let ptr_quals = if let Some(decl) = &param.declarator {
                                                      ^49
 1063|     49|                extract_array_param_qualifiers(decl)
 1064|       |            } else {
 1065|      2|                TypeQualifiers::empty()
 1066|       |            };
 1067|     51|            let decayed_ty = ctx.registry.decay(final_ty, ptr_quals);
 1068|       |
 1069|     51|            let pname = param.declarator.as_ref().and_then(extract_name);
 1070|     51|            FunctionParameter {
 1071|     51|                param_type: decayed_ty,
 1072|     51|                name: pname,
 1073|     51|            }
 1074|     51|        })
 1075|    417|        .collect()
 1076|    417|}
 1077|       |
 1078|       |/// Helper to get the actual parameters from the function declarator being defined.
 1079|       |/// This is necessary because interned function types in TypeRegistry might not have
 1080|       |/// the parameter names if the function was previously declared without them.
 1081|    393|fn get_definition_params(decl: &ParsedDeclarator, ctx: &mut LowerCtx) -> Option<Vec<FunctionParameter>> {
 1082|    393|    match decl {
 1083|    196|        ParsedDeclarator::Function { inner, params, .. } => {
 1084|    196|            if let Some(inner_params) = get_definition_params(inner, ctx) {
                                      ^0
 1085|      0|                Some(inner_params)
 1086|       |            } else {
 1087|    196|                Some(lower_function_parameters(params, ctx))
 1088|       |            }
 1089|       |        }
 1090|      1|        ParsedDeclarator::Pointer(_, inner) => inner.as_ref().and_then(|d| get_definition_params(d, ctx)),
 1091|      0|        ParsedDeclarator::Array(inner, _) => get_definition_params(inner, ctx),
 1092|      0|        ParsedDeclarator::BitField(inner, _) => get_definition_params(inner, ctx),
 1093|    196|        _ => None,
 1094|       |    }
 1095|    393|}
 1096|       |
 1097|    920|fn extract_name(decl: &ParsedDeclarator) -> Option<NameId> {
 1098|    920|    match decl {
 1099|    600|        ParsedDeclarator::Identifier(name, _) => Some(*name),
 1100|     51|        ParsedDeclarator::Pointer(_, inner) => inner.as_ref().and_then(|d| extract_name(d)),
 1101|     45|        ParsedDeclarator::Array(inner, _) => extract_name(inner),
 1102|    221|        ParsedDeclarator::Function { inner, .. } => extract_name(inner),
 1103|      0|        ParsedDeclarator::BitField(inner, _) => extract_name(inner),
 1104|      3|        _ => None,
 1105|       |    }
 1106|    920|}
 1107|       |
 1108|       |/// Apply declarator transformations to a base type
 1109|    920|fn apply_declarator(
 1110|    920|    base_type: QualType,
 1111|    920|    declarator: &ParsedDeclarator,
 1112|    920|    ctx: &mut LowerCtx,
 1113|    920|    span: SourceSpan,
 1114|    920|    spec_info: &DeclSpecInfo,
 1115|    920|) -> QualType {
 1116|    920|    match declarator {
 1117|     51|        ParsedDeclarator::Pointer(qualifiers, next) => {
 1118|     51|            let ty = ctx.registry.pointer_to(base_type);
 1119|       |            // Checked merge
 1120|     51|            let modified_ty = ctx.merge_qualifiers_with_check(QualType::unqualified(ty), *qualifiers, span);
 1121|     51|            if let Some(next_decl) = next {
 1122|     51|                apply_declarator(modified_ty, next_decl, ctx, span, spec_info)
 1123|       |            } else {
 1124|      0|                modified_ty
 1125|       |            }
 1126|       |        }
 1127|    600|        ParsedDeclarator::Identifier(_, qualifiers) => ctx.merge_qualifiers_with_check(base_type, *qualifiers, span),
 1128|     45|        ParsedDeclarator::Array(base, size) => {
 1129|       |            // C11 6.7.6.2 Array declarators
 1130|       |            // "The element type shall not be an incomplete or function type."
 1131|     45|            if !ctx.registry.is_complete(base_type.ty()) || base_type.ty().is_function() {
                                                                          ^44       ^44  ^44
 1132|      1|                let ty_str = ctx.registry.display_type(base_type.ty());
 1133|      1|                ctx.report_error(SemanticError::IncompleteType { ty: ty_str, span });
 1134|     44|            }
 1135|       |
 1136|     45|            let array_size = match size {
 1137|     29|                ParsedArraySize::Expression { expr, qualifiers: _ } => resolve_array_size(Some(*expr), ctx),
 1138|      0|                ParsedArraySize::Star { qualifiers: _ } => ArraySizeType::Star,
 1139|      9|                ParsedArraySize::Incomplete => ArraySizeType::Incomplete,
 1140|       |                ParsedArraySize::VlaSpecifier {
 1141|       |                    is_static: _,
 1142|       |                    qualifiers: _,
 1143|      7|                    size,
 1144|      7|                } => resolve_array_size(*size, ctx),
 1145|       |            };
 1146|       |
 1147|     45|            let ty = ctx.registry.array_of(base_type.ty(), array_size);
 1148|     45|            let array_qt = QualType::new(ty, base_type.qualifiers());
 1149|     45|            apply_declarator(array_qt, base, ctx, span, spec_info)
 1150|       |        }
 1151|       |        ParsedDeclarator::Function {
 1152|    221|            inner: base,
 1153|    221|            params,
 1154|    221|            is_variadic,
 1155|       |        } => {
 1156|    221|            let parameters = lower_function_parameters(params, ctx);
 1157|    221|            let ty = ctx
 1158|    221|                .registry
 1159|    221|                .function_type(base_type.ty(), parameters, *is_variadic, spec_info.is_noreturn);
 1160|    221|            apply_declarator(QualType::unqualified(ty), base, ctx, span, spec_info)
 1161|       |        }
 1162|      0|        ParsedDeclarator::AnonymousRecord(is_union, members) => {
 1163|       |            // Use struct_lowering helper
 1164|      0|            let ty = ctx.registry.declare_record(None, *is_union);
 1165|      0|            let struct_members = lower_struct_members(members, ctx, SourceSpan::empty());
 1166|      0|            ctx.registry.complete_record(ty, struct_members);
 1167|      0|            let _ = ctx.registry.ensure_layout(ty);
 1168|      0|            QualType::unqualified(ty)
 1169|       |        }
 1170|      0|        ParsedDeclarator::BitField(base, _) => {
 1171|       |            // Bitfield logic handled in struct lowering usually. Here just type application.
 1172|      0|            apply_declarator(base_type, base, ctx, span, spec_info)
 1173|       |        }
 1174|      3|        ParsedDeclarator::Abstract => base_type,
 1175|       |    }
 1176|    920|}
 1177|       |
 1178|       |/// Finalize tentative definitions by converting them to defined state
 1179|    205|fn finalize_tentative_definitions(symbol_table: &mut SymbolTable) {
 1180|    205|    for entry in &mut symbol_table.entries {
                      ^0
 1181|      0|        if entry.scope_id == ScopeId::GLOBAL
 1182|      0|            && matches!(entry.kind, SymbolKind::Variable { .. })
 1183|      0|            && entry.def_state == DefinitionState::Tentative
 1184|      0|        {
 1185|      0|            entry.def_state = DefinitionState::Defined;
 1186|      0|        }
 1187|       |    }
 1188|    205|}
 1189|       |
 1190|       |/// Main entry point for semantic lowering on ParsedAst
 1191|    205|pub(crate) fn run_semantic_lowering(
 1192|    205|    parsed_ast: &ParsedAst,
 1193|    205|    ast: &mut Ast,
 1194|    205|    diag: &mut DiagnosticEngine,
 1195|    205|    symbol_table: &mut SymbolTable,
 1196|    205|    registry: &mut TypeRegistry,
 1197|    205|) {
 1198|       |    // Finalize tentative definitions
 1199|    205|    finalize_tentative_definitions(symbol_table);
 1200|       |
 1201|       |    // Create lowering context
 1202|    205|    let mut lower_ctx = LowerCtx::new(parsed_ast, ast, diag, symbol_table, registry);
 1203|       |
 1204|       |    // Perform recursive scope-aware lowering starting from root
 1205|    205|    let root = parsed_ast.get_root();
 1206|    205|    lower_ctx.lower_node(root);
 1207|    205|}
 1208|       |
 1209|       |impl<'a, 'src> LowerCtx<'a, 'src> {
 1210|  1.67k|    pub(crate) fn lower_node(&mut self, parsed_ref: ParsedNodeRef) -> SmallVec<[NodeRef; 1]> {
 1211|  1.67k|        self.lower_node_entry(parsed_ref, None)
 1212|  1.67k|    }
 1213|       |
 1214|  2.18k|    fn lower_node_entry(
 1215|  2.18k|        &mut self,
 1216|  2.18k|        parsed_ref: ParsedNodeRef,
 1217|  2.18k|        target_slots: Option<&[NodeRef]>,
 1218|  2.18k|    ) -> SmallVec<[NodeRef; 1]> {
 1219|  2.18k|        let parsed_node = self.parsed_ast.get_node(parsed_ref);
 1220|  2.18k|        let span = parsed_node.span;
 1221|  2.18k|        let kind = parsed_node.kind.clone();
 1222|       |
 1223|  2.18k|        match kind {
 1224|    205|            ParsedNodeKind::TranslationUnit(children) => {
 1225|    205|                self.symbol_table.set_current_scope(ScopeId::GLOBAL);
 1226|       |
 1227|       |                // Reserve slot for TranslationUnit
 1228|    205|                let tu_node = self.push_dummy(span);
 1229|       |
 1230|       |                // 1. First pass: count how many semantic nodes each child will produce
 1231|    205|                let mut semantic_node_counts = Vec::new();
 1232|    205|                let mut total_semantic_nodes = 0;
 1233|       |
 1234|    564|                for &child_ref in &children {
                                   ^359
 1235|    359|                    let child = self.parsed_ast.get_node(child_ref);
 1236|    359|                    let count = match &child.kind {
 1237|    196|                        ParsedNodeKind::FunctionDef(..) => 1,
 1238|    147|                        ParsedNodeKind::Declaration(decl) => {
 1239|    147|                            if !decl.init_declarators.is_empty() {
 1240|     97|                                decl.init_declarators.len()
 1241|     50|                            } else if let Some(spec) = decl.specifiers.iter().find_map(|s| {
 1242|     50|                                if let ParsedDeclSpecifier::TypeSpecifier(ts) = s {
 1243|     50|                                    Some(ts)
 1244|       |                                } else {
 1245|      0|                                    None
 1246|       |                                }
 1247|     50|                            }) {
 1248|     42|                                match spec {
 1249|     42|                                    ParsedTypeSpecifier::Record(_, _, is_def) if is_def.is_some() => 1,
                                                                                                              ^39  ^39
 1250|      8|                                    ParsedTypeSpecifier::Enum(_, is_def) if is_def.is_some() => 1,
 1251|      3|                                    _ => 0, // Empty declaration or no definition side effects
 1252|       |                                }
 1253|       |                            } else {
 1254|      0|                                0
 1255|       |                            }
 1256|       |                        }
 1257|     16|                        ParsedNodeKind::StaticAssert(..) => 1,
 1258|      0|                        _ => 0, // Should not happen for top-level nodes ideally
 1259|       |                    };
 1260|    359|                    semantic_node_counts.push(count);
 1261|    359|                    total_semantic_nodes += count;
 1262|       |                }
 1263|       |
 1264|       |                // 2. Reserve contiguous slots for all top-level nodes
 1265|    205|                let decl_len = total_semantic_nodes as u16;
 1266|    205|                let mut reserved_slots = Vec::new();
 1267|    356|                for _ in 0..decl_len {
                                          ^205
 1268|    356|                    reserved_slots.push(self.push_dummy(span));
 1269|    356|                }
 1270|       |
 1271|       |                // 3. Second pass: Lower children into reserved slots
 1272|    205|                let mut current_slot_idx = 0;
 1273|    359|                for (i, child_ref) in children.iter().enumerate() {
                                                    ^205            ^205
 1274|    359|                    let count = semantic_node_counts[i];
 1275|    359|                    if count == 0 {
 1276|      3|                        continue;
 1277|    356|                    }
 1278|       |
 1279|    356|                    let target_slots = &reserved_slots[current_slot_idx..current_slot_idx + count];
 1280|    356|                    self.lower_top_level_node(*child_ref, target_slots);
 1281|    356|                    current_slot_idx += count;
 1282|       |                }
 1283|       |
 1284|    205|                let decl_start = if decl_len > 0 { reserved_slots[0] } else { NodeRef::ROOT };
                                                                                            ^0
 1285|       |
 1286|    205|                self.ast.kinds[tu_node.index()] = NodeKind::TranslationUnit(TranslationUnitData {
 1287|    205|                    decl_start,
 1288|    205|                    decl_len,
 1289|    205|                    scope_id: ScopeId::GLOBAL,
 1290|    205|                });
 1291|       |
 1292|    205|                smallvec![tu_node]
                                        ^0
 1293|       |            }
 1294|    205|            ParsedNodeKind::CompoundStatement(stmts) => {
 1295|    205|                let scope_id = self.symbol_table.push_scope();
 1296|       |
 1297|       |                // Use target slot if provided, otherwise reserve new slot
 1298|       |                // Note: We set scope AFTER push_scope since CompoundStatement creates a new scope
 1299|    205|                let node = self.get_or_push_slot(target_slots, span);
 1300|       |
 1301|       |                // Count total semantic nodes
 1302|    205|                let mut total_stmt_nodes = 0;
 1303|    488|                for stmt_ref in stmts.iter().copied() {
                                              ^205         ^205
 1304|    488|                    total_stmt_nodes += self.count_semantic_nodes(stmt_ref);
 1305|    488|                }
 1306|       |
 1307|       |                // Reserve slots for all statements
 1308|    205|                let mut stmt_slots = Vec::new();
 1309|    491|                for _ in 0..total_stmt_nodes {
                                          ^205
 1310|    491|                    stmt_slots.push(self.push_dummy(span));
 1311|    491|                }
 1312|       |
 1313|    205|                let stmt_start = if !stmt_slots.is_empty() {
 1314|    201|                    stmt_slots[0]
 1315|       |                } else {
 1316|      4|                    NodeRef::ROOT
 1317|       |                };
 1318|    205|                let stmt_len = stmt_slots.len() as u16;
 1319|       |
 1320|       |                // Lower statements directly into reserved slots
 1321|    205|                let mut current_slot_idx = 0;
 1322|    693|                for stmt_ref in stmts {
                                  ^488
 1323|    488|                    let count = self.count_semantic_nodes(stmt_ref);
 1324|    488|                    if count > 0 {
 1325|    488|                        let target_slots = &stmt_slots[current_slot_idx..current_slot_idx + count];
 1326|    488|                        self.lower_node_entry(stmt_ref, Some(target_slots));
 1327|    488|                        current_slot_idx += count;
 1328|    488|                    }
                                  ^0
 1329|       |                }
 1330|       |
 1331|    205|                self.symbol_table.pop_scope();
 1332|       |
 1333|       |                // Replace dummy node with actual CompoundStatement
 1334|    205|                self.ast.kinds[node.index()] = NodeKind::CompoundStatement(CompoundStmtData {
 1335|    205|                    stmt_start,
 1336|    205|                    stmt_len,
 1337|    205|                    scope_id,
 1338|    205|                });
 1339|       |
 1340|    205|                smallvec![node]
                                        ^0
 1341|       |            }
 1342|    165|            ParsedNodeKind::Declaration(decl_data) => self.lower_declaration(&decl_data, span, target_slots),
 1343|      0|            ParsedNodeKind::FunctionDef(func_def) => {
 1344|      0|                let node = self.get_or_push_slot(target_slots, span);
 1345|      0|                self.lower_function_definition(&func_def, node, span);
 1346|      0|                smallvec![node]
 1347|       |            }
 1348|       |            // ... other top level kinds ...
 1349|  1.60k|            _ => self.lower_node_rest(parsed_ref, target_slots),
 1350|       |        }
 1351|  2.18k|    }
 1352|       |
 1353|    356|    fn lower_top_level_node(&mut self, parsed_ref: ParsedNodeRef, target_slots: &[NodeRef]) {
 1354|    356|        let parsed_node = self.parsed_ast.get_node(parsed_ref);
 1355|    356|        let span = parsed_node.span;
 1356|       |
 1357|    356|        match &parsed_node.kind {
 1358|    144|            ParsedNodeKind::Declaration(decl) => {
 1359|    144|                self.lower_declaration(decl, span, Some(target_slots));
 1360|    144|            }
 1361|    196|            ParsedNodeKind::FunctionDef(func_def) => {
 1362|    196|                if let Some(target) = target_slots.first() {
 1363|    196|                    self.lower_function_definition(func_def, *target, span);
 1364|    196|                }
                              ^0
 1365|       |            }
 1366|       |            _ => {
 1367|     16|                if let ParsedNodeKind::StaticAssert(expr, msg) = &parsed_node.kind
 1368|     16|                    && let Some(target) = target_slots.first()
 1369|     16|                {
 1370|     16|                    let lowered_expr = self.lower_expression(*expr);
 1371|     16|                    self.ast.kinds[target.index()] = NodeKind::StaticAssert(lowered_expr, *msg);
 1372|     16|                    self.set_scope(*target, self.symbol_table.current_scope());
 1373|     16|                }
                              ^0
 1374|       |            }
 1375|       |        }
 1376|    356|    }
 1377|       |
 1378|    449|    fn check_redeclaration_compatibility(
 1379|    449|        &mut self,
 1380|    449|        name: NameId,
 1381|    449|        new_ty: QualType,
 1382|    449|        span: SourceSpan,
 1383|    449|        storage: Option<StorageClass>,
 1384|    449|    ) {
 1385|    449|        if let Some((existing_ref, existing_scope)) = self.symbol_table.lookup_symbol(name) {
                                   ^20           ^20
 1386|     20|            let current_scope = self.symbol_table.current_scope();
 1387|     20|            let existing = self.symbol_table.get_symbol(existing_ref);
 1388|       |
 1389|     20|            let is_global = current_scope == ScopeId::GLOBAL;
 1390|     20|            let is_func = new_ty.is_function();
 1391|     20|            let new_has_linkage = is_global || storage == Some(StorageClass::Extern) || is_func;
                                                             ^4                                       ^4
 1392|       |
 1393|       |            // Linkage conflict if:
 1394|       |            // 1. Same scope (always conflict)
 1395|       |            // 2. Both have linkage (even different scope)
 1396|     20|            let is_conflict = (existing_scope == current_scope) || (new_has_linkage && existing.has_linkage());
                                                                                  ^4                 ^0       ^0
 1397|       |
 1398|     20|            if is_conflict {
 1399|     16|                if !self.registry.is_compatible(existing.type_info, new_ty) {
 1400|      2|                    let first_def = existing.def_span;
 1401|      2|                    self.report_error(SemanticError::ConflictingTypes {
 1402|      2|                        name: name.to_string(),
 1403|      2|                        span,
 1404|      2|                        first_def,
 1405|      2|                    });
 1406|     14|                } else if new_ty.is_function() {
 1407|       |                    // Check for linkage conflict (static followed by non-static)
 1408|       |                    if let SymbolKind::Function {
 1409|      8|                        storage: existing_storage,
 1410|      8|                    } = &existing.kind
 1411|       |                    {
 1412|      8|                        let existing_is_static = *existing_storage == Some(StorageClass::Static);
 1413|      8|                        let new_is_static = storage == Some(StorageClass::Static);
 1414|       |
 1415|      8|                        if existing_is_static && !new_is_static {
                                                               ^1
 1416|      1|                            let first_def = existing.def_span;
 1417|      1|                            self.report_error(SemanticError::ConflictingLinkage {
 1418|      1|                                name: name.to_string(),
 1419|      1|                                span,
 1420|      1|                                first_def,
 1421|      1|                            });
 1422|      7|                        }
 1423|      0|                    }
 1424|      6|                }
 1425|      4|            }
 1426|    429|        }
 1427|    449|    }
 1428|       |
 1429|    196|    fn lower_function_definition(&mut self, func_def: &ParsedFunctionDefData, node: NodeRef, span: SourceSpan) {
 1430|    196|        let spec_info = lower_decl_specifiers(&func_def.specifiers, self, span);
 1431|    196|        let mut base_ty = spec_info
 1432|    196|            .base_type
 1433|    196|            .unwrap_or_else(|| QualType::unqualified(self.registry.type_int));
                                             ^0                    ^0
 1434|    196|        base_ty = self.merge_qualifiers_with_check(base_ty, spec_info.qualifiers, span);
 1435|       |
 1436|    196|        let final_ty = apply_declarator(base_ty, &func_def.declarator, self, span, &spec_info);
 1437|    196|        let func_name = extract_name(&func_def.declarator).expect("Function definition must have a name");
 1438|       |
 1439|    196|        self.check_redeclaration_compatibility(func_name, final_ty, span, spec_info.storage);
 1440|       |
 1441|    196|        if let Err(crate::semantic::symbol_table::SymbolTableError::InvalidRedefinition { existing, .. }) = self
                                                                                                        ^0
 1442|    196|            .symbol_table
 1443|    196|            .define_function(func_name, final_ty.ty(), spec_info.storage, true, span)
 1444|       |        {
 1445|      0|            let entry = self.symbol_table.get_symbol(existing);
 1446|      0|            if entry.def_state == DefinitionState::Defined {
 1447|      0|                let first_def = entry.def_span;
 1448|      0|                self.report_error(SemanticError::Redefinition {
 1449|      0|                    name: func_name,
 1450|      0|                    first_def,
 1451|      0|                    span,
 1452|      0|                });
 1453|      0|            }
 1454|    196|        }
 1455|    196|        let func_sym_ref = self.symbol_table.lookup_symbol(func_name).map(|(s, _)| s).unwrap();
 1456|       |
 1457|    196|        let scope_id = self.symbol_table.push_scope();
 1458|       |
 1459|       |        // Pre-scan labels for forward goto support
 1460|    196|        self.collect_labels(func_def.body);
 1461|       |
 1462|    196|        let parameters = get_definition_params(&func_def.declarator, self).unwrap_or_default();
 1463|       |
 1464|    196|        let param_len = parameters.len() as u16;
 1465|    196|        let mut param_dummies = Vec::new();
 1466|    196|        for _ in 0..param_len {
 1467|     14|            param_dummies.push(self.push_dummy(span));
 1468|     14|        }
 1469|       |
 1470|    196|        for (i, param) in parameters.iter().enumerate() {
                           ^14^14
 1471|     14|            if let Some(pname) = param.name
 1472|     14|                && let Ok(sym) = self
 1473|     14|                    .symbol_table
 1474|     14|                    .define_variable(pname, param.param_type, None, None, None, span)
 1475|     14|            {
 1476|     14|                let param_ref = param_dummies[i];
 1477|     14|                self.ast.kinds[param_ref.index()] = NodeKind::Param(ParamData {
 1478|     14|                    symbol: sym,
 1479|     14|                    ty: param.param_type,
 1480|     14|                });
 1481|     14|                self.set_scope(param_ref, self.symbol_table.current_scope());
 1482|     14|            }
                          ^0
 1483|       |        }
 1484|       |
 1485|    196|        let param_start = if param_len > 0 { param_dummies[0] } else { NodeRef::ROOT };
                                                           ^9                        ^187
 1486|       |
 1487|    196|        self.set_scope(node, self.symbol_table.current_scope());
 1488|       |
 1489|    196|        let body_node = self.lower_single_statement(func_def.body);
 1490|       |
 1491|    196|        self.symbol_table.pop_scope();
 1492|       |
 1493|    196|        self.ast.kinds[node.index()] = NodeKind::Function(FunctionData {
 1494|    196|            symbol: func_sym_ref,
 1495|    196|            ty: final_ty.ty(),
 1496|    196|            is_noreturn: spec_info.is_noreturn,
 1497|    196|            param_start,
 1498|    196|            param_len,
 1499|    196|            body: body_node,
 1500|    196|            scope_id,
 1501|    196|        });
 1502|    196|    }
 1503|       |
 1504|    309|    fn lower_declaration(
 1505|    309|        &mut self,
 1506|    309|        decl: &ParsedDeclarationData,
 1507|    309|        span: SourceSpan,
 1508|    309|        target_slots: Option<&[NodeRef]>,
 1509|    309|    ) -> SmallVec<[NodeRef; 1]> {
 1510|    309|        let spec_info = lower_decl_specifiers(&decl.specifiers, self, span);
 1511|    309|        let mut base_ty = spec_info
 1512|    309|            .base_type
 1513|    309|            .unwrap_or(QualType::unqualified(self.registry.type_int));
 1514|    309|        base_ty = self.merge_qualifiers_with_check(base_ty, spec_info.qualifiers, span);
 1515|       |
 1516|    309|        if decl.init_declarators.is_empty() {
 1517|     47|            if let Some(ty) = spec_info.base_type {
 1518|       |                // Extract needed data from registry to avoid borrowing self.registry during node creation
 1519|     47|                let type_data = match &self.registry.get(ty.ty()).kind {
 1520|       |                    TypeKind::Record {
 1521|     37|                        tag, members, is_union, ..
 1522|     37|                    } => Some(TypeData::Record(*tag, members.clone(), *is_union)),
 1523|      8|                    TypeKind::Enum { tag, enumerators, .. } => Some(TypeData::Enum(*tag, enumerators.clone())),
 1524|      2|                    _ => None,
 1525|       |                };
 1526|       |
 1527|     47|                if let Some(data) = type_data {
                                          ^45
 1528|     45|                    let node = if let Some(slots) = target_slots {
 1529|     45|                        slots.first().copied().unwrap_or_else(|| self.push_dummy(span))
                                                                               ^0   ^0         ^0
 1530|       |                    } else {
 1531|      0|                        self.push_dummy(span)
 1532|       |                    };
 1533|       |
 1534|     45|                    match data {
 1535|     37|                        TypeData::Record(tag, members, is_union) => {
 1536|     37|                            let mut member_len = 0u16;
 1537|     37|                            let member_start_idx = self.ast.kinds.len() as u32 + 1;
 1538|     37|                            let member_start = NodeRef::new(member_start_idx).expect("NodeRef overflow");
 1539|       |
 1540|    101|                            for m in members {
                                              ^64
 1541|     64|                                let field_node = self.ast.push_node(
 1542|     64|                                    NodeKind::FieldDecl(FieldDeclData {
 1543|     64|                                        name: m.name,
 1544|     64|                                        ty: m.member_type,
 1545|     64|                                    }),
 1546|     64|                                    m.span,
 1547|     64|                                );
 1548|     64|                                self.set_scope(field_node, self.symbol_table.current_scope());
 1549|     64|                                member_len += 1;
 1550|     64|                            }
 1551|       |
 1552|     37|                            self.ast.kinds[node.index()] = NodeKind::RecordDecl(RecordDeclData {
 1553|     37|                                name: tag,
 1554|     37|                                ty: ty.ty(),
 1555|     37|                                member_start,
 1556|     37|                                member_len,
 1557|     37|                                is_union,
 1558|     37|                            });
 1559|       |                        }
 1560|      8|                        TypeData::Enum(tag, enumerators) => {
 1561|      8|                            let mut member_start = NodeRef::ROOT;
 1562|      8|                            let member_len = enumerators.len() as u16;
 1563|       |
 1564|     16|                            for (i, e) in enumerators.iter().enumerate() {
                                                        ^8                 ^8
 1565|     16|                                let member_ref = self.ast.push_node(
 1566|     16|                                    NodeKind::EnumMember(EnumMemberData {
 1567|     16|                                        name: e.name,
 1568|     16|                                        value: e.value,
 1569|     16|                                    }),
 1570|     16|                                    e.span,
 1571|       |                                );
 1572|     16|                                self.set_scope(member_ref, self.symbol_table.current_scope());
 1573|     16|                                if i == 0 {
 1574|      8|                                    member_start = member_ref;
 1575|      8|                                }
 1576|       |                            }
 1577|       |
 1578|      8|                            self.ast.kinds[node.index()] = NodeKind::EnumDecl(EnumDeclData {
 1579|      8|                                name: tag,
 1580|      8|                                ty: ty.ty(),
 1581|      8|                                member_start,
 1582|      8|                                member_len,
 1583|      8|                            });
 1584|       |                        }
 1585|       |                    }
 1586|     45|                    return smallvec![node];
                                                   ^0
 1587|      2|                }
 1588|      0|            }
 1589|      2|            return smallvec![];
 1590|    262|        }
 1591|       |
 1592|       |        enum TypeData {
 1593|       |            Record(Option<NameId>, Vec<StructMember>, bool),
 1594|       |            Enum(Option<NameId>, Vec<EnumConstant>),
 1595|       |        }
 1596|       |
 1597|    262|        let mut nodes = SmallVec::new();
 1598|       |
 1599|    265|        for (i, init) in decl.init_declarators.iter().enumerate() {
                                       ^262                         ^262
 1600|    265|            let final_ty = apply_declarator(base_ty, &init.declarator, self, init.span, &spec_info);
 1601|       |
 1602|    265|            let name = extract_name(&init.declarator).expect("Declarator must have identifier");
 1603|       |
 1604|    265|            let node = if let Some(slots) = target_slots {
 1605|    265|                slots[i]
 1606|       |            } else {
 1607|      0|                self.push_dummy(span)
 1608|       |            };
 1609|    265|            self.set_scope(node, self.symbol_table.current_scope());
 1610|       |
 1611|    265|            if spec_info.is_typedef {
 1612|      2|                if let Err(SymbolTableError::InvalidRedefinition { existing, .. }) =
 1613|     12|                    self.symbol_table.define_typedef(name, final_ty, span)
 1614|       |                {
 1615|      2|                    let existing_symbol = self.symbol_table.get_symbol(existing);
 1616|      2|                    if let SymbolKind::Typedef { aliased_type } = existing_symbol.kind {
 1617|      2|                        if self.registry.is_compatible(aliased_type, final_ty) {
 1618|      1|                            // C11 6.7.8: Compatible redefinition is allowed
 1619|      1|                        } else {
 1620|      1|                            self.report_error(SemanticError::RedefinitionWithDifferentType {
 1621|      1|                                name,
 1622|      1|                                first_def: existing_symbol.def_span,
 1623|      1|                                span,
 1624|      1|                            });
 1625|      1|                        }
 1626|      0|                    } else {
 1627|      0|                        // This case handles variable vs. typedef conflicts, which should
 1628|      0|                        // be caught by a separate check, but we emit a generic error here too.
 1629|      0|                        self.report_error(SemanticError::Redefinition {
 1630|      0|                            name,
 1631|      0|                            first_def: existing_symbol.def_span,
 1632|      0|                            span,
 1633|      0|                        });
 1634|      0|                    }
 1635|     10|                }
 1636|     12|                self.ast.kinds[node.index()] = NodeKind::TypedefDecl(TypedefDeclData { name, ty: final_ty });
 1637|     12|                nodes.push(node);
 1638|     12|                continue;
 1639|    253|            }
 1640|       |
 1641|    253|            let init_expr = init.initializer.map(|init_node| self.lower_expression(init_node));
                                                                           ^132 ^132             ^132
 1642|       |
 1643|    253|            let is_func = final_ty.is_function();
 1644|       |
 1645|       |            // Validate function specifiers (inline, _Noreturn)
 1646|    253|            if !is_func {
 1647|    230|                if spec_info.is_inline {
 1648|      0|                    self.report_error(SemanticError::InvalidFunctionSpecifier {
 1649|      0|                        spec: "inline".to_string(),
 1650|      0|                        span,
 1651|      0|                    });
 1652|    230|                }
 1653|    230|                if spec_info.is_noreturn {
 1654|      0|                    self.report_error(SemanticError::InvalidFunctionSpecifier {
 1655|      0|                        spec: "_Noreturn".to_string(),
 1656|      0|                        span,
 1657|      0|                    });
 1658|    230|                }
 1659|     23|            }
 1660|       |
 1661|    253|            if is_func {
 1662|     23|                let func_decl = FunctionDeclData {
 1663|     23|                    name,
 1664|     23|                    ty: final_ty.ty(),
 1665|     23|                    storage: spec_info.storage,
 1666|     23|                    body: None,
 1667|     23|                    scope_id: self.symbol_table.current_scope(),
 1668|     23|                };
 1669|     23|                self.check_redeclaration_compatibility(name, final_ty, span, spec_info.storage);
 1670|       |
 1671|     23|                if let Err(crate::semantic::symbol_table::SymbolTableError::InvalidRedefinition { existing, .. }) = self
                                                                                                                ^0
 1672|     23|                    .symbol_table
 1673|     23|                    .define_function(name, final_ty.ty(), spec_info.storage, false, span)
 1674|      0|                {
 1675|      0|                    let first_def = self.symbol_table.get_symbol(existing).def_span;
 1676|      0|                    self.report_error(SemanticError::Redefinition { name, first_def, span });
 1677|     23|                }
 1678|     23|                self.ast.kinds[node.index()] = NodeKind::FunctionDecl(func_decl);
 1679|     23|                nodes.push(node);
 1680|       |            } else {
 1681|    230|                let mut final_ty = final_ty;
 1682|    230|                if let Some(ie) = init_expr
                                          ^132
 1683|       |                    && let TypeKind::Array {
 1684|      7|                        element_type,
 1685|       |                        size: ArraySizeType::Incomplete,
 1686|    132|                    } = &self.registry.get(final_ty.ty()).kind
 1687|       |                {
 1688|      7|                    let element_type = *element_type;
 1689|      7|                    if let Some(deduced_size) = self.deduce_array_size_full(ie) {
 1690|      7|                        let new_ty = self
 1691|      7|                            .registry
 1692|      7|                            .array_of(element_type, ArraySizeType::Constant(deduced_size));
 1693|      7|                        final_ty = QualType::new(new_ty, final_ty.qualifiers());
 1694|      7|                    }
                                  ^0
 1695|    223|                }
 1696|       |
 1697|    230|                let var_decl = VarDeclData {
 1698|    230|                    name,
 1699|    230|                    ty: final_ty,
 1700|    230|                    storage: spec_info.storage,
 1701|    230|                    init: init_expr,
 1702|    230|                    alignment: spec_info.alignment.map(|a| a as u16),
                                                                         ^3
 1703|       |                };
 1704|    230|                self.check_redeclaration_compatibility(name, final_ty, span, spec_info.storage);
 1705|       |
 1706|    230|                if let Err(SymbolTableError::InvalidRedefinition { existing, .. }) = self.symbol_table.define_variable(
                                                                                 ^3
 1707|    230|                    name,
 1708|    230|                    final_ty,
 1709|    230|                    spec_info.storage,
 1710|    230|                    init_expr,
 1711|    230|                    spec_info.alignment,
 1712|    230|                    span,
 1713|    230|                ) {
 1714|      3|                    let first_def = self.symbol_table.get_symbol(existing).def_span;
 1715|      3|                    self.report_error(SemanticError::Redefinition { name, first_def, span });
 1716|    227|                }
 1717|       |
 1718|       |                // Important: Ensure layout for variable definitions
 1719|    230|                if self.registry.ensure_layout(final_ty.ty()).is_err() {
 1720|      5|                    // Swallow error here - get_layout will panic or we can't do much.
 1721|      5|                    // But for valid C code like 'int a[]', this fails.
 1722|      5|                    // However, we only need layout if it's used.
 1723|      5|                    // If we access it, get_layout panics.
 1724|      5|                    // This ensure_layout call helps caching layout early and catching ICEs early if possible.
 1725|      5|                    // But for 'extern int a[];', it returns error. We shouldn't error out.
 1726|      5|                    // Just ignore error.
 1727|    225|                }
 1728|       |
 1729|    230|                self.ast.kinds[node.index()] = NodeKind::VarDecl(var_decl);
 1730|    230|                nodes.push(node);
 1731|       |            }
 1732|       |        }
 1733|    262|        nodes
 1734|    309|    }
 1735|       |
 1736|  1.60k|    fn lower_node_rest(
 1737|  1.60k|        &mut self,
 1738|  1.60k|        parsed_ref: ParsedNodeRef,
 1739|  1.60k|        target_slots: Option<&[NodeRef]>,
 1740|  1.60k|    ) -> SmallVec<[NodeRef; 1]> {
 1741|  1.60k|        let parsed_node = self.parsed_ast.get_node(parsed_ref);
 1742|  1.60k|        let span = parsed_node.span;
 1743|  1.60k|        match &parsed_node.kind {
 1744|      0|            ParsedNodeKind::Declaration(decl) => self.lower_declaration(decl, span, target_slots),
 1745|      3|            ParsedNodeKind::StaticAssert(expr, msg) => {
 1746|      3|                let node = self.get_or_push_slot(target_slots, span);
 1747|      3|                let lowered_expr = self.lower_expression(*expr);
 1748|      3|                self.ast.kinds[node.index()] = NodeKind::StaticAssert(lowered_expr, *msg);
 1749|      3|                smallvec![node]
                                        ^0
 1750|       |            }
 1751|     39|            ParsedNodeKind::If(stmt) => {
 1752|     39|                let node = self.get_or_push_slot(target_slots, span);
 1753|     39|                let cond = self.lower_expression(stmt.condition);
 1754|     39|                let then = self.lower_single_statement(stmt.then_branch);
 1755|     39|                let else_branch = stmt.else_branch.map(|b| self.lower_single_statement(b));
                                                                         ^1   ^1                     ^1
 1756|     39|                self.ast.kinds[node.index()] = NodeKind::If(IfStmt {
 1757|     39|                    condition: cond,
 1758|     39|                    then_branch: then,
 1759|     39|                    else_branch,
 1760|     39|                });
 1761|     39|                smallvec![node]
                                        ^0
 1762|       |            }
 1763|      1|            ParsedNodeKind::While(stmt) => {
 1764|      1|                let node = self.get_or_push_slot(target_slots, span);
 1765|      1|                let cond = self.lower_expression(stmt.condition);
 1766|      1|                let body = self.lower_single_statement(stmt.body);
 1767|      1|                self.ast.kinds[node.index()] = NodeKind::While(WhileStmt { condition: cond, body });
 1768|      1|                smallvec![node]
                                        ^0
 1769|       |            }
 1770|      0|            ParsedNodeKind::DoWhile(body, cond) => {
 1771|      0|                let node = self.get_or_push_slot(target_slots, span);
 1772|      0|                let b = self.lower_single_statement(*body);
 1773|      0|                let c = self.lower_expression(*cond);
 1774|      0|                self.ast.kinds[node.index()] = NodeKind::DoWhile(b, c);
 1775|      0|                smallvec![node]
 1776|       |            }
 1777|      1|            ParsedNodeKind::For(stmt) => {
 1778|      1|                let node = self.get_or_push_slot(target_slots, span);
 1779|      1|                let scope_id = self.symbol_table.push_scope();
 1780|      1|                self.set_scope(node, scope_id);
 1781|       |
 1782|      1|                let init = stmt.init.map(|i| self.lower_node(i).first().cloned().unwrap());
                                                           ^0                         ^0       ^0
 1783|      1|                let cond = stmt.condition.map(|c| self.lower_expression(c));
 1784|      1|                let inc = stmt.increment.map(|i| self.lower_expression(i));
                                                               ^0   ^0               ^0
 1785|      1|                let body = self.lower_single_statement(stmt.body);
 1786|      1|                self.symbol_table.pop_scope();
 1787|       |
 1788|      1|                self.ast.kinds[node.index()] = NodeKind::For(crate::ast::ForStmt {
 1789|      1|                    init,
 1790|      1|                    condition: cond,
 1791|      1|                    increment: inc,
 1792|      1|                    body,
 1793|      1|                    scope_id,
 1794|      1|                });
 1795|      1|                smallvec![node]
                                        ^0
 1796|       |            }
 1797|      1|            ParsedNodeKind::Switch(cond, body) => {
 1798|      1|                let node = self.get_or_push_slot(target_slots, span);
 1799|      1|                let c = self.lower_expression(*cond);
 1800|      1|                let b = self.lower_single_statement(*body);
 1801|      1|                self.ast.kinds[node.index()] = NodeKind::Switch(c, b);
 1802|      1|                smallvec![node]
                                        ^0
 1803|       |            }
 1804|      3|            ParsedNodeKind::Case(expr, stmt) => {
 1805|      3|                let node = self.get_or_push_slot(target_slots, span);
 1806|      3|                let e = self.lower_expression(*expr);
 1807|      3|                let s = self.lower_single_statement(*stmt);
 1808|      3|                self.ast.kinds[node.index()] = NodeKind::Case(e, s);
 1809|      3|                smallvec![node]
                                        ^0
 1810|       |            }
 1811|      0|            ParsedNodeKind::CaseRange(start, end, stmt) => {
 1812|      0|                let node = self.get_or_push_slot(target_slots, span);
 1813|      0|                let s_expr = self.lower_expression(*start);
 1814|      0|                let e_expr = self.lower_expression(*end);
 1815|      0|                let s_stmt = self.lower_single_statement(*stmt);
 1816|      0|                self.ast.kinds[node.index()] = NodeKind::CaseRange(s_expr, e_expr, s_stmt);
 1817|      0|                smallvec![node]
 1818|       |            }
 1819|      0|            ParsedNodeKind::Default(stmt) => {
 1820|      0|                let node = self.get_or_push_slot(target_slots, span);
 1821|      0|                let s = self.lower_single_statement(*stmt);
 1822|      0|                self.ast.kinds[node.index()] = NodeKind::Default(s);
 1823|      0|                smallvec![node]
 1824|       |            }
 1825|       |            ParsedNodeKind::Break => {
 1826|      3|                let node = if let Some(target) = target_slots.and_then(|t| t.first()) {
                                                     ^0                                  ^0^0
 1827|      0|                    self.ast.kinds[target.index()] = NodeKind::Break;
 1828|      0|                    self.ast.spans[target.index()] = span;
 1829|      0|                    *target
 1830|       |                } else {
 1831|      3|                    self.ast.push_node(NodeKind::Break, span)
 1832|       |                };
 1833|      3|                self.set_scope(node, self.symbol_table.current_scope());
 1834|      3|                smallvec![node]
                                        ^0
 1835|       |            }
 1836|       |            ParsedNodeKind::Continue => {
 1837|      0|                let node = if let Some(target) = target_slots.and_then(|t| t.first()) {
 1838|      0|                    self.ast.kinds[target.index()] = NodeKind::Continue;
 1839|      0|                    self.ast.spans[target.index()] = span;
 1840|      0|                    *target
 1841|       |                } else {
 1842|      0|                    self.ast.push_node(NodeKind::Continue, span)
 1843|       |                };
 1844|      0|                self.set_scope(node, self.symbol_table.current_scope());
 1845|      0|                smallvec![node]
 1846|       |            }
 1847|      3|            ParsedNodeKind::Goto(name) => {
 1848|      3|                let sym = self.resolve_label(*name, span);
 1849|      3|                let node = if let Some(target) = target_slots.and_then(|t| t.first()) {
 1850|      3|                    self.ast.kinds[target.index()] = NodeKind::Goto(*name, sym);
 1851|      3|                    self.ast.spans[target.index()] = span;
 1852|      3|                    *target
 1853|       |                } else {
 1854|      0|                    self.ast.push_node(NodeKind::Goto(*name, sym), span)
 1855|       |                };
 1856|      3|                self.set_scope(node, self.symbol_table.current_scope());
 1857|      3|                smallvec![node]
                                        ^0
 1858|       |            }
 1859|      6|            ParsedNodeKind::Label(name, inner) => {
 1860|      6|                let node = self.get_or_push_slot(target_slots, span);
 1861|      6|                let sym = self.define_label(*name, span);
 1862|      6|                let s = self.lower_single_statement(*inner);
 1863|      6|                self.ast.kinds[node.index()] = NodeKind::Label(*name, s, sym);
 1864|      6|                smallvec![node]
                                        ^0
 1865|       |            }
 1866|    194|            ParsedNodeKind::Return(expr) => {
 1867|    194|                let node = self.get_or_push_slot(target_slots, span);
 1868|    194|                let e = expr.map(|x| self.lower_expression(x));
                                                   ^190 ^190             ^190
 1869|    194|                self.ast.kinds[node.index()] = NodeKind::Return(e);
 1870|    194|                smallvec![node]
                                        ^0
 1871|       |            }
 1872|    111|            ParsedNodeKind::ExpressionStatement(expr) => {
 1873|    111|                let node = self.get_or_push_slot(target_slots, span);
 1874|    111|                let e = expr.map(|x| self.lower_expression(x));
 1875|    111|                self.ast.kinds[node.index()] = NodeKind::ExpressionStatement(e);
 1876|    111|                smallvec![node]
                                        ^0
 1877|       |            }
 1878|     95|            ParsedNodeKind::BinaryOp(op, lhs, rhs) => {
 1879|     95|                let node = self.get_or_push_slot(target_slots, span);
 1880|     95|                let l = self.lower_expression(*lhs);
 1881|     95|                let r = self.lower_expression(*rhs);
 1882|     95|                self.ast.kinds[node.index()] = NodeKind::BinaryOp(*op, l, r);
 1883|     95|                smallvec![node]
                                        ^0
 1884|       |            }
 1885|     83|            ParsedNodeKind::Assignment(op, lhs, rhs) => {
 1886|     83|                let node = self.get_or_push_slot(target_slots, span);
 1887|     83|                let l = self.lower_expression(*lhs);
 1888|     83|                let r = self.lower_expression(*rhs);
 1889|     83|                self.ast.kinds[node.index()] = NodeKind::Assignment(*op, l, r);
 1890|     83|                smallvec![node]
                                        ^0
 1891|       |            }
 1892|     49|            ParsedNodeKind::UnaryOp(op, operand) => {
 1893|     49|                let node = self.get_or_push_slot(target_slots, span);
 1894|     49|                let o = self.lower_expression(*operand);
 1895|     49|                self.ast.kinds[node.index()] = NodeKind::UnaryOp(*op, o);
 1896|     49|                smallvec![node]
                                        ^0
 1897|       |            }
 1898|    552|            ParsedNodeKind::Literal(literal) => {
 1899|    552|                let node = if let Some(target) = target_slots.and_then(|t| t.first()) {
                                                     ^18                                 ^18^18
 1900|     18|                    self.ast.kinds[target.index()] = NodeKind::Literal(literal.clone());
 1901|     18|                    self.ast.spans[target.index()] = span;
 1902|     18|                    *target
 1903|       |                } else {
 1904|    534|                    self.ast.push_node(NodeKind::Literal(literal.clone()), span)
 1905|       |                };
 1906|    552|                smallvec![node]
                                        ^0
 1907|       |            }
 1908|    285|            ParsedNodeKind::Ident(name) => {
 1909|    285|                let sym = self.resolve_ident(*name, span);
 1910|    285|                let node = if let Some(target) = target_slots.and_then(|t| t.first()) {
                                                     ^2                                  ^2^2
 1911|      2|                    self.ast.kinds[target.index()] = NodeKind::Ident(*name, sym);
 1912|      2|                    self.ast.spans[target.index()] = span;
 1913|      2|                    *target
 1914|       |                } else {
 1915|    283|                    self.ast.push_node(NodeKind::Ident(*name, sym), span)
 1916|       |                };
 1917|    285|                smallvec![node]
                                        ^0
 1918|       |            }
 1919|     30|            ParsedNodeKind::FunctionCall(func, args) => {
 1920|       |                // Reserve a slot for the FunctionCall node to ensure parent < child index (when necessary)
 1921|       |                // If we have a target slot for the result, we can use it directly?
 1922|       |                // But FunctionCall needs to know ranges of args.
 1923|       |                // The structure is: CallNode -> FuncExpr, Arg1, Arg2...
 1924|       |                // FuncExpr and Args can be anywhere, but Args must be contiguous.
 1925|       |
 1926|     30|                let call_node_idx = self.get_or_push_slot(target_slots, span);
 1927|       |
 1928|     30|                let f = self.lower_expression(*func);
 1929|       |
 1930|       |                // Reserve slots for arguments to ensure contiguity
 1931|     30|                let mut arg_dummies = Vec::with_capacity(args.len());
 1932|     30|                for _ in 0..args.len() {
 1933|     21|                    arg_dummies.push(self.push_dummy(span));
 1934|     21|                }
 1935|       |
 1936|       |                // Lower arguments into reserved slots
 1937|     30|                for (i, &arg_parsed_ref) in args.iter().enumerate() {
                                   ^21 ^21
 1938|     21|                    self.lower_expression_into(arg_parsed_ref, arg_dummies[i]);
 1939|     21|                }
 1940|       |
 1941|     30|                let arg_start = if !arg_dummies.is_empty() {
 1942|     11|                    arg_dummies[0]
 1943|       |                } else {
 1944|     19|                    NodeRef::ROOT
 1945|       |                };
 1946|     30|                let arg_len = arg_dummies.len() as u16;
 1947|       |
 1948|       |                // Replace the reserved dummy node with the actual FunctionCall
 1949|     30|                self.ast.kinds[call_node_idx.index()] = NodeKind::FunctionCall(CallExpr {
 1950|     30|                    callee: f,
 1951|     30|                    arg_start,
 1952|     30|                    arg_len,
 1953|     30|                });
 1954|       |
 1955|     30|                smallvec![call_node_idx]
                                        ^0
 1956|       |            }
 1957|     52|            ParsedNodeKind::MemberAccess(base, member, is_arrow) => {
 1958|     52|                let node = self.get_or_push_slot(target_slots, span);
 1959|     52|                let b = self.lower_expression(*base);
 1960|     52|                self.ast.kinds[node.index()] = NodeKind::MemberAccess(b, *member, *is_arrow);
 1961|     52|                smallvec![node]
                                        ^0
 1962|       |            }
 1963|      9|            ParsedNodeKind::Cast(ty_name, expr) => {
 1964|      9|                let node = self.get_or_push_slot(target_slots, span);
 1965|      9|                let e = self.lower_expression(*expr);
 1966|      9|                let ty = convert_to_qual_type(self, *ty_name, span)
 1967|      9|                    .unwrap_or(QualType::unqualified(self.registry.type_error));
 1968|      9|                self.ast.kinds[node.index()] = NodeKind::Cast(ty, e);
 1969|      9|                smallvec![node]
                                        ^0
 1970|       |            }
 1971|      3|            ParsedNodeKind::PostIncrement(operand) => {
 1972|      3|                let node = self.get_or_push_slot(target_slots, span);
 1973|      3|                let o = self.lower_expression(*operand);
 1974|      3|                self.ast.kinds[node.index()] = NodeKind::PostIncrement(o);
 1975|      3|                smallvec![node]
                                        ^0
 1976|       |            }
 1977|      3|            ParsedNodeKind::PostDecrement(operand) => {
 1978|      3|                let node = self.get_or_push_slot(target_slots, span);
 1979|      3|                let o = self.lower_expression(*operand);
 1980|      3|                self.ast.kinds[node.index()] = NodeKind::PostDecrement(o);
 1981|      3|                smallvec![node]
                                        ^0
 1982|       |            }
 1983|     25|            ParsedNodeKind::IndexAccess(base, index) => {
 1984|     25|                let node = self.get_or_push_slot(target_slots, span);
 1985|     25|                let b = self.lower_expression(*base);
 1986|     25|                let i = self.lower_expression(*index);
 1987|     25|                self.ast.kinds[node.index()] = NodeKind::IndexAccess(b, i);
 1988|     25|                smallvec![node]
                                        ^0
 1989|       |            }
 1990|      4|            ParsedNodeKind::TernaryOp(cond, then_branch, else_branch) => {
 1991|      4|                let node = self.get_or_push_slot(target_slots, span);
 1992|      4|                let c = self.lower_expression(*cond);
 1993|      4|                let t = self.lower_expression(*then_branch);
 1994|      4|                let e = self.lower_expression(*else_branch);
 1995|      4|                self.ast.kinds[node.index()] = NodeKind::TernaryOp(c, t, e);
 1996|      4|                smallvec![node]
                                        ^0
 1997|       |            }
 1998|      0|            ParsedNodeKind::GnuStatementExpression(stmt, expr) => {
 1999|      0|                let node = self.get_or_push_slot(target_slots, span);
 2000|      0|                let s = self.lower_expression(*stmt);
 2001|      0|                let e = self.lower_expression(*expr);
 2002|      0|                self.ast.kinds[node.index()] = NodeKind::GnuStatementExpression(s, e);
 2003|      0|                smallvec![node]
 2004|       |            }
 2005|     13|            ParsedNodeKind::SizeOfExpr(expr) => {
 2006|     13|                let node = self.get_or_push_slot(target_slots, span);
 2007|     13|                let e = self.lower_expression(*expr);
 2008|     13|                self.ast.kinds[node.index()] = NodeKind::SizeOfExpr(e);
 2009|     13|                smallvec![node]
                                        ^0
 2010|       |            }
 2011|      4|            ParsedNodeKind::SizeOfType(ty_name) => {
 2012|      4|                let node = if let Some(target) = target_slots.and_then(|t| t.first()) {
                                                     ^0                                  ^0^0
 2013|      0|                    let ty = convert_to_qual_type(self, *ty_name, span)
 2014|      0|                        .unwrap_or(QualType::unqualified(self.registry.type_error));
 2015|      0|                    self.ast.kinds[target.index()] = NodeKind::SizeOfType(ty);
 2016|      0|                    self.ast.spans[target.index()] = span;
 2017|      0|                    *target
 2018|       |                } else {
 2019|      4|                    let ty = convert_to_qual_type(self, *ty_name, span)
 2020|      4|                        .unwrap_or(QualType::unqualified(self.registry.type_error));
 2021|      4|                    self.ast.push_node(NodeKind::SizeOfType(ty), span)
 2022|       |                };
 2023|      4|                smallvec![node]
                                        ^0
 2024|       |            }
 2025|      0|            ParsedNodeKind::AlignOf(ty_name) => {
 2026|      0|                let node = if let Some(target) = target_slots.and_then(|t| t.first()) {
 2027|      0|                    let ty = convert_to_qual_type(self, *ty_name, span)
 2028|      0|                        .unwrap_or(QualType::unqualified(self.registry.type_error));
 2029|      0|                    self.ast.kinds[target.index()] = NodeKind::AlignOf(ty);
 2030|      0|                    self.ast.spans[target.index()] = span;
 2031|      0|                    *target
 2032|       |                } else {
 2033|      0|                    let ty = convert_to_qual_type(self, *ty_name, span)
 2034|      0|                        .unwrap_or(QualType::unqualified(self.registry.type_error));
 2035|      0|                    self.ast.push_node(NodeKind::AlignOf(ty), span)
 2036|       |                };
 2037|      0|                smallvec![node]
 2038|       |            }
 2039|      0|            ParsedNodeKind::BuiltinVaArg(ty_name, expr) => {
 2040|      0|                let node = self.get_or_push_slot(target_slots, span);
 2041|      0|                let e = self.lower_expression(*expr);
 2042|      0|                let ty = convert_to_qual_type(self, *ty_name, span)
 2043|      0|                    .unwrap_or(QualType::unqualified(self.registry.type_error));
 2044|      0|                self.ast.kinds[node.index()] = NodeKind::BuiltinVaArg(ty, e);
 2045|      0|                smallvec![node]
 2046|       |            }
 2047|      0|            ParsedNodeKind::BuiltinVaStart(ap, last) => {
 2048|      0|                let node = self.get_or_push_slot(target_slots, span);
 2049|      0|                let a = self.lower_expression(*ap);
 2050|      0|                let l = self.lower_expression(*last);
 2051|      0|                self.ast.kinds[node.index()] = NodeKind::BuiltinVaStart(a, l);
 2052|      0|                smallvec![node]
 2053|       |            }
 2054|      0|            ParsedNodeKind::BuiltinVaEnd(ap) => {
 2055|      0|                let node = self.get_or_push_slot(target_slots, span);
 2056|      0|                let a = self.lower_expression(*ap);
 2057|      0|                self.ast.kinds[node.index()] = NodeKind::BuiltinVaEnd(a);
 2058|      0|                smallvec![node]
 2059|       |            }
 2060|      0|            ParsedNodeKind::BuiltinVaCopy(dst, src) => {
 2061|      0|                let node = self.get_or_push_slot(target_slots, span);
 2062|      0|                let d = self.lower_expression(*dst);
 2063|      0|                let s = self.lower_expression(*src);
 2064|      0|                self.ast.kinds[node.index()] = NodeKind::BuiltinVaCopy(d, s);
 2065|      0|                smallvec![node]
 2066|       |            }
 2067|      0|            ParsedNodeKind::CompoundLiteral(ty_name, init) => {
 2068|      0|                let node = self.get_or_push_slot(target_slots, span);
 2069|      0|                let ty = convert_to_qual_type(self, *ty_name, span)
 2070|      0|                    .unwrap_or(QualType::unqualified(self.registry.type_error));
 2071|      0|                let i = self.lower_expression(*init);
 2072|      0|                self.ast.kinds[node.index()] = NodeKind::CompoundLiteral(ty, i);
 2073|      0|                smallvec![node]
 2074|       |            }
 2075|      6|            ParsedNodeKind::GenericSelection(control, associations) => {
 2076|      6|                let node = self.get_or_push_slot(target_slots, span);
 2077|      6|                let c = self.lower_expression(*control);
 2078|       |
 2079|      6|                let assoc_len = associations.len() as u16;
 2080|      6|                let mut assoc_dummies = Vec::new();
 2081|     13|                for _ in 0..assoc_len {
                                          ^6
 2082|     13|                    assoc_dummies.push(self.push_dummy(span));
 2083|     13|                }
 2084|       |
 2085|     13|                for (i, a) in associations.iter().enumerate() {
                                            ^6                  ^6
 2086|     13|                    let ty = a.type_name.map(|t| {
                                                               ^8
 2087|      8|                        convert_to_qual_type(self, t, span).unwrap_or(QualType::unqualified(self.registry.type_error))
 2088|      8|                    });
 2089|     13|                    let expr = self.lower_expression(a.result_expr);
 2090|     13|                    let assoc_ref = assoc_dummies[i];
 2091|     13|                    self.ast.kinds[assoc_ref.index()] =
 2092|     13|                        NodeKind::GenericAssociation(GenericAssociationData { ty, result_expr: expr });
 2093|     13|                    self.set_scope(assoc_ref, self.symbol_table.current_scope());
 2094|       |                }
 2095|       |
 2096|      6|                let assoc_start = if assoc_len > 0 { assoc_dummies[0] } else { NodeRef::ROOT };
                                                                                             ^0
 2097|       |
 2098|      6|                self.ast.kinds[node.index()] = NodeKind::GenericSelection(GenericSelectionData {
 2099|      6|                    control: c,
 2100|      6|                    assoc_start,
 2101|      6|                    assoc_len,
 2102|      6|                });
 2103|      6|                smallvec![node]
                                        ^0
 2104|       |            }
 2105|     30|            ParsedNodeKind::InitializerList(inits) => {
 2106|     30|                let node = self.get_or_push_slot(target_slots, span);
 2107|       |
 2108|       |                // Reserve slots for InitializerItems to ensure parent < child index
 2109|     30|                let mut init_dummies = Vec::new();
 2110|     64|                for _ in 0..inits.len() {
                                          ^30   ^30
 2111|     64|                    init_dummies.push(self.push_dummy(span));
 2112|     64|                }
 2113|       |
 2114|     64|                for (i, init) in inits.iter().enumerate() {
                                               ^30          ^30
 2115|     64|                    let expr = self.lower_expression(init.initializer);
 2116|       |
 2117|     64|                    let designator_count = init.designation.len() as u16;
 2118|     64|                    let mut designator_dummies = Vec::with_capacity(designator_count as usize);
 2119|       |
 2120|     64|                    for _ in 0..designator_count {
 2121|     38|                        designator_dummies.push(self.push_dummy(span));
 2122|     38|                    }
 2123|       |
 2124|     64|                    for (j, d) in init.designation.iter().enumerate() {
                                       ^38^38
 2125|     38|                        let node_kind = match d {
 2126|     19|                            ParsedDesignator::FieldName(name) => Designator::FieldName(*name),
 2127|     19|                            ParsedDesignator::ArrayIndex(idx) => Designator::ArrayIndex(self.lower_expression(*idx)),
 2128|      0|                            ParsedDesignator::GnuArrayRange(start, end) => {
 2129|      0|                                Designator::GnuArrayRange(self.lower_expression(*start), self.lower_expression(*end))
 2130|       |                            }
 2131|       |                        };
 2132|     38|                        let d_ref = designator_dummies[j];
 2133|     38|                        self.ast.kinds[d_ref.index()] = NodeKind::Designator(node_kind);
 2134|       |                        // Designators don't really have scopes, but we can set it to current
 2135|     38|                        self.set_scope(d_ref, self.symbol_table.current_scope());
 2136|       |                    }
 2137|       |
 2138|     64|                    let designator_start = if designator_count > 0 {
 2139|     38|                        designator_dummies[0]
 2140|       |                    } else {
 2141|     26|                        NodeRef::ROOT
 2142|       |                    };
 2143|       |
 2144|     64|                    let di = DesignatedInitializer {
 2145|     64|                        designator_start,
 2146|     64|                        designator_len: designator_count,
 2147|     64|                        initializer: expr,
 2148|     64|                    };
 2149|       |
 2150|     64|                    let item_ref = init_dummies[i];
 2151|     64|                    self.ast.kinds[item_ref.index()] = NodeKind::InitializerItem(di);
 2152|     64|                    self.set_scope(item_ref, self.symbol_table.current_scope());
 2153|       |                }
 2154|       |
 2155|     30|                let init_len = init_dummies.len() as u16;
 2156|     30|                let init_start = if init_len > 0 { init_dummies[0] } else { NodeRef::ROOT };
                                                                                          ^0
 2157|       |
 2158|     30|                self.ast.kinds[node.index()] = NodeKind::InitializerList(InitializerListData { init_start, init_len });
 2159|       |
 2160|     30|                smallvec![node]
                                        ^0
 2161|       |            }
 2162|       |            ParsedNodeKind::EmptyStatement => {
 2163|      1|                smallvec![]
 2164|       |            }
 2165|       |            _ => {
 2166|       |                // For unhandled nodes (or Dummy), push a Dummy node to avoid ICE
 2167|      0|                smallvec![self.push_dummy(span)]
 2168|       |            }
 2169|       |        }
 2170|  1.60k|    }
 2171|       |
 2172|  1.22k|    pub(crate) fn lower_expression(&mut self, node: ParsedNodeRef) -> NodeRef {
 2173|  1.22k|        match self.lower_node(node).first().cloned() {
 2174|  1.22k|            Some(n) => n,
 2175|      0|            None => self.push_dummy(SourceSpan::default()),
 2176|       |        }
 2177|  1.22k|    }
 2178|       |
 2179|     21|    pub(crate) fn lower_expression_into(&mut self, node: ParsedNodeRef, target: NodeRef) -> NodeRef {
 2180|     21|        match self.lower_node_entry(node, Some(&[target])).first().cloned() {
 2181|     21|            Some(n) => n,
 2182|      0|            None => target, // Should not happen if node lowering respects target
 2183|       |        }
 2184|     21|    }
 2185|       |
 2186|    248|    pub(crate) fn lower_single_statement(&mut self, node: ParsedNodeRef) -> NodeRef {
 2187|    248|        self.lower_node(node)
 2188|    248|            .first()
 2189|    248|            .cloned()
 2190|    248|            .unwrap_or_else(|| self.push_dummy(SourceSpan::default()))
                                             ^0   ^0         ^0
 2191|    248|    }
 2192|       |
 2193|    285|    fn resolve_ident(&mut self, name: NameId, span: SourceSpan) -> SymbolRef {
 2194|    285|        if let Some((sym_ref, _)) = self.symbol_table.lookup_symbol(name) {
                                   ^284
 2195|    284|            sym_ref
 2196|       |        } else {
 2197|      1|            self.report_error(SemanticError::UndeclaredIdentifier { name, span });
 2198|      1|            SymbolRef::new(1).expect("SymbolRef 1 creation failed")
 2199|       |        }
 2200|    285|    }
 2201|       |
 2202|     12|    fn define_label(&mut self, name: NameId, span: SourceSpan) -> SymbolRef {
 2203|     12|        match self.symbol_table.define_label(name, self.registry.type_void, span) {
 2204|     12|            Ok(sym) => sym,
 2205|       |            Err(_) => {
 2206|       |                // If already defined (e.g. by pre-scan), look it up
 2207|      0|                self.symbol_table
 2208|      0|                    .lookup_label(name)
 2209|      0|                    .map(|(s, _)| s)
 2210|      0|                    .unwrap_or_else(|| SymbolRef::new(1).unwrap())
 2211|       |            }
 2212|       |        }
 2213|     12|    }
 2214|       |
 2215|      3|    fn resolve_label(&mut self, name: NameId, span: SourceSpan) -> SymbolRef {
 2216|      3|        if let Some((sym_ref, _)) = self.symbol_table.lookup_label(name) {
 2217|      3|            sym_ref
 2218|       |        } else {
 2219|       |            // Forward references are okay because of pre-scan
 2220|       |            // But if NOT even in pre-scan, then it's undeclared
 2221|      0|            self.report_error(SemanticError::UndeclaredIdentifier { name, span });
 2222|      0|            SymbolRef::new(1).unwrap()
 2223|       |        }
 2224|      3|    }
 2225|       |
 2226|    736|    fn collect_labels(&mut self, node: ParsedNodeRef) {
 2227|    736|        let parsed_node = self.parsed_ast.get_node(node);
 2228|    736|        match &parsed_node.kind {
 2229|      6|            ParsedNodeKind::Label(name, inner) => {
 2230|      6|                let _ = self.define_label(*name, parsed_node.span);
 2231|      6|                self.collect_labels(*inner);
 2232|      6|            }
 2233|    205|            ParsedNodeKind::CompoundStatement(stmts) => {
 2234|    693|                for stmt in stmts {
                                  ^488
 2235|    488|                    self.collect_labels(*stmt);
 2236|    488|                }
 2237|       |            }
 2238|     39|            ParsedNodeKind::If(stmt) => {
 2239|     39|                self.collect_labels(stmt.then_branch);
 2240|     39|                if let Some(eb) = stmt.else_branch {
                                          ^1
 2241|      1|                    self.collect_labels(eb);
 2242|     38|                }
 2243|       |            }
 2244|      1|            ParsedNodeKind::While(stmt) => {
 2245|      1|                self.collect_labels(stmt.body);
 2246|      1|            }
 2247|      0|            ParsedNodeKind::DoWhile(body, _) => {
 2248|      0|                self.collect_labels(*body);
 2249|      0|            }
 2250|      1|            ParsedNodeKind::For(stmt) => {
 2251|      1|                self.collect_labels(stmt.body);
 2252|      1|            }
 2253|      1|            ParsedNodeKind::Switch(_, body) => {
 2254|      1|                self.collect_labels(*body);
 2255|      1|            }
 2256|      3|            ParsedNodeKind::Case(_, stmt) | ParsedNodeKind::CaseRange(_, _, stmt) | ParsedNodeKind::Default(stmt) => {
                                                                                          ^0                              ^0
 2257|      3|                self.collect_labels(*stmt);
 2258|      3|            }
 2259|    480|            _ => {}
 2260|       |        }
 2261|    736|    }
 2262|       |
 2263|      7|    fn deduce_array_size_full(&self, init_node: NodeRef) -> Option<usize> {
 2264|      7|        let node_kind = self.ast.get_kind(init_node);
 2265|      5|        match node_kind {
 2266|      2|            NodeKind::InitializerList(list_data) => {
 2267|      2|                let mut max_index: i64 = -1;
 2268|      2|                let mut current_index: i64 = 0;
 2269|       |
 2270|      2|                if list_data.init_len == 0 {
 2271|      0|                    return Some(0);
 2272|      2|                }
 2273|       |
 2274|      6|                for item_ref in list_data.init_start.range(list_data.init_len) {
                                              ^2                   ^2    ^2
 2275|      6|                    let NodeKind::InitializerItem(init) = self.ast.get_kind(item_ref) else {
 2276|      0|                        continue;
 2277|       |                    };
 2278|      6|                    if init.designator_len > 0 {
 2279|      2|                        let first_designator_ref = init.designator_start;
 2280|      2|                        match self.ast.get_kind(first_designator_ref) {
 2281|      2|                            NodeKind::Designator(d) => match d {
 2282|      2|                                crate::ast::Designator::ArrayIndex(expr_ref) => {
 2283|      2|                                    let const_ctx = ConstEvalCtx {
 2284|      2|                                        ast: self.ast,
 2285|      2|                                        symbol_table: self.symbol_table,
 2286|      2|                                    };
 2287|      2|                                    if let Some(val) = const_eval::eval_const_expr(&const_ctx, *expr_ref) {
 2288|      2|                                        current_index = val;
 2289|      2|                                    } else {
 2290|      0|                                        return None;
 2291|       |                                    }
 2292|       |                                }
 2293|      0|                                crate::ast::Designator::GnuArrayRange(start, end) => {
 2294|      0|                                    let const_ctx = ConstEvalCtx {
 2295|      0|                                        ast: self.ast,
 2296|      0|                                        symbol_table: self.symbol_table,
 2297|      0|                                    };
 2298|      0|                                    if let (Some(start_val), Some(end_val)) = (
 2299|      0|                                        const_eval::eval_const_expr(&const_ctx, *start),
 2300|      0|                                        const_eval::eval_const_expr(&const_ctx, *end),
 2301|       |                                    ) {
 2302|      0|                                        if start_val > end_val {
 2303|      0|                                            return None;
 2304|      0|                                        }
 2305|      0|                                        current_index = end_val;
 2306|       |                                    } else {
 2307|      0|                                        return None;
 2308|       |                                    }
 2309|       |                                }
 2310|       |                                crate::ast::Designator::FieldName(_) => {
 2311|       |                                    // Should not happen in array initializer
 2312|      0|                                    return None;
 2313|       |                                }
 2314|       |                            },
 2315|      0|                            _ => return None,
 2316|       |                        }
 2317|      4|                    }
 2318|       |
 2319|      6|                    if current_index > max_index {
 2320|      6|                        max_index = current_index;
 2321|      6|                    }
                                  ^0
 2322|      6|                    current_index += 1;
 2323|       |                }
 2324|       |
 2325|      2|                if max_index >= 0 {
 2326|      2|                    Some((max_index + 1) as usize)
 2327|       |                } else {
 2328|      0|                    Some(0)
 2329|       |                }
 2330|       |            }
 2331|      5|            NodeKind::Literal(literal::Literal::String(name_id)) => {
 2332|      5|                let s = name_id.to_string();
 2333|      5|                Some(s.len() + 1)
 2334|       |            }
 2335|      0|            _ => None,
 2336|       |        }
 2337|      7|    }
 2338|       |}
 2339|       |/// Extracts the bit-field width from a declarator if it exists.
 2340|     93|fn extract_bit_field_width<'a>(
 2341|     93|    declarator: &'a ParsedDeclarator,
 2342|     93|    ctx: &mut LowerCtx,
 2343|     93|) -> (Option<NonZeroU16>, &'a ParsedDeclarator) {
 2344|     93|    if let ParsedDeclarator::BitField(base, expr_ref) = declarator {
                                                    ^1    ^1
 2345|      1|        let node = ctx.parsed_ast.get_node(*expr_ref);
 2346|      1|        let width = if let ParsedNodeKind::Literal(literal::Literal::Int { val, .. }) = node.kind {
 2347|      1|            if val > 0 && val <= 64 {
 2348|       |                // Bitfield width can be up to type width (e.g. 64)
 2349|      1|                NonZeroU16::new(val as u16)
 2350|       |            } else {
 2351|      0|                ctx.report_error(SemanticError::InvalidBitfieldWidth { span: node.span });
 2352|      0|                None
 2353|       |            }
 2354|       |        } else {
 2355|       |            // Evaluator needed for non-literals.
 2356|      0|            ctx.report_error(SemanticError::NonConstantBitfieldWidth { span: node.span });
 2357|      0|            None
 2358|       |        };
 2359|      1|        (width, base)
 2360|       |    } else {
 2361|     92|        (None, declarator)
 2362|       |    }
 2363|     93|}
 2364|       |
 2365|       |/// Common logic for lowering struct members, used by both TypeSpecifier::Record lowering
 2366|       |/// and Declarator::AnonymousRecord handling.
 2367|     58|fn lower_struct_members(
 2368|     58|    members: &[ParsedDeclarationData],
 2369|     58|    ctx: &mut LowerCtx,
 2370|     58|    span: crate::ast::SourceSpan,
 2371|     58|) -> Vec<StructMember> {
 2372|     58|    let mut struct_members = Vec::new();
 2373|       |
 2374|    161|    for decl in members {
                      ^103
 2375|       |        // Handle anonymous struct/union members (C11 6.7.2.1p13)
 2376|       |        // "An unnamed member of structure or union type with no tag is called an anonymous structure or anonymous union"
 2377|    103|        if decl.init_declarators.is_empty() {
 2378|     10|            let spec_info = lower_decl_specifiers(&decl.specifiers, ctx, span);
 2379|       |
 2380|       |            // Check for illegal storage classes
 2381|     10|            if spec_info.storage.is_some() {
 2382|      0|                ctx.report_error(SemanticError::ConflictingStorageClasses { span });
 2383|     10|            }
 2384|       |
 2385|     10|            if let Some(type_ref) = spec_info.base_type {
 2386|     10|                let type_ref = ctx.merge_qualifiers_with_check(type_ref, spec_info.qualifiers, span);
 2387|       |
 2388|       |                // Check if it is a Record type (struct or union)
 2389|     10|                if type_ref.is_record() {
 2390|     10|                    let ty = ctx.registry.get(type_ref.ty());
 2391|     10|                    if let TypeKind::Record { tag, .. } = &ty.kind {
 2392|       |                        // It must have no tag to be an anonymous member
 2393|     10|                        if tag.is_none() {
 2394|     10|                            struct_members.push(StructMember {
 2395|     10|                                name: None,
 2396|     10|                                member_type: type_ref,
 2397|     10|                                bit_field_size: None,
 2398|     10|                                span, // Use the parent span since DeclarationData doesn't have one
 2399|     10|                            });
 2400|     10|                        }
                                      ^0
 2401|      0|                    }
 2402|      0|                }
 2403|      0|            }
 2404|     10|            continue;
 2405|     93|        }
 2406|       |
 2407|       |        // Hoist declaration specifier processing out of the loop
 2408|     93|        let spec_info = lower_decl_specifiers(&decl.specifiers, ctx, span);
 2409|       |
 2410|       |        // Check for illegal storage classes
 2411|     93|        if spec_info.storage.is_some() {
 2412|      0|            ctx.report_error(SemanticError::ConflictingStorageClasses { span });
 2413|     93|        }
 2414|       |
 2415|    186|        for init_declarator in &decl.init_declarators {
                          ^93
 2416|     93|            let (bit_field_size, base_declarator) = extract_bit_field_width(&init_declarator.declarator, ctx);
 2417|       |
 2418|     93|            let member_name = extract_name(base_declarator);
 2419|       |
 2420|     93|            let member_type = if let Some(base_type_ref) = spec_info.base_type {
 2421|       |                // Manually re-apply qualifiers from the base type.
 2422|     93|                let ty = apply_declarator(base_type_ref, base_declarator, ctx, init_declarator.span, &spec_info);
 2423|     93|                ctx.merge_qualifiers_with_check(ty, spec_info.qualifiers, init_declarator.span)
 2424|       |            } else {
 2425|      0|                QualType::unqualified(ctx.registry.type_int)
 2426|       |            };
 2427|       |
 2428|       |            // Validate bit-field type
 2429|     93|            if bit_field_size.is_some() && !member_type.is_integer() {
                                                         ^1
 2430|      1|                ctx.report_error(SemanticError::InvalidBitfieldType {
 2431|      1|                    ty: ctx.registry.display_qual_type(member_type),
 2432|      1|                    span: init_declarator.span,
 2433|      1|                });
 2434|     92|            }
 2435|       |
 2436|     93|            struct_members.push(StructMember {
 2437|     93|                name: member_name,
 2438|     93|                member_type,
 2439|     93|                bit_field_size,
 2440|     93|                span: init_declarator.span,
 2441|     93|            });
 2442|       |        }
 2443|       |    }
 2444|     58|    struct_members
 2445|     58|}

/app/src/semantic/symbol_table.rs:
    1|       |//! Symbol table management and scope handling.
    2|       |//!
    3|       |//! This module provides the core data structures and operations for managing
    4|       |//! symbols and scopes during semantic analysis. It maintains a hierarchical
    5|       |//! scope structure and provides efficient symbol lookup and storage.
    6|       |
    7|       |use hashbrown::HashMap;
    8|       |use std::num::NonZeroU32;
    9|       |
   10|       |use log::debug;
   11|       |use thiserror::Error;
   12|       |
   13|       |use crate::{
   14|       |    ast::*,
   15|       |    semantic::{QualType, StructMember, TypeRef},
   16|       |};
   17|       |
   18|       |pub type SymbolRef = NonZeroU32;
   19|       |
   20|       |/// Represents the definition state of a symbol entry.
   21|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   22|       |pub enum DefinitionState {
   23|       |    Tentative,    // int x;
   24|       |    Defined,      // int x = ...;
   25|       |    DeclaredOnly, // extern int x;
   26|       |}
   27|       |
   28|       |/// Represents a resolved symbol entry from the symbol table.
   29|       |/// This structure is typically populated during the semantic analysis phase.
   30|       |/// Symbol are stored in a separate Vec<Symbol> with SymbolRef references.
   31|       |/// invariant:
   32|       |/// - Variable / Typedef / Function: type_info is meaningful
   33|       |/// - EnumConstant: type_info = int (unqualified)
   34|       |/// - Label / RecordTag / EnumTag: type_info = TypeKind::Error
   35|       |#[derive(Debug, Clone)]
   36|       |pub struct Symbol {
   37|       |    pub name: NameId,
   38|       |    pub kind: SymbolKind, // e.g., Variable, Function, Typedef
   39|       |    pub type_info: QualType,
   40|       |    pub scope_id: ScopeId, // Reference to the scope where it's defined
   41|       |    pub def_span: SourceSpan,
   42|       |    pub def_state: DefinitionState,
   43|       |    pub is_completed: bool,
   44|       |}
   45|       |
   46|       |impl Symbol {
   47|      0|    pub fn is_const(&self) -> bool {
   48|      0|        self.type_info.is_const()
   49|      0|    }
   50|       |
   51|      0|    pub fn ty(&self) -> TypeRef {
   52|      0|        self.type_info.ty()
   53|      0|    }
   54|       |
   55|      0|    pub fn has_linkage(&self) -> bool {
   56|      0|        match &self.kind {
   57|      0|            SymbolKind::Function { .. } => true,
   58|      0|            SymbolKind::Variable { is_global, storage, .. } => *is_global || *storage == Some(StorageClass::Extern),
   59|      0|            _ => false,
   60|       |        }
   61|      0|    }
   62|       |}
   63|       |
   64|       |/// Defines the kind of symbol.
   65|       |#[derive(Debug, Clone)]
   66|       |pub enum SymbolKind {
   67|       |    Variable {
   68|       |        is_global: bool,
   69|       |        storage: Option<StorageClass>,
   70|       |        // Initializer might be an AST node or a constant value
   71|       |        initializer: Option<NodeRef>,
   72|       |        alignment: Option<u32>, // Max alignment in bytes
   73|       |    },
   74|       |    Function {
   75|       |        storage: Option<StorageClass>,
   76|       |    },
   77|       |    Typedef {
   78|       |        aliased_type: QualType,
   79|       |    },
   80|       |    EnumConstant {
   81|       |        value: i64, // Resolved constant value
   82|       |    },
   83|       |    Label,
   84|       |    Record {
   85|       |        is_complete: bool,
   86|       |        members: Vec<StructMember>,
   87|       |    },
   88|       |    EnumTag {
   89|       |        is_complete: bool,
   90|       |    },
   91|       |    // Add other symbol kinds as needed (e.g., Macro, BlockScope)
   92|       |}
   93|       |
   94|       |/// Symbol table error types
   95|       |#[derive(Debug, Error)]
   96|       |pub enum SymbolTableError {
   97|       |    #[error("Invalid redefinition: symbol '{name}' cannot be redefined")]
   98|       |    InvalidRedefinition { name: NameId, existing: SymbolRef },
   99|       |}
  100|       |
  101|       |use serde::Serialize;
  102|       |
  103|       |/// Scope ID for efficient scope references
  104|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize)]
  105|       |pub struct ScopeId(NonZeroU32);
  106|       |
  107|       |impl ScopeId {
  108|       |    pub const GLOBAL: Self = Self(NonZeroU32::new(1).unwrap());
  109|       |
  110|    402|    pub(crate) fn new(id: u32) -> Option<Self> {
  111|    402|        NonZeroU32::new(id).map(Self)
  112|    402|    }
  113|       |
  114|  3.54k|    pub(crate) fn get(self) -> u32 {
  115|  3.54k|        self.0.get()
  116|  3.54k|    }
  117|       |}
  118|       |
  119|       |/// Symbol namespaces in C
  120|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
  121|       |pub enum Namespace {
  122|       |    Ordinary, // Variables, functions, typedefs, enum constants
  123|       |    Tag,      // Struct, union, and enum tags
  124|       |    Label,    // Goto labels
  125|       |}
  126|       |
  127|       |/// Scope information
  128|       |#[derive(Debug)]
  129|       |pub struct Scope {
  130|       |    pub parent: Option<ScopeId>,
  131|       |    pub symbols: HashMap<NameId, SymbolRef>, // Ordinary identifiers
  132|       |    pub tags: HashMap<NameId, SymbolRef>,    // Struct/union/enum tags
  133|       |    pub labels: HashMap<NameId, SymbolRef>,  // Goto labels
  134|       |    pub level: u32,
  135|       |}
  136|       |
  137|       |/// Symbol table using flattened storage
  138|       |#[derive(Debug)]
  139|       |pub struct SymbolTable {
  140|       |    pub entries: Vec<Symbol>,
  141|       |    pub scopes: Vec<Scope>,
  142|       |    current_scope_id: ScopeId,
  143|       |    next_scope_id: u32,
  144|       |}
  145|       |
  146|       |impl Default for SymbolTable {
  147|      0|    fn default() -> Self {
  148|      0|        Self::new()
  149|      0|    }
  150|       |}
  151|       |
  152|       |impl SymbolTable {
  153|    205|    pub(crate) fn new() -> Self {
  154|    205|        let mut table = SymbolTable {
  155|    205|            entries: Vec::new(),
  156|    205|            scopes: Vec::new(),
  157|    205|            current_scope_id: ScopeId::GLOBAL,
  158|    205|            next_scope_id: 2, // Start after GLOBAL
  159|    205|        };
  160|       |
  161|       |        // Initialize global scope
  162|    205|        table.scopes.push(Scope {
  163|    205|            parent: None,
  164|    205|            symbols: HashMap::new(),
  165|    205|            tags: HashMap::new(),
  166|    205|            labels: HashMap::new(),
  167|    205|            level: 0,
  168|    205|        });
  169|       |
  170|    205|        table
  171|    205|    }
  172|       |
  173|    402|    pub(crate) fn push_scope(&mut self) -> ScopeId {
  174|    402|        let new_scope_id = ScopeId::new(self.next_scope_id).unwrap();
  175|    402|        self.next_scope_id += 1;
  176|       |
  177|    402|        let new_scope = Scope {
  178|    402|            parent: Some(self.current_scope_id),
  179|    402|            symbols: HashMap::new(),
  180|    402|            tags: HashMap::new(),
  181|    402|            labels: HashMap::new(),
  182|    402|            level: self.scopes[self.current_scope_id.get() as usize - 1].level + 1,
  183|    402|        };
  184|       |
  185|    402|        self.scopes.push(new_scope);
  186|    402|        self.current_scope_id = new_scope_id;
  187|    402|        debug!(
  188|      0|            "SymbolTable: Pushed new scope. New current_scope_id: {}",
  189|      0|            self.current_scope_id.get()
  190|       |        );
  191|    402|        new_scope_id
  192|    402|    }
  193|       |
  194|    402|    pub(crate) fn pop_scope(&mut self) -> Option<ScopeId> {
  195|    402|        let current_scope_id_before_pop = self.current_scope_id;
  196|    402|        let current_scope = &self.scopes[current_scope_id_before_pop.get() as usize - 1];
  197|    402|        if let Some(parent) = current_scope.parent {
  198|    402|            self.current_scope_id = parent;
  199|    402|            debug!(
  200|      0|                "SymbolTable: Popped scope. Old current_scope_id: {}, New current_scope_id: {}",
  201|      0|                current_scope_id_before_pop.get(),
  202|      0|                self.current_scope_id.get()
  203|       |            );
  204|    402|            Some(parent)
  205|       |        } else {
  206|      0|            debug!("SymbolTable: Attempted to pop global scope. No change.");
  207|      0|            None
  208|       |        }
  209|    402|    }
  210|       |
  211|  2.90k|    pub(crate) fn current_scope(&self) -> ScopeId {
  212|  2.90k|        self.current_scope_id
  213|  2.90k|    }
  214|       |
  215|    205|    pub(crate) fn set_current_scope(&mut self, scope_id: ScopeId) {
  216|    205|        self.current_scope_id = scope_id;
  217|    205|        debug!("SymbolTable: Set current_scope_id to {}", self.current_scope_id.get());
                             ^0                                         ^0                    ^0
  218|    205|    }
  219|       |
  220|  2.20k|    pub(crate) fn get_scope(&self, scope_id: ScopeId) -> &Scope {
  221|  2.20k|        &self.scopes[scope_id.get() as usize - 1]
  222|  2.20k|    }
  223|       |
  224|    542|    pub(crate) fn get_scope_mut(&mut self, scope_id: ScopeId) -> &mut Scope {
  225|    542|        &mut self.scopes[scope_id.get() as usize - 1]
  226|    542|    }
  227|       |
  228|    472|    pub(crate) fn add_symbol(&mut self, name: NameId, entry: Symbol) -> SymbolRef {
  229|    472|        let entry_ref = self.push_symbol(entry);
  230|    472|        let current_scope = self.get_scope_mut(self.current_scope_id);
  231|    472|        current_scope.symbols.insert(name, entry_ref);
  232|    472|        entry_ref
  233|    472|    }
  234|       |
  235|     70|    pub(crate) fn add_symbol_in_namespace(&mut self, name: NameId, entry: Symbol, ns: Namespace) -> SymbolRef {
  236|     70|        let entry_ref = self.push_symbol(entry);
  237|     70|        let current_scope = self.get_scope_mut(self.current_scope_id);
  238|     70|        match ns {
  239|      0|            Namespace::Ordinary => current_scope.symbols.insert(name, entry_ref),
  240|     58|            Namespace::Tag => current_scope.tags.insert(name, entry_ref),
  241|     12|            Namespace::Label => current_scope.labels.insert(name, entry_ref),
  242|       |        };
  243|     70|        entry_ref
  244|     70|    }
  245|       |
  246|    944|    pub(crate) fn lookup_symbol(&self, name: NameId) -> Option<(SymbolRef, ScopeId)> {
  247|    944|        self.lookup(name, self.current_scope_id, Namespace::Ordinary)
  248|    944|    }
  249|       |
  250|    152|    pub(crate) fn lookup_tag(&self, name: NameId) -> Option<(SymbolRef, ScopeId)> {
  251|    152|        self.lookup(name, self.current_scope_id, Namespace::Tag)
  252|    152|    }
  253|       |
  254|  1.22k|    pub(crate) fn lookup(&self, name: NameId, start_scope: ScopeId, ns: Namespace) -> Option<(SymbolRef, ScopeId)> {
  255|  1.22k|        let mut scope_id = start_scope;
  256|       |        loop {
  257|  1.80k|            let scope = self.get_scope(scope_id);
  258|  1.80k|            let result = match ns {
  259|  1.56k|                Namespace::Ordinary => scope.symbols.get(&name),
  260|    229|                Namespace::Tag => scope.tags.get(&name),
  261|      5|                Namespace::Label => scope.labels.get(&name),
  262|       |            };
  263|  1.80k|            if let Some(&entry_ref) = result {
                                       ^740
  264|    740|                return Some((entry_ref, scope_id));
  265|  1.06k|            }
  266|  1.06k|            if let Some(parent) = scope.parent {
                                      ^575
  267|    575|                scope_id = parent;
  268|    575|            } else {
  269|    487|                break;
  270|       |            }
  271|       |        }
  272|    487|        None
  273|  1.22k|    }
  274|       |
  275|       |    /// find a symbol in exact scope without looking to parent scope if not exist
  276|    309|    pub(crate) fn fetch(&self, name: NameId, scope_id: ScopeId, ns: Namespace) -> Option<SymbolRef> {
  277|    309|        let scope = self.get_scope(scope_id);
  278|    309|        match ns {
  279|    309|            Namespace::Ordinary => scope.symbols.get(&name).copied(),
  280|      0|            Namespace::Tag => scope.tags.get(&name).copied(),
  281|      0|            Namespace::Label => scope.labels.get(&name).copied(),
  282|       |        }
  283|    309|    }
  284|       |
  285|    542|    fn push_symbol(&mut self, entry: Symbol) -> SymbolRef {
  286|    542|        let index = self.entries.len() as u32 + 1;
  287|    542|        self.entries.push(entry);
  288|    542|        SymbolRef::new(index).expect("SymbolEntryRef overflow")
  289|    542|    }
  290|       |
  291|  1.66k|    pub(crate) fn get_symbol(&self, index: SymbolRef) -> &Symbol {
  292|  1.66k|        &self.entries[(index.get() - 1) as usize]
  293|  1.66k|    }
  294|       |
  295|     68|    pub(crate) fn get_symbol_mut(&mut self, index: SymbolRef) -> &mut Symbol {
  296|     68|        &mut self.entries[(index.get() - 1) as usize]
  297|     68|    }
  298|       |
  299|       |    /// Define a new variable in the current scope.
  300|       |    /// Handles global variable merging and local variable insertion.
  301|    244|    pub(crate) fn define_variable(
  302|    244|        &mut self,
  303|    244|        name: NameId,
  304|    244|        ty: QualType,
  305|    244|        storage: Option<StorageClass>,
  306|    244|        initializer: Option<NodeRef>,
  307|    244|        alignment: Option<u32>,
  308|    244|        span: SourceSpan,
  309|    244|    ) -> Result<SymbolRef, SymbolTableError> {
  310|    244|        let is_global = self.current_scope_id == ScopeId::GLOBAL;
  311|       |
  312|    244|        let def_state = if initializer.is_some() {
  313|    132|            DefinitionState::Defined
  314|    112|        } else if storage == Some(StorageClass::Extern) {
  315|      2|            DefinitionState::DeclaredOnly
  316|       |        } else {
  317|    110|            DefinitionState::Tentative
  318|       |        };
  319|       |
  320|    244|        let symbol_entry = Symbol {
  321|    244|            name,
  322|    244|            kind: SymbolKind::Variable {
  323|    244|                is_global,
  324|    244|                storage,
  325|    244|                initializer,
  326|    244|                alignment,
  327|    244|            },
  328|    244|            type_info: ty,
  329|    244|            scope_id: self.current_scope_id,
  330|    244|            def_span: span,
  331|    244|            def_state,
  332|    244|            is_completed: true,
  333|    244|        };
  334|       |
  335|    244|        if is_global {
  336|     62|            self.merge_global_symbol(name, symbol_entry)
  337|       |        } else {
  338|    182|            Ok(self.add_symbol(name, symbol_entry))
  339|       |        }
  340|    244|    }
  341|       |
  342|       |    /// Define a new function in the current scope.
  343|       |    /// Handles global function merging (declarations/definitions).
  344|    219|    pub(crate) fn define_function(
  345|    219|        &mut self,
  346|    219|        name: NameId,
  347|    219|        ty: TypeRef,
  348|    219|        storage: Option<StorageClass>,
  349|    219|        is_definition: bool,
  350|    219|        span: SourceSpan,
  351|    219|    ) -> Result<SymbolRef, SymbolTableError> {
  352|       |        // Function declarations are "DeclaredOnly" by default, or "Defined" if it's a function definition
  353|    219|        let def_state = if is_definition {
  354|    196|            DefinitionState::Defined
  355|       |        } else {
  356|     23|            DefinitionState::DeclaredOnly
  357|       |        };
  358|       |
  359|    219|        let symbol_entry = Symbol {
  360|    219|            name,
  361|    219|            kind: SymbolKind::Function { storage },
  362|    219|            type_info: QualType::unqualified(ty),
  363|    219|            scope_id: self.current_scope_id,
  364|    219|            def_span: span,
  365|    219|            def_state,
  366|    219|            is_completed: true,
  367|    219|        };
  368|       |
  369|    219|        if self.current_scope_id == ScopeId::GLOBAL {
  370|    219|            self.merge_global_symbol(name, symbol_entry)
  371|       |        } else {
  372|      0|            Ok(self.add_symbol(name, symbol_entry))
  373|       |        }
  374|    219|    }
  375|       |
  376|       |    /// Define a typedef in the current scope.
  377|     12|    pub(crate) fn define_typedef(
  378|     12|        &mut self,
  379|     12|        name: NameId,
  380|     12|        ty: QualType,
  381|     12|        span: SourceSpan,
  382|     12|    ) -> Result<SymbolRef, SymbolTableError> {
  383|     12|        let symbol_entry = Symbol {
  384|     12|            name,
  385|     12|            kind: SymbolKind::Typedef { aliased_type: ty },
  386|     12|            type_info: ty,
  387|     12|            scope_id: self.current_scope_id,
  388|     12|            def_span: span,
  389|     12|            def_state: DefinitionState::Defined,
  390|     12|            is_completed: true,
  391|     12|        };
  392|       |
  393|       |        // Check for redefinition in the SAME scope
  394|     12|        if let Some(existing_ref) = self.fetch(name, self.current_scope_id, Namespace::Ordinary) {
                                  ^2
  395|      2|            return Err(SymbolTableError::InvalidRedefinition {
  396|      2|                name,
  397|      2|                existing: existing_ref,
  398|      2|            });
  399|     10|        }
  400|       |
  401|     10|        Ok(self.add_symbol(name, symbol_entry))
  402|     12|    }
  403|       |
  404|       |    /// Define an enum constant in the current scope.
  405|     16|    pub(crate) fn define_enum_constant(
  406|     16|        &mut self,
  407|     16|        name: NameId,
  408|     16|        value: i64,
  409|     16|        ty: TypeRef,
  410|     16|        span: SourceSpan,
  411|     16|    ) -> Result<SymbolRef, SymbolTableError> {
  412|     16|        let symbol_entry = Symbol {
  413|     16|            name,
  414|     16|            kind: SymbolKind::EnumConstant { value },
  415|     16|            type_info: QualType::unqualified(ty),
  416|     16|            scope_id: self.current_scope_id,
  417|     16|            def_span: span,
  418|     16|            def_state: DefinitionState::Defined,
  419|     16|            is_completed: true,
  420|     16|        };
  421|       |
  422|     16|        if let Some(existing_ref) = self.fetch(name, self.current_scope_id, Namespace::Ordinary) {
                                  ^1
  423|      1|            return Err(SymbolTableError::InvalidRedefinition {
  424|      1|                name,
  425|      1|                existing: existing_ref,
  426|      1|            });
  427|     15|        }
  428|       |
  429|     15|        Ok(self.add_symbol(name, symbol_entry))
  430|     16|    }
  431|       |
  432|       |    /// Define a record (struct/union) tag in the current scope.
  433|     50|    pub(crate) fn define_record(
  434|     50|        &mut self,
  435|     50|        name: NameId,
  436|     50|        ty: TypeRef,
  437|     50|        is_complete: bool,
  438|     50|        span: SourceSpan,
  439|     50|    ) -> SymbolRef {
  440|     50|        let symbol_entry = Symbol {
  441|     50|            name,
  442|     50|            kind: SymbolKind::Record {
  443|     50|                is_complete,
  444|     50|                members: Vec::new(),
  445|     50|            },
  446|     50|            type_info: QualType::unqualified(ty),
  447|     50|            scope_id: self.current_scope_id,
  448|     50|            def_span: span,
  449|     50|            def_state: DefinitionState::Defined,
  450|     50|            is_completed: false,
  451|     50|        };
  452|     50|        self.add_symbol_in_namespace(name, symbol_entry, Namespace::Tag)
  453|     50|    }
  454|       |
  455|       |    /// Define an enum tag in the current scope.
  456|      8|    pub(crate) fn define_enum(&mut self, name: NameId, ty: TypeRef, span: SourceSpan) -> SymbolRef {
  457|      8|        let symbol_entry = Symbol {
  458|      8|            name,
  459|      8|            kind: SymbolKind::EnumTag { is_complete: false },
  460|      8|            type_info: QualType::unqualified(ty),
  461|      8|            scope_id: self.current_scope_id,
  462|      8|            def_span: span,
  463|      8|            def_state: DefinitionState::Defined,
  464|      8|            is_completed: false,
  465|      8|        };
  466|      8|        self.add_symbol_in_namespace(name, symbol_entry, Namespace::Tag)
  467|      8|    }
  468|       |
  469|       |    /// Define a label in the current scope.
  470|     12|    pub(crate) fn define_label(
  471|     12|        &mut self,
  472|     12|        name: NameId,
  473|     12|        ty: TypeRef,
  474|     12|        span: SourceSpan,
  475|     12|    ) -> Result<SymbolRef, SymbolTableError> {
  476|     12|        let symbol_entry = Symbol {
  477|     12|            name,
  478|     12|            kind: SymbolKind::Label,
  479|     12|            type_info: QualType::unqualified(ty),
  480|     12|            scope_id: self.current_scope_id,
  481|     12|            def_span: span,
  482|     12|            def_state: DefinitionState::Defined,
  483|     12|            is_completed: true,
  484|     12|        };
  485|     12|        Ok(self.add_symbol_in_namespace(name, symbol_entry, Namespace::Label))
  486|     12|    }
  487|       |
  488|       |    /// Lookup a label in the current scope.
  489|      3|    pub(crate) fn lookup_label(&self, name: NameId) -> Option<(SymbolRef, ScopeId)> {
  490|      3|        self.lookup(name, self.current_scope_id, Namespace::Label)
  491|      3|    }
  492|       |
  493|       |    /// Merge a new symbol entry with an existing one in the global scope.
  494|       |    /// This implements C11 6.9.2 for handling tentative definitions, extern declarations, and actual definitions.
  495|    281|    fn merge_global_symbol(&mut self, name: NameId, mut new_entry: Symbol) -> Result<SymbolRef, SymbolTableError> {
  496|    281|        let global_scope = ScopeId::GLOBAL;
  497|       |
  498|       |        // Check if symbol already exists in global scope
  499|    281|        if let Some(existing_ref) = self.fetch(name, global_scope, Namespace::Ordinary) {
                                  ^16
  500|     16|            let existing = self.get_symbol_mut(existing_ref);
  501|       |
  502|       |            // Verify kinds match
  503|     16|            match (&existing.kind, &new_entry.kind) {
  504|      5|                (SymbolKind::Variable { .. }, SymbolKind::Variable { .. }) => {}
  505|     10|                (SymbolKind::Function { .. }, SymbolKind::Function { .. }) => {}
  506|       |                _ => {
  507|       |                    // Mismatched kinds
  508|      1|                    debug!("Symbol '{}' redefinition: different kinds", name);
                                         ^0
  509|      1|                    return Err(SymbolTableError::InvalidRedefinition {
  510|      1|                        name,
  511|      1|                        existing: existing_ref,
  512|      1|                    });
  513|       |                }
  514|       |            }
  515|       |
  516|       |            // Check alignment compatibility (Variables only)
  517|       |            if let SymbolKind::Variable {
  518|      5|                alignment: new_align, ..
  519|     15|            } = &new_entry.kind
  520|       |                && let SymbolKind::Variable {
  521|      5|                    alignment: existing_align,
  522|       |                    ..
  523|      5|                } = &existing.kind
  524|       |            {
  525|      5|                match (existing_align, new_align) {
  526|      0|                    (Some(a), Some(b)) if a != b => {
  527|      0|                        return Err(SymbolTableError::InvalidRedefinition {
  528|      0|                            name,
  529|      0|                            existing: existing_ref,
  530|      0|                        });
  531|       |                    }
  532|      0|                    (None, Some(b)) => {
  533|       |                        // Inherit alignment from new declaration
  534|      0|                        if let SymbolKind::Variable { alignment, .. } = &mut existing.kind {
  535|      0|                            *alignment = Some(*b);
  536|      0|                        }
  537|       |                    }
  538|      5|                    _ => {}
  539|       |                }
  540|     10|            }
  541|       |
  542|       |            // Apply C11 merging rules
  543|     15|            match (existing.def_state, new_entry.def_state) {
  544|       |                (DefinitionState::Defined, DefinitionState::Defined) => {
  545|       |                    // Multiple actual definitions - error
  546|      2|                    debug!("Multiple definitions of '{}'", name);
                                         ^0
  547|      2|                    return Err(SymbolTableError::InvalidRedefinition {
  548|      2|                        name,
  549|      2|                        existing: existing_ref,
  550|      2|                    });
  551|       |                }
  552|       |
  553|       |                (DefinitionState::Defined, _) => {
  554|       |                    // Already defined, ignore new declaration/tentative definition
  555|      1|                    debug!("Ignoring redundant declaration for already-defined '{}'", name);
                                         ^0
  556|       |                }
  557|       |
  558|       |                (_, DefinitionState::Defined) => {
  559|       |                    // Upgrade to defined
  560|      4|                    debug!("Upgrading to defined for '{}'", name);
                                         ^0
  561|      4|                    existing.def_state = DefinitionState::Defined;
  562|      4|                    if let SymbolKind::Variable { initializer, .. } = &mut new_entry.kind
                                                                ^1
  563|       |                        && let SymbolKind::Variable {
  564|      1|                            initializer: existing_init,
  565|       |                            ..
  566|      1|                        } = &mut existing.kind
  567|      1|                    {
  568|      1|                        *existing_init = *initializer;
  569|      3|                    }
  570|       |                }
  571|       |
  572|       |                (DefinitionState::Tentative, DefinitionState::Tentative)
  573|       |                | (DefinitionState::Tentative, DefinitionState::DeclaredOnly)
  574|       |                | (DefinitionState::DeclaredOnly, DefinitionState::DeclaredOnly) => {
  575|       |                    // No change to def_state
  576|      8|                    debug!("Merging similar or weaker definition for '{}'", name);
                                         ^0
  577|       |                }
  578|       |
  579|       |                (DefinitionState::DeclaredOnly, DefinitionState::Tentative) => {
  580|       |                    // Upgrade to tentative
  581|      0|                    debug!("Upgrading extern declaration to tentative for '{}'", name);
  582|      0|                    existing.def_state = DefinitionState::Tentative;
  583|       |                }
  584|       |            }
  585|       |
  586|     13|            Ok(existing_ref)
  587|       |        } else {
  588|       |            // Symbol doesn't exist, add it
  589|    265|            debug!(
  590|      0|                "Adding new global symbol '{}' with def_state {:?}",
  591|       |                name, new_entry.def_state
  592|       |            );
  593|    265|            Ok(self.add_symbol(name, new_entry))
  594|       |        }
  595|    281|    }
  596|       |}

/app/src/semantic/type_registry.rs:
    1|       |//! Type Registry
    2|       |//!
    3|       |//! Arena + canonicalization layer for semantic types.
    4|       |//! All TypeRef creation and mutation MUST go through this context.
    5|       |
    6|       |use std::borrow::Cow;
    7|       |
    8|       |use crate::source_manager::SourceSpan;
    9|       |use crate::{ast::NameId, diagnostic::SemanticError, semantic::QualType};
   10|       |use hashbrown::{HashMap, HashSet};
   11|       |use target_lexicon::{PointerWidth, Triple};
   12|       |
   13|       |use super::types::TypeClass;
   14|       |use super::types::{FieldLayout, LayoutKind};
   15|       |use super::{
   16|       |    ArraySizeType, BuiltinType, EnumConstant, FunctionParameter, StructMember, Type, TypeKind, TypeLayout,
   17|       |    TypeQualifiers, TypeRef,
   18|       |};
   19|       |
   20|       |/// Central arena & factory for semantic types.
   21|       |///
   22|       |/// Invariants:
   23|       |/// - All TypeRef come from this context
   24|       |/// - Types are never removed
   25|       |/// - Canonical types are reused when possible
   26|       |pub struct TypeRegistry {
   27|       |    pub target_triple: Triple,
   28|       |
   29|       |    // Index 0 is dummy.
   30|       |    // Index 1..16 are builtins.
   31|       |    // Index 17+ are allocated types.
   32|       |    pub types: Vec<Type>,
   33|       |
   34|       |    // --- Canonicalization caches ---
   35|       |    pointer_cache: HashMap<QualType, TypeRef>,
   36|       |    array_cache: HashMap<(TypeRef, ArraySizeType), TypeRef>,
   37|       |    function_cache: HashMap<FnSigKey, TypeRef>,
   38|       |    complex_cache: HashMap<TypeRef, TypeRef>,
   39|       |
   40|       |    // --- Layout computation tracking ---
   41|       |    layout_in_progress: HashSet<TypeRef>,
   42|       |
   43|       |    // --- Common builtin types ---
   44|       |    pub type_void: TypeRef,
   45|       |    pub type_bool: TypeRef,
   46|       |    pub type_short: TypeRef,
   47|       |    pub type_short_unsigned: TypeRef,
   48|       |    pub type_int: TypeRef,
   49|       |    pub type_int_unsigned: TypeRef,
   50|       |    pub type_long: TypeRef,
   51|       |    pub type_long_unsigned: TypeRef,
   52|       |    pub type_long_long: TypeRef,
   53|       |    pub type_long_long_unsigned: TypeRef,
   54|       |    pub type_char: TypeRef,
   55|       |    pub type_schar: TypeRef,
   56|       |    pub type_char_unsigned: TypeRef,
   57|       |    pub type_float: TypeRef,
   58|       |    pub type_double: TypeRef,
   59|       |    pub type_long_double: TypeRef,
   60|       |    pub type_void_ptr: TypeRef,
   61|       |    pub type_signed: TypeRef,
   62|       |    pub type_error: TypeRef,
   63|       |}
   64|       |
   65|       |impl Default for TypeRegistry {
   66|      0|    fn default() -> Self {
   67|      0|        Self::new(Triple::host())
   68|      0|    }
   69|       |}
   70|       |
   71|       |impl TypeRegistry {
   72|       |    /// Create a new TypeRegistry with builtin types initialized.
   73|    209|    pub(crate) fn new(target_triple: Triple) -> Self {
   74|    209|        let mut reg = TypeRegistry {
   75|    209|            target_triple,
   76|    209|            types: Vec::new(),
   77|    209|            pointer_cache: HashMap::new(),
   78|    209|            array_cache: HashMap::new(),
   79|    209|            function_cache: HashMap::new(),
   80|    209|            complex_cache: HashMap::new(),
   81|    209|            layout_in_progress: HashSet::new(),
   82|    209|
   83|    209|            // temporary placeholders - will be overwritten by create_builtin
   84|    209|            type_void: unsafe { TypeRef::from_raw_unchecked(1) },
   85|    209|            type_bool: unsafe { TypeRef::from_raw_unchecked(1) },
   86|    209|            type_int: unsafe { TypeRef::from_raw_unchecked(1) },
   87|    209|            type_int_unsigned: unsafe { TypeRef::from_raw_unchecked(1) },
   88|    209|            type_short: unsafe { TypeRef::from_raw_unchecked(1) },
   89|    209|            type_long: unsafe { TypeRef::from_raw_unchecked(1) },
   90|    209|            type_long_long: unsafe { TypeRef::from_raw_unchecked(1) },
   91|    209|            type_char: unsafe { TypeRef::from_raw_unchecked(1) },
   92|    209|            type_schar: unsafe { TypeRef::from_raw_unchecked(1) },
   93|    209|            type_short_unsigned: unsafe { TypeRef::from_raw_unchecked(1) },
   94|    209|            type_char_unsigned: unsafe { TypeRef::from_raw_unchecked(1) },
   95|    209|            type_long_unsigned: unsafe { TypeRef::from_raw_unchecked(1) },
   96|    209|            type_long_long_unsigned: unsafe { TypeRef::from_raw_unchecked(1) },
   97|    209|            type_float: unsafe { TypeRef::from_raw_unchecked(1) },
   98|    209|            type_double: unsafe { TypeRef::from_raw_unchecked(1) },
   99|    209|            type_long_double: unsafe { TypeRef::from_raw_unchecked(1) },
  100|    209|            type_void_ptr: unsafe { TypeRef::from_raw_unchecked(1) },
  101|    209|            type_signed: unsafe { TypeRef::from_raw_unchecked(1) },
  102|    209|            type_error: unsafe { TypeRef::from_raw_unchecked(1) },
  103|    209|        };
  104|       |
  105|       |        // Initialize dummy at index 0
  106|    209|        reg.types.push(Type::new(TypeKind::Error));
  107|       |
  108|    209|        reg.create_builtin();
  109|    209|        reg
  110|    209|    }
  111|       |
  112|    209|    fn create_builtin(&mut self) {
  113|       |        // Reset types to just dummy to ensure order
  114|    209|        self.types.truncate(1);
  115|       |
  116|       |        // Must match BuiltinType enum values 1..16 sequentially
  117|       |
  118|       |        // 1: Void
  119|    209|        self.type_void = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Void));
  120|       |
  121|       |        // 2: Bool
  122|    209|        self.type_bool = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Bool));
  123|       |
  124|       |        // 3: Char (signed)
  125|    209|        self.type_char = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Char));
  126|       |
  127|       |        // 4: SChar (explicit signed char)
  128|    209|        self.type_schar = self.alloc_builtin(TypeKind::Builtin(BuiltinType::SChar));
  129|       |
  130|       |        // 5: UChar
  131|    209|        self.type_char_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::UChar));
  132|       |
  133|       |        // 6: Short
  134|    209|        self.type_short = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Short));
  135|       |
  136|       |        // 7: UShort
  137|    209|        self.type_short_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::UShort));
  138|       |
  139|       |        // 8: Int
  140|    209|        self.type_int = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Int));
  141|       |
  142|       |        // 9: UInt
  143|    209|        self.type_int_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::UInt));
  144|       |
  145|       |        // 10: Long
  146|    209|        self.type_long = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Long));
  147|       |
  148|       |        // 11: ULong
  149|    209|        self.type_long_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::ULong));
  150|       |
  151|       |        // 12: LongLong
  152|    209|        self.type_long_long = self.alloc_builtin(TypeKind::Builtin(BuiltinType::LongLong));
  153|       |
  154|       |        // 13: ULongLong
  155|    209|        self.type_long_long_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::ULongLong));
  156|       |
  157|       |        // 14: Float
  158|    209|        self.type_float = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Float));
  159|       |
  160|       |        // 15: Double
  161|    209|        self.type_double = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Double));
  162|       |
  163|       |        // 16: LongDouble
  164|    209|        self.type_long_double = self.alloc_builtin(TypeKind::Builtin(BuiltinType::LongDouble));
  165|       |
  166|       |        // 17: Signed (marker)
  167|    209|        self.type_signed = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Signed));
  168|       |
  169|       |        // Pre-calculate void*
  170|    209|        self.type_void_ptr = self.pointer_to(QualType::unqualified(self.type_void));
  171|       |
  172|       |        // We can assert that the last allocated index was 17
  173|    209|        debug_assert_eq!(self.types.len() - 1, 17, "Builtin types allocation mismatch");
                                                                 ^0
  174|    209|    }
  175|       |
  176|  3.55k|    fn alloc_builtin(&mut self, kind: TypeKind) -> TypeRef {
  177|  3.55k|        let ty = Type::new(kind);
  178|  3.55k|        self.alloc(ty)
  179|  3.55k|    }
  180|       |
  181|       |    /// Allocate a new canonical type and return its TypeRef.
  182|  3.86k|    fn alloc(&mut self, ty: Type) -> TypeRef {
  183|  3.86k|        let idx = self.types.len() as u32;
  184|  3.86k|        self.types.push(ty);
  185|  3.86k|        let kind_ref = &self.types[idx as usize].kind;
  186|  3.86k|        let class = kind_ref.to_class();
  187|       |
  188|  3.86k|        TypeRef::new(idx, class, 0, 0).expect("TypeRef alloc failed")
  189|  3.86k|    }
  190|       |
  191|       |    /// Resolve a TypeRef to a Type.
  192|       |    /// Returns Cow because inline types are constructed on the fly.
  193|       |    #[inline]
  194|  1.93k|    pub(crate) fn get(&self, r: TypeRef) -> Cow<'_, Type> {
  195|  1.93k|        if r.is_inline_pointer() {
  196|       |            // Reconstruct Pointer Type
  197|       |            // We need to know the TypeRef of the pointee.
  198|     97|            let pointee = self.reconstruct_pointee(r);
  199|       |
  200|       |            // Pointer layout is always fixed
  201|     97|            let layout = TypeLayout {
  202|     97|                size: 8,
  203|     97|                alignment: 8,
  204|     97|                kind: LayoutKind::Scalar,
  205|     97|            };
  206|       |
  207|     97|            Cow::Owned(Type {
  208|     97|                kind: TypeKind::Pointer {
  209|     97|                    pointee: QualType::unqualified(pointee),
  210|     97|                },
  211|     97|                layout: Some(layout),
  212|     97|            })
  213|  1.83k|        } else if r.is_inline_array() {
  214|       |            // Reconstruct Array Type
  215|    115|            let element = self.reconstruct_element(r);
  216|    115|            let len = r.array_len().unwrap() as u64;
  217|       |
  218|    115|            Cow::Owned(Type {
  219|    115|                kind: TypeKind::Array {
  220|    115|                    element_type: element,
  221|    115|                    size: ArraySizeType::Constant(len as usize),
  222|    115|                },
  223|    115|                layout: None,
  224|    115|            })
  225|       |        } else {
  226|       |            // Registry type
  227|  1.72k|            Cow::Borrowed(&self.types[r.index()])
  228|       |        }
  229|  1.93k|    }
  230|       |
  231|       |    /// Helper to get the pointee type if the given type is a pointer.
  232|     92|    pub(crate) fn get_pointee(&self, ty: TypeRef) -> Option<QualType> {
  233|     92|        if ty.is_inline_pointer() {
  234|     84|            Some(QualType::unqualified(self.reconstruct_pointee(ty)))
  235|       |        } else {
  236|      8|            match &self.get(ty).kind {
  237|      8|                TypeKind::Pointer { pointee } => Some(*pointee),
  238|      0|                _ => None,
  239|       |            }
  240|       |        }
  241|     92|    }
  242|       |
  243|       |    // Legacy support: mutable access only for completing records/enums
  244|       |    #[inline]
  245|     66|    fn get_mut(&mut self, r: TypeRef) -> &mut Type {
  246|       |        // Cannot mutate inline types
  247|     66|        if r.is_inline_pointer() || r.is_inline_array() {
  248|      0|            panic!("Cannot get_mut on inline type {:?}", r);
  249|     66|        }
  250|     66|        &mut self.types[r.index()]
  251|     66|    }
  252|       |
  253|    183|    fn reconstruct_pointee(&self, r: TypeRef) -> TypeRef {
  254|    183|        debug_assert!(r.is_inline_pointer());
  255|    183|        let depth = r.pointer_depth();
  256|    183|        if depth > 1 {
  257|       |            // Decrement depth
  258|      1|            TypeRef::new(r.base(), r.class(), depth - 1, 0).unwrap()
  259|       |        } else {
  260|       |            // Depth becomes 0. Class becomes Class of Base.
  261|       |            // Look up base in registry.
  262|    182|            let base_idx = r.base();
  263|    182|            let base_type = &self.types[base_idx as usize];
  264|    182|            let base_class = base_type.kind.to_class();
  265|    182|            TypeRef::new(base_idx, base_class, 0, 0).unwrap()
  266|       |        }
  267|    183|    }
  268|       |
  269|    237|    fn reconstruct_element(&self, r: TypeRef) -> TypeRef {
  270|    237|        debug_assert!(r.is_inline_array());
  271|       |        // Array becomes non-array (arr=0). Class becomes Class of Base.
  272|    237|        let base_idx = r.base();
  273|    237|        let base_type = &self.types[base_idx as usize];
  274|    237|        let base_class = base_type.kind.to_class();
  275|    237|        TypeRef::new(base_idx, base_class, 0, 0).unwrap()
  276|    237|    }
  277|       |
  278|       |    // ============================================================
  279|       |    // Canonical type constructors
  280|       |    // ============================================================
  281|    326|    pub(crate) fn pointer_to(&mut self, base: QualType) -> TypeRef {
  282|       |        // Try inline if unqualified
  283|    326|        if base.qualifiers().is_empty() {
  284|    301|            let base_ty = base.ty();
  285|       |            // 1. If base is Inline Pointer (depth 1..2), we can increment depth (max 3).
  286|    301|            if base_ty.is_inline_pointer() {
  287|      6|                let depth = base_ty.pointer_depth();
  288|      6|                if depth < 3 {
  289|      5|                    return TypeRef::new(base_ty.base(), TypeClass::Pointer, depth + 1, 0).unwrap();
  290|      1|                }
  291|    295|            }
  292|       |
  293|       |            // 2. If base is Simple (Ptr=0, Arr=0), we can make Inline Pointer depth 1.
  294|    296|            if base_ty.pointer_depth() == 0 && base_ty.array_len().is_none() {
                                                             ^295                ^295
  295|    292|                return TypeRef::new(base_ty.base(), TypeClass::Pointer, 1, 0).unwrap();
  296|      4|            }
  297|     25|        }
  298|       |
  299|       |        // Fallback to Registry
  300|     29|        if let Some(&ptr) = self.pointer_cache.get(&base) {
                                   ^11
  301|     11|            return ptr;
  302|     18|        }
  303|       |
  304|     18|        let ptr = self.alloc(Type::new(TypeKind::Pointer { pointee: base }));
  305|     18|        self.pointer_cache.insert(base, ptr);
  306|     18|        ptr
  307|    326|    }
  308|       |
  309|     71|    pub(crate) fn array_of(&mut self, elem: TypeRef, size: ArraySizeType) -> TypeRef {
  310|       |        // Try inline
  311|     71|        if let ArraySizeType::Constant(len) = size
                                                     ^59
  312|     59|            && len <= 31
  313|     58|            && elem.pointer_depth() == 0
  314|     56|            && elem.array_len().is_none()
  315|       |        {
  316|       |            // Check if elem is Simple
  317|     54|            return TypeRef::new(elem.base(), TypeClass::Array, 0, len as u32).unwrap();
  318|     17|        }
  319|       |
  320|     17|        let key = (elem, size.clone());
  321|     17|        if let Some(&arr) = self.array_cache.get(&key) {
                                   ^1
  322|      1|            return arr;
  323|     16|        }
  324|       |
  325|     16|        let arr = self.alloc(Type::new(TypeKind::Array {
  326|     16|            element_type: elem,
  327|     16|            size,
  328|     16|        }));
  329|     16|        self.array_cache.insert(key, arr);
  330|     16|        arr
  331|     71|    }
  332|       |
  333|    222|    pub(crate) fn function_type(
  334|    222|        &mut self,
  335|    222|        return_type: TypeRef,
  336|    222|        params: Vec<FunctionParameter>,
  337|    222|        is_variadic: bool,
  338|    222|        is_noreturn: bool,
  339|    222|    ) -> TypeRef {
  340|    222|        let key = FnSigKey {
  341|    222|            return_type,
  342|    222|            params: params.iter().map(|p| p.param_type).collect(),
  343|    222|            is_variadic,
  344|    222|            is_noreturn,
  345|       |        };
  346|       |
  347|    222|        if let Some(&f) = self.function_cache.get(&key) {
                                   ^13
  348|     13|            return f;
  349|    209|        }
  350|       |
  351|    209|        let f = self.alloc(Type::new(TypeKind::Function {
  352|    209|            return_type,
  353|    209|            parameters: params,
  354|    209|            is_variadic,
  355|    209|            is_noreturn,
  356|    209|        }));
  357|       |
  358|    209|        self.function_cache.insert(key, f);
  359|    209|        f
  360|    222|    }
  361|       |
  362|      0|    pub(crate) fn complex_type(&mut self, base_type: TypeRef) -> TypeRef {
  363|      0|        if let Some(&complex) = self.complex_cache.get(&base_type) {
  364|      0|            return complex;
  365|      0|        }
  366|       |
  367|       |        // Complex is usually stored in registry.
  368|      0|        let complex = self.alloc(Type::new(TypeKind::Complex { base_type }));
  369|      0|        self.complex_cache.insert(base_type, complex);
  370|      0|        complex
  371|      0|    }
  372|       |
  373|       |    // ============================================================
  374|       |    // Record / enum handling
  375|       |    // ============================================================
  376|       |
  377|     62|    pub(crate) fn declare_record(&mut self, tag: Option<NameId>, is_union: bool) -> TypeRef {
  378|     62|        self.alloc(Type::new(TypeKind::Record {
  379|     62|            tag,
  380|     62|            members: Vec::new(),
  381|     62|            is_complete: false,
  382|     62|            is_union,
  383|     62|        }))
  384|     62|    }
  385|       |
  386|     58|    pub(crate) fn complete_record(&mut self, record: TypeRef, members: Vec<StructMember>) {
  387|     58|        let ty = self.get_mut(record);
  388|     58|        match &mut ty.kind {
  389|       |            TypeKind::Record {
  390|     58|                is_complete,
  391|     58|                members: slot,
  392|       |                ..
  393|     58|            } => {
  394|     58|                *slot = members;
  395|     58|                *is_complete = true;
  396|     58|            }
  397|      0|            _ => unreachable!("complete_record on non-record"),
  398|       |        }
  399|     58|    }
  400|       |
  401|      8|    pub(crate) fn declare_enum(&mut self, tag: Option<NameId>, base_type: TypeRef) -> TypeRef {
  402|      8|        self.alloc(Type::new(TypeKind::Enum {
  403|      8|            tag,
  404|      8|            base_type,
  405|      8|            enumerators: Vec::new(),
  406|      8|            is_complete: false,
  407|      8|        }))
  408|      8|    }
  409|       |
  410|      8|    pub(crate) fn complete_enum(&mut self, enum_ty: TypeRef, enumerators: Vec<EnumConstant>) {
  411|      8|        let ty = self.get_mut(enum_ty);
  412|      8|        match &mut ty.kind {
  413|       |            TypeKind::Enum {
  414|      8|                is_complete,
  415|      8|                enumerators: slot,
  416|       |                ..
  417|      8|            } => {
  418|      8|                *slot = enumerators;
  419|      8|                *is_complete = true;
  420|      8|            }
  421|      0|            _ => unreachable!("complete_enum on non-enum"),
  422|       |        }
  423|      8|    }
  424|       |
  425|       |    // ============================================================
  426|       |    // Layout
  427|       |    // ============================================================
  428|       |
  429|    129|    pub(crate) fn get_layout(&self, ty: TypeRef) -> Cow<'_, TypeLayout> {
  430|    129|        if ty.is_inline_pointer() {
  431|      3|            return Cow::Owned(TypeLayout {
  432|      3|                size: 8,
  433|      3|                alignment: 8,
  434|      3|                kind: LayoutKind::Scalar,
  435|      3|            });
  436|    126|        }
  437|       |
  438|    126|        if ty.is_inline_array() {
  439|     28|            let elem = self.reconstruct_element(ty);
  440|     28|            let elem_layout = self.get_layout(elem);
  441|     28|            let len = ty.array_len().unwrap() as u64;
  442|     28|            return Cow::Owned(TypeLayout {
  443|     28|                size: elem_layout.size * (len as u16), // Potential overflow if not careful, but C rules apply
  444|     28|                alignment: elem_layout.alignment,
  445|     28|                kind: LayoutKind::Array { element: elem, len },
  446|     28|            });
  447|     98|        }
  448|       |
  449|     98|        let idx = ty.index();
  450|     98|        match self.types[idx].layout.as_ref() {
  451|     98|            Some(x) => Cow::Borrowed(x),
  452|      0|            None => panic!("ICE: TypeRef {ty} layout not computed. make sure layout is computed in previous phase"),
  453|       |        }
  454|    129|    }
  455|       |
  456|     22|    pub(crate) fn get_array_layout(&self, ty: TypeRef) -> (u16, u16, TypeRef, u64) {
  457|     22|        let layout = self.get_layout(ty);
  458|     22|        match layout.kind {
  459|     22|            LayoutKind::Array { element, len } => (layout.size, layout.alignment, element, len),
  460|      0|            _ => panic!("ICE: layout is not array"),
  461|       |        }
  462|     22|    }
  463|       |
  464|     42|    pub(crate) fn get_record_layout(&self, ty: TypeRef) -> (u16, u16, Vec<FieldLayout>, bool) {
  465|     42|        let layout = self.get_layout(ty);
  466|     42|        match &layout.kind {
  467|     42|            LayoutKind::Record { fields, is_union } => (layout.size, layout.alignment, fields.clone(), *is_union),
  468|      0|            _ => panic!("ICE: layout is not record"),
  469|       |        }
  470|     42|    }
  471|       |
  472|    776|    pub(crate) fn ensure_layout(&mut self, ty: TypeRef) -> Result<Cow<'_, TypeLayout>, SemanticError> {
  473|    776|        if ty.is_inline_pointer() {
  474|     60|            return Ok(Cow::Owned(TypeLayout {
  475|     60|                size: 8,
  476|     60|                alignment: 8,
  477|     60|                kind: LayoutKind::Scalar,
  478|     60|            }));
  479|    716|        }
  480|       |
  481|    716|        if ty.is_inline_array() {
  482|       |            // Recursive check
  483|     85|            let elem = self.reconstruct_element(ty);
  484|     85|            let elem_layout = self.ensure_layout(elem)?; // returns Cow
                              ^84                                   ^1
  485|     84|            let len = ty.array_len().unwrap() as u64;
  486|     84|            let size = (elem_layout.size as u64 * len) as u16;
  487|       |
  488|     84|            return Ok(Cow::Owned(TypeLayout {
  489|     84|                size,
  490|     84|                alignment: elem_layout.alignment,
  491|     84|                kind: LayoutKind::Array { element: elem, len },
  492|     84|            }));
  493|    631|        }
  494|       |
  495|    631|        let idx = ty.index();
  496|    631|        if self.types[idx].layout.is_some() {
  497|    369|            return Ok(Cow::Borrowed(self.types[idx].layout.as_ref().unwrap()));
  498|    262|        }
  499|       |
  500|    262|        let layout = self.compute_layout(ty)?;
                          ^250                            ^12
  501|    250|        self.types[idx].layout = Some(layout);
  502|       |
  503|    250|        Ok(Cow::Borrowed(self.types[idx].layout.as_ref().unwrap()))
  504|    776|    }
  505|       |
  506|    262|    fn compute_layout(&mut self, ty: TypeRef) -> Result<TypeLayout, SemanticError> {
  507|    262|        if self.layout_in_progress.contains(&ty) {
  508|      4|            return Err(SemanticError::RecursiveType { ty });
  509|    258|        }
  510|       |
  511|       |        // We clone Kind to release borrow on self
  512|    258|        let type_kind = self.get(ty).kind.clone();
  513|       |
  514|    258|        self.layout_in_progress.insert(ty);
  515|       |
  516|    258|        let layout = match type_kind {
                          ^250
  517|    177|            TypeKind::Builtin(b) => match b {
  518|      1|                BuiltinType::Void => TypeLayout {
  519|      1|                    size: 0,
  520|      1|                    alignment: 1,
  521|      1|                    kind: LayoutKind::Scalar,
  522|      1|                },
  523|     18|                BuiltinType::Bool | BuiltinType::Char | BuiltinType::SChar | BuiltinType::UChar => TypeLayout {
  524|     18|                    size: 1,
  525|     18|                    alignment: 1,
  526|     18|                    kind: LayoutKind::Scalar,
  527|     18|                },
  528|      4|                BuiltinType::Short | BuiltinType::UShort => TypeLayout {
  529|      4|                    size: 2,
  530|      4|                    alignment: 2,
  531|      4|                    kind: LayoutKind::Scalar,
  532|      4|                },
  533|    137|                BuiltinType::Int | BuiltinType::UInt | BuiltinType::Float => TypeLayout {
  534|    137|                    size: 4,
  535|    137|                    alignment: 4,
  536|    137|                    kind: LayoutKind::Scalar,
  537|    137|                },
  538|       |                BuiltinType::Long | BuiltinType::ULong => {
  539|       |                    // long is usually pointer width
  540|      7|                    let size = match self.target_triple.pointer_width() {
  541|      0|                        Ok(PointerWidth::U16) => 2,
  542|      0|                        Ok(PointerWidth::U32) => 4,
  543|      7|                        Ok(PointerWidth::U64) => 8,
  544|      0|                        Err(_) => 8, // Default to 64-bit if unknown
  545|       |                    };
  546|      7|                    TypeLayout {
  547|      7|                        size,
  548|      7|                        alignment: size,
  549|      7|                        kind: LayoutKind::Scalar,
  550|      7|                    }
  551|       |                }
  552|      9|                BuiltinType::LongLong | BuiltinType::ULongLong | BuiltinType::Double => TypeLayout {
  553|      9|                    size: 8,
  554|      9|                    alignment: 8,
  555|      9|                    kind: LayoutKind::Scalar,
  556|      9|                },
  557|      1|                BuiltinType::LongDouble => TypeLayout {
  558|      1|                    size: 16,
  559|      1|                    alignment: 16,
  560|      1|                    kind: LayoutKind::Scalar,
  561|      1|                },
  562|      0|                BuiltinType::Signed => TypeLayout {
  563|      0|                    size: 4,
  564|      0|                    alignment: 4,
  565|      0|                    kind: LayoutKind::Scalar,
  566|      0|                },
  567|       |            },
  568|       |
  569|       |            TypeKind::Pointer { .. } => {
  570|      7|                let size = match self.target_triple.pointer_width() {
  571|      0|                    Ok(PointerWidth::U16) => 2,
  572|      0|                    Ok(PointerWidth::U32) => 4,
  573|      7|                    Ok(PointerWidth::U64) => 8,
  574|      0|                    Err(_) => 8,
  575|       |                };
  576|      7|                TypeLayout {
  577|      7|                    size,
  578|      7|                    alignment: size,
  579|      7|                    kind: LayoutKind::Scalar,
  580|      7|                }
  581|       |            }
  582|       |
  583|      0|            TypeKind::Complex { base_type } => {
  584|      0|                let base_layout = self.ensure_layout(base_type)?;
  585|      0|                TypeLayout {
  586|      0|                    size: base_layout.size * 2,
  587|      0|                    alignment: base_layout.alignment,
  588|      0|                    kind: LayoutKind::Scalar,
  589|      0|                }
  590|       |            }
  591|       |
  592|      6|            TypeKind::Array { element_type, size } => match size {
  593|      2|                ArraySizeType::Constant(len) => {
  594|      2|                    let element_layout = self.ensure_layout(element_type)?;
                                                                                       ^0
  595|      2|                    let total_size = element_layout.size as u64 * len as u64;
  596|      2|                    TypeLayout {
  597|      2|                        size: total_size as u16,
  598|      2|                        alignment: element_layout.alignment,
  599|      2|                        kind: LayoutKind::Array {
  600|      2|                            element: element_type,
  601|      2|                            len: len as u64,
  602|      2|                        },
  603|      2|                    }
  604|       |                }
  605|       |                _ => {
  606|      4|                    return Err(SemanticError::UnsupportedFeature {
  607|      4|                        feature: "incomplete/VLA array layout".to_string(),
  608|      4|                        span: SourceSpan::dummy(),
  609|      4|                    });
  610|       |                }
  611|       |            },
  612|       |
  613|      0|            TypeKind::Function { .. } => TypeLayout {
  614|      0|                size: 0,
  615|      0|                alignment: 1,
  616|      0|                kind: LayoutKind::Scalar,
  617|      0|            },
  618|       |
  619|       |            TypeKind::Record {
  620|     60|                members,
  621|     60|                is_complete,
  622|     60|                is_union,
  623|       |                ..
  624|       |            } => {
  625|     60|                if !is_complete {
  626|       |                    // This is the correct error when sizeof is used on an incomplete type.
  627|      2|                    return Err(SemanticError::SizeOfIncompleteType {
  628|      2|                        ty,
  629|      2|                        // The span from the caller (e.g., the sizeof expression) is used,
  630|      2|                        // so a dummy span here is acceptable.
  631|      2|                        span: SourceSpan::dummy(),
  632|      2|                    });
  633|     58|                }
  634|     58|                self.compute_record_layout(&members, is_union)?
                                                                            ^2
  635|       |            }
  636|       |
  637|       |            TypeKind::Enum {
  638|      8|                base_type, is_complete, ..
  639|       |            } => {
  640|      8|                if !is_complete {
  641|      0|                    return Err(SemanticError::UnsupportedFeature {
  642|      0|                        feature: "incomplete enum type layout".to_string(),
  643|      0|                        span: SourceSpan::dummy(),
  644|      0|                    });
  645|      8|                }
  646|      8|                self.ensure_layout(base_type)?.into_owned()
                                                           ^0
  647|       |            }
  648|       |
  649|       |            TypeKind::Error => {
  650|      0|                return Err(SemanticError::UnsupportedFeature {
  651|      0|                    feature: "error layout".to_string(),
  652|      0|                    span: SourceSpan::dummy(),
  653|      0|                });
  654|       |            }
  655|       |        };
  656|       |
  657|    250|        self.layout_in_progress.remove(&ty);
  658|    250|        Ok(layout)
  659|    262|    }
  660|       |
  661|     58|    fn compute_record_layout(&mut self, members: &[StructMember], is_union: bool) -> Result<TypeLayout, SemanticError> {
  662|     58|        let mut max_align = 1;
  663|     58|        let mut current_size = 0;
  664|     58|        let mut field_layouts = Vec::with_capacity(members.len());
  665|       |        // For C11 6.7.2.1p18 flexible array check:
  666|       |        // "the last element of a structure with more than one named member may have an incomplete array type"
  667|       |        // But incomplete array types are NOT allowed in unions.
  668|       |        // We will check validity as we iterate.
  669|       |        // Note: The count of members might include anonymous struct/union members which are technically members.
  670|       |
  671|     58|        let member_count = members.len();
  672|       |
  673|    102|        for (i, member) in members.iter().enumerate() {
                                         ^58     ^58    ^58
  674|    102|            let member_ty = member.member_type.ty();
  675|       |
  676|       |            // Special handling for flexible array member (FAM)
  677|       |            // Need to check if it is incomplete array
  678|       |            // We can't use is_complete because that recurses. We check TypeKind directly.
  679|    102|            let is_incomplete_array = if member_ty.is_inline_array() {
  680|      1|                false // inline array always has len
  681|       |            } else {
  682|    100|                matches!(
  683|    101|                    self.get(member_ty).kind,
  684|       |                    TypeKind::Array {
  685|       |                        size: ArraySizeType::Incomplete,
  686|       |                        ..
  687|       |                    }
  688|       |                )
  689|       |            };
  690|       |
  691|    102|            if is_incomplete_array {
  692|      1|                if is_union {
  693|       |                    // Incomplete types not allowed in union
  694|      0|                    return Err(SemanticError::UnsupportedFeature {
  695|      0|                        feature: "incomplete/VLA array in union".to_string(),
  696|      0|                        span: member.span,
  697|      0|                    });
  698|      1|                }
  699|       |
  700|       |                // Must be last member
  701|      1|                if i != member_count - 1 {
  702|      1|                    return Err(SemanticError::FlexibleArrayNotLast { span: member.span });
  703|      0|                }
  704|       |
  705|       |                // Must have at least one other named member.
  706|       |                // Or rather, "structure with more than one named member".
  707|       |                // If this is the only member, it's invalid.
  708|      0|                if member_count < 2 {
  709|      0|                    return Err(SemanticError::FlexibleArrayInEmptyStruct { span: member.span });
  710|      0|                }
  711|       |
  712|       |                // If valid FAM:
  713|       |                // Size of structure is as if FAM was omitted.
  714|       |                // But we must respect its alignment for the struct's alignment.
  715|       |                // We need to get the element type to find alignment.
  716|      0|                let elem_ty = match &self.get(member_ty).kind {
  717|      0|                    TypeKind::Array { element_type, .. } => *element_type,
  718|      0|                    _ => unreachable!(),
  719|       |                };
  720|      0|                let elem_layout = self.ensure_layout(elem_ty)?;
  721|       |
  722|      0|                max_align = max_align.max(elem_layout.alignment);
  723|       |
  724|       |                // FAM has size 0 for layout purposes of the struct size,
  725|       |                // but its offset is where it would start.
  726|       |                // The standard says: "size of the structure is as if the flexible array member were omitted"
  727|       |                // This means current_size stays as is (after padding for alignment of FAM? No, omitted means omitted).
  728|       |                // "except that it may have more trailing padding than the omission would imply"
  729|       |                // Usually this is interpreted as: sizeof(struct) = max(sizeof(struct_without_fam), offsetof(fam)).
  730|       |                // Or simply: layout the FAM, but don't increment current_size by its size (which is unknown/0).
  731|       |                // But we might need to add padding to current_size to reach FAM alignment?
  732|       |                // "as if the flexible array member were omitted" implies we don't even add padding for it?
  733|       |                // BUT "except that it may have more trailing padding".
  734|       |                // Most compilers align the end of the struct to the alignment of the FAM.
  735|       |
  736|       |                // Let's compute offset.
  737|      0|                let offset = (current_size + elem_layout.alignment - 1) & !(elem_layout.alignment - 1);
  738|      0|                field_layouts.push(FieldLayout { offset });
  739|       |
  740|       |                // We do NOT update current_size with FAM size (which is effectively 0 or variable).
  741|       |                // But we might update current_size to offset?
  742|       |                // GCC: sizeof(struct { int x; int y[]; }) == 4.
  743|       |                //      sizeof(struct { char c; int y[]; }) == 4 (aligned to 4).
  744|       |                // So we do align current_size.
  745|      0|                current_size = offset;
  746|       |
  747|      0|                continue;
  748|    101|            }
  749|       |
  750|    101|            let layout = self.ensure_layout(member_ty)?;
                              ^100                                  ^1
  751|    100|            max_align = max_align.max(layout.alignment);
  752|       |
  753|    100|            if is_union {
  754|     11|                current_size = current_size.max(layout.size);
  755|     11|                field_layouts.push(FieldLayout { offset: 0 });
  756|     89|            } else {
  757|     89|                // Align current_size to member's alignment to find its offset
  758|     89|                let offset = (current_size + layout.alignment - 1) & !(layout.alignment - 1);
  759|     89|                field_layouts.push(FieldLayout { offset });
  760|     89|                current_size = offset + layout.size;
  761|     89|            }
  762|       |        }
  763|       |
  764|       |        // Final size is padded to the record's max alignment
  765|     56|        let final_size = (current_size + max_align - 1) & !(max_align - 1);
  766|       |
  767|     56|        Ok(TypeLayout {
  768|     56|            size: final_size,
  769|     56|            alignment: max_align,
  770|     56|            kind: LayoutKind::Record {
  771|     56|                fields: field_layouts,
  772|     56|                is_union,
  773|     56|            },
  774|     56|        })
  775|     58|    }
  776|       |
  777|     65|    pub(crate) fn decay(&mut self, qt: QualType, ptr_qualifiers: TypeQualifiers) -> QualType {
  778|     65|        let kind = self.get(qt.ty()).kind.clone();
  779|     65|        match kind {
  780|     17|            TypeKind::Array { element_type, .. } => {
  781|       |                // Correct logic: Array of T decays to Pointer to T.
  782|       |                // Qualifiers on Array apply to the element in the resulting pointer type.
  783|     17|                let elem_qt = QualType::new(element_type, qt.qualifiers());
  784|     17|                let ptr = self.pointer_to(elem_qt);
  785|       |                // Apply the extracted pointer qualifiers (e.g. from static/const inside [])
  786|     17|                QualType::new(ptr, ptr_qualifiers)
  787|       |            }
  788|       |            TypeKind::Function { .. } => {
  789|      5|                let ptr = self.pointer_to(qt);
  790|      5|                QualType::new(ptr, ptr_qualifiers)
  791|       |            }
  792|     43|            _ => qt,
  793|       |        }
  794|     65|    }
  795|       |
  796|     28|    pub(crate) fn strip_all(&self, qt: QualType) -> QualType {
  797|     28|        QualType::unqualified(qt.ty())
  798|     28|    }
  799|       |
  800|  1.33k|    pub(crate) fn merge_qualifiers(&self, base: QualType, add: TypeQualifiers) -> QualType {
  801|  1.33k|        QualType::new(base.ty(), base.qualifiers() | add)
  802|  1.33k|    }
  803|       |
  804|     40|    pub(crate) fn is_compatible(&self, a: QualType, b: QualType) -> bool {
  805|     40|        if a == b {
  806|     26|            return true;
  807|     14|        }
  808|       |
  809|     14|        if a.qualifiers() != b.qualifiers() {
  810|      3|            return false;
  811|     11|        }
  812|       |
  813|     11|        let ty_a_ref = a.ty();
  814|     11|        let ty_b_ref = b.ty();
  815|       |
  816|     11|        if ty_a_ref == ty_b_ref {
  817|      0|            return true;
  818|     11|        }
  819|       |
  820|     11|        let kind_a = self.get(ty_a_ref).kind.clone();
  821|     11|        let kind_b = self.get(ty_b_ref).kind.clone();
  822|       |
  823|     11|        match (kind_a, kind_b) {
  824|       |            (
  825|       |                TypeKind::Array {
  826|      0|                    element_type: elem_a,
  827|      0|                    size: size_a,
  828|       |                },
  829|       |                TypeKind::Array {
  830|      0|                    element_type: elem_b,
  831|      0|                    size: size_b,
  832|       |                },
  833|       |            ) => {
  834|      0|                if !self.is_compatible(QualType::unqualified(elem_a), QualType::unqualified(elem_b)) {
  835|      0|                    return false;
  836|      0|                }
  837|      0|                match (size_a, size_b) {
  838|      0|                    (ArraySizeType::Incomplete, _) => true,
  839|      0|                    (_, ArraySizeType::Incomplete) => true,
  840|      0|                    (ArraySizeType::Constant(sa), ArraySizeType::Constant(sb)) => sa == sb,
  841|      0|                    (ArraySizeType::Star, _) => true,
  842|      0|                    (_, ArraySizeType::Star) => true,
  843|      0|                    _ => false,
  844|       |                }
  845|       |            }
  846|       |            (
  847|       |                TypeKind::Function {
  848|      3|                    return_type: ret_a,
  849|      3|                    parameters: params_a,
  850|      3|                    is_variadic: var_a,
  851|       |                    ..
  852|       |                },
  853|       |                TypeKind::Function {
  854|      3|                    return_type: ret_b,
  855|      3|                    parameters: params_b,
  856|      3|                    is_variadic: var_b,
  857|       |                    ..
  858|       |                },
  859|       |            ) => {
  860|      3|                if var_a != var_b {
  861|      0|                    return false;
  862|      3|                }
  863|      3|                if !self.is_compatible(QualType::unqualified(ret_a), QualType::unqualified(ret_b)) {
  864|      0|                    return false;
  865|      3|                }
  866|      3|                if params_a.len() != params_b.len() {
  867|      0|                    return false;
  868|      3|                }
  869|      3|                for (p_a, p_b) in params_a.iter().zip(params_b.iter()) {
  870|       |                    // Ignore top-level qualifiers on parameters
  871|      3|                    let type_a = QualType::unqualified(p_a.param_type.ty());
  872|      3|                    let type_b = QualType::unqualified(p_b.param_type.ty());
  873|      3|                    if !self.is_compatible(type_a, type_b) {
  874|      2|                        return false;
  875|      1|                    }
  876|       |                }
  877|      1|                true
  878|       |            }
  879|      2|            (TypeKind::Pointer { pointee: p_a }, TypeKind::Pointer { pointee: p_b }) => self.is_compatible(p_a, p_b),
  880|      6|            _ => false,
  881|       |        }
  882|     40|    }
  883|       |
  884|     70|    pub(crate) fn is_complete(&self, ty: TypeRef) -> bool {
  885|     70|        if ty.is_inline_pointer() {
  886|      3|            return true;
  887|     67|        }
  888|     67|        if ty.is_inline_array() {
  889|       |            // Array is complete if element is complete
  890|       |            // But strict C says array valid if element type is complete (except local VLA which is complete at runtime allocation point?)
  891|       |            // Here we just check element kind.
  892|      9|            let elem = self.reconstruct_element(ty);
  893|      9|            return self.is_complete(elem);
  894|     58|        }
  895|       |
  896|     58|        let kind = &self.types[ty.index()].kind;
  897|     55|        match kind {
  898|      2|            TypeKind::Record { is_complete, .. } => *is_complete,
  899|      0|            TypeKind::Enum { is_complete, .. } => *is_complete,
  900|      1|            TypeKind::Array { element_type, size } => {
  901|      1|                if let ArraySizeType::Incomplete = size {
  902|      1|                    return false;
  903|      0|                }
  904|      0|                self.is_complete(*element_type)
  905|       |            }
  906|      0|            TypeKind::Builtin(BuiltinType::Void) => false,
  907|     55|            _ => true, // Scalars are always complete
  908|       |        }
  909|     70|    }
  910|       |
  911|     85|    pub(crate) fn is_const_recursive(&self, qt: QualType) -> bool {
  912|     85|        if qt.is_const() {
  913|      8|            return true;
  914|     77|        }
  915|       |
  916|     77|        let ty_ref = qt.ty();
  917|     77|        if ty_ref.is_record()
  918|      3|            && let TypeKind::Record { members, .. } = &self.get(ty_ref).kind
  919|       |        {
  920|      6|            for member in members {
                              ^3
  921|      3|                if self.is_const_recursive(member.member_type) {
  922|      0|                    return true;
  923|      3|                }
  924|       |            }
  925|     74|        }
  926|     77|        false
  927|     85|    }
  928|       |
  929|     11|    pub(crate) fn display_qual_type(&self, qt: QualType) -> String {
  930|     11|        let quals = qt.qualifiers();
  931|     11|        let ty_str = self.display_type(qt.ty());
  932|     11|        if quals.is_empty() {
  933|      9|            ty_str
  934|       |        } else {
  935|      2|            format!("{} {}", quals, ty_str)
  936|       |        }
  937|     11|    }
  938|       |
  939|     18|    pub(crate) fn display_type(&self, ty: TypeRef) -> String {
  940|     18|        if ty.is_inline_pointer() {
  941|      2|            let pointee = self.reconstruct_pointee(ty);
  942|      2|            return format!("{}*", self.display_type(pointee));
  943|     16|        }
  944|       |
  945|     16|        if ty.is_inline_array() {
  946|      0|            let elem = self.reconstruct_element(ty);
  947|      0|            let len = ty.array_len().unwrap();
  948|      0|            return format!("{}[{}]", self.display_type(elem), len);
  949|     16|        }
  950|       |
  951|     16|        let type_kind = &self.types[ty.index()].kind;
  952|     16|        match type_kind {
  953|     14|            TypeKind::Builtin(b) => match b {
  954|      0|                BuiltinType::Void => "void".to_string(),
  955|      0|                BuiltinType::Bool => "_Bool".to_string(),
  956|      0|                BuiltinType::Char => "char".to_string(),
  957|      0|                BuiltinType::SChar => "signed char".to_string(),
  958|      0|                BuiltinType::UChar => "unsigned char".to_string(),
  959|      1|                BuiltinType::Short => "short".to_string(),
  960|      1|                BuiltinType::UShort => "unsigned short".to_string(),
  961|      2|                BuiltinType::Int => "int".to_string(),
  962|      0|                BuiltinType::UInt => "unsigned int".to_string(),
  963|      1|                BuiltinType::Long => "long".to_string(),
  964|      2|                BuiltinType::ULong => "unsigned long".to_string(),
  965|      2|                BuiltinType::LongLong => "long long".to_string(),
  966|      2|                BuiltinType::ULongLong => "unsigned long long".to_string(),
  967|      1|                BuiltinType::Float => "float".to_string(),
  968|      1|                BuiltinType::Double => "double".to_string(),
  969|      1|                BuiltinType::LongDouble => "long double".to_string(),
  970|      0|                BuiltinType::Signed => "signed".to_string(),
  971|       |            },
  972|      0|            TypeKind::Complex { base_type } => format!("_Complex {}", self.display_type(*base_type)),
  973|      0|            TypeKind::Pointer { pointee } => format!("{}*", self.display_qual_type(*pointee)),
  974|      0|            TypeKind::Array { element_type, size } => {
  975|      0|                let elem_str = self.display_type(*element_type);
  976|      0|                match size {
  977|      0|                    ArraySizeType::Constant(len) => format!("{}[{}]", elem_str, len),
  978|      0|                    ArraySizeType::Variable(_) => format!("{}[*]", elem_str), // Using * for VLA for now or expr?
  979|      0|                    ArraySizeType::Incomplete => format!("{}[]", elem_str),
  980|      0|                    ArraySizeType::Star => format!("{}[*]", elem_str),
  981|       |                }
  982|       |            }
  983|       |            TypeKind::Function {
  984|      0|                return_type,
  985|      0|                parameters,
  986|      0|                is_variadic,
  987|       |                ..
  988|       |            } => {
  989|      0|                let ret_str = self.display_type(*return_type);
  990|      0|                let params_str = parameters
  991|      0|                    .iter()
  992|      0|                    .map(|p| self.display_qual_type(p.param_type))
  993|      0|                    .collect::<Vec<_>>()
  994|      0|                    .join(", ");
  995|      0|                let var_str = if *is_variadic { ", ..." } else { "" };
  996|      0|                format!("{}({}{})", ret_str, params_str, var_str)
  997|       |            }
  998|      2|            TypeKind::Record { tag, is_union, .. } => {
  999|      2|                let kind_str = if *is_union { "union" } else { "struct" };
                                                            ^0
 1000|      2|                if let Some(tag_name) = tag {
 1001|      2|                    format!("{} {}", kind_str, tag_name)
 1002|       |                } else {
 1003|      0|                    format!("{} (anonymous)", kind_str)
 1004|       |                }
 1005|       |            }
 1006|      0|            TypeKind::Enum { tag, .. } => {
 1007|      0|                if let Some(tag_name) = tag {
 1008|      0|                    format!("enum {}", tag_name)
 1009|       |                } else {
 1010|      0|                    "enum (anonymous)".to_string()
 1011|       |                }
 1012|       |            }
 1013|      0|            TypeKind::Error => "<error>".to_string(),
 1014|       |        }
 1015|     18|    }
 1016|       |}
 1017|       |
 1018|       |// ================================================================
 1019|       |// Helper types
 1020|       |// ================================================================
 1021|       |
 1022|       |#[derive(Debug, Clone, PartialEq, Eq, Hash)]
 1023|       |struct FnSigKey {
 1024|       |    return_type: TypeRef,
 1025|       |    params: Vec<QualType>,
 1026|       |    is_variadic: bool,
 1027|       |    is_noreturn: bool,
 1028|       |}

/app/src/semantic/types.rs:
    1|       |//! Type system representation and utilities.
    2|       |//!
    3|       |//! This module defines the semantic type system used during analysis,
    4|       |//! distinct from the syntactic TypeSpecifier constructs used in parsing.
    5|       |
    6|       |use std::num::NonZeroU16;
    7|       |use std::{fmt::Display, num::NonZeroU32};
    8|       |
    9|       |use bitflags::bitflags;
   10|       |use serde::Serialize;
   11|       |
   12|       |use crate::ast::{NameId, NodeRef, SourceSpan};
   13|       |
   14|       |/// Type representation (for semantic analysis)
   15|       |/// This is a canonical type, distinct from TypeSpecifier which is a syntax construct.
   16|       |/// Types are stored in a separate Vec<Type> with TypeRef references.
   17|       |/// invariant:
   18|       |/// - layout == None for incomplete types
   19|       |/// - layout is computed according to C abstract machine rules
   20|       |/// - layout may differ from MIR layout
   21|       |
   22|       |#[derive(Debug, Clone)]
   23|       |pub struct Type {
   24|       |    pub kind: TypeKind,
   25|       |    pub layout: Option<TypeLayout>,
   26|       |}
   27|       |
   28|       |#[derive(Debug, Clone)]
   29|       |pub struct TypeLayout {
   30|       |    pub size: u16,
   31|       |    pub alignment: u16,
   32|       |    pub kind: LayoutKind,
   33|       |}
   34|       |
   35|       |#[derive(Debug, Clone)]
   36|       |pub enum LayoutKind {
   37|       |    Scalar,
   38|       |    Array { element: TypeRef, len: u64 },
   39|       |    Record { fields: Vec<FieldLayout>, is_union: bool },
   40|       |}
   41|       |
   42|       |#[derive(Debug, Clone)]
   43|       |pub struct FieldLayout {
   44|       |    pub offset: u16,
   45|       |}
   46|       |
   47|       |impl Type {
   48|       |    /// Create a new type with default qualifiers
   49|       |    /// can only be called by TypeRegistry
   50|  4.07k|    pub(crate) fn new(kind: TypeKind) -> Self {
   51|  4.07k|        Type { kind, layout: None }
   52|  4.07k|    }
   53|       |
   54|     20|    pub(crate) fn flatten_members(&self, registry: &super::TypeRegistry, flat_members: &mut Vec<StructMember>) {
   55|     20|        if let TypeKind::Record { members, .. } = &self.kind {
   56|     45|            for member in members.iter().cloned() {
                                        ^20            ^20
   57|     45|                if member.name.is_none() {
   58|      2|                    let inner_type = registry.get(member.member_type.ty());
   59|      2|                    inner_type.flatten_members(registry, flat_members);
   60|     43|                } else {
   61|     43|                    flat_members.push(member);
   62|     43|                }
   63|       |            }
   64|      0|        }
   65|     20|    }
   66|       |}
   67|       |
   68|       |#[repr(u8)]
   69|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   70|       |pub enum TypeClass {
   71|       |    Builtin = 0,
   72|       |    Pointer = 1,
   73|       |    Array = 2,
   74|       |    Function = 3,
   75|       |    Record = 4,
   76|       |    Enum = 5,
   77|       |    Typedef = 6,
   78|       |}
   79|       |
   80|       |impl TypeClass {
   81|  12.9k|    pub fn from_u32(v: u32) -> Self {
   82|  12.9k|        match v {
   83|  7.92k|            0 => Self::Builtin,
   84|  1.24k|            1 => Self::Pointer,
   85|    978|            2 => Self::Array,
   86|    828|            3 => Self::Function,
   87|  1.80k|            4 => Self::Record,
   88|    122|            5 => Self::Enum,
   89|      0|            6 => Self::Typedef,
   90|      0|            _ => unreachable!("Invalid TypeClass value: {}", v),
   91|       |        }
   92|  12.9k|    }
   93|       |}
   94|       |
   95|       |#[repr(u8)]
   96|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
   97|       |pub enum BuiltinType {
   98|       |    Void = 1,
   99|       |    Bool = 2,
  100|       |    Char = 3,
  101|       |    SChar = 4,
  102|       |    UChar = 5,
  103|       |    Short = 6,
  104|       |    UShort = 7,
  105|       |    Int = 8,
  106|       |    UInt = 9,
  107|       |    Long = 10,
  108|       |    ULong = 11,
  109|       |    LongLong = 12,
  110|       |    ULongLong = 13,
  111|       |    Float = 14,
  112|       |    Double = 15,
  113|       |    LongDouble = 16,
  114|       |    Signed = 17,
  115|       |}
  116|       |
  117|       |impl BuiltinType {
  118|  2.30k|    pub fn from_u32(v: u32) -> Option<Self> {
  119|  2.30k|        match v {
  120|     11|            1 => Some(Self::Void),
  121|      8|            2 => Some(Self::Bool),
  122|     13|            3 => Some(Self::Char),
  123|      3|            4 => Some(Self::SChar),
  124|     10|            5 => Some(Self::UChar),
  125|     13|            6 => Some(Self::Short),
  126|      3|            7 => Some(Self::UShort),
  127|  1.95k|            8 => Some(Self::Int),
  128|     36|            9 => Some(Self::UInt),
  129|     22|            10 => Some(Self::Long),
  130|    104|            11 => Some(Self::ULong),
  131|     23|            12 => Some(Self::LongLong),
  132|      3|            13 => Some(Self::ULongLong),
  133|     24|            14 => Some(Self::Float),
  134|     83|            15 => Some(Self::Double),
  135|      0|            16 => Some(Self::LongDouble),
  136|      0|            17 => Some(Self::Signed),
  137|      0|            _ => None,
  138|       |        }
  139|  2.30k|    }
  140|       |}
  141|       |
  142|       |/// Opaque reference to a canonical type.
  143|       |/// Internally index + 1 (NonZeroU32 for niche optimization).
  144|       |#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Serialize)]
  145|       |#[repr(transparent)]
  146|       |pub struct TypeRef(NonZeroU32);
  147|       |
  148|       |impl TypeRef {
  149|       |    // Layout:
  150|       |    // bit  0..=17  (18 bit)  BASE INDEX
  151|       |    // bit 18..=20  (3 bit)   TYPE CLASS
  152|       |    // bit 21..=22  (2 bit)   POINTER DEPTH (0..3)
  153|       |    // bit 23..=27  (5 bit)   ARRAY LEN INLINE (0..31)
  154|       |
  155|       |    const BASE_BITS: u32 = 18;
  156|       |    const CLASS_BITS: u32 = 3;
  157|       |    const PTR_BITS: u32 = 2;
  158|       |    const ARR_BITS: u32 = 5;
  159|       |
  160|       |    const BASE_SHIFT: u32 = 0;
  161|       |    const CLASS_SHIFT: u32 = Self::BASE_BITS;
  162|       |    const PTR_SHIFT: u32 = Self::CLASS_SHIFT + Self::CLASS_BITS;
  163|       |    const ARR_SHIFT: u32 = Self::PTR_SHIFT + Self::PTR_BITS;
  164|       |
  165|       |    const BASE_MASK: u32 = (1 << Self::BASE_BITS) - 1;
  166|       |    const CLASS_MASK: u32 = (1 << Self::CLASS_BITS) - 1;
  167|       |    const PTR_MASK: u32 = (1 << Self::PTR_BITS) - 1;
  168|       |    const ARR_MASK: u32 = (1 << Self::ARR_BITS) - 1;
  169|       |
  170|       |    #[inline]
  171|  4.64k|    pub fn new(base_index: u32, class: TypeClass, ptr_depth: u8, arr_len: u32) -> Option<Self> {
  172|  4.64k|        if base_index == 0 || base_index > Self::BASE_MASK {
  173|      0|            return None; // Base index must be non-zero and fit in 18 bits
  174|  4.64k|        }
  175|  4.64k|        if ptr_depth as u32 > Self::PTR_MASK {
  176|      1|            return None;
  177|  4.64k|        }
  178|  4.64k|        if arr_len > Self::ARR_MASK {
  179|      1|            return None;
  180|  4.64k|        }
  181|       |
  182|       |        // Validate combinations
  183|  4.64k|        match class {
  184|       |            TypeClass::Builtin => {
  185|  3.91k|                if ptr_depth != 0 || arr_len != 0 {
                                                   ^3.91k
  186|      1|                    return None;
  187|  3.91k|                }
  188|       |            }
  189|       |            TypeClass::Pointer => {
  190|    319|                if arr_len != 0 {
  191|      1|                    return None;
  192|    318|                }
  193|       |                // Pointer depth 0 means "Registry Pointer" (valid)
  194|       |                // Pointer depth 1..3 means "Inline Pointer" (valid)
  195|       |            }
  196|       |            TypeClass::Array => {
  197|       |                // Array len 0 means "Registry Array" (valid)
  198|       |                // Array len 1..31 means "Inline Array" (valid)
  199|     73|                if ptr_depth != 0 {
  200|      1|                    return None;
  201|     72|                }
  202|       |            }
  203|       |            TypeClass::Function | TypeClass::Record | TypeClass::Enum | TypeClass::Typedef => {
  204|    335|                if ptr_depth != 0 || arr_len != 0 {
  205|      0|                    return None;
  206|    335|                }
  207|       |            }
  208|       |        }
  209|       |
  210|  4.64k|        let mut raw = 0u32;
  211|  4.64k|        raw |= base_index & Self::BASE_MASK;
  212|  4.64k|        raw |= (class as u32) << Self::CLASS_SHIFT;
  213|  4.64k|        raw |= (ptr_depth as u32) << Self::PTR_SHIFT;
  214|  4.64k|        raw |= (arr_len) << Self::ARR_SHIFT;
  215|       |
  216|  4.64k|        NonZeroU32::new(raw).map(TypeRef)
  217|  4.64k|    }
  218|       |
  219|       |    // Unsafe constructor for internal use / tests
  220|       |    #[inline]
  221|  18.0k|    pub unsafe fn from_raw_unchecked(n: u32) -> Self {
  222|  18.0k|        unsafe { TypeRef(NonZeroU32::new_unchecked(n)) }
  223|  18.0k|    }
  224|       |
  225|       |    #[inline]
  226|     55|    pub fn get(self) -> u32 {
  227|     55|        self.raw()
  228|     55|    }
  229|       |
  230|       |    #[inline]
  231|  5.70k|    pub fn base(self) -> u32 {
  232|  5.70k|        (self.0.get() >> Self::BASE_SHIFT) & Self::BASE_MASK
  233|  5.70k|    }
  234|       |
  235|       |    #[inline]
  236|  12.9k|    pub fn class(self) -> TypeClass {
  237|  12.9k|        TypeClass::from_u32((self.0.get() >> Self::CLASS_SHIFT) & Self::CLASS_MASK)
  238|  12.9k|    }
  239|       |
  240|       |    #[inline]
  241|  1.06k|    pub fn pointer_depth(self) -> u8 {
  242|  1.06k|        ((self.0.get() >> Self::PTR_SHIFT) & Self::PTR_MASK) as u8
  243|  1.06k|    }
  244|       |
  245|       |    #[inline]
  246|  1.10k|    pub fn array_len(self) -> Option<u32> {
  247|  1.10k|        let val = (self.0.get() >> Self::ARR_SHIFT) & Self::ARR_MASK;
  248|  1.10k|        if val == 0 { None } else { Some(val) }
                                    ^396          ^712
  249|  1.10k|    }
  250|       |
  251|       |    #[inline]
  252|  2.52k|    pub(crate) fn is_builtin(self) -> bool {
  253|  2.52k|        self.class() == TypeClass::Builtin
  254|  2.52k|    }
  255|       |
  256|       |    #[inline]
  257|  1.28k|    pub fn is_pointer(self) -> bool {
  258|  1.28k|        self.class() == TypeClass::Pointer
  259|  1.28k|    }
  260|       |
  261|       |    #[inline]
  262|    158|    pub fn is_array(self) -> bool {
  263|    158|        self.class() == TypeClass::Array
  264|    158|    }
  265|       |
  266|       |    #[inline]
  267|    435|    pub fn is_function(self) -> bool {
  268|    435|        self.class() == TypeClass::Function
  269|    435|    }
  270|       |
  271|       |    #[inline]
  272|    357|    pub fn is_record(self) -> bool {
  273|    357|        self.class() == TypeClass::Record
  274|    357|    }
  275|       |
  276|       |    #[inline]
  277|  1.37k|    pub fn is_enum(self) -> bool {
  278|  1.37k|        self.class() == TypeClass::Enum
  279|  1.37k|    }
  280|       |
  281|       |    // --- Helpers for inline/registry check ---
  282|       |
  283|       |    #[inline]
  284|  3.57k|    pub(crate) fn is_inline_pointer(self) -> bool {
  285|  3.57k|        self.class() == TypeClass::Pointer && self.pointer_depth() != 0
                                                            ^503
  286|  3.57k|    }
  287|       |
  288|       |    #[inline]
  289|  3.17k|    pub(crate) fn is_inline_array(self) -> bool {
  290|  3.17k|        self.class() == TypeClass::Array && self.array_len().is_some()
                                                          ^518             ^518
  291|  3.17k|    }
  292|       |    // --- Legacy/Compat helpers ---
  293|       |
  294|       |    #[inline]
  295|  2.51k|    pub fn builtin(self) -> Option<BuiltinType> {
  296|  2.51k|        if self.is_builtin() {
  297|  2.30k|            BuiltinType::from_u32(self.base())
  298|       |        } else {
  299|    207|            None
  300|       |        }
  301|  2.51k|    }
  302|       |
  303|       |    #[inline]
  304|  8.64k|    pub fn raw(self) -> u32 {
  305|  8.64k|        self.0.get()
  306|  8.64k|    }
  307|       |
  308|       |    #[inline]
  309|  2.59k|    pub fn index(self) -> usize {
  310|       |        // Compatibility: returns base as index.
  311|       |        // For inline types, this returns the index of the base type.
  312|       |        // For registry types, this returns the registry index.
  313|  2.59k|        self.base() as usize
  314|  2.59k|    }
  315|       |
  316|       |    #[inline]
  317|    163|    pub fn is_void(self) -> bool {
  318|    163|        matches!(self.builtin(), Some(BuiltinType::Void))
                      ^158
  319|    163|    }
  320|       |
  321|       |    #[inline]
  322|  1.37k|    pub fn is_integer(self) -> bool {
  323|  1.37k|        self.is_enum()
  324|    154|            || matches!(
  325|  1.36k|                self.builtin(),
  326|       |                Some(BuiltinType::Bool)
  327|       |                    | Some(BuiltinType::Char)
  328|       |                    | Some(BuiltinType::SChar)
  329|       |                    | Some(BuiltinType::UChar)
  330|       |                    | Some(BuiltinType::Short)
  331|       |                    | Some(BuiltinType::UShort)
  332|       |                    | Some(BuiltinType::Int)
  333|       |                    | Some(BuiltinType::UInt)
  334|       |                    | Some(BuiltinType::Long)
  335|       |                    | Some(BuiltinType::ULong)
  336|       |                    | Some(BuiltinType::LongLong)
  337|       |                    | Some(BuiltinType::ULongLong)
  338|       |            )
  339|  1.37k|    }
  340|       |
  341|       |    #[inline]
  342|    151|    pub fn is_floating(self) -> bool {
  343|    101|        matches!(
  344|    151|            self.builtin(),
  345|       |            Some(BuiltinType::Float) | Some(BuiltinType::Double) | Some(BuiltinType::LongDouble)
  346|       |        )
  347|    151|    }
  348|       |
  349|       |    #[inline]
  350|  1.35k|    pub fn is_arithmetic(self) -> bool {
  351|  1.35k|        self.is_integer() || self.is_floating()
                                           ^151 ^151
  352|  1.35k|    }
  353|       |
  354|       |    #[inline]
  355|     70|    pub fn is_scalar(self) -> bool {
  356|     70|        self.is_arithmetic() || self.is_pointer()
                                              ^15  ^15
  357|     70|    }
  358|       |}
  359|       |
  360|       |impl Display for TypeRef {
  361|      8|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  362|      8|        if self.is_builtin() {
  363|      2|            write!(f, "{:?}", self.builtin().unwrap())
  364|       |        } else {
  365|      6|            write!(
  366|      6|                f,
  367|      6|                "TypeRef(base={}, class={:?}, ptr={}, arr={:?})",
  368|      6|                self.base(),
  369|      6|                self.class(),
  370|      6|                self.pointer_depth(),
  371|      6|                self.array_len()
  372|       |            )
  373|       |        }
  374|      8|    }
  375|       |}
  376|       |
  377|       |#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Serialize)]
  378|       |#[repr(transparent)]
  379|       |pub struct QualType(u32);
  380|       |
  381|       |// bits  0..=27   TypeRef (28 bit)
  382|       |// bits 28..=31   qualifiers (4 bit)
  383|       |
  384|       |impl QualType {
  385|       |    const QUAL_BITS: u32 = 4;
  386|       |    const QUAL_SHIFT: u32 = 28;
  387|       |    const TY_MASK: u32 = (1 << Self::QUAL_SHIFT) - 1;
  388|       |
  389|       |    #[inline]
  390|  4.29k|    pub fn new(ty: TypeRef, quals: TypeQualifiers) -> Self {
  391|  4.29k|        debug_assert!(quals.bits() < (1 << Self::QUAL_BITS));
  392|  4.29k|        debug_assert!(ty.raw() <= Self::TY_MASK);
  393|       |
  394|  4.29k|        QualType((ty.raw() & Self::TY_MASK) | ((quals.bits() as u32) << Self::QUAL_SHIFT))
  395|  4.29k|    }
  396|       |
  397|       |    #[inline]
  398|  2.82k|    pub fn unqualified(ty: TypeRef) -> Self {
  399|  2.82k|        Self::new(ty, TypeQualifiers::empty())
  400|  2.82k|    }
  401|       |
  402|       |    #[inline]
  403|  14.0k|    pub fn ty(self) -> TypeRef {
  404|  14.0k|        unsafe { TypeRef::from_raw_unchecked(self.0 & Self::TY_MASK) }
  405|  14.0k|    }
  406|       |
  407|       |    #[inline]
  408|  2.47k|    pub fn qualifiers(self) -> TypeQualifiers {
  409|  2.47k|        TypeQualifiers::from_bits_truncate((self.0 >> Self::QUAL_SHIFT) as u8)
  410|  2.47k|    }
  411|       |
  412|       |    #[inline]
  413|     96|    pub fn is_const(self) -> bool {
  414|     96|        self.qualifiers().contains(TypeQualifiers::CONST)
  415|     96|    }
  416|       |
  417|       |    #[inline]
  418|  1.26k|    pub fn is_pointer(self) -> bool {
  419|  1.26k|        self.ty().is_pointer()
  420|  1.26k|    }
  421|       |    #[inline]
  422|    150|    pub fn is_array(self) -> bool {
  423|    150|        self.ty().is_array()
  424|    150|    }
  425|       |    #[inline]
  426|    387|    pub fn is_function(self) -> bool {
  427|    387|        self.ty().is_function()
  428|    387|    }
  429|       |    #[inline]
  430|    105|    pub fn is_record(self) -> bool {
  431|    105|        self.ty().is_record()
  432|    105|    }
  433|       |    #[inline]
  434|      0|    pub fn is_enum(self) -> bool {
  435|      0|        self.ty().is_enum()
  436|      0|    }
  437|       |    #[inline]
  438|      0|    pub fn is_builtin(self) -> bool {
  439|      0|        self.ty().is_builtin()
  440|      0|    }
  441|       |    #[inline]
  442|    163|    pub fn is_void(self) -> bool {
  443|    163|        self.ty().is_void()
  444|    163|    }
  445|       |    #[inline]
  446|     21|    pub fn is_integer(self) -> bool {
  447|     21|        self.ty().is_integer()
  448|     21|    }
  449|       |    #[inline]
  450|      0|    pub fn is_floating(self) -> bool {
  451|      0|        self.ty().is_floating()
  452|      0|    }
  453|       |    #[inline]
  454|  1.28k|    pub fn is_arithmetic(self) -> bool {
  455|  1.28k|        self.ty().is_arithmetic()
  456|  1.28k|    }
  457|       |    #[inline]
  458|     70|    pub fn is_scalar(self) -> bool {
  459|     70|        self.ty().is_scalar()
  460|     70|    }
  461|       |}
  462|       |
  463|       |impl Display for QualType {
  464|      4|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  465|      4|        let quals = self.qualifiers();
  466|      4|        if !quals.is_empty() {
  467|      0|            write!(f, "{} ", quals)?;
  468|      4|        }
  469|      4|        write!(f, "{}", self.ty())
  470|      4|    }
  471|       |}
  472|       |
  473|       |const _: () = assert!(std::mem::size_of::<QualType>() == 4);
  474|       |
  475|       |/// The kind of type
  476|       |#[derive(Debug, Clone, PartialEq, Default)]
  477|       |pub enum TypeKind {
  478|       |    Builtin(BuiltinType),
  479|       |    Complex {
  480|       |        base_type: TypeRef,
  481|       |    },
  482|       |    Pointer {
  483|       |        pointee: QualType,
  484|       |    },
  485|       |    Array {
  486|       |        element_type: TypeRef,
  487|       |        size: ArraySizeType,
  488|       |    },
  489|       |    Function {
  490|       |        return_type: TypeRef,
  491|       |        parameters: Vec<FunctionParameter>,
  492|       |        is_variadic: bool,
  493|       |        is_noreturn: bool,
  494|       |    },
  495|       |    Record {
  496|       |        tag: Option<NameId>,
  497|       |        members: Vec<StructMember>,
  498|       |        is_complete: bool,
  499|       |        is_union: bool,
  500|       |    },
  501|       |    Enum {
  502|       |        tag: Option<NameId>,
  503|       |        base_type: TypeRef,
  504|       |        enumerators: Vec<EnumConstant>,
  505|       |        is_complete: bool,
  506|       |    },
  507|       |    #[default]
  508|       |    Error,
  509|       |}
  510|       |
  511|       |impl TypeKind {
  512|  4.28k|    pub fn to_class(&self) -> TypeClass {
  513|  4.28k|        match self {
  514|  3.91k|            TypeKind::Builtin(_) | TypeKind::Error => TypeClass::Builtin,
  515|      0|            TypeKind::Complex { .. } => TypeClass::Record, // Treat complex as Record for now in terms of class, or fallthrough
  516|     18|            TypeKind::Pointer { .. } => TypeClass::Pointer,
  517|     16|            TypeKind::Array { .. } => TypeClass::Array,
  518|    222|            TypeKind::Function { .. } => TypeClass::Function,
  519|    105|            TypeKind::Record { .. } => TypeClass::Record,
  520|      8|            TypeKind::Enum { .. } => TypeClass::Enum,
  521|       |        }
  522|  4.28k|    }
  523|       |}
  524|       |
  525|       |impl Display for TypeKind {
  526|     30|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  527|     30|        match self {
  528|     19|            TypeKind::Builtin(b) => match b {
  529|      2|                BuiltinType::Void => write!(f, "void"),
  530|      0|                BuiltinType::Bool => write!(f, "_Bool"),
  531|      1|                BuiltinType::Char => write!(f, "char"),
  532|      0|                BuiltinType::SChar => write!(f, "signed char"),
  533|      0|                BuiltinType::UChar => write!(f, "unsigned char"),
  534|      0|                BuiltinType::Short => write!(f, "short"),
  535|      0|                BuiltinType::UShort => write!(f, "unsigned short"),
  536|     13|                BuiltinType::Int => write!(f, "int"),
  537|      0|                BuiltinType::UInt => write!(f, "unsigned int"),
  538|      0|                BuiltinType::Long => write!(f, "long"),
  539|      0|                BuiltinType::ULong => write!(f, "unsigned long"),
  540|      0|                BuiltinType::LongLong => write!(f, "long long"),
  541|      0|                BuiltinType::ULongLong => write!(f, "unsigned long long"),
  542|      0|                BuiltinType::Float => write!(f, "float"),
  543|      3|                BuiltinType::Double => write!(f, "double"),
  544|      0|                BuiltinType::LongDouble => write!(f, "long double"),
  545|      0|                BuiltinType::Signed => write!(f, "signed"),
  546|       |            },
  547|      0|            TypeKind::Complex { .. } => write!(f, "_Complex"),
  548|      4|            TypeKind::Pointer { .. } => write!(f, "<pointer>"),
  549|      0|            TypeKind::Array { .. } => write!(f, "<array>"),
  550|      0|            TypeKind::Function { .. } => write!(f, "<function>"),
  551|      7|            TypeKind::Record { tag, is_union, .. } => {
  552|      7|                let kind_str = if *is_union { "union" } else { "struct" };
                                                            ^0
  553|      7|                if let Some(tag_name) = tag {
  554|      7|                    write!(f, "{} {}", kind_str, tag_name)
  555|       |                } else {
  556|      0|                    write!(f, "{} (anonymous)", kind_str)
  557|       |                }
  558|       |            }
  559|      0|            TypeKind::Enum { tag, .. } => {
  560|      0|                if let Some(tag_name) = tag {
  561|      0|                    write!(f, "enum {}", tag_name)
  562|       |                } else {
  563|      0|                    write!(f, "enum (anonymous)")
  564|       |                }
  565|       |            }
  566|      0|            TypeKind::Error => write!(f, "<error>"),
  567|       |        }
  568|     30|    }
  569|       |}
  570|       |
  571|       |/// Array size types
  572|       |#[derive(Debug, Clone, PartialEq, Eq, Hash)]
  573|       |pub enum ArraySizeType {
  574|       |    Constant(usize),
  575|       |    Variable(NodeRef),
  576|       |    Incomplete,
  577|       |    Star,
  578|       |}
  579|       |
  580|       |bitflags! {
  581|       |    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Default)]
  582|       |    pub struct TypeQualifiers: u8 {
  583|       |        const CONST = 1 << 0;
  584|       |        const VOLATILE = 1 << 1;
  585|       |        const RESTRICT = 1 << 2;
  586|       |        const ATOMIC = 1 << 3;
  587|       |    }
  588|       |}
  589|       |
  590|       |impl Display for TypeQualifiers {
  591|      2|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  592|      2|        if self.contains(TypeQualifiers::CONST) {
  593|      2|            write!(f, "const")?;
                                            ^0
  594|      0|        }
  595|      2|        if self.contains(TypeQualifiers::VOLATILE) {
  596|      0|            write!(f, "volatile")?;
  597|      2|        }
  598|      2|        if self.contains(TypeQualifiers::RESTRICT) {
  599|      0|            write!(f, "restrict")?;
  600|      2|        }
  601|      2|        if self.contains(TypeQualifiers::ATOMIC) {
  602|      0|            write!(f, "_Atomic")?;
  603|      2|        }
  604|       |
  605|      2|        Ok(())
  606|      2|    }
  607|       |}
  608|       |
  609|       |#[derive(Debug, Clone, PartialEq)]
  610|       |pub struct FunctionParameter {
  611|       |    pub param_type: QualType,
  612|       |    pub name: Option<NameId>,
  613|       |}
  614|       |
  615|       |#[derive(Debug, Clone, PartialEq)]
  616|       |pub struct StructMember {
  617|       |    pub name: Option<NameId>,
  618|       |    pub member_type: QualType,
  619|       |    pub bit_field_size: Option<NonZeroU16>,
  620|       |    pub span: SourceSpan,
  621|       |}
  622|       |
  623|       |#[derive(Debug, Clone, PartialEq)]
  624|       |pub struct EnumConstant {
  625|       |    pub name: NameId,
  626|       |    pub value: i64,
  627|       |    pub span: SourceSpan,
  628|       |}

/app/src/source_manager.rs:
    1|       |use hashbrown::HashMap;
    2|       |use serde::Serialize;
    3|       |use std::{cmp::Ordering, num::NonZeroU32, path::PathBuf};
    4|       |
    5|       |/// Source ID for identifying source files
    6|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize)]
    7|       |pub struct SourceId(pub(crate) NonZeroU32);
    8|       |
    9|       |impl std::fmt::Display for SourceId {
   10|      3|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   11|      3|        write!(f, "SourceId({})", self.0)
   12|      3|    }
   13|       |}
   14|       |
   15|       |impl SourceId {
   16|       |    /// create a new SourceId from a u32. panics if id is zero.
   17|  49.8k|    pub fn new(id: u32) -> Self {
   18|  49.8k|        SourceId(NonZeroU32::new(id).expect("SourceId must be non-zero"))
   19|  49.8k|    }
   20|       |
   21|  19.6k|    pub fn to_u32(&self) -> u32 {
   22|  19.6k|        self.0.get()
   23|  19.6k|    }
   24|       |}
   25|       |
   26|       |/// Source ID and byte offset.
   27|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize)]
   28|       |pub struct SourceLoc {
   29|       |    pub source_id: SourceId,
   30|       |    pub offset: u32,
   31|       |}
   32|       |
   33|       |impl Default for SourceLoc {
   34|      0|    fn default() -> Self {
   35|      0|        Self::builtin()
   36|      0|    }
   37|       |}
   38|       |
   39|       |impl SourceLoc {
   40|  49.2k|    pub fn new(source_id: SourceId, offset: u32) -> Self {
   41|  49.2k|        SourceLoc { source_id, offset }
   42|  49.2k|    }
   43|       |
   44|       |    /// built-in source location (SourceId = 1, offset = 0)
   45|  33.7k|    pub fn builtin() -> Self {
   46|  33.7k|        SourceLoc::new(SourceId::new(1), 0)
   47|  33.7k|    }
   48|       |
   49|  15.6k|    pub fn source_id(&self) -> SourceId {
   50|  15.6k|        self.source_id
   51|  15.6k|    }
   52|       |
   53|  11.5k|    pub fn offset(&self) -> u32 {
   54|  11.5k|        self.offset
   55|  11.5k|    }
   56|       |}
   57|       |
   58|       |impl std::fmt::Display for SourceLoc {
   59|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   60|      0|        write!(f, "SourceLoc(source_id={}, offset={})", self.source_id, self.offset)
   61|      0|    }
   62|       |}
   63|       |
   64|       |/// Represents a range in the source file.
   65|       |/// Packed representation (64 bits total):
   66|       |/// - Bits 0-23: Offset (24 bits) - Max 16 MiB
   67|       |/// - Bits 24-39: Length (16 bits) - Max 64 KiB
   68|       |/// - Bits 40-63: SourceId (24 bits) - Max ~16M files
   69|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize)]
   70|       |pub struct SourceSpan(u64);
   71|       |
   72|       |impl Default for SourceSpan {
   73|     90|    fn default() -> Self {
   74|     90|        Self::empty()
   75|     90|    }
   76|       |}
   77|       |
   78|       |impl SourceSpan {
   79|       |    const OFFSET_BITS: u64 = 24;
   80|       |    const LENGTH_BITS: u64 = 16;
   81|       |    const SOURCE_ID_BITS: u64 = 24;
   82|       |
   83|       |    const OFFSET_MASK: u64 = (1 << Self::OFFSET_BITS) - 1;
   84|       |    const LENGTH_MASK: u64 = (1 << Self::LENGTH_BITS) - 1;
   85|       |    const SOURCE_ID_MASK: u64 = (1 << Self::SOURCE_ID_BITS) - 1;
   86|       |
   87|       |    const LENGTH_SHIFT: u64 = Self::OFFSET_BITS;
   88|       |    const SOURCE_ID_SHIFT: u64 = Self::OFFSET_BITS + Self::LENGTH_BITS;
   89|       |
   90|       |    const MAX_OFFSET: u32 = Self::OFFSET_MASK as u32;
   91|       |    const MAX_LENGTH: u32 = Self::LENGTH_MASK as u32;
   92|       |    const MAX_SOURCE_ID: u32 = Self::SOURCE_ID_MASK as u32;
   93|       |
   94|  8.32k|    pub fn new(start: SourceLoc, end: SourceLoc) -> Self {
   95|  8.32k|        if start.source_id != end.source_id {
   96|       |            // Panic removed: When start and end are in different files (e.g. usage of macro vs macro expansion),
   97|       |            // we cannot represent the span correctly in our packed format.
   98|       |            // Gracefully degrade to a zero-length span at the start location.
   99|      0|            return Self::new_with_length(start.source_id, start.offset, 0);
  100|  8.32k|        }
  101|       |
  102|  8.32k|        let source_id = start.source_id.to_u32();
  103|  8.32k|        if source_id > Self::MAX_SOURCE_ID {
  104|      0|            panic!("SourceId exceeds 24-bit limit: {}", source_id);
  105|  8.32k|        }
  106|       |
  107|  8.32k|        let offset = start.offset;
  108|  8.32k|        let mut length = end.offset.saturating_sub(offset);
  109|       |
  110|  8.32k|        if offset > Self::MAX_OFFSET {
  111|      1|            panic!("SourceSpan offset exceeds 16 MiB limit: {}", offset);
  112|  8.32k|        }
  113|       |
  114|  8.32k|        if length > Self::MAX_LENGTH {
  115|      1|            // Cap length if it's too long
  116|      1|            length = Self::MAX_LENGTH;
  117|  8.31k|        }
  118|       |
  119|  8.32k|        let packed = (offset as u64 & Self::OFFSET_MASK)
  120|  8.32k|            | ((length as u64 & Self::LENGTH_MASK) << Self::LENGTH_SHIFT)
  121|  8.32k|            | ((source_id as u64 & Self::SOURCE_ID_MASK) << Self::SOURCE_ID_SHIFT);
  122|       |
  123|  8.32k|        Self(packed)
  124|  8.32k|    }
  125|       |
  126|  11.2k|    pub fn new_with_length(source_id: SourceId, offset: u32, length: u32) -> Self {
  127|  11.2k|        let id = source_id.to_u32();
  128|  11.2k|        if id > Self::MAX_SOURCE_ID {
  129|      0|            panic!("SourceId exceeds 24-bit limit: {}", id);
  130|  11.2k|        }
  131|       |
  132|  11.2k|        if offset > Self::MAX_OFFSET {
  133|      1|            panic!("SourceSpan offset exceeds 16 MiB limit: {}", offset);
  134|  11.2k|        }
  135|       |
  136|  11.2k|        let mut len = length;
  137|  11.2k|        if len > Self::MAX_LENGTH {
  138|      1|            len = Self::MAX_LENGTH;
  139|  11.2k|        }
  140|       |
  141|  11.2k|        let packed = (offset as u64 & Self::OFFSET_MASK)
  142|  11.2k|            | ((len as u64 & Self::LENGTH_MASK) << Self::LENGTH_SHIFT)
  143|  11.2k|            | ((id as u64 & Self::SOURCE_ID_MASK) << Self::SOURCE_ID_SHIFT);
  144|       |
  145|  11.2k|        Self(packed)
  146|  11.2k|    }
  147|       |
  148|  4.18k|    pub fn empty() -> Self {
  149|  4.18k|        Self::new(SourceLoc::builtin(), SourceLoc::builtin())
  150|  4.18k|    }
  151|       |
  152|      7|    pub fn dummy() -> Self {
  153|      7|        Self::empty()
  154|      7|    }
  155|       |
  156|  5.44k|    pub fn start(&self) -> SourceLoc {
  157|  5.44k|        let offset = (self.0 & Self::OFFSET_MASK) as u32;
  158|  5.44k|        SourceLoc {
  159|  5.44k|            source_id: self.source_id(),
  160|  5.44k|            offset,
  161|  5.44k|        }
  162|  5.44k|    }
  163|       |
  164|  4.92k|    pub fn end(&self) -> SourceLoc {
  165|  4.92k|        let offset = (self.0 & Self::OFFSET_MASK) as u32;
  166|  4.92k|        let length = ((self.0 >> Self::LENGTH_SHIFT) & Self::LENGTH_MASK) as u32;
  167|  4.92k|        SourceLoc {
  168|  4.92k|            source_id: self.source_id(),
  169|  4.92k|            offset: offset + length,
  170|  4.92k|        }
  171|  4.92k|    }
  172|       |
  173|  12.4k|    pub fn source_id(&self) -> SourceId {
  174|  12.4k|        let id = ((self.0 >> Self::SOURCE_ID_SHIFT) & Self::SOURCE_ID_MASK) as u32;
  175|  12.4k|        SourceId::new(id)
  176|  12.4k|    }
  177|       |
  178|      0|    pub fn is_source_id_builtin(&self) -> bool {
  179|      0|        self.source_id().to_u32() == 1
  180|      0|    }
  181|       |
  182|      0|    pub fn is_empty(&self) -> bool {
  183|       |        // Length is bits 24-39
  184|      0|        ((self.0 >> Self::LENGTH_SHIFT) & Self::LENGTH_MASK) == 0
  185|      0|    }
  186|       |
  187|       |    /// Merge two source spans into a single span covering both
  188|  1.04k|    pub fn merge(self, other: SourceSpan) -> SourceSpan {
  189|  1.04k|        let id1 = self.source_id();
  190|  1.04k|        let id2 = other.source_id();
  191|       |
  192|  1.04k|        if id1 != id2 {
  193|      0|            return self;
  194|  1.04k|        }
  195|       |
  196|  1.04k|        let start1 = self.start().offset;
  197|  1.04k|        let end1 = self.end().offset;
  198|  1.04k|        let start2 = other.start().offset;
  199|  1.04k|        let end2 = other.end().offset;
  200|       |
  201|  1.04k|        let min_start = start1.min(start2);
  202|  1.04k|        let max_end = end1.max(end2);
  203|       |
  204|  1.04k|        let start_loc = SourceLoc::new(id1, min_start);
  205|  1.04k|        let end_loc = SourceLoc::new(id1, max_end);
  206|       |
  207|  1.04k|        Self::new(start_loc, end_loc)
  208|  1.04k|    }
  209|       |}
  210|       |
  211|       |impl std::fmt::Display for SourceSpan {
  212|      2|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  213|      2|        write!(
  214|      2|            f,
  215|      2|            "SourceSpan(source_id={}, start={}, end={})",
  216|      2|            self.source_id(),
  217|      2|            self.start().offset,
  218|      2|            self.end().offset
  219|       |        )
  220|      2|    }
  221|       |}
  222|       |
  223|       |/// Represents a single #line directive entry
  224|       |#[derive(Debug, Clone, PartialEq, Eq)]
  225|       |pub struct LineDirective {
  226|       |    pub physical_line: u32,
  227|       |    pub logical_line: u32,
  228|       |    pub logical_file: Option<String>,
  229|       |}
  230|       |
  231|       |impl LineDirective {
  232|    113|    pub fn new(physical_line: u32, logical_line: u32, logical_file: Option<String>) -> Self {
  233|    113|        LineDirective {
  234|    113|            physical_line,
  235|    113|            logical_line,
  236|    113|            logical_file,
  237|    113|        }
  238|    113|    }
  239|       |}
  240|       |
  241|       |impl Ord for LineDirective {
  242|      2|    fn cmp(&self, other: &Self) -> Ordering {
  243|      2|        self.physical_line.cmp(&other.physical_line)
  244|      2|    }
  245|       |}
  246|       |
  247|       |impl PartialOrd for LineDirective {
  248|      1|    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
  249|      1|        Some(self.cmp(other))
  250|      1|    }
  251|       |}
  252|       |
  253|       |/// Stores all #line directives for a single file, sorted by physical line
  254|       |#[derive(Debug, Clone, Default)]
  255|       |pub struct LineMap {
  256|       |    pub(crate) entries: Vec<LineDirective>,
  257|       |}
  258|       |
  259|       |impl LineMap {
  260|  3.57k|    pub fn new() -> Self {
  261|  3.57k|        LineMap { entries: Vec::new() }
  262|  3.57k|    }
  263|       |
  264|       |    /// Add a line directive entry. Must be added in sorted order by physical_line.
  265|    110|    pub fn add_entry(&mut self, entry: LineDirective) {
  266|       |        // Ensure monotonic addition
  267|    110|        if let Some(last) = self.entries.last() {
                                  ^100
  268|    100|            assert!(
  269|    100|                entry.physical_line >= last.physical_line,
  270|      0|                "Line directives must be added in sorted order"
  271|       |            );
  272|     10|        }
  273|    110|        self.entries.push(entry);
  274|    110|    }
  275|       |
  276|       |    /// Find the presumed location for a given physical line
  277|  1.01k|    pub fn presumed_location(&self, physical_line: u32) -> (u32, Option<&str>) {
  278|       |        // Binary search to find the last entry where physical_line <= target
  279|  8.01k|        let idx = self.entries.partition_point(|e| e.physical_line <= physical_line);
                          ^1.01k^1.01k       ^1.01k
  280|       |
  281|  1.01k|        if idx == 0 {
  282|       |            // No mapping, use physical line
  283|      4|            (physical_line, None)
  284|       |        } else {
  285|  1.00k|            let entry = &self.entries[idx - 1];
  286|  1.00k|            let logical_line = entry.logical_line + (physical_line - entry.physical_line);
  287|       |            // If entry has no logical file, it means no change from physical file
  288|  1.00k|            (logical_line, entry.logical_file.as_deref())
  289|       |        }
  290|  1.01k|    }
  291|       |}
  292|       |
  293|       |/// File information for tracking source files
  294|       |#[derive(Debug)]
  295|       |pub struct FileInfo {
  296|       |    pub file_id: SourceId,
  297|       |    pub path: PathBuf,
  298|       |    pub size: u32,
  299|       |    pub buffer_index: usize,            // Index into buffers Vec
  300|       |    pub line_starts: Vec<u32>,          // Line start offsets for efficient line lookup
  301|       |    pub line_map: LineMap,              // #line directive mappings
  302|       |    pub include_loc: Option<SourceLoc>, // Location where this file was included/expanded from
  303|       |}
  304|       |
  305|       |/// Manages source files and locations
  306|       |/// File size limit: 4 MiB per file (22-bit offset in SourceLoc)
  307|       |/// Maximum files: 1023 unique source files (10-bit file ID in SourceLoc)
  308|       |pub struct SourceManager {
  309|       |    buffers: Vec<Vec<u8>>, // Use Rust Vec<u8>
  310|       |    file_infos: HashMap<SourceId, FileInfo>,
  311|       |    next_file_id: u32,
  312|       |}
  313|       |
  314|       |impl SourceManager {
  315|    715|    pub fn new() -> Self {
  316|    715|        SourceManager {
  317|    715|            buffers: Vec::new(),
  318|    715|            file_infos: HashMap::new(),
  319|    715|            next_file_id: 2, // Start from 2, reserve 1 for built-ins
  320|    715|        }
  321|    715|    }
  322|       |
  323|       |    /// Add a file to the source manager from a file path
  324|       |    /// Since we only support UTF-8, we can read directly as bytes and assume validity
  325|     12|    pub fn add_file_from_path(
  326|     12|        &mut self,
  327|     12|        path: &std::path::Path,
  328|     12|        include_loc: Option<SourceLoc>,
  329|     12|    ) -> Result<SourceId, std::io::Error> {
  330|     12|        let buffer = std::fs::read(path)?;
                          ^11                         ^1
  331|     11|        let path_str = path.to_str().unwrap_or("<invalid-utf8>");
  332|     11|        Ok(self.add_buffer(buffer, path_str, include_loc))
  333|     12|    }
  334|       |
  335|       |    /// Add a buffer to the source manager with raw bytes (UTF-8 assumed)
  336|  3.50k|    pub fn add_buffer(&mut self, buffer: Vec<u8>, path: &str, include_loc: Option<SourceLoc>) -> SourceId {
  337|  3.50k|        let file_id = SourceId::new(self.next_file_id);
  338|  3.50k|        self.next_file_id += 1;
  339|       |
  340|  3.50k|        let size = buffer.len() as u32;
  341|  3.50k|        let buffer_index = self.buffers.len();
  342|  3.50k|        self.buffers.push(buffer);
  343|       |
  344|  3.50k|        let file_info = FileInfo {
  345|  3.50k|            file_id,
  346|  3.50k|            path: PathBuf::from(path),
  347|  3.50k|            size,
  348|  3.50k|            buffer_index,
  349|  3.50k|            line_starts: Vec::new(),
  350|  3.50k|            line_map: LineMap::new(),
  351|  3.50k|            include_loc,
  352|  3.50k|        };
  353|       |
  354|  3.50k|        self.file_infos.insert(file_id, file_info);
  355|       |
  356|  3.50k|        file_id
  357|  3.50k|    }
  358|       |
  359|       |    /// Add a virtual buffer for macro expansions (Level B support)
  360|       |    /// Virtual buffers contain expanded macro text with proper sequential locations
  361|     66|    pub fn add_virtual_buffer(&mut self, buffer: Vec<u8>, name: &str, include_loc: Option<SourceLoc>) -> SourceId {
  362|     66|        let file_id = SourceId::new(self.next_file_id);
  363|     66|        self.next_file_id += 1;
  364|       |
  365|     66|        let size = buffer.len() as u32;
  366|     66|        let buffer_index = self.buffers.len();
  367|     66|        self.buffers.push(buffer);
  368|       |
  369|       |        // Calculate line starts for the virtual buffer
  370|     66|        let mut line_starts = vec![0]; // First line starts at offset 0
  371|    388|        for (i, &byte) in self.buffers[buffer_index].iter().enumerate() {
                                        ^66                               ^66
  372|    388|            if byte == b'\n' {
  373|      2|                line_starts.push((i + 1) as u32);
  374|    386|            }
  375|       |        }
  376|       |
  377|     66|        let file_info = FileInfo {
  378|     66|            file_id,
  379|     66|            path: PathBuf::from(format!("<{}>", name)), // Virtual files use <> notation
  380|     66|            size,
  381|     66|            buffer_index,
  382|     66|            line_starts,
  383|     66|            line_map: LineMap::new(),
  384|     66|            include_loc,
  385|     66|        };
  386|       |
  387|     66|        self.file_infos.insert(file_id, file_info);
  388|       |
  389|     66|        file_id
  390|     66|    }
  391|       |
  392|       |    /// Get the buffer for a given source ID
  393|       |    /// Since SourceId is always valid (we panic if not found), we can use indexing
  394|       |    /// use get_source_text to get &str from SourceSpan instead if you need text
  395|    767|    pub fn get_buffer(&self, source_id: SourceId) -> &[u8] {
  396|    767|        let info = match self.file_infos.get(&source_id) {
                          ^766
  397|    766|            Some(info) => info,
  398|      1|            None => panic!("invalid source_id {source_id}"),
  399|       |        };
  400|    766|        &self.buffers[info.buffer_index][..]
  401|    766|    }
  402|       |
  403|       |    /// Get file info for a given source ID
  404|  4.32k|    pub fn get_file_info(&self, source_id: SourceId) -> Option<&FileInfo> {
  405|  4.32k|        self.file_infos.get(&source_id)
  406|  4.32k|    }
  407|       |
  408|       |    /// Get file info for a given source ID
  409|     24|    pub fn get_file_id(&self, path: &str) -> Option<SourceId> {
  410|     99|        for (id, info) in self.file_infos.iter() {
                                        ^24             ^24
  411|     99|            if info.path == std::path::Path::new(path) {
  412|     23|                return Some(*id);
  413|     76|            }
  414|       |        }
  415|      1|        None
  416|     24|    }
  417|       |
  418|       |    /// Get mutable access to the LineMap for a given source ID
  419|      5|    pub(crate) fn get_line_map_mut(&mut self, source_id: SourceId) -> Option<&mut LineMap> {
  420|      5|        self.file_infos.get_mut(&source_id).map(|fi| &mut fi.line_map)
  421|      5|    }
  422|       |
  423|       |    /// Set line starts for a given source ID
  424|  1.34k|    pub(crate) fn set_line_starts(&mut self, source_id: SourceId, line_starts: Vec<u32>) {
  425|  1.34k|        if let Some(file_info) = self.file_infos.get_mut(&source_id) {
                                  ^1.34k
  426|  1.34k|            file_info.line_starts = line_starts;
  427|  1.34k|        }
                      ^1
  428|  1.34k|    }
  429|       |
  430|       |    /// Calculate line starts for a given source ID (for testing)
  431|       |    #[cfg(test)]
  432|      5|    pub(crate) fn calculate_line_starts_for_test(&mut self, source_id: SourceId) {
  433|      5|        if let Some(file_info) = self.file_infos.get_mut(&source_id) {
                                  ^4
  434|      4|            let buffer = &self.buffers[file_info.buffer_index];
  435|      4|            let mut line_starts = vec![0]; // First line starts at offset 0
  436|       |
  437|     74|            for (i, &byte) in buffer.iter().enumerate() {
                                            ^4            ^4
  438|     74|                if byte == b'\n' {
  439|      9|                    line_starts.push((i + 1) as u32);
  440|     65|                }
  441|       |            }
  442|       |
  443|      4|            file_info.line_starts = line_starts;
  444|      1|        }
  445|      5|    }
  446|       |
  447|       |    /// Get the source text for a given span
  448|       |    /// Since we only support UTF-8, we can assume the bytes are valid UTF-8
  449|      2|    pub fn get_source_text(&self, span: SourceSpan) -> &str {
  450|      2|        let buffer = self.get_buffer(span.source_id());
  451|      2|        let start = span.start().offset() as usize;
  452|      2|        let end = span.end().offset() as usize;
  453|       |
  454|      2|        if start <= end && end <= buffer.len() {
  455|      1|            unsafe { std::str::from_utf8_unchecked(&buffer[start..end]) }
  456|       |        } else {
  457|      1|            panic!("Invalid span range");
  458|       |        }
  459|      1|    }
  460|       |
  461|       |    /// Get line and column for a source location
  462|     32|    pub fn get_line_column(&self, loc: SourceLoc) -> Option<(u32, u32)> {
  463|     32|        let file_info = self.get_file_info(loc.source_id())?;
                          ^31                                            ^1
  464|     31|        let offset = loc.offset();
  465|       |
  466|     31|        let line_starts = &file_info.line_starts;
  467|     31|        if line_starts.is_empty() {
  468|       |            // If line_starts not calculated yet, assume single line starting at 0
  469|      1|            return Some((1, offset + 1));
  470|     30|        }
  471|       |
  472|       |        // Binary search to find the line
  473|     30|        let mut left = 0;
  474|     30|        let mut right = line_starts.len();
  475|       |
  476|    106|        while left < right {
  477|     76|            let mid = left + (right - left) / 2;
  478|     76|            if line_starts[mid] <= offset {
  479|     37|                left = mid + 1;
  480|     39|            } else {
  481|     39|                right = mid;
  482|     39|            }
  483|       |        }
  484|       |
  485|     30|        let line = (left.wrapping_sub(1)) as u32;
  486|     30|        let column = if line < line_starts.len() as u32 {
  487|     29|            offset - line_starts[line as usize]
  488|       |        } else {
  489|      1|            0
  490|       |        };
  491|       |
  492|     30|        Some((line.wrapping_add(1), column + 1)) // 1-based indexing
  493|     32|    }
  494|       |
  495|       |    /// Get the presumed location (logical line and file) for a source location
  496|      6|    pub(crate) fn get_presumed_location(&self, loc: SourceLoc) -> Option<(u32, u32, Option<&str>)> {
  497|      6|        let file_info = self.get_file_info(loc.source_id())?;
                          ^5                                             ^1
  498|      5|        let physical_line = self.get_line_column(loc)?.0;
                                                                   ^0
  499|       |
  500|      5|        let (logical_line, logical_file) = file_info.line_map.presumed_location(physical_line);
  501|      5|        let column = self.get_line_column(loc)?.1;
                                                            ^0
  502|       |
  503|       |        // If no logical file specified, use the physical filename
  504|      5|        let filename = logical_file.or_else(|| file_info.path.to_str());
                                                             ^2             ^2
  505|       |
  506|      5|        Some((logical_line, column, filename))
  507|      6|    }
  508|       |}
  509|       |
  510|       |impl Default for SourceManager {
  511|      0|    fn default() -> Self {
  512|      0|        Self::new()
  513|      0|    }
  514|       |}