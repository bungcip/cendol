/app/src/ast.rs:
    1|       |//! Abstract Syntax Tree (AST) for C11 compiler.
    2|       |//!
    3|       |//! This module provides the core AST data structures and APIs for representing
    4|       |//! C11 programs. The AST is designed as a flattened storage system for efficiency,
    5|       |//! with index-based references to child nodes and types.
    6|       |//!
    7|       |//! ## Architecture
    8|       |//!
    9|       |//! The AST is organized into focused submodules for better maintainability:
   10|       |//!
   11|       |//! - [`nodes`]: Node definitions, constructors, and builder patterns for AST nodes
   12|       |//! - [`types`]: Type system representation and utilities for semantic analysis
   13|       |//!
   14|       |//! ## Key Features
   15|       |//!
   16|       |//! - **Flattened Storage**: All AST nodes are stored in contiguous vectors with index-based references
   17|       |//! - **Interior Mutability**: Uses `Cell` for type annotations without requiring mutable AST access
   18|       |//! - **Builder Patterns**: Ergonomic constructors for complex AST nodes
   19|       |//! - **Type System**: Canonical types distinct from syntactic type specifiers
   20|       |//!
   21|       |
   22|       |use std::num::NonZeroU32;
   23|       |
   24|       |/// Represents an interned string using symbol_table crate.
   25|       |/// Alias for GlobalSymbol from symbol_table crate with global feature.
   26|       |pub type NameId = symbol_table::GlobalSymbol;
   27|       |pub type StringId = NameId;
   28|       |
   29|       |use crate::semantic::{QualType, ScopeId, SemanticInfo, SymbolRef, TypeRef, ValueCategory};
   30|       |pub use crate::source_manager::{SourceId, SourceLoc, SourceSpan};
   31|       |
   32|       |// Submodules
   33|       |// Submodules
   34|       |pub mod dumper;
   35|       |pub mod literal;
   36|       |pub mod literal_parsing;
   37|       |pub mod nodes;
   38|       |pub mod parsed;
   39|       |pub mod parsed_types;
   40|       |
   41|       |// Re-export commonly used items for convenience
   42|       |pub use nodes::*;
   43|       |pub use parsed::*;
   44|       |pub use parsed_types::*;
   45|       |
   46|       |// Re-export operators that are used throughout the codebase
   47|       |pub use nodes::{BinaryOp, UnaryOp};
   48|       |
   49|       |/// The flattened AST storage.
   50|       |/// Contains all AST nodes, types, symbol entries in contiguous vectors.
   51|       |#[derive(Clone, Default)]
   52|       |pub struct Ast {
   53|       |    pub kinds: Vec<NodeKind>,
   54|       |    pub spans: Vec<SourceSpan>,
   55|       |    pub semantic_info: Option<SemanticInfo>, // Populated after type resolution
   56|       |}
   57|       |
   58|       |impl Ast {
   59|       |    /// Create a new empty AST
   60|    534|    pub(crate) fn new() -> Self {
   61|    534|        Ast::default()
   62|    534|    }
   63|       |
   64|       |    /// Add a node to the AST and return its reference
   65|  6.58k|    pub(crate) fn push_node(&mut self, kind: NodeKind, span: SourceSpan) -> NodeRef {
   66|  6.58k|        let index = self.kinds.len() as u32 + 1; // Start from 1 for NonZeroU32
   67|  6.58k|        self.kinds.push(kind);
   68|  6.58k|        self.spans.push(span);
   69|  6.58k|        NodeRef::new(index).expect("NodeRef overflow")
   70|  6.58k|    }
   71|       |
   72|       |    /// Add a dummy node to the AST and return its reference
   73|  6.41k|    pub(crate) fn push_dummy(&mut self, span: SourceSpan) -> NodeRef {
   74|  6.41k|        self.push_node(NodeKind::Dummy, span)
   75|  6.41k|    }
   76|       |
   77|       |    /// Get node kind by reference
   78|  18.2k|    pub(crate) fn get_kind(&self, node_ref: NodeRef) -> &NodeKind {
   79|  18.2k|        &self.kinds[node_ref.index()]
   80|  18.2k|    }
   81|       |
   82|       |    /// Get node span by reference
   83|    970|    pub(crate) fn get_span(&self, node_ref: NodeRef) -> SourceSpan {
   84|    970|        self.spans[node_ref.index()]
   85|    970|    }
   86|       |
   87|       |    /// get root node ref
   88|    578|    pub(crate) fn get_root(&self) -> NodeRef {
   89|    578|        NodeRef::ROOT
   90|    578|    }
   91|       |
   92|    666|    pub(crate) fn scope_of(&self, node_ref: NodeRef) -> ScopeId {
   93|    666|        match &self.kinds[node_ref.index()] {
   94|    209|            NodeKind::TranslationUnit(data) => data.scope_id,
   95|    215|            NodeKind::Function(data) => data.scope_id,
   96|      1|            NodeKind::FunctionDecl(data) => data.scope_id,
   97|    237|            NodeKind::CompoundStatement(data) => data.scope_id,
   98|      4|            NodeKind::For(data) => data.scope_id,
   99|      0|            _ => panic!("ICE: Node {:?} does not have a scope", self.get_kind(node_ref)),
  100|       |        }
  101|    666|    }
  102|       |
  103|       |    /// attach semantic info side table for AST (populated after type resolution)
  104|    248|    pub(crate) fn attach_semantic_info(&mut self, semantic_info: SemanticInfo) {
  105|    248|        self.semantic_info = Some(semantic_info);
  106|    248|    }
  107|       |}
  108|       |
  109|       |/// Node reference type for referencing child nodes.
  110|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
  111|       |pub struct NodeRef(NonZeroU32);
  112|       |
  113|       |impl NodeRef {
  114|       |    pub const ROOT: NodeRef = NodeRef(NonZeroU32::new(1).unwrap());
  115|       |
  116|  17.9k|    pub(crate) fn new(value: u32) -> Option<Self> {
  117|  17.9k|        NonZeroU32::new(value).map(Self)
  118|  17.9k|    }
  119|       |
  120|  50.5k|    pub(crate) fn get(self) -> u32 {
  121|  50.5k|        self.0.get()
  122|  50.5k|    }
  123|       |
  124|  36.6k|    pub(crate) fn index(self) -> usize {
  125|  36.6k|        (self.get() - 1) as usize
  126|  36.6k|    }
  127|       |
  128|       |    /// Create an iterator over a range of consecutive NodeRefs, starting from `self`.
  129|       |    #[inline]
  130|  4.19k|    pub(crate) fn range(self, len: impl Into<u32>) -> NodeRefRange {
  131|  4.19k|        NodeRefRange {
  132|  4.19k|            current: self.get(),
  133|  4.19k|            end: self.get() + len.into(),
  134|  4.19k|        }
  135|  4.19k|    }
  136|       |}
  137|       |
  138|       |/// An iterator over a contiguous range of `NodeRef`s.
  139|       |#[derive(Clone, Debug)]
  140|       |pub struct NodeRefRange {
  141|       |    current: u32,
  142|       |    end: u32,
  143|       |}
  144|       |
  145|       |impl Iterator for NodeRefRange {
  146|       |    type Item = NodeRef;
  147|       |
  148|       |    #[inline]
  149|  10.9k|    fn next(&mut self) -> Option<Self::Item> {
  150|  10.9k|        if self.current < self.end {
  151|  6.78k|            let node = NodeRef::new(self.current).expect("NodeRef overflow in range");
  152|  6.78k|            self.current += 1;
  153|  6.78k|            Some(node)
  154|       |        } else {
  155|  4.19k|            None
  156|       |        }
  157|  10.9k|    }
  158|       |
  159|       |    #[inline]
  160|     22|    fn size_hint(&self) -> (usize, Option<usize>) {
  161|     22|        let len = (self.end - self.current) as usize;
  162|     22|        (len, Some(len))
  163|     22|    }
  164|       |}
  165|       |
  166|       |impl ExactSizeIterator for NodeRefRange {}
  167|       |
  168|       |impl Ast {
  169|       |    /// Get the resolved type for a node (reads from attached semantic_info)
  170|  3.32k|    pub(crate) fn get_resolved_type(&self, node_ref: NodeRef) -> Option<QualType> {
  171|  3.32k|        self.semantic_info.as_ref()?.types[node_ref.index()]
                                                 ^0
  172|  3.32k|    }
  173|       |
  174|       |    /// Get the value category for a node (reads from attached semantic_info)
  175|    107|    pub(crate) fn get_value_category(&self, node_ref: NodeRef) -> Option<ValueCategory> {
  176|    107|        self.semantic_info
  177|    107|            .as_ref()?
                                   ^0
  178|       |            .value_categories
  179|    107|            .get(node_ref.index())
  180|    107|            .copied()
  181|    107|    }
  182|       |}

/app/src/ast/dumper.rs:
    1|       |//! AST Dumper module
    2|       |//!
    3|       |//! This module handles AST dumping for debugging and visualization.
    4|       |
    5|       |use hashbrown::HashSet;
    6|       |use std::fmt;
    7|       |
    8|       |use crate::ast::literal;
    9|       |use crate::ast::parsed::{ParsedAst, ParsedNodeKind};
   10|       |use crate::ast::{Ast, DesignatedInitializer, Designator, NodeKind};
   11|       |use crate::semantic::{ArraySizeType, BuiltinType, SymbolRef, SymbolTable, TypeKind, TypeRef, TypeRegistry};
   12|       |
   13|       |pub struct ParsedAstDisplay<'a>(pub &'a ParsedAst);
   14|       |
   15|       |impl<'a> fmt::Display for ParsedAstDisplay<'a> {
   16|     23|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   17|     23|        let ast = self.0;
   18|    298|        for (i, node) in ast.nodes.iter().enumerate() {
                                       ^23              ^23
   19|    298|            if matches!(node.kind, ParsedNodeKind::Dummy) {
                             ^278
   20|     20|                continue;
   21|    278|            }
   22|    278|            write!(f, "{}: ", i + 1)?;
                                                  ^0
   23|    278|            AstDumper::dump_parsed_node_kind(f, &node.kind, ast)?;
                                                                              ^0
   24|       |        }
   25|     23|        Ok(())
   26|     23|    }
   27|       |}
   28|       |
   29|       |pub struct ParserAstDisplay<'a> {
   30|       |    pub ast: &'a Ast,
   31|       |    pub symbol_table: Option<&'a SymbolTable>,
   32|       |}
   33|       |
   34|       |impl<'a> fmt::Display for ParserAstDisplay<'a> {
   35|     15|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   36|     15|        let ast = self.ast;
   37|    213|        for (i, kind) in ast.kinds.iter().enumerate() {
                                       ^15              ^15
   38|    213|            if matches!(kind, NodeKind::Dummy) {
                             ^212
   39|      1|                continue;
   40|    212|            }
   41|    212|            write!(f, "{}: ", i + 1)?;
                                                  ^0
   42|    212|            AstDumper::dump_parser_kind(f, kind, ast, self.symbol_table)?;
                                                                                      ^0
   43|       |        }
   44|     15|        Ok(())
   45|     15|    }
   46|       |}
   47|       |
   48|       |pub struct TypeRegistryDisplay<'a> {
   49|       |    pub ast: &'a Ast,
   50|       |    pub registry: &'a TypeRegistry,
   51|       |}
   52|       |
   53|       |impl<'a> fmt::Display for TypeRegistryDisplay<'a> {
   54|      3|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
   55|       |        // Collect all TypeRefs used in the AST
   56|      3|        let mut used_type_refs = HashSet::new();
   57|       |
   58|     53|        for kind in &self.ast.kinds {
                          ^50
   59|     50|            AstDumper::collect_type_refs_from_node(kind, &mut used_type_refs);
   60|     50|        }
   61|       |
   62|      3|        if used_type_refs.is_empty() {
   63|      0|            return Ok(());
   64|      3|        }
   65|       |
   66|       |        // Print header
   67|      3|        writeln!(f, "\n=== TypeRegistry (Used TypeRefs) ===")?;
                                                                           ^0
   68|       |
   69|       |        // Sort TypeRefs for consistent output
   70|      3|        let mut sorted_type_refs: Vec<_> = used_type_refs.into_iter().collect();
   71|     56|        sorted_type_refs.sort_by_key(|ty_ref| ty_ref.get());
                      ^3               ^3
   72|       |
   73|       |        // Dump each used TypeRef with user-friendly formatting
   74|     18|        for ty_ref in sorted_type_refs {
                          ^15
   75|     15|            let ty = self.registry.get(ty_ref);
   76|     15|            let formatted_type = AstDumper::format_type_kind_user_friendly(&ty.kind, self.registry);
   77|     15|            writeln!(f, "TypeRef({}): {}", ty_ref.base(), formatted_type)?;
                                                                                       ^0
   78|       |        }
   79|      3|        Ok(())
   80|      3|    }
   81|       |}
   82|       |
   83|       |/// Dumper for AST
   84|       |pub(crate) struct AstDumper;
   85|       |
   86|       |impl AstDumper {
   87|       |    /// Dump parsed AST to stdout
   88|     23|    pub(crate) fn dump_parsed_ast(ast: &ParsedAst) -> ParsedAstDisplay<'_> {
   89|     23|        ParsedAstDisplay(ast)
   90|     23|    }
   91|       |
   92|       |    /// Dump parser AST to stdout
   93|     15|    pub(crate) fn dump_parser<'a>(ast: &'a Ast, symbol_table: Option<&'a SymbolTable>) -> ParserAstDisplay<'a> {
   94|     15|        ParserAstDisplay { ast, symbol_table }
   95|     15|    }
   96|       |
   97|       |    /// Dump TypeRegistry information for used TypeRefs in the AST
   98|      3|    pub(crate) fn dump_type_registry<'a>(ast: &'a Ast, registry: &'a TypeRegistry) -> TypeRegistryDisplay<'a> {
   99|      3|        TypeRegistryDisplay { ast, registry }
  100|      3|    }
  101|       |
  102|       |    /// Format TypeKind in a user-friendly way for TypeRegistry dump
  103|       |    #[allow(clippy::only_used_in_recursion)]
  104|     24|    fn format_type_kind_user_friendly(kind: &TypeKind, registry: &TypeRegistry) -> String {
  105|     24|        match kind {
  106|       |            // Basic types - use the existing dump format
  107|     13|            TypeKind::Builtin(b) => match b {
  108|      2|                BuiltinType::Void => "void".to_string(),
  109|      0|                BuiltinType::Bool => "_Bool".to_string(),
  110|      0|                BuiltinType::Char => "char".to_string(),
  111|      0|                BuiltinType::SChar => "signed char".to_string(),
  112|      0|                BuiltinType::UChar => "unsigned char".to_string(),
  113|      0|                BuiltinType::Short => "short".to_string(),
  114|      0|                BuiltinType::UShort => "unsigned short".to_string(),
  115|      9|                BuiltinType::Int => "int".to_string(),
  116|      0|                BuiltinType::UInt => "unsigned int".to_string(),
  117|      0|                BuiltinType::Long => "long".to_string(),
  118|      0|                BuiltinType::ULong => "unsigned long".to_string(),
  119|      0|                BuiltinType::LongLong => "long long".to_string(),
  120|      0|                BuiltinType::ULongLong => "unsigned long long".to_string(),
  121|      2|                BuiltinType::Float => "float".to_string(),
  122|      0|                BuiltinType::Double => "double".to_string(),
  123|      0|                BuiltinType::LongDouble => "long double".to_string(),
  124|      0|                BuiltinType::Signed => "signed".to_string(),
  125|      0|                BuiltinType::VaList => "__builtin_va_list".to_string(),
  126|      0|                BuiltinType::Complex => "_Complex (marker)".to_string(),
  127|       |            },
  128|      1|            TypeKind::Complex { .. } => "_Complex".to_string(),
  129|      0|            TypeKind::Error => "<error>".to_string(),
  130|       |
  131|       |            // Complex types - provide more detailed information
  132|      1|            TypeKind::Pointer { pointee } => {
  133|      1|                let current_type = registry.get(pointee.ty());
  134|      1|                format!(
  135|      1|                    "{}*",
  136|      1|                    Self::format_type_kind_user_friendly(&current_type.kind, registry)
  137|       |                )
  138|       |            }
  139|      2|            TypeKind::Array { element_type, size } => {
  140|      2|                let element_str = Self::format_type_kind_user_friendly(&registry.get(*element_type).kind, registry);
  141|      2|                match size {
  142|      1|                    ArraySizeType::Constant(len) => format!("{}[{}]", element_str, len),
  143|      0|                    ArraySizeType::Incomplete => format!("{}[]", element_str),
  144|      1|                    ArraySizeType::Variable(_) => "<VLA>".to_string(),
  145|      0|                    ArraySizeType::Star => format!("{}[*]", element_str),
  146|       |                }
  147|       |            }
  148|       |            TypeKind::Function {
  149|      4|                return_type,
  150|      4|                parameters,
  151|      4|                is_variadic,
  152|       |                ..
  153|       |            } => {
  154|      4|                let return_str = Self::format_type_kind_user_friendly(&registry.get(*return_type).kind, registry);
  155|      4|                let mut param_strs = Vec::new();
  156|      4|                for param in parameters.iter() {
                                  ^2
  157|      2|                    let param_str =
  158|      2|                        Self::format_type_kind_user_friendly(&registry.get(param.param_type.ty()).kind, registry);
  159|      2|                    param_strs.push(param_str);
  160|      2|                }
  161|      4|                let params = param_strs.join(", ");
  162|      4|                let variadic = if *is_variadic { ", ..." } else { "" };
                                                               ^1               ^3
  163|      4|                format!("{}({}{})", return_str, params, variadic)
  164|       |            }
  165|      2|            TypeKind::Record { tag, is_union, .. } => {
  166|      2|                let kind_str = if *is_union { "union" } else { "struct" };
                                                            ^0
  167|      2|                if let Some(tag_name) = tag {
  168|      2|                    format!("{} {}", kind_str, tag_name)
  169|       |                } else {
  170|      0|                    format!("{} (anonymous)", kind_str)
  171|       |                }
  172|       |            }
  173|      1|            TypeKind::Enum { tag, .. } => {
  174|      1|                if let Some(tag_name) = tag {
  175|      1|                    format!("enum {}", tag_name)
  176|       |                } else {
  177|      0|                    "enum (anonymous)".to_string()
  178|       |                }
  179|       |            }
  180|       |        }
  181|     24|    }
  182|       |
  183|       |    /// Collect TypeRefs from a NodeKind
  184|     50|    fn collect_type_refs_from_node(kind: &NodeKind, type_refs: &mut HashSet<TypeRef>) {
  185|     50|        match kind {
  186|      0|            NodeKind::Designator(_) => {}
  187|      3|            NodeKind::Function(data) => {
  188|      3|                type_refs.insert(data.ty);
  189|      3|            }
  190|      1|            NodeKind::Param(data) => {
  191|      1|                type_refs.insert(data.ty.ty());
  192|      1|            }
  193|      1|            NodeKind::FunctionDecl(func_decl) => {
  194|      1|                type_refs.insert(func_decl.ty);
  195|      1|            }
  196|      1|            NodeKind::RecordDecl(record_decl) => {
  197|      1|                type_refs.insert(record_decl.ty);
  198|      1|            }
  199|      2|            NodeKind::FieldDecl(field_decl) => {
  200|      2|                type_refs.insert(field_decl.ty.ty());
  201|      2|            }
  202|      1|            NodeKind::EnumDecl(enum_decl) => {
  203|      1|                type_refs.insert(enum_decl.ty);
  204|      1|            }
  205|      3|            NodeKind::EnumMember(_) => {}
  206|       |
  207|       |            // QualType usage (contains TypeRef)
  208|      1|            NodeKind::Cast(qual_type, _) => {
  209|      1|                type_refs.insert(qual_type.ty());
  210|      1|            }
  211|      0|            NodeKind::SizeOfType(qual_type) => {
  212|      0|                type_refs.insert(qual_type.ty());
  213|      0|            }
  214|      0|            NodeKind::AlignOf(qual_type) => {
  215|      0|                type_refs.insert(qual_type.ty());
  216|      0|            }
  217|      0|            NodeKind::CompoundLiteral(qual_type, _) => {
  218|      0|                type_refs.insert(qual_type.ty());
  219|      0|            }
  220|      0|            NodeKind::BuiltinVaArg(qual_type, _) | NodeKind::BuiltinOffsetof(qual_type, _) => {
  221|      0|                type_refs.insert(qual_type.ty());
  222|      0|            }
  223|       |            NodeKind::BuiltinVaStart(_, _)
  224|       |            | NodeKind::BuiltinVaEnd(_)
  225|       |            | NodeKind::BuiltinVaCopy(_, _)
  226|       |            | NodeKind::BuiltinExpect(_, _)
  227|      0|            | NodeKind::AtomicOp(..) => {}
  228|      9|            NodeKind::VarDecl(var_decl) => {
  229|      9|                type_refs.insert(var_decl.ty.ty());
  230|      9|            }
  231|      1|            NodeKind::TypedefDecl(typedef_decl) => {
  232|      1|                type_refs.insert(typedef_decl.ty.ty());
  233|      1|            }
  234|      0|            NodeKind::GenericSelection(_) => {
  235|      0|                // GenericSelectionData doesn't contain TypeRefs directly.
  236|      0|            }
  237|      0|            NodeKind::GenericAssociation(ga) => {
  238|      0|                if let Some(qual_type) = ga.ty {
  239|      0|                    type_refs.insert(qual_type.ty());
  240|      0|                }
  241|       |            }
  242|       |
  243|       |            // Literal nodes - don't contain TypeRefs
  244|     13|            NodeKind::Literal(_) | NodeKind::Ident(_, _) => {
  245|     13|                // These don't contain TypeRefs
  246|     13|            }
  247|       |
  248|       |            // Statement types that don't directly contain TypeRefs
  249|       |            NodeKind::TranslationUnit(_)
  250|       |            | NodeKind::CompoundStatement(_)
  251|       |            | NodeKind::If(_)
  252|       |            | NodeKind::While(_)
  253|       |            | NodeKind::DoWhile(_, _)
  254|       |            | NodeKind::For(_)
  255|       |            | NodeKind::Return(_)
  256|       |            | NodeKind::Break
  257|       |            | NodeKind::Continue
  258|       |            | NodeKind::Goto(_, _)
  259|       |            | NodeKind::Label(_, _, _)
  260|       |            | NodeKind::Switch(_, _)
  261|       |            | NodeKind::Case(_, _)
  262|       |            | NodeKind::CaseRange(_, _, _)
  263|       |            | NodeKind::Default(_)
  264|       |            | NodeKind::ExpressionStatement(_)
  265|       |            | NodeKind::InitializerList(_)
  266|       |            | NodeKind::InitializerItem(_)
  267|       |            | NodeKind::StaticAssert(_, _)
  268|       |            | NodeKind::EnumConstant(_, _)
  269|     11|            | NodeKind::Dummy => {
  270|     11|                // These don't directly contain TypeRefs
  271|     11|            }
  272|       |
  273|       |            // GNU extensions
  274|      0|            NodeKind::GnuStatementExpression(_, _) => {
  275|      0|                // Doesn't directly contain TypeRef
  276|      0|            }
  277|       |
  278|       |            // Expression nodes with NodeRef children - types handled during traversal
  279|       |            NodeKind::FunctionCall(_)
  280|       |            | NodeKind::BinaryOp(_, _, _)
  281|       |            | NodeKind::UnaryOp(_, _)
  282|       |            | NodeKind::TernaryOp(_, _, _)
  283|       |            | NodeKind::PostIncrement(_)
  284|       |            | NodeKind::PostDecrement(_)
  285|       |            | NodeKind::Assignment(_, _, _)
  286|       |            | NodeKind::MemberAccess(_, _, _)
  287|       |            | NodeKind::IndexAccess(_, _)
  288|      3|            | NodeKind::SizeOfExpr(_) => {
  289|      3|                // These don't directly contain TypeRefs, they will be handled when we process child nodes
  290|      3|            }
  291|       |        }
  292|     50|    }
  293|       |
  294|       |    /// Get function name from symbol entry reference
  295|     15|    fn get_function_name(symbol_ref: SymbolRef, symbol_table: Option<&SymbolTable>) -> String {
  296|     15|        if let Some(table) = symbol_table {
  297|     15|            let entry = table.get_symbol(symbol_ref);
  298|     15|            return entry.name.to_string();
  299|      0|        }
  300|      0|        format!("func_{}", symbol_ref.get())
  301|     15|    }
  302|       |
  303|       |    /// Format a DesignatedInitializer for display
  304|      5|    fn format_designated_initializer(init: &DesignatedInitializer, ast: &Ast) -> String {
  305|      5|        let mut result = String::new();
  306|      5|        for designator_ref in init.designator_start.range(init.designator_len) {
                          ^4
  307|      4|            match ast.get_kind(designator_ref) {
  308|      4|                NodeKind::Designator(d) => match d {
  309|      2|                    Designator::FieldName(name) => {
  310|      2|                        result.push_str(&format!(".{}", name));
  311|      2|                    }
  312|      2|                    Designator::ArrayIndex(index) => {
  313|      2|                        result.push_str(&format!("[{}]", index.get()));
  314|      2|                    }
  315|      0|                    Designator::GnuArrayRange(start, end) => {
  316|      0|                        result.push_str(&format!("[{} ... {}]", start.get(), end.get()));
  317|      0|                    }
  318|       |                },
  319|      0|                _ => result.push_str("<invalid designator>"),
  320|       |            }
  321|       |        }
  322|       |
  323|      5|        if init.designator_len > 0 {
  324|      4|            result.push_str(" = ");
  325|      4|        }
                      ^1
  326|       |
  327|      5|        result.push_str(&init.initializer.get().to_string());
  328|      5|        result
  329|      5|    }
  330|       |
  331|       |    /// Dump a single parsed parsed node kind
  332|    278|    fn dump_parsed_node_kind(f: &mut fmt::Formatter<'_>, kind: &ParsedNodeKind, ast: &ParsedAst) -> fmt::Result {
  333|    278|        match kind {
  334|     59|            ParsedNodeKind::Literal(literal) => match literal {
  335|     44|                crate::ast::literal::Literal::Int { val, suffix } => {
  336|     44|                    writeln!(f, "LiteralInt({:?}, {:?})", val, suffix)
  337|       |                }
  338|      3|                crate::ast::literal::Literal::Float { val, suffix } => {
  339|      3|                    writeln!(f, "LiteralFloat({}, {:?})", val, suffix)
  340|       |                }
  341|      9|                crate::ast::literal::Literal::String(s) => writeln!(f, "LiteralString(\"{}\")", s),
  342|      3|                crate::ast::literal::Literal::Char(c) => writeln!(
  343|      3|                    f,
  344|      3|                    "LiteralChar('{}')",
  345|      3|                    char::from_u32(*c as u32).unwrap_or(char::REPLACEMENT_CHARACTER)
  346|       |                ),
  347|       |            },
  348|     34|            ParsedNodeKind::Ident(name) => writeln!(f, "Ident({})", name),
  349|       |
  350|       |            // Expressions
  351|      3|            ParsedNodeKind::UnaryOp(op, node) => writeln!(f, "UnaryOp({:?}, {})", op, node.get()),
  352|     11|            ParsedNodeKind::BinaryOp(op, l, r) => {
  353|     11|                writeln!(f, "BinaryOp({:?}, {}, {})", op, l.get(), r.get())
  354|       |            }
  355|      1|            ParsedNodeKind::TernaryOp(c, t, e) => {
  356|      1|                writeln!(f, "TernaryOp({}, {}, {})", c.get(), t.get(), e.get())
  357|       |            }
  358|      1|            ParsedNodeKind::GnuStatementExpression(stmt, expr) => {
  359|      1|                writeln!(f, "GnuStatementExpression({}, {})", stmt.get(), expr.get())
  360|       |            }
  361|      2|            ParsedNodeKind::PostIncrement(node) => writeln!(f, "PostIncrement({})", node.get()),
  362|      1|            ParsedNodeKind::PostDecrement(node) => writeln!(f, "PostDecrement({})", node.get()),
  363|      0|            ParsedNodeKind::Assignment(op, l, r) => {
  364|      0|                writeln!(f, "Assignment({:?}, {}, {})", op, l.get(), r.get())
  365|       |            }
  366|      7|            ParsedNodeKind::FunctionCall(callee, args) => {
  367|      8|                let args_str = args.iter().map(|a| a.get().to_string()).collect::<Vec<_>>().join(", ");
                                  ^7         ^7          ^7                           ^7                  ^7   ^7
  368|      7|                writeln!(f, "FunctionCall(callee={}, args=[{}])", callee.get(), args_str)
  369|       |            }
  370|      4|            ParsedNodeKind::MemberAccess(obj, field, arrow) => writeln!(
  371|      4|                f,
  372|      4|                "MemberAccess({}, {}, {})",
  373|      4|                obj.get(),
  374|       |                field,
  375|      4|                if *arrow { "->" } else { "." }
                                          ^1            ^3
  376|       |            ),
  377|      1|            ParsedNodeKind::IndexAccess(arr, idx) => {
  378|      1|                writeln!(f, "IndexAccess({}, {})", arr.get(), idx.get())
  379|       |            }
  380|      1|            ParsedNodeKind::Cast(ty, expr) => writeln!(f, "Cast({:?}, {})", ty, expr.get()),
  381|      1|            ParsedNodeKind::SizeOfExpr(expr) => writeln!(f, "SizeOfExpr({})", expr.get()),
  382|      1|            ParsedNodeKind::SizeOfType(ty) => writeln!(f, "SizeOfType({:?})", ty),
  383|      1|            ParsedNodeKind::AlignOf(ty) => writeln!(f, "AlignOf({:?})", ty),
  384|      1|            ParsedNodeKind::CompoundLiteral(ty, init) => {
  385|      1|                writeln!(f, "CompoundLiteral({:?}, {})", ty, init.get())
  386|       |            }
  387|      1|            ParsedNodeKind::BuiltinVaArg(ty, expr) => {
  388|      1|                writeln!(f, "BuiltinVaArg({:?}, {})", ty, expr.get())
  389|       |            }
  390|      1|            ParsedNodeKind::BuiltinVaStart(ap, last) => {
  391|      1|                writeln!(f, "BuiltinVaStart({}, {})", ap.get(), last.get())
  392|       |            }
  393|      1|            ParsedNodeKind::BuiltinVaEnd(ap) => {
  394|      1|                writeln!(f, "BuiltinVaEnd({})", ap.get())
  395|       |            }
  396|      1|            ParsedNodeKind::BuiltinVaCopy(dst, src) => {
  397|      1|                writeln!(f, "BuiltinVaCopy({}, {})", dst.get(), src.get())
  398|       |            }
  399|      0|            ParsedNodeKind::BuiltinExpect(exp, c) => {
  400|      0|                writeln!(f, "BuiltinExpect({}, {})", exp.get(), c.get())
  401|       |            }
  402|      1|            ParsedNodeKind::BuiltinOffsetof(ty, expr) => {
  403|      1|                writeln!(f, "BuiltinOffsetof({:?}, {})", ty, expr.get())
  404|       |            }
  405|      1|            ParsedNodeKind::AtomicOp(op, args) => {
  406|      2|                let args_str = args.iter().map(|a| a.get().to_string()).collect::<Vec<_>>().join(", ");
                                  ^1         ^1          ^1                           ^1                  ^1   ^1
  407|      1|                writeln!(f, "AtomicOp({:?}, args=[{}])", op, args_str)
  408|       |            }
  409|      1|            ParsedNodeKind::GenericSelection(ctrl, assocs) => {
  410|      1|                writeln!(f, "GenericSelection({}, {:?})", ctrl.get(), assocs)
  411|       |            }
  412|       |
  413|       |            // Statements
  414|     24|            ParsedNodeKind::CompoundStatement(stmts) => {
  415|     47|                let stmts_str = stmts.iter().map(|s| s.get().to_string()).collect::<Vec<_>>().join(", ");
                                  ^24         ^24          ^24                          ^24                 ^24  ^24
  416|     24|                writeln!(f, "CompoundStatement(stmts=[{}])", stmts_str)
  417|       |            }
  418|      2|            ParsedNodeKind::If(data) => writeln!(f, "If({:?})", data),
  419|      1|            ParsedNodeKind::While(data) => writeln!(f, "While({:?})", data),
  420|      1|            ParsedNodeKind::DoWhile(body, cond) => {
  421|      1|                writeln!(f, "DoWhile(body={}, cond={})", body.get(), cond.get())
  422|       |            }
  423|      1|            ParsedNodeKind::For(data) => writeln!(f, "For({:?})", data),
  424|     12|            ParsedNodeKind::Return(expr) => writeln!(
  425|     12|                f,
  426|     12|                "Return({})",
  427|     12|                expr.map(|e| e.get().to_string()).unwrap_or("void".to_string())
  428|       |            ),
  429|      3|            ParsedNodeKind::Break => writeln!(f, "Break"),
  430|      0|            ParsedNodeKind::Continue => writeln!(f, "Continue"),
  431|      1|            ParsedNodeKind::Goto(label) => writeln!(f, "Goto({})", label),
  432|      1|            ParsedNodeKind::Label(label, stmt) => writeln!(f, "Label({}, {})", label, stmt.get()),
  433|      2|            ParsedNodeKind::Switch(cond, body) => {
  434|      2|                writeln!(f, "Switch({}, {})", cond.get(), body.get())
  435|       |            }
  436|      2|            ParsedNodeKind::Case(val, stmt) => writeln!(f, "Case({}, {})", val.get(), stmt.get()),
  437|      1|            ParsedNodeKind::CaseRange(start, end, stmt) => {
  438|      1|                writeln!(f, "CaseRange({}, {}, {})", start.get(), end.get(), stmt.get())
  439|       |            }
  440|      1|            ParsedNodeKind::Default(stmt) => writeln!(f, "Default({})", stmt.get()),
  441|     13|            ParsedNodeKind::ExpressionStatement(expr) => writeln!(
  442|     13|                f,
  443|     13|                "ExpressionStatement({})",
  444|     13|                expr.map(|e| e.get().to_string()).unwrap_or("empty".to_string())
  445|       |            ),
  446|      1|            ParsedNodeKind::EmptyStatement => writeln!(f, "EmptyStatement"),
  447|       |
  448|       |            // Declarations & Definitions
  449|     31|            ParsedNodeKind::Declaration(data) => writeln!(f, "Declaration({:?})", data),
  450|     15|            ParsedNodeKind::FunctionDef(data) => writeln!(f, "FunctionDef({:?})", data),
  451|      3|            ParsedNodeKind::EnumConstant(name, val) => writeln!(
  452|      3|                f,
  453|      3|                "EnumConstant({}, {})",
  454|       |                name,
  455|      3|                val.map(|v| v.get().to_string()).unwrap_or("auto".to_string())
                                          ^1      ^1
  456|       |            ),
  457|      1|            ParsedNodeKind::StaticAssert(cond, msg) => {
  458|      1|                let message_str = if let ParsedNodeKind::Literal(literal::Literal::String(s)) = &ast.get_node(*msg).kind
  459|       |                {
  460|      1|                    s.to_string()
  461|       |                } else {
  462|      0|                    "<invalid>".to_string()
  463|       |                };
  464|      1|                writeln!(f, "StaticAssert({}, \"{}\")", cond.get(), message_str)
  465|       |            }
  466|       |
  467|       |            // Top Level
  468|     23|            ParsedNodeKind::TranslationUnit(decls) => {
  469|     35|                let decls_str = decls.iter().map(|d| d.get().to_string()).collect::<Vec<_>>().join(", ");
                                  ^23         ^23          ^23                          ^23                 ^23  ^23
  470|     23|                writeln!(f, "TranslationUnit(decls=[{}])", decls_str)
  471|       |            }
  472|       |
  473|       |            // InitializerList
  474|      3|            ParsedNodeKind::InitializerList(inits) => writeln!(f, "InitializerList({:?})", inits),
  475|       |
  476|      0|            ParsedNodeKind::Dummy => writeln!(f, "Dummy"),
  477|       |        }
  478|    278|    }
  479|       |
  480|       |    /// Dump a single AST node kind
  481|    212|    fn dump_parser_kind(
  482|    212|        f: &mut fmt::Formatter<'_>,
  483|    212|        kind: &NodeKind,
  484|    212|        ast: &Ast,
  485|    212|        symbol_table: Option<&SymbolTable>,
  486|    212|    ) -> fmt::Result {
  487|    212|        match kind {
  488|     15|            NodeKind::TranslationUnit(tu_data) => {
  489|     15|                let start = tu_data.decl_start.get();
  490|     15|                if tu_data.decl_len > 0 {
  491|     15|                    let last = start + tu_data.decl_len as u32 - 1;
  492|     15|                    writeln!(f, "TranslationUnit(decls={}..{}) (parser kind)", start, last)
  493|       |                } else {
  494|      0|                    writeln!(f, "TranslationUnit(decls=[]) (parser kind)")
  495|       |                }
  496|       |            }
  497|     47|            NodeKind::Literal(literal) => match literal {
  498|     30|                crate::ast::literal::Literal::Int { val, suffix } => {
  499|     30|                    writeln!(f, "LiteralInt({:?}, {:?})", val, suffix)
  500|       |                }
  501|      1|                crate::ast::literal::Literal::Float { val, suffix } => {
  502|      1|                    writeln!(f, "LiteralFloat({}, {:?})", val, suffix)
  503|       |                }
  504|     16|                crate::ast::literal::Literal::String(s) => writeln!(f, "LiteralString({})", s),
  505|      0|                crate::ast::literal::Literal::Char(c) => writeln!(
  506|      0|                    f,
  507|      0|                    "LiteralChar('{}')",
  508|      0|                    char::from_u32(*c as u32).unwrap_or(char::REPLACEMENT_CHARACTER)
  509|       |                ),
  510|       |            },
  511|     20|            NodeKind::Ident(sym, _) => writeln!(f, "Ident({})", sym),
  512|      1|            NodeKind::UnaryOp(op, operand) => writeln!(f, "UnaryOp({:?}, {})", op, operand.get()),
  513|      7|            NodeKind::BinaryOp(op, left, right) => {
  514|      7|                writeln!(f, "BinaryOp({:?}, {}, {})", op, left.get(), right.get())
  515|       |            }
  516|      1|            NodeKind::TernaryOp(cond, then, else_) => {
  517|      1|                writeln!(f, "TernaryOp({}, {}, {})", cond.get(), then.get(), else_.get())
  518|       |            }
  519|      1|            NodeKind::PostIncrement(expr) => writeln!(f, "PostIncrement({})", expr.get()),
  520|      0|            NodeKind::PostDecrement(expr) => writeln!(f, "PostDecrement({})", expr.get()),
  521|      3|            NodeKind::Assignment(op, lhs, rhs) => {
  522|      3|                writeln!(f, "Assignment({:?}, {}, {})", op, lhs.get(), rhs.get())
  523|       |            }
  524|      1|            NodeKind::FunctionCall(call_expr) => {
  525|      1|                let start = call_expr.arg_start.get();
  526|      1|                if call_expr.arg_len > 0 {
  527|      1|                    let last = start + call_expr.arg_len as u32 - 1;
  528|      1|                    writeln!(
  529|      1|                        f,
  530|      1|                        "FunctionCall(callee={}, args={}..{})",
  531|      1|                        call_expr.callee.get(),
  532|       |                        start,
  533|       |                        last
  534|       |                    )
  535|       |                } else {
  536|      0|                    writeln!(f, "FunctionCall(callee={}, args=[])", call_expr.callee.get())
  537|       |                }
  538|       |            }
  539|       |
  540|      3|            NodeKind::MemberAccess(obj, field, is_arrow) => writeln!(
  541|      3|                f,
  542|      3|                "MemberAccess({}, {}, {})",
  543|      3|                obj.get(),
  544|       |                field,
  545|      3|                if *is_arrow { "->" } else { "." }
                                             ^1            ^2
  546|       |            ),
  547|      1|            NodeKind::IndexAccess(array, index) => {
  548|      1|                writeln!(f, "IndexAccess({}, {})", array.get(), index.get())
  549|       |            }
  550|      1|            NodeKind::Cast(ty, expr) => writeln!(f, "Cast({}, {})", ty, expr.get()),
  551|      1|            NodeKind::SizeOfExpr(expr) => writeln!(f, "SizeOfExpr({})", expr.get()),
  552|      1|            NodeKind::SizeOfType(ty) => writeln!(f, "SizeOfType({})", ty),
  553|      1|            NodeKind::AlignOf(ty) => writeln!(f, "AlignOf({})", ty),
  554|      1|            NodeKind::CompoundLiteral(ty, init) => {
  555|      1|                writeln!(f, "CompoundLiteral({}, {})", ty, init.get())
  556|       |            }
  557|      0|            NodeKind::BuiltinVaArg(ty, expr) => {
  558|      0|                writeln!(f, "BuiltinVaArg({}, {})", ty, expr.get())
  559|       |            }
  560|      0|            NodeKind::BuiltinVaStart(ap, last) => {
  561|      0|                writeln!(f, "BuiltinVaStart({}, {})", ap.get(), last.get())
  562|       |            }
  563|      0|            NodeKind::BuiltinVaEnd(ap) => {
  564|      0|                writeln!(f, "BuiltinVaEnd({})", ap.get())
  565|       |            }
  566|      0|            NodeKind::BuiltinVaCopy(dst, src) => {
  567|      0|                writeln!(f, "BuiltinVaCopy({}, {})", dst.get(), src.get())
  568|       |            }
  569|      0|            NodeKind::BuiltinExpect(exp, c) => {
  570|      0|                writeln!(f, "BuiltinExpect({}, {})", exp.get(), c.get())
  571|       |            }
  572|      1|            NodeKind::BuiltinOffsetof(ty, expr) => {
  573|      1|                writeln!(f, "BuiltinOffsetof({}, {})", ty, expr.get())
  574|       |            }
  575|      0|            NodeKind::AtomicOp(op, args_start, args_len) => {
  576|      0|                let start = args_start.get();
  577|      0|                if *args_len > 0 {
  578|      0|                    let last = start + *args_len as u32 - 1;
  579|      0|                    writeln!(f, "AtomicOp({:?}, args={}..{})", op, start, last)
  580|       |                } else {
  581|      0|                    writeln!(f, "AtomicOp({:?}, args=[])", op)
  582|       |                }
  583|       |            }
  584|       |
  585|      1|            NodeKind::GenericSelection(gs) => {
  586|      1|                let start = gs.assoc_start.get();
  587|      1|                if gs.assoc_len > 0 {
  588|      1|                    let last = start + gs.assoc_len as u32 - 1;
  589|      1|                    writeln!(
  590|      1|                        f,
  591|      1|                        "GenericSelection(control={}, associations={}..{})",
  592|      1|                        gs.control.get(),
  593|       |                        start,
  594|       |                        last
  595|       |                    )
  596|       |                } else {
  597|      0|                    writeln!(f, "GenericSelection(control={}, associations=[])", gs.control.get())
  598|       |                }
  599|       |            }
  600|      2|            NodeKind::GenericAssociation(ga) => {
  601|      2|                writeln!(
  602|      2|                    f,
  603|      2|                    "GenericAssociation(ty={:?}, result_expr={})",
  604|       |                    ga.ty,
  605|      2|                    ga.result_expr.get()
  606|       |                )
  607|       |            }
  608|      1|            NodeKind::GnuStatementExpression(compound_stmt, result_expr) => {
  609|      1|                writeln!(
  610|      1|                    f,
  611|      1|                    "GnuStatementExpression({}, {})",
  612|      1|                    compound_stmt.get(),
  613|      1|                    result_expr.get()
  614|       |                )
  615|       |            }
  616|     22|            NodeKind::CompoundStatement(cs) => {
  617|     22|                let start = cs.stmt_start.get();
  618|     22|                if cs.stmt_len > 0 {
  619|     18|                    let last = start + cs.stmt_len as u32 - 1;
  620|     18|                    writeln!(f, "CompoundStatement(stmts={}..{})", start, last)
  621|       |                } else {
  622|      4|                    writeln!(f, "CompoundStatement(stmts=[])")
  623|       |                }
  624|       |            }
  625|      1|            NodeKind::If(if_stmt) => writeln!(
  626|      1|                f,
  627|      1|                "If(condition={}, then={}, else={})",
  628|      1|                if_stmt.condition.get(),
  629|      1|                if_stmt.then_branch.get(),
  630|      1|                if_stmt
  631|      1|                    .else_branch
  632|      1|                    .map(|r| r.get().to_string())
                                           ^0      ^0
  633|      1|                    .unwrap_or("none".to_string())
  634|       |            ),
  635|      1|            NodeKind::While(while_stmt) => writeln!(
  636|      1|                f,
  637|      1|                "While(condition={}, body={})",
  638|      1|                while_stmt.condition.get(),
  639|      1|                while_stmt.body.get()
  640|       |            ),
  641|      1|            NodeKind::DoWhile(body, cond) => {
  642|      1|                writeln!(f, "DoWhile(body={}, condition={})", body.get(), cond.get())
  643|       |            }
  644|      1|            NodeKind::For(for_stmt) => writeln!(
  645|      1|                f,
  646|      1|                "For(init={}, condition={}, increment={}, body={})",
  647|      1|                for_stmt.init.map(|r| r.get().to_string()).unwrap_or("none".to_string()),
                                                    ^0      ^0
  648|      1|                for_stmt
  649|      1|                    .condition
  650|      1|                    .map(|r| r.get().to_string())
                                           ^0      ^0
  651|      1|                    .unwrap_or("none".to_string()),
  652|      1|                for_stmt
  653|      1|                    .increment
  654|      1|                    .map(|r| r.get().to_string())
                                           ^0      ^0
  655|      1|                    .unwrap_or("none".to_string()),
  656|      1|                for_stmt.body.get()
  657|       |            ),
  658|      4|            NodeKind::Return(expr) => writeln!(
  659|      4|                f,
  660|      4|                "Return({})",
  661|      4|                expr.map(|r| r.get().to_string()).unwrap_or("void".to_string())
  662|       |            ),
  663|      2|            NodeKind::Break => writeln!(f, "Break"),
  664|      1|            NodeKind::Continue => writeln!(f, "Continue"),
  665|      1|            NodeKind::Goto(label, _) => writeln!(f, "Goto({})", label),
  666|      1|            NodeKind::Label(label, stmt, _) => writeln!(f, "Label({}, {})", label, stmt.get()),
  667|      2|            NodeKind::Switch(cond, body) => {
  668|      2|                writeln!(f, "Switch(condition={}, body={})", cond.get(), body.get())
  669|       |            }
  670|      1|            NodeKind::Case(expr, stmt) => writeln!(f, "Case({}, {})", expr.get(), stmt.get()),
  671|      1|            NodeKind::CaseRange(start, end, stmt) => {
  672|      1|                writeln!(f, "CaseRange({}, {}, {})", start.get(), end.get(), stmt.get())
  673|       |            }
  674|      1|            NodeKind::Default(stmt) => writeln!(f, "Default({})", stmt.get()),
  675|      6|            NodeKind::ExpressionStatement(expr) => writeln!(
  676|      6|                f,
  677|      6|                "ExpressionStatement({})",
  678|      6|                expr.map(|r| r.get().to_string()).unwrap_or("none".to_string())
  679|       |            ),
  680|       |
  681|       |            // Declaration and FunctionDef removed
  682|     15|            NodeKind::Function(data) => {
  683|     15|                let func_name = Self::get_function_name(data.symbol, symbol_table);
  684|     15|                let start = data.param_start.get();
  685|     15|                if data.param_len > 0 {
  686|      1|                    let last = start + data.param_len as u32 - 1;
  687|      1|                    writeln!(
  688|      1|                        f,
  689|      1|                        "Function(name={}, symbol={:?}, ty={}, params={}..{}, body={})",
  690|       |                        func_name,
  691|       |                        data.symbol,
  692|       |                        data.ty,
  693|       |                        start,
  694|       |                        last,
  695|      1|                        data.body.get()
  696|       |                    )
  697|       |                } else {
  698|     14|                    writeln!(
  699|     14|                        f,
  700|     14|                        "Function(name={}, symbol={:?}, ty={}, params=[], body={})",
  701|       |                        func_name,
  702|       |                        data.symbol,
  703|       |                        data.ty,
  704|     14|                        data.body.get()
  705|       |                    )
  706|       |                }
  707|       |            }
  708|      2|            NodeKind::Param(data) => {
  709|      2|                writeln!(f, "Param(symbol={:?}, ty={:?})", data.symbol, data.ty)
  710|       |            }
  711|      0|            NodeKind::EnumConstant(name, value) => writeln!(
  712|      0|                f,
  713|      0|                "EnumConstant({}, {})",
  714|       |                name,
  715|      0|                value.map(|r| r.get().to_string()).unwrap_or("auto".to_string())
  716|       |            ),
  717|      1|            NodeKind::StaticAssert(cond, msg) => {
  718|      1|                let message_str = if let NodeKind::Literal(literal::Literal::String(s)) = ast.get_kind(*msg) {
  719|      1|                    s.to_string()
  720|       |                } else {
  721|      0|                    "<invalid>".to_string()
  722|       |                };
  723|      1|                writeln!(f, "StaticAssert(condition={}, message=\"{}\")", cond.get(), message_str)
  724|       |            }
  725|     17|            NodeKind::VarDecl(var_decl) => {
  726|     17|                writeln!(
  727|     17|                    f,
  728|     17|                    "VarDecl(name={}, ty={}, storage={:?})",
  729|       |                    var_decl.name, var_decl.ty, var_decl.storage
  730|       |                )
  731|       |            }
  732|      0|            NodeKind::FunctionDecl(func_decl) => {
  733|      0|                writeln!(
  734|      0|                    f,
  735|      0|                    "FunctionDecl(name={}, ty={}, storage={:?})",
  736|       |                    func_decl.name,
  737|      0|                    func_decl.ty.get(),
  738|       |                    func_decl.storage
  739|       |                )
  740|       |            }
  741|      0|            NodeKind::TypedefDecl(typedef_decl) => {
  742|      0|                writeln!(f, "TypedefDecl(name={}, ty={})", typedef_decl.name, typedef_decl.ty)
  743|       |            }
  744|      4|            NodeKind::RecordDecl(record_decl) => {
  745|      4|                let start = record_decl.member_start.get();
  746|      4|                if record_decl.member_len > 0 {
  747|      4|                    let last = start + record_decl.member_len as u32 - 1;
  748|      4|                    writeln!(
  749|      4|                        f,
  750|      4|                        "RecordDecl(name={:?}, ty={}, is_union={}, members={}..{})",
  751|       |                        record_decl.name,
  752|      4|                        record_decl.ty.get(),
  753|       |                        record_decl.is_union,
  754|       |                        start,
  755|       |                        last
  756|       |                    )
  757|       |                } else {
  758|      0|                    writeln!(
  759|      0|                        f,
  760|      0|                        "RecordDecl(name={:?}, ty={}, is_union={}, members=[])",
  761|       |                        record_decl.name,
  762|      0|                        record_decl.ty.get(),
  763|       |                        record_decl.is_union
  764|       |                    )
  765|       |                }
  766|       |            }
  767|      5|            NodeKind::FieldDecl(field_decl) => {
  768|      5|                writeln!(f, "FieldDecl(name={:?}, ty={})", field_decl.name, field_decl.ty)
  769|       |            }
  770|      0|            NodeKind::EnumDecl(enum_decl) => {
  771|      0|                let start = enum_decl.member_start.get();
  772|      0|                if enum_decl.member_len > 0 {
  773|      0|                    let last = start + enum_decl.member_len as u32 - 1;
  774|      0|                    writeln!(
  775|      0|                        f,
  776|      0|                        "EnumDecl(name={:?}, ty={}, members={}..{})",
  777|       |                        enum_decl.name,
  778|      0|                        enum_decl.ty.get(),
  779|       |                        start,
  780|       |                        last
  781|       |                    )
  782|       |                } else {
  783|      0|                    writeln!(
  784|      0|                        f,
  785|      0|                        "EnumDecl(name={:?}, ty={}, members=[])",
  786|       |                        enum_decl.name,
  787|      0|                        enum_decl.ty.get()
  788|       |                    )
  789|       |                }
  790|       |            }
  791|      0|            NodeKind::EnumMember(enum_member) => {
  792|      0|                writeln!(f, "EnumMember(name={}, value={})", enum_member.name, enum_member.value)
  793|       |            }
  794|      3|            NodeKind::InitializerList(list) => {
  795|      3|                let start = list.init_start.get();
  796|      3|                if list.init_len > 0 {
  797|      3|                    let last = start + list.init_len as u32 - 1;
  798|      3|                    writeln!(f, "InitializerList(inits={}..{})", start, last)
  799|       |                } else {
  800|      0|                    writeln!(f, "InitializerList(inits=[])")
  801|       |                }
  802|       |            }
  803|      5|            NodeKind::InitializerItem(init) => {
  804|      5|                writeln!(f, "InitializerItem({})", Self::format_designated_initializer(init, ast))
  805|       |            }
  806|      4|            NodeKind::Designator(d) => match d {
  807|      2|                Designator::FieldName(name) => writeln!(f, "Designator(.{})", name),
  808|      2|                Designator::ArrayIndex(idx) => writeln!(f, "Designator([{}])", idx.get()),
  809|      0|                Designator::GnuArrayRange(start, end) => writeln!(f, "Designator([{} ... {}])", start.get(), end.get()),
  810|       |            },
  811|      0|            NodeKind::Dummy => writeln!(f, "DUMMY"),
  812|       |        }
  813|    212|    }
  814|       |}

/app/src/ast/literal_parsing.rs:
    1|       |use crate::ast::literal::{FloatSuffix, IntegerSuffix};
    2|       |use std::char;
    3|       |use std::iter::Peekable;
    4|       |use std::str::Chars;
    5|       |
    6|       |const INTEGER_SUFFIXES: &[(&str, IntegerSuffix)] = &[
    7|       |    ("ull", IntegerSuffix::ULL),
    8|       |    ("llu", IntegerSuffix::ULL),
    9|       |    ("ul", IntegerSuffix::UL),
   10|       |    ("lu", IntegerSuffix::UL),
   11|       |    ("ll", IntegerSuffix::LL),
   12|       |    ("u", IntegerSuffix::U),
   13|       |    ("l", IntegerSuffix::L),
   14|       |];
   15|       |
   16|       |/// Strip integer literal suffix (u, l, ll, ul, ull, etc.)
   17|  1.39k|fn strip_integer_suffix(text: &str) -> (&str, Option<IntegerSuffix>) {
   18|  10.9k|    for &(suffix, variant) in INTEGER_SUFFIXES {
                        ^9.61k  ^9.61k
   19|  9.61k|        if text.len() >= suffix.len() && text[text.len() - suffix.len()..].eq_ignore_ascii_case(suffix) {
                                                       ^3.64k^3.64k^3.64k                  ^3.64k               ^3.64k
   20|     49|            return (&text[..text.len() - suffix.len()], Some(variant));
   21|  9.56k|        }
   22|       |    }
   23|  1.34k|    (text, None)
   24|  1.39k|}
   25|       |
   26|       |/// Parse C11 integer literal syntax
   27|       |/// Returns (value, suffix)
   28|  1.39k|pub(crate) fn parse_c11_integer_literal(text: &str) -> Option<(u64, Option<IntegerSuffix>)> {
   29|  1.39k|    let (number_part, suffix) = strip_integer_suffix(text);
   30|       |
   31|  1.39k|    if number_part.is_empty() {
   32|      1|        return None;
   33|  1.38k|    }
   34|       |
   35|  1.38k|    let (base, digits) = if let Some(stripped) = number_part.strip_prefix("0x") {
                       ^1.04k^1.04k                ^23
   36|     23|        (16, stripped)
   37|  1.36k|    } else if let Some(stripped) = number_part.strip_prefix("0X") {
                                     ^1
   38|      1|        (16, stripped)
   39|  1.36k|    } else if let Some(stripped) = number_part.strip_prefix('0') {
                                     ^357
   40|    357|        if stripped.is_empty() {
   41|    348|            return Some((0, suffix));
   42|      9|        }
   43|      9|        (8, stripped)
   44|       |    } else {
   45|  1.00k|        (10, number_part)
   46|       |    };
   47|       |
   48|  1.04k|    if digits.is_empty() {
   49|      1|        return None;
   50|  1.04k|    }
   51|       |
   52|       |    // Use built-in radix parsing which is robust and handles overflow checks
   53|  1.04k|    let val = u64::from_str_radix(digits, base).ok()?;
                      ^1.00k                                      ^38
   54|  1.00k|    Some((val, suffix))
   55|  1.39k|}
   56|       |
   57|       |/// Parse C11 floating-point literal syntax
   58|     48|pub(crate) fn parse_c11_float_literal(text: &str) -> Option<(f64, Option<FloatSuffix>)> {
   59|     48|    if text.is_empty() {
   60|      1|        return None;
   61|     47|    }
   62|       |
   63|     47|    let (text_without_suffix, suffix) = if let Some(stripped) = text.strip_suffix(|c| c == 'f' || c == 'F') {
                                                                  ^5                                            ^42
   64|      5|        (stripped, Some(FloatSuffix::F))
   65|     42|    } else if let Some(stripped) = text.strip_suffix(|c| c == 'l' || c == 'L') {
                                     ^3
   66|      3|        (stripped, Some(FloatSuffix::L))
   67|       |    } else {
   68|     39|        (text, None)
   69|       |    };
   70|       |
   71|       |    // Handle hexadecimal floating-point literals (C99/C11)
   72|     47|    if text.starts_with("0x") || text.starts_with("0X") {
                                               ^38  ^38
   73|     10|        parse_hex_float_literal(text_without_suffix).map(|val| (val, suffix))
                                                                              ^2   ^2
   74|       |    } else {
   75|       |        // Use Rust's built-in parsing for decimal floats
   76|     37|        text_without_suffix.parse::<f64>().ok().map(|val| (val, suffix))
   77|       |    }
   78|     48|}
   79|       |
   80|       |/// Parse hexadecimal floating-point literal (C99/C11)
   81|     10|fn parse_hex_float_literal(text: &str) -> Option<f64> {
   82|       |    // Format: 0[xX][hexdigits][.hexdigits][pP[+|-]digits][fFlL]
   83|     10|    let mut chars = text.chars().peekable();
   84|       |
   85|       |    // Skip "0x"
   86|     10|    if chars.next() != Some('0') {
   87|      0|        return None;
   88|     10|    }
   89|     10|    let x = chars.next()?;
                                      ^0
   90|     10|    if x != 'x' && x != 'X' {
                                 ^1
   91|      0|        return None;
   92|     10|    }
   93|       |
   94|     10|    let mut result = 0.0f64;
   95|     10|    let mut exponent = 0i32;
   96|     10|    let mut has_dot = false;
   97|     10|    let mut fraction_digits = 0;
   98|     10|    let mut has_digits = false;
   99|       |
  100|       |    // Parse significand
  101|     21|    while let Some(&c) = chars.peek() {
                                  ^19
  102|     19|        if let Some(digit) = c.to_digit(16) {
                                  ^7
  103|      7|            result = result * 16.0 + digit as f64;
  104|      7|            if has_dot {
  105|      1|                fraction_digits += 1;
  106|      6|            }
  107|      7|            has_digits = true;
  108|      7|            chars.next();
  109|     12|        } else if c == '.' {
  110|      5|            if has_dot {
  111|      1|                return None;
  112|      4|            } // Double dot
  113|      4|            has_dot = true;
  114|      4|            chars.next();
  115|      7|        } else if c == 'p' || c == 'P' {
                                            ^1
  116|      6|            break;
  117|       |        } else {
  118|      1|            return None; // Invalid character
  119|       |        }
  120|       |    }
  121|       |
  122|      8|    if !has_digits {
  123|      3|        return None;
  124|      5|    }
  125|       |
  126|       |    // Parse exponent
  127|      5|    if let Some('p' | 'P') = chars.peek() {
  128|      5|        chars.next();
  129|      5|        let mut exp_sign = 1;
  130|      5|        if let Some(&c) = chars.peek() {
                                   ^4
  131|      4|            if c == '-' {
  132|      0|                exp_sign = -1;
  133|      0|                chars.next();
  134|      4|            } else if c == '+' {
  135|      2|                chars.next();
  136|      2|            }
  137|      1|        }
  138|       |
  139|      5|        let mut exp_val = 0i32;
  140|      5|        let mut has_exp_digits = false;
  141|      7|        while let Some(&c) = chars.peek() {
                                      ^3
  142|      3|            if let Some(d) = c.to_digit(10) {
                                      ^2
  143|      2|                exp_val = exp_val.checked_mul(10)?.checked_add(d as i32)?;
                                                               ^0                     ^0
  144|      2|                has_exp_digits = true;
  145|      2|                chars.next();
  146|       |            } else {
  147|      1|                break;
  148|       |            }
  149|       |        }
  150|      5|        if !has_exp_digits {
  151|      3|            return None;
  152|      2|        }
  153|      2|        exponent = exp_val * exp_sign;
  154|      0|    }
  155|       |
  156|       |    // Apply adjustments
  157|      2|    if fraction_digits > 0 {
  158|      1|        result /= 16.0f64.powi(fraction_digits);
  159|      1|    }
  160|      2|    if exponent != 0 {
  161|      1|        result *= 2.0f64.powi(exponent);
  162|      1|    }
  163|       |
  164|      2|    Some(result)
  165|     10|}
  166|       |
  167|       |/// Unescape C11 string literal content
  168|    202|pub(crate) fn unescape_string(s: &str) -> String {
  169|    202|    if !s.contains('\\') {
  170|    112|        return s.to_string();
  171|     90|    }
  172|     90|    let mut result = String::with_capacity(s.len());
  173|     90|    unescape_string_into(s, &mut result);
  174|     90|    result
  175|    202|}
  176|       |
  177|       |/// Unescape C11 string literal content into a buffer
  178|     90|fn unescape_string_into(s: &str, result: &mut String) {
  179|     90|    let mut chars = s.chars().peekable();
  180|  1.09k|    while let Some(c) = chars.next() {
                                 ^1.00k
  181|  1.00k|        if c == '\\' {
  182|    102|            parse_escape_sequence(&mut chars, result);
  183|    900|        } else {
  184|    900|            result.push(c);
  185|    900|        }
  186|       |    }
  187|     90|}
  188|       |
  189|    102|fn parse_escape_sequence(chars: &mut Peekable<Chars>, result: &mut String) {
  190|    102|    match chars.peek() {
  191|     54|        Some('n') => {
  192|     54|            chars.next();
  193|     54|            result.push('\n');
  194|     54|        }
  195|      3|        Some('t') => {
  196|      3|            chars.next();
  197|      3|            result.push('\t');
  198|      3|        }
  199|      2|        Some('r') => {
  200|      2|            chars.next();
  201|      2|            result.push('\r');
  202|      2|        }
  203|      1|        Some('b') => {
  204|      1|            chars.next();
  205|      1|            result.push('\x08');
  206|      1|        }
  207|      1|        Some('f') => {
  208|      1|            chars.next();
  209|      1|            result.push('\x0C');
  210|      1|        }
  211|      1|        Some('v') => {
  212|      1|            chars.next();
  213|      1|            result.push('\x0B');
  214|      1|        }
  215|      1|        Some('a') => {
  216|      1|            chars.next();
  217|      1|            result.push('\x07');
  218|      1|        }
  219|      3|        Some('\\') => {
  220|      3|            chars.next();
  221|      3|            result.push('\\');
  222|      3|        }
  223|      2|        Some('\'') => {
  224|      2|            chars.next();
  225|      2|            result.push('\'');
  226|      2|        }
  227|      9|        Some('"') => {
  228|      9|            chars.next();
  229|      9|            result.push('"');
  230|      9|        }
  231|      1|        Some('?') => {
  232|      1|            chars.next();
  233|      1|            result.push('?');
  234|      1|        }
  235|     10|        Some('x') => parse_hex_escape(chars, result),
  236|      2|        Some('u') | Some('U') => parse_ucn_escape(chars, result),
  237|     12|        Some(c) if c.is_digit(8) => parse_octal_escape(chars, result),
  238|      0|        Some(c) => {
  239|      0|            // Unknown escape, keep char
  240|      0|            result.push(*c);
  241|      0|            chars.next();
  242|      0|        }
  243|      0|        None => {
  244|      0|            result.push('\\');
  245|      0|        }
  246|       |    }
  247|    102|}
  248|       |
  249|     10|fn parse_hex_escape(chars: &mut Peekable<Chars>, result: &mut String) {
  250|     10|    chars.next(); // consume 'x'
  251|     10|    let mut val: u64 = 0;
  252|     10|    let mut has_digits = false;
  253|       |
  254|     29|    while let Some(&ch) = chars.peek() {
                                  ^22
  255|     22|        if let Some(digit) = ch.to_digit(16) {
                                  ^19
  256|     19|            val = val.saturating_mul(16).saturating_add(digit as u64);
  257|     19|            has_digits = true;
  258|     19|            chars.next();
  259|     19|        } else {
  260|      3|            break;
  261|       |        }
  262|       |    }
  263|       |
  264|     10|    if has_digits {
  265|     10|        let char_val = if val > 0x10FFFF { 0xFFFD } else { val as u32 };
                                                         ^0
  266|     10|        result.push(char::from_u32(char_val).unwrap_or(char::REPLACEMENT_CHARACTER));
  267|      0|    } else {
  268|      0|        result.push('\\');
  269|      0|        result.push('x');
  270|      0|    }
  271|     10|}
  272|       |
  273|     12|fn parse_octal_escape(chars: &mut Peekable<Chars>, result: &mut String) {
  274|     12|    let mut val = 0u32;
  275|     33|    for _ in 0..3 {
  276|     29|        if let Some(&ch) = chars.peek() {
                                   ^22
  277|     22|            if let Some(digit) = ch.to_digit(8) {
                                      ^21
  278|     21|                val = val * 8 + digit;
  279|     21|                chars.next();
  280|     21|            } else {
  281|      1|                break;
  282|       |            }
  283|       |        } else {
  284|      7|            break;
  285|       |        }
  286|       |    }
  287|     12|    result.push(char::from_u32(val).unwrap_or(char::REPLACEMENT_CHARACTER));
  288|     12|}
  289|       |
  290|      2|fn parse_ucn_escape(chars: &mut Peekable<Chars>, result: &mut String) {
  291|      2|    let is_u = chars.next() == Some('u'); // consume u/U
  292|      2|    let digits_needed = if is_u { 4 } else { 8 };
                                                           ^0
  293|      2|    let mut hex_str = String::new();
  294|       |
  295|      2|    for _ in 0..digits_needed {
  296|      8|        if let Some(&ch) = chars.peek() {
  297|      8|            if ch.is_ascii_hexdigit() {
  298|      8|                chars.next();
  299|      8|                hex_str.push(ch);
  300|      8|            } else {
  301|      0|                break;
  302|       |            }
  303|       |        } else {
  304|      0|            break;
  305|       |        }
  306|       |    }
  307|       |
  308|      2|    if hex_str.len() != digits_needed {
  309|       |        // Invalid, preserve as raw
  310|      0|        result.push('\\');
  311|      0|        result.push(if is_u { 'u' } else { 'U' });
  312|      0|        result.push_str(&hex_str);
  313|      0|        return;
  314|      2|    }
  315|       |
  316|      2|    if let Some(c) = u32::from_str_radix(&hex_str, 16).ok().and_then(char::from_u32) {
  317|      2|        result.push(c);
  318|      2|        return;
  319|      0|    }
  320|       |
  321|       |    // Invalid codepoint
  322|      0|    result.push(char::REPLACEMENT_CHARACTER);
  323|      2|}
  324|       |
  325|       |/// Parse a character literal content (e.g. "a", "\n", "\x41") into a codepoint
  326|     32|pub(crate) fn parse_char_literal(s: &str) -> Option<u32> {
  327|     32|    if s.is_empty() {
  328|      1|        return None;
  329|     31|    }
  330|       |    // Optimization: if simple char, just return it
  331|     31|    if !s.contains('\\') {
  332|     19|        let mut chars = s.chars();
  333|     19|        let c = chars.next()?;
                                          ^0
  334|     19|        return Some(c as u32);
  335|     12|    }
  336|       |
  337|     12|    let unescaped = unescape_string(s);
  338|     12|    unescaped.chars().next().map(|c| c as u32)
  339|     32|}
  340|       |
  341|       |#[cfg(test)]
  342|       |mod tests {
  343|       |    use super::*;
  344|       |
  345|       |    #[test]
  346|      1|    fn test_uppercase_hex_literals() {
  347|       |        // Test 0X integer prefix
  348|      1|        assert_eq!(parse_c11_integer_literal("0X10"), Some((16, None)));
  349|       |
  350|       |        // Test 0X float prefix
  351|       |        // 0X1p0 -> 1.0 * 2^0 = 1.0
  352|      1|        assert_eq!(parse_c11_float_literal("0X1p0"), Some((1.0, None)));
  353|      1|    }
  354|       |
  355|       |    #[test]
  356|      1|    fn test_escape_sequences() {
  357|       |        // Test various C escape sequences
  358|      1|        assert_eq!(unescape_string(r"\n"), "\n");
  359|      1|        assert_eq!(unescape_string(r"\t"), "\t");
  360|      1|        assert_eq!(unescape_string(r"\r"), "\r");
  361|      1|        assert_eq!(unescape_string(r"\b"), "\x08"); // BS
  362|      1|        assert_eq!(unescape_string(r"\f"), "\x0C"); // FF
  363|      1|        assert_eq!(unescape_string(r"\v"), "\x0B"); // VT
  364|      1|        assert_eq!(unescape_string(r"\a"), "\x07"); // BEL
  365|      1|        assert_eq!(unescape_string(r"\\"), "\\");
  366|      1|        assert_eq!(unescape_string(r"\'"), "\'");
  367|      1|        assert_eq!(unescape_string(r#"\""#), "\"");
  368|      1|        assert_eq!(unescape_string(r"\?"), "?");
  369|       |
  370|       |        // Mixed content
  371|      1|        assert_eq!(unescape_string(r"Hello\nWorld"), "Hello\nWorld");
  372|      1|    }
  373|       |}

/app/src/ast/nodes.rs:
    1|       |//! AST Node definitions, constructors, and builder patterns.
    2|       |//!
    3|       |//! This module contains the core AST node types, including the NodeKind enum
    4|       |//! and associated data structures. It provides constructors and builder patterns
    5|       |//! for creating complex AST nodes ergonomically.
    6|       |
    7|       |use serde::Serialize;
    8|       |
    9|       |use crate::{
   10|       |    ast::{NameId, NodeRef, SymbolRef, TypeRef},
   11|       |    semantic::{QualType, ScopeId},
   12|       |};
   13|       |
   14|       |/// The core enum defining all possible AST node types for C11.
   15|       |/// Variants use NodeIndex for child references, enabling flattened storage.
   16|       |/// Maintained original structure for compatibility, but moved to this module.
   17|       |use crate::ast::literal::Literal;
   18|       |
   19|       |#[derive(Debug, Clone, Copy, Serialize)]
   20|       |pub enum NodeKind {
   21|       |    // --- Literals (Inline storage for common types) ---
   22|       |    Literal(Literal),
   23|       |
   24|       |    // --- Expressions ---
   25|       |    // Ident now includes a resolved SymbolRef after semantic analysis
   26|       |    Ident(NameId, SymbolRef),
   27|       |    UnaryOp(UnaryOp, NodeRef),
   28|       |    BinaryOp(BinaryOp, NodeRef, NodeRef),
   29|       |    TernaryOp(NodeRef, NodeRef, NodeRef),
   30|       |    GnuStatementExpression(
   31|       |        NodeRef, /* compound statement */
   32|       |        NodeRef, /* result expression */
   33|       |    ),
   34|       |
   35|       |    PostIncrement(NodeRef),
   36|       |    PostDecrement(NodeRef),
   37|       |
   38|       |    Assignment(BinaryOp, NodeRef /* lhs */, NodeRef /* rhs */),
   39|       |    FunctionCall(CallExpr),
   40|       |
   41|       |    MemberAccess(
   42|       |        NodeRef, /* object */
   43|       |        NameId,  /* field */
   44|       |        bool,    /* is_arrow */
   45|       |    ),
   46|       |    IndexAccess(NodeRef /* array */, NodeRef /* index */),
   47|       |
   48|       |    Cast(QualType, NodeRef),
   49|       |    BuiltinVaArg(QualType, NodeRef),
   50|       |    BuiltinOffsetof(QualType, NodeRef),
   51|       |    BuiltinVaStart(NodeRef, NodeRef),
   52|       |    BuiltinVaEnd(NodeRef),
   53|       |    BuiltinVaCopy(NodeRef, NodeRef),
   54|       |    BuiltinExpect(NodeRef, NodeRef),
   55|       |    AtomicOp(AtomicOp, NodeRef /* args start */, u16 /* arg count */),
   56|       |    SizeOfExpr(NodeRef),
   57|       |    SizeOfType(QualType),
   58|       |    AlignOf(QualType), // C11 _Alignof
   59|       |
   60|       |    CompoundLiteral(QualType, NodeRef),
   61|       |    GenericSelection(GenericSelectionData),
   62|       |    GenericAssociation(GenericAssociationData),
   63|       |
   64|       |    // --- Statements (Complex statements are separate structs) ---
   65|       |    CompoundStatement(CompoundStmtData),
   66|       |    If(IfStmt),
   67|       |    While(WhileStmt),
   68|       |    DoWhile(NodeRef /* body */, NodeRef /* condition */),
   69|       |    For(ForStmt),
   70|       |
   71|       |    Return(Option<NodeRef>),
   72|       |    Break,
   73|       |    Continue,
   74|       |    Goto(NameId, SymbolRef),                           // resolved symbol after semantic analysis
   75|       |    Label(NameId, NodeRef /* statement */, SymbolRef), // resolved symbol after semantic analysis
   76|       |
   77|       |    Switch(NodeRef /* condition */, NodeRef /* body statement */),
   78|       |    Case(NodeRef /* const_expr */, NodeRef /* statement */),
   79|       |    CaseRange(
   80|       |        NodeRef, /* start_expr */
   81|       |        NodeRef, /* end_expr */
   82|       |        NodeRef, /* statement */
   83|       |    ), // GNU Extension often supported
   84|       |    Default(NodeRef /* statement */),
   85|       |
   86|       |    ExpressionStatement(Option<NodeRef> /* expression */), // Expression followed by ';'
   87|       |
   88|       |    // --- Declarations & Definitions ---
   89|       |    // Removed Parser-only Declaration and FunctionDef variants.
   90|       |    // They are now lowered to semantic nodes immediately or exist only in ParsedAst.
   91|       |    EnumConstant(NameId, Option<NodeRef> /* value expr */),
   92|       |    StaticAssert(NodeRef /* condition */, NodeRef /* message */),
   93|       |
   94|       |    // --- Semantic Nodes (Type-Resolved) ---
   95|       |    // declarations of VarDecl/FunctionDecl/TypedefDecl/RecordDecl
   96|       |    VarDecl(VarDeclData),
   97|       |    FunctionDecl(FunctionDeclData),
   98|       |    TypedefDecl(TypedefDeclData),
   99|       |    RecordDecl(RecordDeclData),
  100|       |    FieldDecl(FieldDeclData),
  101|       |    EnumDecl(EnumDeclData),
  102|       |    EnumMember(EnumMemberData),
  103|       |    Function(FunctionData),
  104|       |    Param(ParamData),
  105|       |
  106|       |    // --- Top Level ---
  107|       |    TranslationUnit(TranslationUnitData),
  108|       |
  109|       |    // --- InitializerList ---
  110|       |    InitializerList(InitializerListData),
  111|       |    InitializerItem(DesignatedInitializer),
  112|       |    Designator(Designator),
  113|       |
  114|       |    // --- Dummy Node ---
  115|       |    Dummy,
  116|       |}
  117|       |
  118|       |impl NodeKind {
  119|  9.28k|    pub(crate) fn visit_children<F: FnMut(NodeRef)>(&self, mut f: F) {
  120|  9.28k|        match self {
  121|       |            NodeKind::Literal(_)
  122|       |            | NodeKind::Ident(..)
  123|       |            | NodeKind::SizeOfType(_)
  124|       |            | NodeKind::AlignOf(_)
  125|       |            | NodeKind::Break
  126|       |            | NodeKind::Continue
  127|       |            | NodeKind::Goto(..)
  128|       |            | NodeKind::TypedefDecl(_)
  129|       |            | NodeKind::FieldDecl(_)
  130|       |            | NodeKind::EnumMember(_)
  131|       |            | NodeKind::Param(_)
  132|  3.66k|            | NodeKind::Dummy => {}
  133|       |
  134|    173|            NodeKind::UnaryOp(_, child)
  135|     21|            | NodeKind::PostIncrement(child)
  136|      9|            | NodeKind::PostDecrement(child)
  137|    254|            | NodeKind::MemberAccess(child, ..)
  138|     42|            | NodeKind::Cast(_, child)
  139|     14|            | NodeKind::BuiltinVaArg(_, child)
  140|     22|            | NodeKind::BuiltinOffsetof(_, child)
  141|      4|            | NodeKind::BuiltinVaEnd(child)
  142|     62|            | NodeKind::SizeOfExpr(child)
  143|     14|            | NodeKind::CompoundLiteral(_, child)
  144|     17|            | NodeKind::Label(_, child, _)
  145|      3|            | NodeKind::Default(child)
  146|    691|            | NodeKind::StaticAssert(child, _) => f(*child),
                                                   ^56
  147|       |
  148|      8|            NodeKind::BuiltinVaStart(lhs, rhs)
  149|      0|            | NodeKind::BuiltinVaCopy(lhs, rhs)
  150|      6|            | NodeKind::BuiltinExpect(lhs, rhs)
  151|    364|            | NodeKind::BinaryOp(_, lhs, rhs)
  152|      5|            | NodeKind::GnuStatementExpression(lhs, rhs)
  153|    209|            | NodeKind::Assignment(_, lhs, rhs)
  154|     87|            | NodeKind::IndexAccess(lhs, rhs)
  155|      7|            | NodeKind::DoWhile(lhs, rhs)
  156|      5|            | NodeKind::Switch(lhs, rhs)
  157|    699|            | NodeKind::Case(lhs, rhs) => {
                                           ^8   ^8
  158|    699|                f(*lhs);
  159|    699|                f(*rhs);
  160|    699|            }
  161|       |
  162|     15|            NodeKind::TernaryOp(c1, c2, c3) | NodeKind::CaseRange(c1, c2, c3) => {
                                              ^14 ^14 ^14                       ^1  ^1  ^1
  163|     15|                f(*c1);
  164|     15|                f(*c2);
  165|     15|                f(*c3);
  166|     15|            }
  167|       |
  168|    172|            NodeKind::FunctionCall(call) => {
  169|    172|                f(call.callee);
  170|    286|                for child in call.arg_start.range(call.arg_len) {
                                           ^172           ^172  ^172
  171|    286|                    f(child);
  172|    286|                }
  173|       |            }
  174|       |
  175|     23|            NodeKind::AtomicOp(_, args_start, args_len) => {
  176|     77|                for child in args_start.range(*args_len) {
                                           ^23        ^23   ^23
  177|     77|                    f(child);
  178|     77|                }
  179|       |            }
  180|       |
  181|     85|            NodeKind::GenericSelection(gs) => {
  182|     85|                f(gs.control);
  183|    175|                for child in gs.assoc_start.range(gs.assoc_len) {
                                           ^85            ^85   ^85
  184|    175|                    f(child);
  185|    175|                }
  186|       |            }
  187|       |
  188|    175|            NodeKind::GenericAssociation(ga) => {
  189|    175|                f(ga.result_expr);
  190|    175|            }
  191|       |
  192|    607|            NodeKind::CompoundStatement(cs) => {
  193|  1.59k|                for child in cs.stmt_start.range(cs.stmt_len) {
                                           ^607          ^607  ^607
  194|  1.59k|                    f(child);
  195|  1.59k|                }
  196|       |            }
  197|       |
  198|    127|            NodeKind::If(stmt) => {
  199|    127|                f(stmt.condition);
  200|    127|                f(stmt.then_branch);
  201|    127|                if let Some(else_branch) = stmt.else_branch {
                                          ^8
  202|      8|                    f(else_branch);
  203|    119|                }
  204|       |            }
  205|       |
  206|      7|            NodeKind::While(stmt) => {
  207|      7|                f(stmt.condition);
  208|      7|                f(stmt.body);
  209|      7|            }
  210|       |
  211|      9|            NodeKind::For(stmt) => {
  212|      9|                if let Some(init) = stmt.init {
                                          ^4
  213|      4|                    f(init);
  214|      5|                }
  215|      9|                if let Some(cond) = stmt.condition {
                                          ^8
  216|      8|                    f(cond);
  217|      8|                }
                              ^1
  218|      9|                if let Some(inc) = stmt.increment {
                                          ^6
  219|      6|                    f(inc);
  220|      6|                }
                              ^3
  221|      9|                f(stmt.body);
  222|       |            }
  223|       |
  224|    510|            NodeKind::Return(expr) | NodeKind::ExpressionStatement(expr) | NodeKind::EnumConstant(_, expr) => {
                                                                                 ^397                              ^0
  225|    907|                if let Some(child) = expr {
                                          ^902
  226|    902|                    f(*child);
  227|    902|                }
                              ^5
  228|       |            }
  229|       |
  230|    779|            NodeKind::VarDecl(data) => {
  231|    779|                if let Some(init) = data.init {
                                          ^436
  232|    436|                    f(init);
  233|    436|                }
                              ^343
  234|       |            }
  235|       |
  236|     67|            NodeKind::FunctionDecl(data) => {
  237|     67|                if let Some(body) = data.body {
                                          ^0
  238|      0|                    f(body);
  239|     67|                }
  240|       |            }
  241|       |
  242|     77|            NodeKind::RecordDecl(data) => {
  243|    125|                for child in data.member_start.range(data.member_len) {
                                           ^77               ^77   ^77
  244|    125|                    f(child);
  245|    125|                }
  246|       |            }
  247|       |
  248|     13|            NodeKind::EnumDecl(data) => {
  249|     26|                for child in data.member_start.range(data.member_len) {
                                           ^13               ^13   ^13
  250|     26|                    f(child);
  251|     26|                }
  252|       |            }
  253|       |
  254|    334|            NodeKind::Function(data) => {
  255|    334|                for child in data.param_start.range(data.param_len) {
                                  ^68
  256|     68|                    f(child);
  257|     68|                }
  258|    334|                f(data.body);
  259|       |            }
  260|       |
  261|    451|            NodeKind::TranslationUnit(data) => {
  262|    753|                for child in data.decl_start.range(data.decl_len) {
                                           ^451            ^451  ^451
  263|    753|                    f(child);
  264|    753|                }
  265|       |            }
  266|       |
  267|    106|            NodeKind::InitializerList(data) => {
  268|    203|                for child in data.init_start.range(data.init_len) {
                                           ^106            ^106  ^106
  269|    203|                    f(child);
  270|    203|                }
  271|       |            }
  272|       |
  273|    203|            NodeKind::InitializerItem(item) => {
  274|    203|                for designator in item.designator_start.range(item.designator_len) {
                                  ^65
  275|     65|                    f(designator);
  276|     65|                }
  277|    203|                f(item.initializer);
  278|       |            }
  279|       |
  280|     65|            NodeKind::Designator(d) => match d {
  281|     31|                Designator::ArrayIndex(idx) => f(*idx),
  282|      2|                Designator::GnuArrayRange(start, end) => {
  283|      2|                    f(*start);
  284|      2|                    f(*end);
  285|      2|                }
  286|     32|                Designator::FieldName(_) => {}
  287|       |            },
  288|       |        }
  289|  9.28k|    }
  290|       |}
  291|       |
  292|       |// Structs for Large/Indirect Variants (to keep NodeKind size small and cache-friendly)
  293|       |// These are stored separately with index-based references.
  294|       |
  295|       |// Control flow statements
  296|       |#[derive(Debug, Clone, Copy, Serialize)]
  297|       |pub struct IfStmt {
  298|       |    pub condition: NodeRef,
  299|       |    pub then_branch: NodeRef,
  300|       |    pub else_branch: Option<NodeRef>,
  301|       |}
  302|       |
  303|       |#[derive(Debug, Clone, Copy, Serialize)]
  304|       |pub struct WhileStmt {
  305|       |    pub condition: NodeRef,
  306|       |    pub body: NodeRef,
  307|       |}
  308|       |
  309|       |#[derive(Debug, Clone, Copy, Serialize)]
  310|       |pub struct ForStmt {
  311|       |    pub init: Option<NodeRef>, // Can be Declaration or Expression
  312|       |    pub condition: Option<NodeRef>,
  313|       |    pub increment: Option<NodeRef>,
  314|       |    pub body: NodeRef,
  315|       |    pub scope_id: ScopeId,
  316|       |}
  317|       |
  318|       |// Semantic node data structures (type-resolved)
  319|       |#[derive(Debug, Clone, Copy, Serialize)]
  320|       |pub struct CompoundStmtData {
  321|       |    pub stmt_start: NodeRef,
  322|       |    pub stmt_len: u16,
  323|       |    pub scope_id: ScopeId,
  324|       |}
  325|       |
  326|       |#[derive(Debug, Clone, Copy, Serialize)]
  327|       |pub struct TranslationUnitData {
  328|       |    pub decl_start: NodeRef,
  329|       |    pub decl_len: u16,
  330|       |    pub scope_id: ScopeId,
  331|       |}
  332|       |
  333|       |#[derive(Debug, Clone, Copy, Serialize)]
  334|       |pub struct InitializerListData {
  335|       |    pub init_start: NodeRef,
  336|       |    pub init_len: u16,
  337|       |}
  338|       |
  339|       |#[derive(Debug, Clone, Copy, Serialize)]
  340|       |pub struct FunctionData {
  341|       |    pub symbol: SymbolRef,
  342|       |    pub ty: TypeRef, // function type, not the return type
  343|       |    pub is_noreturn: bool,
  344|       |    pub param_start: NodeRef,
  345|       |    pub param_len: u16,
  346|       |    pub body: NodeRef, // compound statement
  347|       |    pub scope_id: ScopeId,
  348|       |}
  349|       |
  350|       |#[derive(Debug, Clone, Copy, Serialize)]
  351|       |pub struct ParamData {
  352|       |    pub symbol: SymbolRef,
  353|       |    pub ty: QualType,
  354|       |}
  355|       |
  356|       |// Semantic node data structures (type-resolved)
  357|       |#[derive(Debug, Clone, Copy, Serialize)]
  358|       |pub struct VarDeclData {
  359|       |    pub name: NameId,
  360|       |    pub ty: QualType,
  361|       |    pub storage: Option<StorageClass>,
  362|       |    pub init: Option<NodeRef>,  // InitializerList or Expression
  363|       |    pub alignment: Option<u16>, // Max alignment in bytes
  364|       |}
  365|       |
  366|       |#[derive(Debug, Clone, Copy, Serialize)]
  367|       |pub struct FunctionDeclData {
  368|       |    pub name: NameId,
  369|       |    pub ty: TypeRef,
  370|       |    pub storage: Option<StorageClass>,
  371|       |    pub body: Option<NodeRef>,
  372|       |    pub scope_id: ScopeId,
  373|       |}
  374|       |
  375|       |#[derive(Debug, Clone, Copy, Serialize)]
  376|       |pub struct TypedefDeclData {
  377|       |    pub name: NameId,
  378|       |    pub ty: QualType,
  379|       |}
  380|       |
  381|       |#[derive(Debug, Clone, Copy, Serialize)]
  382|       |pub struct RecordDeclData {
  383|       |    pub name: Option<NameId>,
  384|       |    pub ty: TypeRef,
  385|       |    pub member_start: NodeRef,
  386|       |    /// index where FieldDecl located
  387|       |    pub member_len: u16,
  388|       |
  389|       |    pub is_union: bool,
  390|       |}
  391|       |
  392|       |#[derive(Debug, Clone, Copy, Serialize)]
  393|       |pub struct FieldDeclData {
  394|       |    pub name: Option<NameId>,
  395|       |    pub ty: QualType, // object type
  396|       |    pub alignment: Option<u32>,
  397|       |}
  398|       |
  399|       |#[derive(Debug, Clone, Copy, Serialize)]
  400|       |pub struct CallExpr {
  401|       |    pub callee: NodeRef,
  402|       |    pub arg_start: NodeRef, // index where CallArg located
  403|       |    pub arg_len: u16,
  404|       |}
  405|       |
  406|       |#[derive(Debug, Clone, Copy, Serialize)]
  407|       |pub struct EnumDeclData {
  408|       |    pub name: Option<NameId>,
  409|       |    pub ty: TypeRef,
  410|       |    pub member_start: NodeRef,
  411|       |    pub member_len: u16,
  412|       |}
  413|       |
  414|       |#[derive(Debug, Clone, Copy, Serialize)]
  415|       |pub struct EnumMemberData {
  416|       |    pub name: NameId,
  417|       |    pub value: i64,
  418|       |    pub init_expr: Option<NodeRef>,
  419|       |}
  420|       |
  421|       |#[derive(Debug, Clone, Copy, Serialize, PartialEq, Eq)]
  422|       |pub enum TypeQualifier {
  423|       |    Const,
  424|       |    Restrict,
  425|       |    Volatile,
  426|       |    Atomic,
  427|       |}
  428|       |
  429|       |// Storage classes
  430|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  431|       |#[repr(u8)]
  432|       |pub enum StorageClass {
  433|       |    Typedef,
  434|       |    Extern,
  435|       |    Static,
  436|       |    Auto,
  437|       |    Register,
  438|       |    ThreadLocal, // C11 _Thread_local
  439|       |}
  440|       |
  441|       |// Function specifiers
  442|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  443|       |#[repr(u8)]
  444|       |pub enum FunctionSpecifier {
  445|       |    Inline,
  446|       |    Noreturn, // C11 _Noreturn
  447|       |}
  448|       |
  449|       |// Unary Operators
  450|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  451|       |#[repr(u8)]
  452|       |pub enum UnaryOp {
  453|       |    Plus,
  454|       |    Minus,
  455|       |    Deref,
  456|       |    AddrOf,
  457|       |    BitNot,
  458|       |    LogicNot,
  459|       |    PreIncrement,
  460|       |    PreDecrement,
  461|       |    Real,
  462|       |    Imag,
  463|       |}
  464|       |
  465|       |// Binary Operators (includes assignment types)
  466|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  467|       |pub enum AtomicOp {
  468|       |    LoadN,
  469|       |    StoreN,
  470|       |    ExchangeN,
  471|       |    CompareExchangeN,
  472|       |    FetchAdd,
  473|       |    FetchSub,
  474|       |    FetchAnd,
  475|       |    FetchOr,
  476|       |    FetchXor,
  477|       |}
  478|       |
  479|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  480|       |#[repr(u8)]
  481|       |pub enum BinaryOp {
  482|       |    Add,
  483|       |    Sub,
  484|       |    Mul,
  485|       |    Div,
  486|       |    Mod,
  487|       |    BitAnd,
  488|       |    BitOr,
  489|       |    BitXor,
  490|       |    LShift,
  491|       |    RShift,
  492|       |    Equal,
  493|       |    NotEqual,
  494|       |    Less,
  495|       |    LessEqual,
  496|       |    Greater,
  497|       |    GreaterEqual,
  498|       |    LogicAnd,
  499|       |    LogicOr,
  500|       |    Comma,
  501|       |    Assign,
  502|       |    AssignAdd,
  503|       |    AssignSub,
  504|       |    AssignMul,
  505|       |    AssignDiv,
  506|       |    AssignMod,
  507|       |    AssignBitAnd,
  508|       |    AssignBitOr,
  509|       |    AssignBitXor,
  510|       |    AssignLShift,
  511|       |    AssignRShift,
  512|       |}
  513|       |
  514|       |impl BinaryOp {
  515|  1.23k|    pub(crate) fn is_assignment(&self) -> bool {
  516|    786|        matches!(
  517|  1.23k|            self,
  518|       |            BinaryOp::Assign
  519|       |                | BinaryOp::AssignAdd
  520|       |                | BinaryOp::AssignSub
  521|       |                | BinaryOp::AssignMul
  522|       |                | BinaryOp::AssignDiv
  523|       |                | BinaryOp::AssignMod
  524|       |                | BinaryOp::AssignBitAnd
  525|       |                | BinaryOp::AssignBitOr
  526|       |                | BinaryOp::AssignBitXor
  527|       |                | BinaryOp::AssignLShift
  528|       |                | BinaryOp::AssignRShift
  529|       |        )
  530|  1.23k|    }
  531|       |
  532|    304|    pub(crate) fn without_assignment(&self) -> Option<BinaryOp> {
  533|    304|        match self {
  534|      9|            BinaryOp::AssignAdd => Some(BinaryOp::Add),
  535|      9|            BinaryOp::AssignSub => Some(BinaryOp::Sub),
  536|      2|            BinaryOp::AssignMul => Some(BinaryOp::Mul),
  537|      2|            BinaryOp::AssignDiv => Some(BinaryOp::Div),
  538|      2|            BinaryOp::AssignMod => Some(BinaryOp::Mod),
  539|      0|            BinaryOp::AssignBitAnd => Some(BinaryOp::BitAnd),
  540|      0|            BinaryOp::AssignBitOr => Some(BinaryOp::BitOr),
  541|      0|            BinaryOp::AssignBitXor => Some(BinaryOp::BitXor),
  542|      0|            BinaryOp::AssignLShift => Some(BinaryOp::LShift),
  543|      0|            BinaryOp::AssignRShift => Some(BinaryOp::RShift),
  544|    280|            _ => None,
  545|       |        }
  546|    304|    }
  547|       |}
  548|       |
  549|       |#[derive(Debug, Clone, Copy, Serialize)]
  550|       |pub struct DesignatedInitializer {
  551|       |    pub designator_start: NodeRef,
  552|       |    pub designator_len: u16,
  553|       |    pub initializer: NodeRef,
  554|       |}
  555|       |
  556|       |#[derive(Debug, Clone, Copy, Serialize)]
  557|       |pub enum Designator {
  558|       |    FieldName(NameId),
  559|       |    ArrayIndex(NodeRef),             // Index expression
  560|       |    GnuArrayRange(NodeRef, NodeRef), // GCC extension: Range expression [start ... end]
  561|       |}
  562|       |
  563|       |#[derive(Debug, Clone, Copy, Serialize)]
  564|       |pub struct GenericSelectionData {
  565|       |    pub control: NodeRef,
  566|       |    pub assoc_start: NodeRef,
  567|       |    pub assoc_len: u16,
  568|       |}
  569|       |
  570|       |#[derive(Debug, Clone, Copy, Serialize)]
  571|       |pub struct GenericAssociationData {
  572|       |    pub ty: Option<QualType>, // None for 'default:'
  573|       |    pub result_expr: NodeRef,
  574|       |}

/app/src/ast/parsed.rs:
    1|       |use crate::{
    2|       |    ast::{
    3|       |        AtomicOp, BinaryOp, FunctionSpecifier, NameId, ParsedType, SourceSpan, StorageClass, TypeQualifier, UnaryOp,
    4|       |    },
    5|       |    semantic::TypeQualifiers,
    6|       |};
    7|       |use std::num::NonZeroU32;
    8|       |use thin_vec::ThinVec;
    9|       |
   10|       |use super::ParsedTypeArena;
   11|       |
   12|       |/// Node reference type for referencing child nodes in ParsedAst.
   13|       |pub type ParsedNodeRef = NonZeroU32;
   14|       |
   15|       |/// The parsed AST storage.
   16|       |/// Produced by the Parser. Purely syntactic.
   17|       |#[derive(Clone, Default)]
   18|       |pub struct ParsedAst {
   19|       |    pub nodes: Vec<ParsedNode>,
   20|       |    pub parsed_types: ParsedTypeArena,
   21|       |}
   22|       |
   23|       |impl ParsedAst {
   24|    670|    pub(crate) fn new() -> Self {
   25|    670|        ParsedAst::default()
   26|    670|    }
   27|       |
   28|  6.92k|    pub(crate) fn push_node(&mut self, node: ParsedNode) -> ParsedNodeRef {
   29|  6.92k|        let index = self.nodes.len() as u32 + 1;
   30|  6.92k|        self.nodes.push(node);
   31|  6.92k|        ParsedNodeRef::new(index).expect("ParsedNodeRef overflow")
   32|  6.92k|    }
   33|       |
   34|  17.2k|    pub(crate) fn get_node(&self, index: ParsedNodeRef) -> &ParsedNode {
   35|  17.2k|        &self.nodes[(index.get() - 1) as usize]
   36|  17.2k|    }
   37|       |
   38|  2.47k|    pub(crate) fn replace_node(&mut self, old_node_ref: ParsedNodeRef, new_node: ParsedNode) -> ParsedNodeRef {
   39|  2.47k|        let old_index = (old_node_ref.get() - 1) as usize;
   40|  2.47k|        self.nodes[old_index] = new_node;
   41|  2.47k|        old_node_ref
   42|  2.47k|    }
   43|       |
   44|    539|    pub(crate) fn get_root(&self) -> ParsedNodeRef {
   45|    539|        ParsedNodeRef::new(1).expect("Parsed AST empty")
   46|    539|    }
   47|       |}
   48|       |
   49|       |#[derive(Debug, Clone)]
   50|       |pub struct ParsedNode {
   51|       |    pub kind: ParsedNodeKind,
   52|       |    pub span: SourceSpan,
   53|       |}
   54|       |
   55|       |impl ParsedNode {
   56|  9.40k|    pub(crate) fn new(kind: ParsedNodeKind, span: SourceSpan) -> Self {
   57|  9.40k|        ParsedNode { kind, span }
   58|  9.40k|    }
   59|       |}
   60|       |
   61|       |#[derive(Debug, Clone)]
   62|       |pub enum ParsedNodeKind {
   63|       |    // --- Literals ---
   64|       |    Literal(crate::ast::literal::Literal),
   65|       |
   66|       |    // --- Expressions ---
   67|       |    Ident(NameId), // No symbol ref yet
   68|       |    UnaryOp(UnaryOp, ParsedNodeRef),
   69|       |    BinaryOp(BinaryOp, ParsedNodeRef, ParsedNodeRef),
   70|       |    TernaryOp(ParsedNodeRef, ParsedNodeRef, ParsedNodeRef),
   71|       |    GnuStatementExpression(ParsedNodeRef, ParsedNodeRef),
   72|       |
   73|       |    PostIncrement(ParsedNodeRef),
   74|       |    PostDecrement(ParsedNodeRef),
   75|       |
   76|       |    Assignment(BinaryOp, ParsedNodeRef, ParsedNodeRef),
   77|       |    FunctionCall(ParsedNodeRef, Vec<ParsedNodeRef>),
   78|       |    MemberAccess(ParsedNodeRef, NameId, bool),
   79|       |    IndexAccess(ParsedNodeRef, ParsedNodeRef),
   80|       |
   81|       |    Cast(ParsedType, ParsedNodeRef),
   82|       |    BuiltinVaArg(ParsedType, ParsedNodeRef),
   83|       |    BuiltinOffsetof(ParsedType, ParsedNodeRef),
   84|       |    BuiltinVaStart(ParsedNodeRef, ParsedNodeRef),
   85|       |    BuiltinVaEnd(ParsedNodeRef),
   86|       |    BuiltinVaCopy(ParsedNodeRef, ParsedNodeRef),
   87|       |    BuiltinExpect(ParsedNodeRef, ParsedNodeRef),
   88|       |    AtomicOp(AtomicOp, Vec<ParsedNodeRef>),
   89|       |    SizeOfExpr(ParsedNodeRef),
   90|       |    SizeOfType(ParsedType),
   91|       |    AlignOf(ParsedType),
   92|       |
   93|       |    CompoundLiteral(ParsedType, ParsedNodeRef),
   94|       |    GenericSelection(ParsedNodeRef, Vec<ParsedGenericAssociation>),
   95|       |
   96|       |    // --- Statements ---
   97|       |    CompoundStatement(Vec<ParsedNodeRef>),
   98|       |    If(ParsedIfStmt),
   99|       |    While(ParsedWhileStmt),
  100|       |    DoWhile(ParsedNodeRef, ParsedNodeRef),
  101|       |    For(ParsedForStmt),
  102|       |
  103|       |    Return(Option<ParsedNodeRef>),
  104|       |    Break,
  105|       |    Continue,
  106|       |    Goto(NameId),
  107|       |    Label(NameId, ParsedNodeRef),
  108|       |
  109|       |    Switch(ParsedNodeRef, ParsedNodeRef),
  110|       |    Case(ParsedNodeRef, ParsedNodeRef),
  111|       |    CaseRange(ParsedNodeRef, ParsedNodeRef, ParsedNodeRef),
  112|       |    Default(ParsedNodeRef),
  113|       |
  114|       |    ExpressionStatement(Option<ParsedNodeRef>),
  115|       |    EmptyStatement,
  116|       |
  117|       |    // --- Declarations & Definitions ---
  118|       |    Declaration(ParsedDeclarationData),
  119|       |    FunctionDef(ParsedFunctionDefData),
  120|       |    EnumConstant(NameId, Option<ParsedNodeRef>),
  121|       |    StaticAssert(ParsedNodeRef, ParsedNodeRef),
  122|       |
  123|       |    // --- Top Level ---
  124|       |    TranslationUnit(Vec<ParsedNodeRef>),
  125|       |
  126|       |    // --- InitializerList ---
  127|       |    InitializerList(Vec<ParsedDesignatedInitializer>),
  128|       |
  129|       |    // --- Dummy Node ---
  130|       |    Dummy,
  131|       |}
  132|       |
  133|       |#[derive(Debug, Clone)]
  134|       |pub struct ParsedIfStmt {
  135|       |    pub condition: ParsedNodeRef,
  136|       |    pub then_branch: ParsedNodeRef,
  137|       |    pub else_branch: Option<ParsedNodeRef>,
  138|       |}
  139|       |
  140|       |#[derive(Debug, Clone)]
  141|       |pub struct ParsedWhileStmt {
  142|       |    pub condition: ParsedNodeRef,
  143|       |    pub body: ParsedNodeRef,
  144|       |}
  145|       |
  146|       |#[derive(Debug, Clone)]
  147|       |pub struct ParsedForStmt {
  148|       |    pub init: Option<ParsedNodeRef>,
  149|       |    pub condition: Option<ParsedNodeRef>,
  150|       |    pub increment: Option<ParsedNodeRef>,
  151|       |    pub body: ParsedNodeRef,
  152|       |}
  153|       |
  154|       |#[derive(Debug, Clone)]
  155|       |pub struct ParsedInitDeclarator {
  156|       |    pub declarator: ParsedDeclarator,
  157|       |    pub initializer: Option<ParsedNodeRef>,
  158|       |    pub span: SourceSpan,
  159|       |}
  160|       |
  161|       |#[derive(Debug, Clone)]
  162|       |pub struct ParsedDeclarationData {
  163|       |    pub specifiers: ThinVec<ParsedDeclSpecifier>,
  164|       |    pub init_declarators: ThinVec<ParsedInitDeclarator>,
  165|       |}
  166|       |
  167|       |#[derive(Debug, Clone)]
  168|       |pub struct ParsedFunctionDefData {
  169|       |    pub specifiers: ThinVec<ParsedDeclSpecifier>,
  170|       |    pub declarator: Box<ParsedDeclarator>,
  171|       |    pub body: ParsedNodeRef,
  172|       |}
  173|       |
  174|       |// Declaration specifiers and related types
  175|       |#[derive(Debug, Clone)]
  176|       |pub enum ParsedDeclSpecifier {
  177|       |    StorageClass(StorageClass),
  178|       |    TypeQualifier(TypeQualifier),
  179|       |    FunctionSpecifier(FunctionSpecifier),
  180|       |    AlignmentSpecifier(ParsedAlignmentSpecifier),
  181|       |    TypeSpecifier(ParsedTypeSpecifier),
  182|       |    Attribute,
  183|       |}
  184|       |
  185|       |// Type specifiers
  186|       |#[derive(Debug, Clone)]
  187|       |pub enum ParsedTypeSpecifier {
  188|       |    Void,
  189|       |    Char,
  190|       |    Short,
  191|       |    Int,
  192|       |    Long,
  193|       |    LongLong,
  194|       |    // Combined types for parser correctness
  195|       |    UnsignedLong,
  196|       |    UnsignedLongLong,
  197|       |    UnsignedShort,
  198|       |    UnsignedChar,
  199|       |    SignedChar,
  200|       |    SignedShort,
  201|       |    SignedLong,
  202|       |    SignedLongLong,
  203|       |    Float,
  204|       |    Double,
  205|       |    LongDouble,
  206|       |    ComplexFloat,
  207|       |    ComplexDouble,
  208|       |    ComplexLongDouble,
  209|       |    Signed,
  210|       |    Unsigned,
  211|       |    Bool,
  212|       |    Complex,
  213|       |    Atomic(ParsedType), // _Bool, _Complex, _Atomic
  214|       |    Record(
  215|       |        bool,                        /* is_union */
  216|       |        Option<NameId>,              /* tag */
  217|       |        Option<ParsedRecordDefData>, /* definition */
  218|       |    ),
  219|       |    Enum(
  220|       |        Option<NameId>,             /* tag */
  221|       |        Option<Vec<ParsedNodeRef>>, /* enumerators */
  222|       |    ),
  223|       |    TypedefName(NameId),
  224|       |    VaList,
  225|       |}
  226|       |
  227|       |// Alignment specifiers
  228|       |#[derive(Debug, Clone)]
  229|       |pub enum ParsedAlignmentSpecifier {
  230|       |    Type(ParsedType),    // _Alignas(type-name)
  231|       |    Expr(ParsedNodeRef), // _Alignas(constant-expression)
  232|       |}
  233|       |
  234|       |// Declarators
  235|       |#[derive(Debug, Clone)]
  236|       |pub enum ParsedDeclarator {
  237|       |    Identifier(NameId, TypeQualifiers),                     // Base case: name (e.g., `x`)
  238|       |    Abstract,                                               // for abstract declarator
  239|       |    Pointer(TypeQualifiers, Option<Box<ParsedDeclarator>>), // e.g., `*`
  240|       |    Array(Box<ParsedDeclarator>, ParsedArraySize),          // e.g., `[10]`
  241|       |    Function {
  242|       |        inner: Box<ParsedDeclarator>,
  243|       |        params: ThinVec<ParsedParamData>,
  244|       |        is_variadic: bool,
  245|       |    }, // e.g., `(int x)`
  246|       |    AnonymousRecord(
  247|       |        bool,                           /* is_union */
  248|       |        ThinVec<ParsedDeclarationData>, /* members */
  249|       |    ), // C11 anonymous struct/union
  250|       |    BitField(Box<ParsedDeclarator>, ParsedNodeRef /* bit width expression */), // e.g., `x : 8`
  251|       |}
  252|       |
  253|       |impl ParsedDeclarator {}
  254|       |
  255|       |#[derive(Debug, Clone)]
  256|       |pub struct ParsedParamData {
  257|       |    pub specifiers: ThinVec<ParsedDeclSpecifier>,
  258|       |    pub declarator: Option<ParsedDeclarator>, // Optional name for abstract declarator
  259|       |    pub span: SourceSpan,
  260|       |}
  261|       |
  262|       |// Array sizes
  263|       |#[derive(Debug, Clone)]
  264|       |pub enum ParsedArraySize {
  265|       |    Expression {
  266|       |        expr: ParsedNodeRef,
  267|       |        qualifiers: TypeQualifiers,
  268|       |    },
  269|       |    Star {
  270|       |        qualifiers: TypeQualifiers,
  271|       |    }, // [*] VLA
  272|       |    Incomplete, // []
  273|       |    VlaSpecifier {
  274|       |        is_static: bool,
  275|       |        qualifiers: TypeQualifiers,
  276|       |        size: Option<ParsedNodeRef>,
  277|       |    }, // for VLA
  278|       |}
  279|       |
  280|       |// Record definitions
  281|       |#[derive(Debug, Clone)]
  282|       |pub struct ParsedGenericAssociation {
  283|       |    pub type_name: Option<ParsedType>, // None for 'default:'
  284|       |    pub result_expr: ParsedNodeRef,
  285|       |}
  286|       |
  287|       |#[derive(Debug, Clone)]
  288|       |pub struct ParsedRecordDefData {
  289|       |    pub tag: Option<NameId>,                         // None if anonymous
  290|       |    pub members: Option<Vec<ParsedDeclarationData>>, // Field declarations
  291|       |    pub is_union: bool,
  292|       |}
  293|       |
  294|       |#[derive(Debug, Clone)]
  295|       |pub struct ParsedDesignatedInitializer {
  296|       |    pub designation: Vec<ParsedDesignator>,
  297|       |    pub initializer: ParsedNodeRef,
  298|       |}
  299|       |
  300|       |#[derive(Debug, Clone)]
  301|       |pub enum ParsedDesignator {
  302|       |    FieldName(NameId),
  303|       |    ArrayIndex(ParsedNodeRef),
  304|       |    GnuArrayRange(ParsedNodeRef, ParsedNodeRef),
  305|       |}

/app/src/ast/parsed_types.rs:
    1|       |//! Parsed type system for the Parser phase.
    2|       |//!
    3|       |//! This module defines the syntactic type representations used during parsing,
    4|       |//! distinct from the semantic type system used during analysis. These types
    5|       |//! are only relevant in the Parser phase and will be converted to semantic
    6|       |//! types during the SymbolResolver phase.
    7|       |
    8|       |use std::num::NonZeroU32;
    9|       |
   10|       |use serde::Serialize;
   11|       |
   12|       |use crate::ast::parsed::{ParsedArraySize, ParsedTypeSpecifier};
   13|       |use crate::ast::{NameId, SourceSpan};
   14|       |use crate::semantic::TypeQualifiers;
   15|       |
   16|       |/// Type reference for parsed base types
   17|       |pub type ParsedBaseTypeRef = NonZeroU32;
   18|       |
   19|       |/// Type reference for parsed declarators
   20|       |pub type ParsedDeclRef = NonZeroU32;
   21|       |
   22|       |/// A parsed type that represents the syntactic structure of a type
   23|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
   24|       |pub struct ParsedType {
   25|       |    pub base: ParsedBaseTypeRef,   // NonZeroU32
   26|       |    pub declarator: ParsedDeclRef, // NonZeroU32
   27|       |    pub qualifiers: TypeQualifiers,
   28|       |}
   29|       |
   30|       |/// Range for struct members in the arena
   31|       |#[derive(Debug, Clone, Copy)]
   32|       |pub struct ParsedStructMemberRange {
   33|       |    pub start: u32,
   34|       |    pub len: u32,
   35|       |}
   36|       |
   37|       |/// Range for function parameters in the arena
   38|       |#[derive(Debug, Clone, Copy)]
   39|       |pub struct ParsedParamRange {
   40|       |    pub start: u32,
   41|       |    pub len: u32,
   42|       |}
   43|       |
   44|       |/// Range for enum values in the arena
   45|       |#[derive(Debug, Clone, Copy)]
   46|       |pub struct ParsedEnumRange {
   47|       |    pub start: u32,
   48|       |    pub len: u32,
   49|       |}
   50|       |
   51|       |/// Function parameter information
   52|       |#[derive(Debug, Clone)]
   53|       |pub struct ParsedFunctionParam {
   54|       |    pub name: Option<NameId>,
   55|       |    pub ty: ParsedType,
   56|       |    pub span: SourceSpan,
   57|       |}
   58|       |
   59|       |/// Parsed struct/union member information
   60|       |#[derive(Debug, Clone)]
   61|       |pub struct ParsedStructMember {
   62|       |    pub name: Option<NameId>,
   63|       |    pub ty: ParsedType,
   64|       |    pub bit_field_size: Option<u16>,
   65|       |    pub alignment: Option<u32>,
   66|       |    pub span: SourceSpan,
   67|       |}
   68|       |
   69|       |/// Parsed enum constant information
   70|       |#[derive(Debug, Clone)]
   71|       |pub struct ParsedEnumConstant {
   72|       |    pub name: NameId,
   73|       |    pub value: Option<i64>, // None for now, resolved later
   74|       |    pub span: SourceSpan,
   75|       |}
   76|       |
   77|       |/// Function flags for declarators
   78|       |#[derive(Debug, Clone, Copy)]
   79|       |pub struct FunctionFlags {
   80|       |    pub is_variadic: bool,
   81|       |}
   82|       |
   83|       |/// Parsed base type node (the fundamental type specifier)
   84|       |#[derive(Clone, Debug)]
   85|       |pub enum ParsedBaseTypeNode {
   86|       |    Builtin(ParsedTypeSpecifier),
   87|       |
   88|       |    Record {
   89|       |        tag: Option<NameId>,
   90|       |        members: Option<ParsedStructMemberRange>, // index range
   91|       |        is_union: bool,
   92|       |    },
   93|       |
   94|       |    Enum {
   95|       |        tag: Option<NameId>,
   96|       |        enumerators: Option<ParsedEnumRange>,
   97|       |    },
   98|       |
   99|       |    Typedef(NameId),
  100|       |
  101|       |    Error,
  102|       |}
  103|       |
  104|       |/// Parsed declarator node (the declarator structure)
  105|       |#[derive(Debug, Clone)]
  106|       |pub enum ParsedDeclaratorNode {
  107|       |    Identifier {
  108|       |        name: Option<NameId>,
  109|       |    },
  110|       |
  111|       |    Pointer {
  112|       |        qualifiers: TypeQualifiers,
  113|       |        inner: ParsedDeclRef,
  114|       |    },
  115|       |
  116|       |    Array {
  117|       |        size: ParsedArraySize,
  118|       |        inner: ParsedDeclRef,
  119|       |    },
  120|       |
  121|       |    Function {
  122|       |        params: ParsedParamRange,
  123|       |        flags: FunctionFlags,
  124|       |        inner: ParsedDeclRef,
  125|       |    },
  126|       |}
  127|       |
  128|       |/// Arena for storing parsed type information
  129|       |/// This provides efficient allocation and referencing for parsed types
  130|       |#[derive(Clone, Debug, Default)]
  131|       |pub struct ParsedTypeArena {
  132|       |    base_types: Vec<ParsedBaseTypeNode>,
  133|       |    declarators: Vec<ParsedDeclaratorNode>,
  134|       |    params: Vec<ParsedFunctionParam>,
  135|       |    struct_members: Vec<ParsedStructMember>,
  136|       |    enum_constants: Vec<ParsedEnumConstant>,
  137|       |}
  138|       |
  139|       |impl ParsedTypeArena {
  140|       |    /// Allocate a new base type and return its reference
  141|    227|    pub(crate) fn alloc_base_type(&mut self, base_type: ParsedBaseTypeNode) -> ParsedBaseTypeRef {
  142|    227|        let index = self.base_types.len() as u32 + 1; // Start from 1 for NonZeroU32
  143|    227|        self.base_types.push(base_type);
  144|    227|        ParsedBaseTypeRef::new(index).expect("ParsedBaseTypeRef overflow")
  145|    227|    }
  146|       |
  147|       |    /// Allocate a new declarator and return its reference
  148|    266|    pub(crate) fn alloc_decl(&mut self, declarator: ParsedDeclaratorNode) -> ParsedDeclRef {
  149|    266|        let index = self.declarators.len() as u32 + 1; // Start from 1 for NonZeroU32
  150|    266|        self.declarators.push(declarator);
  151|    266|        ParsedDeclRef::new(index).expect("ParsedDeclRef overflow")
  152|    266|    }
  153|       |
  154|       |    /// Allocate function parameters and return the range
  155|      7|    pub(crate) fn alloc_params(&mut self, params: Vec<ParsedFunctionParam>) -> ParsedParamRange {
  156|      7|        let start = self.params.len() as u32;
  157|      7|        self.params.extend(params);
  158|      7|        let len = self.params.len() as u32 - start;
  159|      7|        ParsedParamRange { start, len }
  160|      7|    }
  161|       |
  162|       |    /// Allocate struct members and return the range
  163|      3|    pub(crate) fn alloc_struct_members(&mut self, members: Vec<ParsedStructMember>) -> ParsedStructMemberRange {
  164|      3|        let start = self.struct_members.len() as u32;
  165|      3|        self.struct_members.extend(members);
  166|      3|        let len = self.struct_members.len() as u32 - start;
  167|      3|        ParsedStructMemberRange { start, len }
  168|      3|    }
  169|       |
  170|       |    /// Allocate enum constants and return the range
  171|      1|    pub(crate) fn alloc_enum_constants(&mut self, enumerators: Vec<ParsedEnumConstant>) -> ParsedEnumRange {
  172|      1|        let start = self.enum_constants.len() as u32;
  173|      1|        self.enum_constants.extend(enumerators);
  174|      1|        let len = self.enum_constants.len() as u32 - start;
  175|      1|        ParsedEnumRange { start, len }
  176|      1|    }
  177|       |
  178|       |    /// Get a base type by reference
  179|    201|    pub(crate) fn get_base_type(&self, base_ref: ParsedBaseTypeRef) -> ParsedBaseTypeNode {
  180|    201|        let index = (base_ref.get() - 1) as usize;
  181|    201|        self.base_types[index].clone()
  182|    201|    }
  183|       |
  184|       |    /// Get a declarator by reference
  185|    234|    pub(crate) fn get_decl(&self, decl_ref: ParsedDeclRef) -> ParsedDeclaratorNode {
  186|    234|        let index = (decl_ref.get() - 1) as usize;
  187|    234|        self.declarators[index].clone()
  188|    234|    }
  189|       |
  190|       |    /// Get function parameters by range
  191|      5|    pub(crate) fn get_params(&self, range: ParsedParamRange) -> &[ParsedFunctionParam] {
  192|      5|        let start = range.start as usize;
  193|      5|        let end = start + range.len as usize;
  194|      5|        &self.params[start..end]
  195|      5|    }
  196|       |
  197|       |    /// Get struct members by range
  198|      3|    pub(crate) fn get_struct_members(&self, range: ParsedStructMemberRange) -> &[ParsedStructMember] {
  199|      3|        let start = range.start as usize;
  200|      3|        let end = start + range.len as usize;
  201|      3|        &self.struct_members[start..end]
  202|      3|    }
  203|       |
  204|       |    /// Get enum constants by range
  205|      1|    pub(crate) fn get_enum_constants(&self, range: ParsedEnumRange) -> &[ParsedEnumConstant] {
  206|      1|        let start = range.start as usize;
  207|      1|        let end = start + range.len as usize;
  208|      1|        &self.enum_constants[start..end]
  209|      1|    }
  210|       |}

/app/src/codegen/clif_gen.rs:
    1|       |//! MIR to Cranelift IR lowering module
    2|       |//!
    3|       |//! This module provides the mechanical translation from MIR to Cranelift IR.
    4|       |//! The translation follows these rules:
    5|       |//! - No C logic
    6|       |//! - Assume MIR is valid
    7|       |
    8|       |use crate::mir::MirProgram;
    9|       |use crate::mir::{
   10|       |    BinaryFloatOp, BinaryIntOp, CallTarget, ConstValueId, ConstValueKind, GlobalId, LocalId, MirBlockId, MirFunction,
   11|       |    MirFunctionId, MirFunctionKind, MirStmt, MirType, Operand, Place, Rvalue, Terminator, TypeId, UnaryFloatOp,
   12|       |    UnaryIntOp,
   13|       |};
   14|       |use cranelift::codegen::ir::{AtomicRmwOp, Inst, StackSlot, StackSlotData, StackSlotKind};
   15|       |use cranelift::prelude::{
   16|       |    AbiParam, Block, Configurable, FloatCC, FunctionBuilderContext, InstBuilder, IntCC, MemFlags, Signature, Type,
   17|       |    Value, types,
   18|       |};
   19|       |use cranelift_frontend::FunctionBuilder;
   20|       |use cranelift_module::{DataDescription, DataId, FuncId, Linkage, Module};
   21|       |use cranelift_object::{ObjectBuilder, ObjectModule};
   22|       |use hashbrown::HashMap;
   23|       |use hashbrown::HashSet;
   24|       |use target_lexicon::Triple;
   25|       |
   26|       |/// emitted from codegen
   27|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   28|       |pub(crate) enum EmitKind {
   29|       |    Object,
   30|       |    Clif,
   31|       |}
   32|       |
   33|       |pub(crate) enum ClifOutput {
   34|       |    ObjectFile(Vec<u8>),
   35|       |    ClifDump(String),
   36|       |}
   37|       |
   38|       |/// Helper function to convert MIR type to Cranelift type
   39|       |/// Returns None for void types, as they don't have a representation in Cranelift
   40|  1.22k|fn lower_type(mir_type: &MirType) -> Option<Type> {
   41|  1.22k|    match mir_type {
   42|     37|        MirType::Void => None,
   43|      4|        MirType::Bool => Some(types::I8), // Booleans as i8 (standard C)
   44|       |
   45|    102|        MirType::I8 | MirType::U8 => Some(types::I8),
   46|     10|        MirType::I16 | MirType::U16 => Some(types::I16),
   47|    747|        MirType::I32 | MirType::U32 => Some(types::I32),
   48|     29|        MirType::I64 | MirType::U64 => Some(types::I64),
   49|      4|        MirType::F32 => Some(types::F32),
   50|     17|        MirType::F64 => Some(types::F64),
   51|     29|        MirType::F80 | MirType::F128 => Some(types::F128),
   52|    178|        MirType::Pointer { .. } => Some(types::I64), // Pointers are 64-bit on most modern systems
   53|       |
   54|     69|        MirType::Array { .. } | MirType::Record { .. } => None,
   55|      1|        MirType::Function { .. } => Some(types::I64), // Function pointers
   56|       |    }
   57|  1.22k|}
   58|       |
   59|       |/// Helper function to convert MIR function kind to Cranelift linkage
   60|    210|fn lower_linkage(kind: MirFunctionKind) -> Linkage {
   61|    210|    match kind {
   62|     60|        MirFunctionKind::Extern => Linkage::Import,
   63|    150|        MirFunctionKind::Defined => Linkage::Export,
   64|       |    }
   65|    210|}
   66|       |
   67|       |/// Helper function to get the size of a MIR type in bytes
   68|    298|fn lower_type_size(mir_type: &MirType, mir: &MirProgram) -> Result<u32, String> {
   69|    298|    match mir_type {
   70|     49|        MirType::I8 | MirType::U8 => Ok(1),
   71|      7|        MirType::I16 | MirType::U16 => Ok(2),
   72|    110|        MirType::I32 | MirType::U32 => Ok(4),
   73|      4|        MirType::I64 | MirType::U64 => Ok(8),
   74|      0|        MirType::F32 => Ok(4),
   75|      1|        MirType::F64 => Ok(8),
   76|      8|        MirType::F80 | MirType::F128 => Ok(16),
   77|       |
   78|     15|        MirType::Pointer { .. } => Ok(mir.pointer_width as u32),
   79|     24|        MirType::Array { layout, .. } => Ok(layout.size as u32),
   80|     78|        MirType::Record { layout, .. } => Ok(layout.size as u32),
   81|      2|        MirType::Bool => Ok(1),
   82|      0|        MirType::Void => Ok(0),
   83|       |        // For other complex types, let's have a default, though this should be comprehensive.
   84|      0|        _ => Ok(4), // Default size for other types
   85|       |    }
   86|    298|}
   87|       |
   88|       |/// Context for constant emission
   89|       |pub(crate) struct EmitContext<'a> {
   90|       |    pub mir: &'a MirProgram,
   91|       |    pub func_id_map: &'a HashMap<MirFunctionId, FuncId>,
   92|       |    pub data_id_map: &'a HashMap<GlobalId, DataId>,
   93|       |}
   94|       |
   95|       |/// Context for emitting function bodies
   96|       |pub(crate) struct BodyEmitContext<'a, 'b> {
   97|       |    pub builder: &'a mut FunctionBuilder<'b>,
   98|       |    pub mir: &'a MirProgram,
   99|       |    pub stack_slots: &'a HashMap<LocalId, StackSlot>,
  100|       |    pub module: &'a mut ObjectModule,
  101|       |    pub clif_blocks: &'a HashMap<MirBlockId, Block>,
  102|       |    pub worklist: &'a mut Vec<MirBlockId>,
  103|       |    pub return_type: Option<Type>,
  104|       |    pub va_spill_slot: Option<StackSlot>,
  105|       |    pub func: &'a MirFunction,
  106|       |    pub func_id_map: &'a HashMap<MirFunctionId, FuncId>,
  107|       |    pub data_id_map: &'a HashMap<GlobalId, DataId>,
  108|       |    pub triple: &'a Triple,
  109|       |    pub set_al_func: &'a mut Option<FuncId>,
  110|       |}
  111|       |
  112|       |/// Helper to emit integer constants
  113|    671|fn emit_const_int(val: i64, layout: &MirType, output: &mut Vec<u8>) -> Result<(), String> {
  114|    671|    match layout {
  115|    623|        MirType::I8 | MirType::U8 => {
  116|    623|            let bytes = (val as i8).to_le_bytes();
  117|    623|            output.extend_from_slice(&bytes);
  118|    623|        }
  119|      9|        MirType::I16 | MirType::U16 => {
  120|      9|            let bytes = (val as i16).to_le_bytes();
  121|      9|            output.extend_from_slice(&bytes);
  122|      9|        }
  123|     31|        MirType::I32 | MirType::U32 => {
  124|     31|            let bytes = (val as i32).to_le_bytes();
  125|     31|            output.extend_from_slice(&bytes);
  126|     31|        }
  127|      8|        MirType::I64 | MirType::U64 => {
  128|      8|            let bytes = val.to_le_bytes();
  129|      8|            output.extend_from_slice(&bytes);
  130|      8|        }
  131|       |        MirType::Bool => {
  132|      0|            let byte = if val != 0 { 1u8 } else { 0u8 };
  133|      0|            output.push(byte);
  134|       |        }
  135|      0|        MirType::Pointer { .. } => {
  136|      0|            let bytes = (val).to_le_bytes();
  137|      0|            output.extend_from_slice(&bytes);
  138|      0|        }
  139|      0|        _ => {
  140|      0|            let bytes = (val as i32).to_le_bytes();
  141|      0|            output.extend_from_slice(&bytes);
  142|      0|        }
  143|       |    }
  144|    671|    Ok(())
  145|    671|}
  146|       |
  147|      0|fn f64_to_f128_bytes(val: f64) -> [u8; 16] {
  148|      0|    let bits = val.to_bits();
  149|      0|    let sign = (bits >> 63) & 1;
  150|      0|    let exp = (bits >> 52) & 0x7FF;
  151|      0|    let mant = bits & 0xFFFFFFFFFFFFF;
  152|       |
  153|      0|    let (new_exp, new_mant) = if exp == 0 {
  154|      0|        if mant == 0 {
  155|       |            // Zero
  156|      0|            (0, 0)
  157|       |        } else {
  158|       |            // Subnormal f64 -> Normal f128
  159|       |            // mant is 0.bbbb... (52 bits)
  160|      0|            let lz = mant.leading_zeros() - (64 - 52);
  161|      0|            let shift = lz + 1;
  162|      0|            let normalized_mant = mant << shift;
  163|      0|            let payload = normalized_mant & 0xFFFFFFFFFFFFF; // 52 bits
  164|       |
  165|      0|            let unbiased_exp = -1022 - (shift as i32);
  166|      0|            let biased_exp = unbiased_exp + 16383;
  167|       |
  168|      0|            (biased_exp as u64, (payload as u128) << (112 - 52))
  169|       |        }
  170|      0|    } else if exp == 0x7FF {
  171|       |        // Inf or NaN
  172|      0|        (0x7FFF, (mant as u128) << (112 - 52))
  173|       |    } else {
  174|       |        // Normal
  175|      0|        let unbiased_exp = (exp as i32) - 1023;
  176|      0|        let biased_exp = unbiased_exp + 16383;
  177|      0|        (biased_exp as u64, (mant as u128) << (112 - 52))
  178|       |    };
  179|       |
  180|      0|    let sign_bit = (sign as u128) << 127;
  181|      0|    let exp_bits = (new_exp as u128) << 112;
  182|      0|    let mant_bits = new_mant;
  183|       |
  184|      0|    let result = sign_bit | exp_bits | mant_bits;
  185|      0|    result.to_le_bytes()
  186|      0|}
  187|       |
  188|      8|fn f64_to_x87_bytes(val: f64) -> [u8; 16] {
  189|      8|    let bits = val.to_bits();
  190|      8|    let sign = (bits >> 63) & 1;
  191|      8|    let exp = (bits >> 52) & 0x7FF;
  192|      8|    let mant = bits & 0xFFFFFFFFFFFFF;
  193|       |
  194|      8|    let mut out = [0u8; 16];
  195|       |
  196|      8|    if exp == 0 {
  197|      0|        if mant == 0 {
  198|       |            // Zero
  199|      0|            if sign == 1 {
  200|      0|                out[9] = 0x80;
  201|      0|            }
  202|      0|            return out;
  203|      0|        }
  204|       |
  205|       |        // Subnormal f64
  206|       |        // Calculate leading zeros in the 52-bit mantissa
  207|       |        // 12 zeros because u64 has 64 bits but mant only 52
  208|      0|        let lz = mant.leading_zeros() - 12;
  209|       |
  210|       |        // Shift to make MSB 1 (integer bit for x87)
  211|       |        // We want to put the first '1' at bit 63.
  212|       |        // Currently it is at (51 - lz).
  213|       |        // Shift left by 63 - (51 - lz) = 12 + lz.
  214|      0|        let new_mant = mant << (12 + lz);
  215|       |
  216|       |        // Exponent calculation
  217|       |        // Real exponent of f64 subnormal is -1022.
  218|       |        // We effectively shifted left by (lz + 1) to normalize (because we moved 0.1... to 1.0...)
  219|       |        // So we must subtract (lz + 1) from exponent.
  220|      0|        let real_exp = -1022 - (lz as i32 + 1);
  221|       |
  222|       |        // x87 bias 16383
  223|      0|        let new_exp_biased = (real_exp + 16383) as u16;
  224|       |
  225|      0|        out[0..8].copy_from_slice(&new_mant.to_le_bytes());
  226|      0|        out[8..10].copy_from_slice(&new_exp_biased.to_le_bytes());
  227|      0|        if sign == 1 {
  228|      0|            out[9] |= 0x80;
  229|      0|        }
  230|      0|        return out;
  231|      8|    } else if exp == 0x7FF {
  232|       |        // Inf or NaN
  233|      0|        out[8] = 0xFF;
  234|      0|        out[9] = 0x7F | ((sign as u8) << 7);
  235|       |
  236|      0|        if mant == 0 {
  237|      0|            // Infinity: Integer bit 1, mantissa 0
  238|      0|            out[7] = 0x80;
  239|      0|        } else {
  240|      0|            // NaN: Set integer bit 1
  241|      0|            // f64 mantissa is 52 bits. x87 is 63 bits.
  242|      0|            // Shift left by 11.
  243|      0|            let new_mant = (1u64 << 63) | (mant << 11);
  244|      0|            out[0..8].copy_from_slice(&new_mant.to_le_bytes());
  245|      0|        }
  246|      0|        return out;
  247|      8|    }
  248|       |
  249|       |    // Normal f64
  250|      8|    let unbiased_exp = (exp as i32) - 1023;
  251|      8|    let new_exp = (unbiased_exp + 16383) as u16;
  252|       |
  253|       |    // Explicit integer bit 1 for Normal numbers in x87
  254|      8|    let new_mant = (1u64 << 63) | (mant << 11);
  255|       |
  256|      8|    out[0..8].copy_from_slice(&new_mant.to_le_bytes());
  257|      8|    out[8..10].copy_from_slice(&new_exp.to_le_bytes());
  258|       |
  259|       |    // Sign bit in byte 9, bit 7
  260|      8|    if sign == 1 {
  261|      0|        out[9] |= 0x80;
  262|      8|    }
  263|       |
  264|      8|    out
  265|      8|}
  266|       |
  267|       |/// Helper to emit float constants
  268|      7|fn emit_const_float(val: f64, ty: &MirType, output: &mut Vec<u8>) -> Result<(), String> {
  269|      7|    match ty {
  270|      2|        MirType::F32 => {
  271|      2|            let bytes = (val as f32).to_bits().to_le_bytes();
  272|      2|            output.extend_from_slice(&bytes);
  273|      2|        }
  274|      1|        MirType::F64 => {
  275|      1|            let bytes = val.to_bits().to_le_bytes();
  276|      1|            output.extend_from_slice(&bytes);
  277|      1|        }
  278|      4|        MirType::F80 => {
  279|      4|            let bytes = f64_to_x87_bytes(val);
  280|      4|            output.extend_from_slice(&bytes);
  281|      4|        }
  282|      0|        MirType::F128 => {
  283|      0|            let bytes = f64_to_f128_bytes(val);
  284|      0|            output.extend_from_slice(&bytes);
  285|      0|        }
  286|      0|        _ => {
  287|      0|            let bytes = val.to_bits().to_le_bytes();
  288|      0|            output.extend_from_slice(&bytes);
  289|      0|        }
  290|       |    }
  291|      7|    Ok(())
  292|      7|}
  293|       |
  294|       |/// Helper to emit struct constants
  295|     11|fn emit_const_struct(
  296|     11|    fields: &[(usize, ConstValueId)],
  297|     11|    ty: &MirType,
  298|     11|    output: &mut Vec<u8>,
  299|     11|    ctx: &EmitContext,
  300|     11|    mut module: Option<&mut ObjectModule>,
  301|     11|    mut data_description: Option<&mut DataDescription>,
  302|     11|    base_offset: u32,
  303|     11|) -> Result<(), String> {
  304|     11|    match ty {
  305|       |        MirType::Record {
  306|     11|            layout: record_layout,
  307|       |            field_types: _,
  308|       |            ..
  309|       |        } => {
  310|       |            // Initialize the entire struct with zeros
  311|     11|            let struct_size = record_layout.size as usize;
  312|     11|            let mut struct_bytes = vec![0u8; struct_size];
  313|       |
  314|       |            // Emit each field at its proper offset
  315|     34|            for (field_index, field_const_id) in fields {
                               ^23          ^23
  316|     23|                if *field_index < record_layout.field_offsets.len() {
  317|     23|                    let field_offset = record_layout.field_offsets[*field_index] as usize;
  318|       |
  319|     23|                    let mut field_bytes = Vec::new();
  320|     23|                    emit_const(
  321|     23|                        *field_const_id,
  322|     23|                        &mut field_bytes,
  323|     23|                        ctx,
  324|     23|                        reborrow_module(&mut module),
  325|     23|                        reborrow_data_description(&mut data_description),
  326|     23|                        base_offset + field_offset as u32,
  327|      0|                    )?;
  328|       |
  329|       |                    // Copy the field bytes into the struct buffer
  330|     23|                    let required_size = field_offset + field_bytes.len();
  331|     23|                    if required_size > struct_bytes.len() {
  332|      0|                        struct_bytes.resize(required_size, 0);
  333|     23|                    }
  334|     23|                    struct_bytes[field_offset..field_offset + field_bytes.len()].copy_from_slice(&field_bytes);
  335|      0|                }
  336|       |            }
  337|     11|            output.extend_from_slice(&struct_bytes);
  338|     11|            Ok(())
  339|       |        }
  340|      0|        _ => Err("StructLiteral with non-record type".to_string()),
  341|       |    }
  342|     11|}
  343|       |
  344|       |/// Helper to emit array constants
  345|       |#[allow(clippy::manual_saturating_arithmetic, clippy::manual_repeat_n)]
  346|     57|fn emit_const_array(
  347|     57|    elements: &[ConstValueId],
  348|     57|    ty: &MirType,
  349|     57|    output: &mut Vec<u8>,
  350|     57|    ctx: &EmitContext,
  351|     57|    mut module: Option<&mut ObjectModule>,
  352|     57|    mut data_description: Option<&mut DataDescription>,
  353|     57|    base_offset: u32,
  354|     57|) {
  355|       |    let MirType::Array {
  356|     57|        element,
  357|     57|        size,
  358|     57|        layout: array_layout,
  359|     57|    } = ty
  360|       |    else {
  361|      0|        panic!("ArrayLiteral with non-array type");
  362|       |    };
  363|       |
  364|     57|    let element_type = ctx.mir.get_type(*element);
  365|     57|    let element_size = lower_type_size(element_type, ctx.mir).expect("valid type") as usize;
  366|     57|    let stride = array_layout.stride as usize;
  367|     57|    let padding = stride.checked_sub(element_size).unwrap_or(0);
  368|       |
  369|    672|    for (i, element_const_id) in elements.iter().take(*size).enumerate() {
                                               ^57      ^57    ^57  ^57    ^57
  370|    672|        let element_offset = (i * stride) as u32;
  371|       |
  372|    672|        emit_const(
  373|    672|            *element_const_id,
  374|    672|            output,
  375|    672|            ctx,
  376|    672|            reborrow_module(&mut module),
  377|    672|            reborrow_data_description(&mut data_description),
  378|    672|            base_offset + element_offset,
  379|       |        )
  380|    672|        .expect("emit_const failed");
  381|       |
  382|    672|        if padding > 0 {
  383|      0|            output.extend(std::iter::repeat(0).take(padding));
  384|    672|        }
  385|       |    }
  386|       |
  387|       |    // Fill remaining space with zeros if array is partially initialized
  388|     57|    let count = elements.len().min(*size);
  389|     57|    let emitted_size = count * stride;
  390|     57|    let total_size = array_layout.size as usize;
  391|       |
  392|     57|    if emitted_size < total_size {
  393|      0|        let remaining = total_size - emitted_size;
  394|      0|        output.extend(std::iter::repeat(0).take(remaining));
  395|     57|    }
  396|     57|}
  397|       |
  398|       |/// Emit a constant value to the output buffer based on its type layout
  399|    762|pub(crate) fn emit_const(
  400|    762|    const_id: ConstValueId,
  401|    762|    output: &mut Vec<u8>,
  402|    762|    ctx: &EmitContext,
  403|    762|    mut module: Option<&mut ObjectModule>,
  404|    762|    mut data_description: Option<&mut DataDescription>,
  405|    762|    offset: u32,
  406|    762|) -> Result<(), String> {
  407|    762|    let const_value = ctx
  408|    762|        .mir
  409|    762|        .constants
  410|    762|        .get(&const_id)
  411|    762|        .ok_or_else(|| format!("Constant ID {} not found", const_id.get()))?;
                                     ^0      ^0                          ^0       ^0     ^0
  412|       |
  413|    762|    let ty = ctx.mir.get_type(const_value.ty);
  414|       |
  415|    762|    match &const_value.kind {
  416|    671|        ConstValueKind::Int(val) => emit_const_int(*val, ty, output),
  417|      7|        ConstValueKind::Float(val) => emit_const_float(*val, ty, output),
  418|      0|        ConstValueKind::Bool(val) => {
  419|      0|            let byte = if *val { 1u8 } else { 0u8 };
  420|      0|            output.push(byte);
  421|      0|            Ok(())
  422|       |        }
  423|       |        ConstValueKind::Null => {
  424|       |            // Emit null as all zeros (pointer-sized)
  425|      0|            let null_bytes = 0i64.to_le_bytes();
  426|      0|            output.extend_from_slice(&null_bytes);
  427|      0|            Ok(())
  428|       |        }
  429|       |        ConstValueKind::Zero => {
  430|       |            // Emit zeros for the entire type size
  431|     12|            let size = lower_type_size(ty, ctx.mir)? as usize;
                                                                 ^0
  432|     12|            output.extend_from_slice(&vec![0u8; size]);
  433|     12|            Ok(())
  434|       |        }
  435|      3|        ConstValueKind::GlobalAddress(global_id) => {
  436|       |            // Handle Global Relocation
  437|      3|            if let (Some(dd), Some(mod_obj)) = (&mut data_description, &mut module) {
  438|      3|                if let Some(&data_id) = ctx.data_id_map.get(global_id) {
  439|      3|                    let global_val = mod_obj.declare_data_in_data(data_id, dd);
  440|      3|                    dd.write_data_addr(offset, global_val, 0);
  441|      3|                } else {
  442|      0|                    return Err(format!(
  443|      0|                        "Global ID {} not found in map during relocation",
  444|      0|                        global_id.get()
  445|      0|                    ));
  446|       |                }
  447|      0|            }
  448|       |
  449|       |            // Emit zero placeholder
  450|      3|            let addr_bytes = 0i64.to_le_bytes();
  451|      3|            output.extend_from_slice(&addr_bytes);
  452|      3|            Ok(())
  453|       |        }
  454|      1|        ConstValueKind::FunctionAddress(func_id) => {
  455|       |            // Handle Function Relocation
  456|      1|            if let (Some(dd), Some(mod_obj)) = (&mut data_description, &mut module) {
  457|      1|                if let Some(&clif_func_id) = ctx.func_id_map.get(func_id) {
  458|      1|                    let func_ref = mod_obj.declare_func_in_data(clif_func_id, dd);
  459|      1|                    dd.write_function_addr(offset, func_ref);
  460|      1|                } else {
  461|      0|                    println!(
  462|      0|                        "Warning: Function ID {} not found in map during relocation. Maps available: {:?}",
  463|      0|                        func_id.get(),
  464|      0|                        ctx.func_id_map.keys()
  465|      0|                    );
  466|      0|                }
  467|      0|            }
  468|       |
  469|       |            // Emit zero placeholder
  470|      1|            let addr_bytes = 0i64.to_le_bytes();
  471|      1|            output.extend_from_slice(&addr_bytes);
  472|      1|            Ok(())
  473|       |        }
  474|     11|        ConstValueKind::StructLiteral(fields) => {
  475|     11|            emit_const_struct(fields, ty, output, ctx, module, data_description, offset)
  476|       |        }
  477|     57|        ConstValueKind::ArrayLiteral(elements) => {
  478|     57|            emit_const_array(elements, ty, output, ctx, module, data_description, offset);
  479|     57|            Ok(())
  480|       |        }
  481|       |    }
  482|    762|}
  483|       |
  484|    695|fn reborrow_module<'b>(m: &'b mut Option<&mut ObjectModule>) -> Option<&'b mut ObjectModule> {
  485|    695|    m.as_mut().map(|inner| &mut **inner)
  486|    695|}
  487|       |
  488|    695|fn reborrow_data_description<'b>(dd: &'b mut Option<&mut DataDescription>) -> Option<&'b mut DataDescription> {
  489|    695|    dd.as_mut().map(|inner| &mut **inner)
  490|    695|}
  491|       |
  492|       |/// Helper to determine if a type consumes an XMM register (float/vector)
  493|    240|fn is_xmm_argument(mir_type: &MirType) -> bool {
  494|    240|    matches!(mir_type, MirType::F32 | MirType::F64 | MirType::F80 | MirType::F128)
                  ^198
  495|    240|}
  496|       |
  497|       |/// Helper to determine if a type should be packed into registers (I64)
  498|       |/// Returns Some(count) of I64 registers needed (max 2)
  499|    194|fn get_struct_packing(mir_type: &MirType, mir: &MirProgram) -> Option<usize> {
  500|    194|    if !mir_type.is_aggregate() {
  501|    178|        return None;
  502|     16|    }
  503|       |
  504|     16|    let size = lower_type_size(mir_type, mir).ok()?;
                                                                ^0
  505|     16|    if size == 0 || size > 16 {
  506|      0|        return None;
  507|     16|    }
  508|       |
  509|     16|    Some(size.div_ceil(8) as usize)
  510|    194|}
  511|       |
  512|       |/// Helper to prepare a function signature for a call
  513|     80|fn lower_call_signature(
  514|     80|    call_conv: cranelift::codegen::isa::CallConv,
  515|     80|    return_type_id: TypeId,
  516|     80|    param_types: &[TypeId],
  517|     80|    args: &[Operand],
  518|     80|    mir: &MirProgram,
  519|     80|    is_variadic: bool,
  520|     80|    use_variadic_hack: bool,
  521|     80|    triple: &Triple,
  522|     80|) -> Signature {
  523|     80|    let mut sig = Signature::new(call_conv);
  524|       |    // sig.set_is_variadic(is_variadic); // Try if this method exists
  525|       |
  526|       |    // Return type
  527|     80|    let return_mir_type = mir.get_type(return_type_id);
  528|     80|    let return_type_opt = match lower_type(return_mir_type) {
  529|     72|        Some(t) => Some(t),
  530|      8|        None if return_mir_type.is_aggregate() => Some(types::I64),
                                                           ^0   ^0
  531|      8|        None => None,
  532|       |    };
  533|     80|    if let Some(ret_type) = return_type_opt {
                              ^72
  534|     72|        sig.returns.push(AbiParam::new(ret_type));
  535|     72|    }
                  ^8
  536|       |
  537|       |    // Use split ABI for internal functions (defined or indirect calls)
  538|     80|    let split_f128 = use_variadic_hack;
  539|       |
  540|       |    // Track used XMM registers for SystemV ABI hack
  541|     80|    let mut xmm_used = 0;
  542|       |
  543|       |    // Fixed parameters
  544|    163|    for &param_type_id in param_types {
                       ^83
  545|     83|        let mir_type = mir.get_type(param_type_id);
  546|       |
  547|     83|        if is_xmm_argument(mir_type) {
  548|      0|            xmm_used += 1;
  549|     83|        }
  550|       |
  551|       |        // Check for struct packing (HFA workaround: pass as I64s in GPRs)
  552|     83|        if let Some(count) = get_struct_packing(mir_type, mir) {
                                  ^2
  553|      2|            for _ in 0..count {
  554|      2|                sig.params.push(AbiParam::new(types::I64));
  555|      2|            }
  556|      2|            continue;
  557|     81|        }
  558|       |
  559|     81|        if split_f128 && matches!(mir_type, MirType::F80 | MirType::F128) {
                                       ^9       ^9
  560|      0|            sig.params.push(AbiParam::new(types::I64));
  561|      0|            sig.params.push(AbiParam::new(types::I64));
  562|      0|            continue;
  563|     81|        }
  564|       |
  565|     81|        let param_type = match lower_type(mir_type) {
  566|     81|            Some(t) => t,
  567|      0|            None if mir_type.is_aggregate() => types::I64,
  568|      0|            None => types::I32, // Should not happen for valid MIR
  569|       |        };
  570|     81|        sig.params.push(AbiParam::new(param_type));
  571|       |    }
  572|       |
  573|       |    // Variadic arguments (if any) - structs are expanded to multiple I64 slots
  574|     80|    for arg in args.iter().skip(param_types.len()) {
                      ^62
  575|     62|        let arg_type_id = lower_operand_type_id(arg, mir).ok();
  576|     62|        if let Some(type_id) = arg_type_id {
  577|     62|            let mir_type = mir.get_type(type_id);
  578|     62|            if mir_type.is_aggregate() {
  579|       |                // For structs/arrays, calculate how many I64 slots we need
  580|      5|                let size = lower_type_size(mir_type, mir).unwrap_or(8);
  581|      5|                let num_slots = size.div_ceil(8) as usize; // Round up to nearest 8 bytes
  582|     33|                for _ in 0..num_slots {
                                          ^5
  583|     33|                    sig.params.push(AbiParam::new(types::I64));
  584|     33|                }
  585|      5|                continue;
  586|     57|            }
  587|       |
  588|     57|            if split_f128 && matches!(mir_type, MirType::F80 | MirType::F128) {
                                           ^2       ^3
  589|      1|                sig.params.push(AbiParam::new(types::I64));
  590|      1|                sig.params.push(AbiParam::new(types::I64));
  591|      1|                continue;
  592|     56|            }
  593|       |
  594|       |            // HACK: For x86_64 SystemV extern calls, force long double (F80/F128) to stack
  595|       |            // by exhausting XMM registers if they are not already full.
  596|     56|            if !split_f128
  597|     54|                && triple.architecture == target_lexicon::Architecture::X86_64
  598|     54|                && matches!(mir_type, MirType::F80 | MirType::F128)
                                 ^43
  599|       |            {
  600|     11|                let needed_padding = 8usize.saturating_sub(xmm_used);
  601|     55|                for _ in 0..needed_padding {
                                          ^11
  602|     55|                    sig.params.push(AbiParam::new(types::F64));
  603|     55|                }
  604|       |                // We've effectively filled the registers
  605|     11|                xmm_used = 8;
  606|     45|            }
  607|       |
  608|     56|            if is_xmm_argument(mir_type) {
  609|     21|                xmm_used += 1;
  610|     35|            }
  611|      0|        }
  612|     56|        let mut arg_type = lower_operand_type(arg, mir).unwrap_or(types::I32);
  613|       |
  614|     56|        if is_variadic && arg_type == types::F32 {
  615|      0|            arg_type = types::F64;
  616|     56|        }
  617|       |
  618|     56|        if use_variadic_hack {
  619|       |            // Normalized Variadic Signature hack: promote variadic GPR args to i64
  620|      2|            if is_variadic && arg_type.is_int() && arg_type.bits() < 64 {
  621|      2|                arg_type = types::I64;
  622|      2|            }
                          ^0
  623|     54|        }
  624|       |
  625|     56|        sig.params.push(AbiParam::new(arg_type));
  626|       |    }
  627|       |
  628|     80|    if use_variadic_hack {
  629|       |        // Normalized Variadic Signature hack: Ensure at least 32 slots for variadic functions
  630|       |        // This matches the 32-slot spill area in lower_function_signature
  631|      8|        if is_variadic {
  632|      5|            let current_gpr_count = sig.params.len();
  633|      5|            let total_variadic_slots = 128;
  634|      5|            if current_gpr_count < total_variadic_slots {
  635|    599|                for _ in 0..(total_variadic_slots - current_gpr_count) {
                                          ^5
  636|    599|                    sig.params.push(AbiParam::new(types::I64));
  637|    599|                }
  638|      0|            }
  639|      3|        }
  640|     72|    }
  641|       |
  642|     80|    sig
  643|     80|}
  644|       |
  645|       |/// Helper to resolve arguments for a call, handling variadic struct expansion if needed
  646|     42|fn emit_call_args(
  647|     42|    args: &[Operand],
  648|     42|    fixed_param_count: usize,
  649|     42|    sig: &Signature,
  650|     42|    ctx: &mut BodyEmitContext,
  651|     42|    is_variadic: bool,
  652|     42|    split_f128: bool,
  653|     42|    triple: &Triple,
  654|     42|) -> Result<Vec<Value>, String> {
  655|     42|    let mut arg_values = Vec::new();
  656|     42|    let mut sig_idx = 0;
  657|     42|    let mut xmm_used = 0;
  658|       |
  659|       |    // Count XMM usage from fixed parameters first (checking signatures from ctx.mir logic if needed)
  660|       |    // But here we iterate all args. We need to distinguish fixed params.
  661|       |    // We can assume first `fixed_param_count` args match `sig`'s first params,
  662|       |    // but `sig` might have split params.
  663|       |    // Simpler: iterate fixed_param_count args and check types.
  664|     45|    for i in 0..fixed_param_count {
                              ^42
  665|     45|        if let Some(arg) = args.get(i)
  666|     45|            && let Ok(type_id) = lower_operand_type_id(arg, ctx.mir)
  667|       |        {
  668|     45|            let mir_type = ctx.mir.get_type(type_id);
  669|     45|            if is_xmm_argument(mir_type) {
  670|      0|                xmm_used += 1;
  671|     45|            }
  672|      0|        }
  673|       |    }
  674|       |
  675|    107|    for (arg_idx, arg) in args.iter().enumerate() {
                                        ^42  ^42    ^42
  676|    107|        if sig_idx >= sig.params.len() {
  677|      0|            break;
  678|    107|        }
  679|       |
  680|       |        // Check operand type
  681|    107|        let arg_type_id = lower_operand_type_id(arg, ctx.mir).ok();
  682|       |
  683|       |        // Check for struct packing in fixed parameters
  684|    107|        if arg_idx < fixed_param_count
  685|     45|            && let Some(type_id) = arg_type_id
  686|     45|            && let Some(count) = get_struct_packing(ctx.mir.get_type(type_id), ctx.mir)
                                      ^2
  687|       |        {
  688|       |            // Resolve struct to address
  689|      2|            let struct_addr = emit_operand(arg, ctx, types::I64)?;
                                                                              ^0
  690|      2|            let size = lower_type_size(ctx.mir.get_type(type_id), ctx.mir).unwrap_or(8u32);
  691|       |
  692|      2|            for i in 0..count {
  693|       |                // If it's the last chunk, we might need partial load
  694|      2|                let offset = (i * 8) as i32;
  695|      2|                let remaining = size.saturating_sub((i * 8) as u32);
  696|       |
  697|      2|                let val = if remaining >= 8 {
  698|      2|                    ctx.builder.ins().load(types::I64, MemFlags::new(), struct_addr, offset)
  699|       |                } else {
  700|       |                    // Partial load
  701|      0|                    let mut current_val = ctx.builder.ins().iconst(types::I64, 0);
  702|      0|                    for b in 0..remaining {
  703|      0|                        let byte_val =
  704|      0|                            ctx.builder
  705|      0|                                .ins()
  706|      0|                                .load(types::I8, MemFlags::new(), struct_addr, offset + b as i32);
  707|      0|                        let byte_ext = ctx.builder.ins().uextend(types::I64, byte_val);
  708|      0|                        let shift_amt = ctx.builder.ins().iconst(types::I64, (b * 8) as i64);
  709|      0|                        let shifted = ctx.builder.ins().ishl(byte_ext, shift_amt);
  710|      0|                        current_val = ctx.builder.ins().bor(current_val, shifted);
  711|      0|                    }
  712|      0|                    current_val
  713|       |                };
  714|      2|                arg_values.push(val);
  715|       |            }
  716|       |
  717|      2|            sig_idx += count;
  718|      2|            continue;
  719|    105|        }
  720|       |
  721|       |        // Check if F128 splitting is needed
  722|    105|        if split_f128
  723|     14|            && let Some(type_id) = arg_type_id
  724|     14|            && matches!(ctx.mir.get_type(type_id), MirType::F80 | MirType::F128)
                             ^13
  725|       |        {
  726|      1|            let val = emit_operand(arg, ctx, types::F128)?;
                                                                       ^0
  727|       |            // Split val into lo, hi by storing to stack and reloading
  728|      1|            let slot = ctx
  729|      1|                .builder
  730|      1|                .create_sized_stack_slot(StackSlotData::new(StackSlotKind::ExplicitSlot, 16, 0));
  731|      1|            ctx.builder.ins().stack_store(val, slot, 0);
  732|      1|            let lo = ctx.builder.ins().stack_load(types::I64, slot, 0);
  733|      1|            let hi = ctx.builder.ins().stack_load(types::I64, slot, 8);
  734|       |
  735|      1|            arg_values.push(lo);
  736|      1|            arg_values.push(hi);
  737|       |
  738|      1|            sig_idx += 2;
  739|      1|            continue;
  740|    104|        }
  741|       |
  742|       |        // Check if this is a variadic struct argument that needs expansion
  743|    104|        if is_variadic
  744|    100|            && arg_idx >= fixed_param_count
  745|     61|            && let Some(type_id) = arg_type_id
  746|       |        {
  747|     61|            let mir_type = ctx.mir.get_type(type_id);
  748|     61|            if mir_type.is_aggregate() {
  749|       |                // Get the struct address
  750|      5|                let struct_addr = emit_operand(arg, ctx, types::I64)?;
                                                                                  ^0
  751|       |
  752|       |                // Calculate how many I64 slots this struct needs
  753|      5|                let size = lower_type_size(mir_type, ctx.mir).unwrap_or(8);
  754|      5|                let num_slots = size.div_ceil(8) as usize;
  755|       |
  756|       |                // Load each I64 chunk from the struct
  757|     33|                for slot in 0..num_slots {
                                             ^5
  758|     33|                    if sig_idx < sig.params.len() {
  759|     33|                        let offset = (slot * 8) as i32;
  760|       |
  761|       |                        // Check if this is the last slot and if we need partial load
  762|     33|                        let current_offset = slot * 8;
  763|     33|                        let remaining_bytes = size as usize - current_offset;
  764|       |
  765|     33|                        let value = if remaining_bytes >= 8 {
  766|     32|                            ctx.builder.ins().load(types::I64, MemFlags::new(), struct_addr, offset)
  767|       |                        } else {
  768|       |                            // Partial load byte-by-byte to avoid OOB read
  769|      1|                            let mut current_val = ctx.builder.ins().iconst(types::I64, 0);
  770|      1|                            for i in 0..remaining_bytes {
  771|      1|                                let byte_val =
  772|      1|                                    ctx.builder
  773|      1|                                        .ins()
  774|      1|                                        .load(types::I8, MemFlags::new(), struct_addr, offset + i as i32);
  775|      1|                                let byte_ext = ctx.builder.ins().uextend(types::I64, byte_val);
  776|      1|                                let shift_amt = ctx.builder.ins().iconst(types::I64, (i * 8) as i64);
  777|      1|                                let shifted = ctx.builder.ins().ishl(byte_ext, shift_amt);
  778|      1|                                current_val = ctx.builder.ins().bor(current_val, shifted);
  779|      1|                            }
  780|      1|                            current_val
  781|       |                        };
  782|       |
  783|     33|                        arg_values.push(value);
  784|     33|                        sig_idx += 1;
  785|      0|                    }
  786|       |                }
  787|      5|                continue;
  788|     56|            }
  789|       |
  790|       |            // HACK: Apply padding to force stack usage for long double
  791|     56|            if !split_f128
  792|     54|                && triple.architecture == target_lexicon::Architecture::X86_64
  793|     54|                && matches!(mir_type, MirType::F80 | MirType::F128)
                                 ^43
  794|       |            {
  795|     11|                let needed_padding = 8usize.saturating_sub(xmm_used);
  796|     11|                for _ in 0..needed_padding {
  797|     55|                    if sig_idx < sig.params.len() {
  798|     55|                        arg_values.push(ctx.builder.ins().f64const(0.0));
  799|     55|                        sig_idx += 1;
  800|     55|                    }
                                  ^0
  801|       |                }
  802|     11|                xmm_used = 8;
  803|     45|            }
  804|       |
  805|     56|            if is_xmm_argument(mir_type) {
  806|     21|                xmm_used += 1;
  807|     35|            }
  808|     43|        }
  809|       |
  810|       |        // Update param_type as sig_idx might have changed due to padding
  811|     99|        if sig_idx >= sig.params.len() {
  812|      0|            break;
  813|     99|        }
  814|     99|        let param_type = sig.params[sig_idx].value_type;
  815|       |
  816|       |        // Non-struct argument (or fixed param)
  817|     99|        match emit_operand(arg, ctx, param_type) {
  818|     99|            Ok(value) => arg_values.push(value),
  819|      0|            Err(e) => return Err(format!("Failed to resolve function argument: {}", e)),
  820|       |        }
  821|     99|        sig_idx += 1;
  822|       |    }
  823|       |
  824|       |    // Padding for remaining signature params (variadic slot padding SysV x86_64 hack)
  825|    387|    while sig_idx < sig.params.len() {
  826|    345|        let param_type = sig.params[sig_idx].value_type;
  827|    345|        arg_values.push(ctx.builder.ins().iconst(param_type, 0i64));
  828|    345|        sig_idx += 1;
  829|    345|    }
  830|       |
  831|     42|    Ok(arg_values)
  832|     42|}
  833|       |
  834|       |/// Helper to get the result of a call, or a zero constant if it has no return value
  835|     42|fn get_call_result(builder: &mut FunctionBuilder, call_inst: Inst, expected_type: Type) -> Value {
  836|     42|    let results = builder.inst_results(call_inst);
  837|     42|    if results.is_empty() {
  838|      5|        builder.ins().iconst(expected_type, 0i64)
  839|       |    } else {
  840|     37|        results[0]
  841|       |    }
  842|     42|}
  843|       |
  844|     42|fn emit_function_call(
  845|     42|    call_target: &CallTarget,
  846|     42|    args: &[Operand],
  847|     42|    expected_type: Type,
  848|     42|    ctx: &mut BodyEmitContext,
  849|     42|) -> Result<Value, String> {
  850|       |    // 1. Determine function properties and callee address if indirect/variadic
  851|     42|    let (return_type_id, param_types, is_variadic, name_linkage, target_addr, use_variadic_hack) = match call_target {
  852|     40|        CallTarget::Direct(func_id) => {
  853|     40|            let func = ctx.mir.get_function(*func_id);
  854|     43|            let param_types: Vec<TypeId> = func.params.iter().map(|&p| ctx.mir.get_local(p).type_id).collect();
                              ^40          ^40           ^40                ^40                                    ^40
  855|     40|            let name_linkage = Some((func.name.as_str(), lower_linkage(func.kind)));
  856|     40|            let is_defined = matches!(func.kind, MirFunctionKind::Defined);
                                           ^36
  857|     40|            (
  858|     40|                func.return_type,
  859|     40|                param_types,
  860|     40|                func.is_variadic,
  861|     40|                name_linkage,
  862|     40|                None,
  863|     40|                is_defined,
  864|     40|            )
  865|       |        }
  866|      2|        CallTarget::Indirect(func_operand) => {
  867|      2|            let func_ptr_type_id = lower_operand_type_id(func_operand, ctx.mir)
  868|      2|                .map_err(|e| format!("Failed to get function pointer type: {}", e))?;
                                           ^0      ^0                                            ^0
  869|      2|            let func_ptr_type = ctx.mir.get_type(func_ptr_type_id);
  870|       |
  871|      2|            let ((return_type_id, param_types), is_function_type, is_variadic_call) = match func_ptr_type {
  872|      2|                MirType::Pointer { pointee } => match ctx.mir.get_type(*pointee) {
  873|       |                    MirType::Function {
  874|      2|                        return_type,
  875|      2|                        params,
  876|      2|                        is_variadic,
  877|      2|                    } => ((*return_type, params.clone()), false, *is_variadic),
  878|      0|                    _ => return Err("Indirect call operand points to non-function type".to_string()),
  879|       |                },
  880|       |                MirType::Function {
  881|      0|                    return_type,
  882|      0|                    params,
  883|      0|                    is_variadic,
  884|      0|                } => ((*return_type, params.clone()), true, *is_variadic),
  885|      0|                _ => return Err("Indirect call operand is not a pointer".to_string()),
  886|       |            };
  887|       |
  888|      2|            let callee_val = if is_function_type {
  889|      0|                match func_operand {
  890|      0|                    Operand::Copy(place) => emit_place_addr(place, ctx)?,
  891|      0|                    _ => emit_operand(func_operand, ctx, types::I64)?,
  892|       |                }
  893|       |            } else {
  894|      2|                emit_operand(func_operand, ctx, types::I64)?
                                                                         ^0
  895|       |            };
  896|       |
  897|       |            // Assuming function pointers point to internal functions requiring the hack.
  898|       |            // TODO: Distinguish between internal and external function pointers if possible.
  899|      2|            (
  900|      2|                return_type_id,
  901|      2|                param_types,
  902|      2|                is_variadic_call,
  903|      2|                None,
  904|      2|                Some(callee_val),
  905|      2|                true,
  906|      2|            )
  907|       |        }
  908|       |    };
  909|       |
  910|       |    // 2. Prepare call site signature and resolve arguments
  911|     42|    let sig = lower_call_signature(
  912|     42|        ctx.builder.func.signature.call_conv,
  913|     42|        return_type_id,
  914|     42|        &param_types,
  915|     42|        args,
  916|     42|        ctx.mir,
  917|     42|        is_variadic,
  918|     42|        use_variadic_hack,
  919|     42|        ctx.triple,
  920|       |    );
  921|       |
  922|     42|    let split_f128 = use_variadic_hack;
  923|     42|    let arg_values = emit_call_args(args, param_types.len(), &sig, ctx, is_variadic, split_f128, ctx.triple)?;
                                                                                                                          ^0
  924|       |
  925|       |    // 3. Emit the call
  926|     42|    let call_inst = if is_variadic {
  927|     39|        if let Some((name, linkage)) = name_linkage {
                                   ^38   ^38
  928|       |            // Variadic direct calls must be indirect to use the custom signature
  929|     38|            let canonical_sig = lower_call_signature(
  930|     38|                ctx.builder.func.signature.call_conv,
  931|     38|                return_type_id,
  932|     38|                &param_types,
  933|     38|                &[],
  934|     38|                ctx.mir,
  935|     38|                is_variadic,
  936|     38|                use_variadic_hack,
  937|     38|                ctx.triple,
  938|       |            );
  939|     38|            let decl = ctx
  940|     38|                .module
  941|     38|                .declare_function(name, linkage, &canonical_sig)
  942|     38|                .map_err(|e| format!("Failed to declare variadic function {}: {:?}", name, e))?;
                                           ^0      ^0                                                       ^0
  943|     38|            let func_ref = ctx.module.declare_func_in_func(decl, ctx.builder.func);
  944|     38|            let addr = ctx.builder.ins().func_addr(types::I64, func_ref);
  945|     38|            let sig_ref = ctx.builder.import_signature(sig);
  946|       |
  947|     38|            let addr = emit_al_count_and_pass_addr(args, &param_types, addr, ctx)?;
                                                                                               ^0
  948|       |
  949|     38|            ctx.builder.ins().call_indirect(sig_ref, addr, &arg_values)
  950|      1|        } else if let Some(addr) = target_addr {
  951|      1|            let sig_ref = ctx.builder.import_signature(sig);
  952|      1|            let addr = emit_al_count_and_pass_addr(args, &param_types, addr, ctx)?;
                                                                                               ^0
  953|      1|            ctx.builder.ins().call_indirect(sig_ref, addr, &arg_values)
  954|       |        } else {
  955|      0|            return Err("Variadic call without target".to_string());
  956|       |        }
  957|      3|    } else if let Some(addr) = target_addr {
                                     ^1
  958|      1|        let sig_ref = ctx.builder.import_signature(sig);
  959|      1|        ctx.builder.ins().call_indirect(sig_ref, addr, &arg_values)
  960|       |    } else {
  961|       |        // Direct non-variadic call
  962|      2|        let (name, linkage) = name_linkage.unwrap();
  963|      2|        let decl = ctx
  964|      2|            .module
  965|      2|            .declare_function(name, linkage, &sig)
  966|      2|            .map_err(|e| format!("Failed to declare function {}: {:?}", name, e))?;
                                       ^0      ^0                                              ^0
  967|      2|        let func_ref = ctx.module.declare_func_in_func(decl, ctx.builder.func);
  968|      2|        ctx.builder.ins().call(func_ref, &arg_values)
  969|       |    };
  970|       |
  971|     42|    Ok(get_call_result(ctx.builder, call_inst, expected_type))
  972|     42|}
  973|       |
  974|       |/// Helper function to convert boolean to integer (0 or 1)
  975|     39|fn emit_al_count_and_pass_addr(
  976|     39|    args: &[Operand],
  977|     39|    param_types: &[TypeId],
  978|     39|    addr: Value,
  979|     39|    ctx: &mut BodyEmitContext,
  980|     39|) -> Result<Value, String> {
  981|       |    // x86_64 SysV ABI requires AL to be set to the number of floating point arguments for variadic calls.
  982|     39|    if ctx.triple.architecture == target_lexicon::Architecture::X86_64
  983|     39|        && ctx.builder.func.signature.call_conv == cranelift::codegen::isa::CallConv::SystemV
  984|       |    {
  985|     39|        let mut fp_arg_count = 0;
  986|    101|        for (i, arg) in args.iter().enumerate() {
                                      ^39  ^39    ^39
  987|       |            // Only count arguments that are NOT fixed parameters
  988|    101|            if i >= param_types.len() {
  989|     62|                let arg_mir_type = ctx.mir.get_type(lower_operand_type_id(arg, ctx.mir).unwrap());
  990|     62|                if matches!(arg_mir_type, MirType::F32 | MirType::F64) {
                                 ^52
  991|     10|                    fp_arg_count += 1;
  992|     52|                }
  993|     39|            }
  994|       |        }
  995|       |
  996|       |        // Ensure fp_arg_count doesn't exceed 8 (number of XMM registers used for args)
  997|     39|        let fp_arg_count = fp_arg_count.min(8);
  998|       |
  999|       |        // Define __cendol_set_al if not already defined
 1000|     39|        if ctx.set_al_func.is_none() {
 1001|     24|            *ctx.set_al_func = Some(emit_cendol_set_al(ctx.module)?);
                                                                                ^0
 1002|     15|        }
 1003|       |
 1004|     39|        let set_al_func = ctx.set_al_func.unwrap();
 1005|     39|        let local_set_al = ctx.module.declare_func_in_func(set_al_func, ctx.builder.func);
 1006|     39|        let count_val = ctx.builder.ins().iconst(types::I64, fp_arg_count as i64);
 1007|     39|        let call_inst = ctx.builder.ins().call(local_set_al, &[count_val, addr]);
 1008|     39|        Ok(ctx.builder.inst_results(call_inst)[1]) // Return the address (RDX)
 1009|       |    } else {
 1010|      0|        Ok(addr)
 1011|       |    }
 1012|     39|}
 1013|       |
 1014|     44|fn emit_bool_to_int(val: Value, target_type: Type, builder: &mut FunctionBuilder) -> Value {
 1015|     44|    let one = builder.ins().iconst(target_type, 1);
 1016|     44|    let zero = builder.ins().iconst(target_type, 0i64);
 1017|     44|    builder.ins().select(val, one, zero)
 1018|     44|}
 1019|       |
 1020|       |/// Helper function to emit a memcpy call
 1021|     18|fn emit_memcpy(
 1022|     18|    dest: Value,
 1023|     18|    src: Value,
 1024|     18|    size: i64,
 1025|     18|    builder: &mut FunctionBuilder,
 1026|     18|    module: &mut ObjectModule,
 1027|     18|) -> Result<(), String> {
 1028|     18|    let mut sig = Signature::new(builder.func.signature.call_conv);
 1029|     18|    sig.params.push(AbiParam::new(types::I64)); // dest
 1030|     18|    sig.params.push(AbiParam::new(types::I64)); // src
 1031|     18|    sig.params.push(AbiParam::new(types::I64)); // size
 1032|     18|    sig.returns.push(AbiParam::new(types::I64)); // returns dest (ignored)
 1033|       |
 1034|     18|    let callee = module
 1035|     18|        .declare_function("memcpy", Linkage::Import, &sig)
 1036|     18|        .map_err(|e| format!("Failed to declare memcpy: {:?}", e))?;
                                   ^0      ^0                                   ^0
 1037|     18|    let local_callee = module.declare_func_in_func(callee, builder.func);
 1038|       |
 1039|     18|    let size_val = builder.ins().iconst(types::I64, size);
 1040|     18|    builder.ins().call(local_callee, &[dest, src, size_val]);
 1041|     18|    Ok(())
 1042|     18|}
 1043|       |
 1044|       |/// Helper function to emit a memset call
 1045|      7|fn emit_memset(
 1046|      7|    dest: Value,
 1047|      7|    val: i8,
 1048|      7|    size: i64,
 1049|      7|    builder: &mut FunctionBuilder,
 1050|      7|    module: &mut ObjectModule,
 1051|      7|) -> Result<(), String> {
 1052|      7|    let mut sig = Signature::new(builder.func.signature.call_conv);
 1053|      7|    sig.params.push(AbiParam::new(types::I64)); // dest
 1054|      7|    sig.params.push(AbiParam::new(types::I32)); // val
 1055|      7|    sig.params.push(AbiParam::new(types::I64)); // size
 1056|      7|    sig.returns.push(AbiParam::new(types::I64)); // returns dest (ignored)
 1057|       |
 1058|      7|    let callee = module
 1059|      7|        .declare_function("memset", Linkage::Import, &sig)
 1060|      7|        .map_err(|e| format!("Failed to declare memset: {:?}", e))?;
                                   ^0      ^0                                   ^0
 1061|      7|    let local_callee = module.declare_func_in_func(callee, builder.func);
 1062|       |
 1063|      7|    let val_val = builder.ins().iconst(types::I32, val as i64);
 1064|      7|    let size_val = builder.ins().iconst(types::I64, size);
 1065|      7|    builder.ins().call(local_callee, &[dest, val_val, size_val]);
 1066|      7|    Ok(())
 1067|      7|}
 1068|       |
 1069|       |/// Helper function to emit a type conversion in Cranelift
 1070|    556|fn emit_type_conversion(val: Value, from: Type, to: Type, is_signed: bool, builder: &mut FunctionBuilder) -> Value {
 1071|    556|    if from == to {
 1072|    486|        return val;
 1073|     70|    }
 1074|       |
 1075|       |    // Float to Float
 1076|     70|    if from.is_float() && to.is_float() {
                                        ^4 ^4
 1077|      2|        let from_width = from.bits();
 1078|      2|        let to_width = to.bits();
 1079|      2|        if from_width < to_width {
 1080|      2|            return builder.ins().fpromote(to, val);
 1081|      0|        } else if from_width > to_width {
 1082|      0|            return builder.ins().fdemote(to, val);
 1083|       |        } else {
 1084|      0|            return val;
 1085|       |        }
 1086|     68|    }
 1087|       |
 1088|       |    // Integer to Float
 1089|     68|    if from.is_int() && to.is_float() {
                                      ^66^66
 1090|      0|        return if is_signed {
 1091|      0|            builder.ins().fcvt_from_sint(to, val)
 1092|       |        } else {
 1093|      0|            builder.ins().fcvt_from_uint(to, val)
 1094|       |        };
 1095|     68|    }
 1096|       |
 1097|       |    // Float to Integer
 1098|     68|    if from.is_float() && to.is_int() {
                                        ^2 ^2
 1099|      2|        let to_width = to.bits();
 1100|      2|        if to_width < 32 {
 1101|       |            // Cranelift x64 backend doesn't support fcvt_to_sint/uint for < 32-bit targets
 1102|       |            // Convert to I32 first, then reduce
 1103|      2|            let intermediate = if is_signed {
 1104|      0|                builder.ins().fcvt_to_sint(types::I32, val)
 1105|       |            } else {
 1106|      2|                builder.ins().fcvt_to_uint(types::I32, val)
 1107|       |            };
 1108|      2|            return builder.ins().ireduce(to, intermediate);
 1109|      0|        }
 1110|       |
 1111|      0|        return if is_signed {
 1112|      0|            builder.ins().fcvt_to_sint(to, val)
 1113|       |        } else {
 1114|      0|            builder.ins().fcvt_to_uint(to, val)
 1115|       |        };
 1116|     66|    }
 1117|       |
 1118|       |    // General Integer/Pointer/Bool conversions (Extension/Reduction/Bitcast)
 1119|     66|    let from_width = from.bits();
 1120|     66|    let to_width = to.bits();
 1121|       |
 1122|     66|    if from_width < to_width {
 1123|       |        // Extension
 1124|     45|        if is_signed {
 1125|     10|            builder.ins().sextend(to, val)
 1126|       |        } else {
 1127|     35|            builder.ins().uextend(to, val)
 1128|       |        }
 1129|     21|    } else if from_width > to_width {
 1130|       |        // Reduction
 1131|     21|        builder.ins().ireduce(to, val)
 1132|       |    } else {
 1133|       |        // Same width, diff types (e.g. I64 <-> F64 bitcast, or I32 <-> F32 bitcast, or Pointer types)
 1134|       |        // Note: Float bitcasts usually handled above if involving floats, but check standard bitcast rules.
 1135|       |        // Actually bitcast works for any same-sized types.
 1136|      0|        builder.ins().bitcast(to, MemFlags::new(), val)
 1137|       |    }
 1138|    556|}
 1139|       |
 1140|       |/// Helper to emit a constant to anonymous memory and return its address
 1141|      2|fn emit_constant_to_memory(const_id: ConstValueId, ctx: &mut BodyEmitContext) -> Result<Value, String> {
 1142|      2|    let const_value = ctx.mir.constants.get(&const_id).ok_or("Constant not found")?;
                                                                                                ^0
 1143|      2|    let ty = ctx.mir.get_type(const_value.ty);
 1144|      2|    let size = lower_type_size(ty, ctx.mir)? as usize;
                                                         ^0
 1145|       |
 1146|      2|    let mut bytes = Vec::with_capacity(size);
 1147|      2|    let emit_ctx = EmitContext {
 1148|      2|        mir: ctx.mir,
 1149|      2|        func_id_map: ctx.func_id_map,
 1150|      2|        data_id_map: ctx.data_id_map,
 1151|      2|    };
 1152|       |
 1153|      2|    let mut data_description = DataDescription::new();
 1154|       |
 1155|      2|    emit_const(
 1156|      2|        const_id,
 1157|      2|        &mut bytes,
 1158|      2|        &emit_ctx,
 1159|      2|        Some(&mut *ctx.module),
 1160|      2|        Some(&mut data_description),
 1161|       |        0,
 1162|      0|    )?;
 1163|       |
 1164|      2|    data_description.define(bytes.into_boxed_slice());
 1165|       |
 1166|      2|    let data_id = ctx
 1167|      2|        .module
 1168|      2|        .declare_anonymous_data(false, false)
 1169|      2|        .map_err(|e| format!("Failed to declare anonymous data: {:?}", e))?;
                                   ^0      ^0                                           ^0
 1170|       |
 1171|      2|    ctx.module
 1172|      2|        .define_data(data_id, &data_description)
 1173|      2|        .map_err(|e| format!("Failed to define anonymous data: {:?}", e))?;
                                   ^0      ^0                                          ^0
 1174|       |
 1175|      2|    let global_val = ctx.module.declare_data_in_func(data_id, ctx.builder.func);
 1176|      2|    Ok(ctx.builder.ins().global_value(types::I64, global_val))
 1177|      2|}
 1178|       |
 1179|       |/// Helper function to resolve a MIR operand to a Cranelift value
 1180|    711|fn emit_operand(operand: &Operand, ctx: &mut BodyEmitContext, expected_type: Type) -> Result<Value, String> {
 1181|    711|    match operand {
 1182|    345|        Operand::Constant(const_id) => {
 1183|    345|            let const_value = ctx.mir.constants.get(const_id).expect("constant id not found");
 1184|    345|            match &const_value.kind {
 1185|    291|                ConstValueKind::Int(val) => Ok(ctx.builder.ins().iconst(expected_type, *val)),
 1186|     13|                ConstValueKind::Float(val) => {
 1187|       |                    // Use the appropriate float constant based on expected type
 1188|     13|                    if expected_type == types::F64 {
 1189|      9|                        Ok(ctx.builder.ins().f64const(*val))
 1190|      4|                    } else if expected_type == types::F32 {
 1191|      0|                        Ok(ctx.builder.ins().f32const(*val as f32))
 1192|      4|                    } else if expected_type == types::F128 {
 1193|       |                        // Use memory load for F128 to ensure precision and correct bit pattern (x87 or IEEE)
 1194|      4|                        let bytes = if ctx.triple.architecture == target_lexicon::Architecture::X86_64 {
 1195|      4|                            f64_to_x87_bytes(*val)
 1196|       |                        } else {
 1197|      0|                            f64_to_f128_bytes(*val)
 1198|       |                        };
 1199|       |
 1200|      4|                        let data_id = ctx
 1201|      4|                            .module
 1202|      4|                            .declare_anonymous_data(false, false)
 1203|      4|                            .map_err(|e| format!("Failed to declare anonymous data: {:?}", e))?;
                                                       ^0      ^0                                           ^0
 1204|       |
 1205|      4|                        let mut dd = DataDescription::new();
 1206|      4|                        dd.define(bytes.to_vec().into_boxed_slice());
 1207|      4|                        ctx.module
 1208|      4|                            .define_data(data_id, &dd)
 1209|      4|                            .map_err(|e| format!("Failed to define anonymous data: {:?}", e))?;
                                                       ^0      ^0                                          ^0
 1210|       |
 1211|      4|                        let global_val = ctx.module.declare_data_in_func(data_id, ctx.builder.func);
 1212|      4|                        let addr = ctx.builder.ins().global_value(types::I64, global_val);
 1213|      4|                        Ok(ctx
 1214|      4|                            .builder
 1215|      4|                            .ins()
 1216|      4|                            .load(types::F128, MemFlags::new().with_readonly(), addr, 0))
 1217|       |                    } else {
 1218|      0|                        Ok(ctx.builder.ins().f32const(*val as f32))
 1219|       |                    }
 1220|       |                }
 1221|      0|                ConstValueKind::Bool(val) => {
 1222|      0|                    let int_val = if *val { 1 } else { 0 };
 1223|      0|                    Ok(ctx.builder.ins().iconst(expected_type, int_val))
 1224|       |                }
 1225|      0|                ConstValueKind::Null => Ok(ctx.builder.ins().iconst(expected_type, 0i64)),
 1226|     37|                ConstValueKind::GlobalAddress(global_id) => {
 1227|       |                    // Get the global variable and return its address
 1228|       |                    // This handles the array-to-pointer decay for string literals
 1229|     37|                    let global = ctx.mir.get_global(*global_id);
 1230|       |                    // Use local linkage for string literals and internal symbols to avoid conflicts
 1231|     37|                    let linkage = if global.name.as_str().starts_with(".L.str") {
 1232|     37|                        Linkage::Local
 1233|       |                    } else {
 1234|      0|                        Linkage::Export
 1235|       |                    };
 1236|     37|                    let global_val = ctx
 1237|     37|                        .module
 1238|     37|                        .declare_data(global.name.as_str(), linkage, true, false)
 1239|     37|                        .map_err(|e| format!("Failed to declare global data: {:?}", e))?;
                                                   ^0      ^0                                        ^0
 1240|     37|                    let local_id = ctx.module.declare_data_in_func(global_val, ctx.builder.func);
 1241|       |                    // Global addresses are always pointer-sized (i64)
 1242|     37|                    let addr = ctx.builder.ins().global_value(types::I64, local_id);
 1243|     37|                    Ok(emit_type_conversion(
 1244|     37|                        addr,
 1245|     37|                        types::I64,
 1246|     37|                        expected_type,
 1247|     37|                        false,
 1248|     37|                        ctx.builder,
 1249|     37|                    ))
 1250|       |                }
 1251|      2|                ConstValueKind::FunctionAddress(func_id) => {
 1252|      2|                    if let Some(&clif_func_id) = ctx.func_id_map.get(func_id) {
 1253|      2|                        let func_ref = ctx.module.declare_func_in_func(clif_func_id, ctx.builder.func);
 1254|      2|                        let addr = ctx.builder.ins().func_addr(types::I64, func_ref);
 1255|      2|                        Ok(emit_type_conversion(
 1256|      2|                            addr,
 1257|      2|                            types::I64,
 1258|      2|                            expected_type,
 1259|      2|                            false,
 1260|      2|                            ctx.builder,
 1261|      2|                        ))
 1262|       |                    } else {
 1263|      0|                        Err(format!("Function ID {} not found in map", func_id.get()))
 1264|       |                    }
 1265|       |                }
 1266|       |                ConstValueKind::ArrayLiteral(_) | ConstValueKind::StructLiteral(_) => {
 1267|      2|                    emit_constant_to_memory(*const_id, ctx)
 1268|       |                }
 1269|       |                _ => {
 1270|       |                    // Check if the type is aggregate, if so, we must emit to memory
 1271|       |                    // This handles ConstValueKind::Zero for aggregates
 1272|      0|                    let mir_type = ctx.mir.get_type(const_value.ty);
 1273|      0|                    if mir_type.is_aggregate() {
 1274|      0|                        emit_constant_to_memory(*const_id, ctx)
 1275|       |                    } else {
 1276|      0|                        Ok(ctx.builder.ins().iconst(expected_type, 0i64))
 1277|       |                    }
 1278|       |                }
 1279|       |            }
 1280|       |        }
 1281|    205|        Operand::Copy(place) => {
 1282|       |            // Determine the correct type from the place itself
 1283|    205|            let place_type_id = lower_place_type_id(place, ctx.mir);
 1284|    205|            let place_type = ctx.mir.get_type(place_type_id);
 1285|       |
 1286|    205|            if place_type.is_aggregate() {
 1287|       |                // For aggregate types, resolving the operand value means getting its address
 1288|     19|                let addr = emit_place_addr(place, ctx)?;
                                                                    ^0
 1289|     19|                return Ok(emit_type_conversion(
 1290|     19|                    addr,
 1291|     19|                    types::I64,
 1292|     19|                    expected_type,
 1293|     19|                    false,
 1294|     19|                    ctx.builder,
 1295|     19|                ));
 1296|    186|            }
 1297|       |
 1298|    186|            let place_clif_type =
 1299|    186|                lower_type(place_type).ok_or_else(|| format!("Unsupported place type: {:?}", place_type))?;
                                                                   ^0      ^0                                          ^0
 1300|       |
 1301|    186|            let val = emit_place(place, ctx, place_clif_type)?;
                                                                           ^0
 1302|    186|            Ok(emit_type_conversion(
 1303|    186|                val,
 1304|    186|                place_clif_type,
 1305|    186|                expected_type,
 1306|    186|                place_type.is_signed(),
 1307|    186|                ctx.builder,
 1308|    186|            ))
 1309|       |        }
 1310|    151|        Operand::Cast(type_id, inner_operand) => {
 1311|    151|            let inner_type = lower_operand_type(inner_operand, ctx.mir)?;
                                                                                     ^0
 1312|    151|            let inner_val = emit_operand(inner_operand, ctx, inner_type)?;
                                                                                      ^0
 1313|       |
 1314|    151|            let mir_type = ctx.mir.get_type(*type_id);
 1315|    151|            let target_type = lower_type(mir_type).unwrap_or(types::I32);
 1316|       |
 1317|    151|            let converted = emit_type_conversion(
 1318|    151|                inner_val,
 1319|    151|                inner_type,
 1320|    151|                target_type,
 1321|    151|                is_operand_signed(inner_operand, ctx.mir),
 1322|    151|                ctx.builder,
 1323|       |            );
 1324|    151|            Ok(emit_type_conversion(
 1325|    151|                converted,
 1326|    151|                target_type,
 1327|    151|                expected_type,
 1328|    151|                mir_type.is_signed(),
 1329|    151|                ctx.builder,
 1330|    151|            ))
 1331|       |        }
 1332|     10|        Operand::AddressOf(place) => {
 1333|       |            // The value of an AddressOf operand is the address of the place.
 1334|     10|            let addr = emit_place_addr(place, ctx)?;
                                                                ^0
 1335|     10|            Ok(emit_type_conversion(
 1336|     10|                addr,
 1337|     10|                types::I64,
 1338|     10|                expected_type,
 1339|     10|                false,
 1340|     10|                ctx.builder,
 1341|     10|            ))
 1342|       |        }
 1343|       |    }
 1344|    711|}
 1345|       |
 1346|       |/// Helper function to resolve a MIR place to a Cranelift value
 1347|    186|fn emit_place(place: &Place, ctx: &mut BodyEmitContext, expected_type: Type) -> Result<Value, String> {
 1348|    186|    match place {
 1349|    125|        Place::Local(local_id) => {
 1350|       |            // A local place is resolved by loading from its stack slot
 1351|    125|            if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
 1352|    125|                Ok(ctx.builder.ins().stack_load(expected_type, *stack_slot, 0))
 1353|       |            } else {
 1354|       |                // Zero-sized locals don't have stack slots. Return a dummy value.
 1355|       |                // This can happen with flexible array members or zero-length arrays.
 1356|      0|                Ok(ctx.builder.ins().iconst(expected_type, 0))
 1357|       |            }
 1358|       |        }
 1359|      2|        Place::Global(_global_id) => {
 1360|       |            // First, get the memory address of the global.
 1361|      2|            let addr = emit_place_addr(place, ctx)?;
                                                                ^0
 1362|       |
 1363|       |            // Then, load the value from that address.
 1364|      2|            Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
 1365|       |        }
 1366|      0|        Place::Deref(operand) => {
 1367|       |            // The address is the value of the operand, so we load from that value
 1368|      0|            let addr = emit_operand(operand, ctx, types::I64)?;
 1369|      0|            Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
 1370|       |        }
 1371|     34|        Place::StructField(base_place, field_index) => {
 1372|       |            // Get the address of the struct field
 1373|     34|            let addr = emit_place_addr(&Place::StructField(base_place.clone(), *field_index), ctx)?;
                                                                                                                ^0
 1374|     34|            Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
 1375|       |        }
 1376|     25|        Place::ArrayIndex(base_place, index_operand) => {
 1377|       |            // Get the address of the array element
 1378|     25|            let addr = emit_place_addr(&Place::ArrayIndex(base_place.clone(), index_operand.clone()), ctx)?;
                                                                                                                        ^0
 1379|     25|            Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
 1380|       |        }
 1381|       |    }
 1382|    186|}
 1383|       |
 1384|       |/// Helper function to get the Cranelift Type of an operand
 1385|    314|fn lower_operand_type(operand: &Operand, mir: &MirProgram) -> Result<Type, String> {
 1386|    314|    match operand {
 1387|    128|        Operand::Constant(const_id) => {
 1388|    128|            let const_value = mir.constants.get(const_id).expect("constant id not found");
 1389|    128|            let mir_type = mir.get_type(const_value.ty);
 1390|       |
 1391|       |            // If we have a specific type for the constant, use that to determine the Cranelift type
 1392|    128|            if let Some(clif_type) = lower_type(mir_type) {
                                      ^91
 1393|     91|                return Ok(clif_type);
 1394|     37|            }
 1395|       |
 1396|       |            // Fallback to kind-based determination if type is not convertible (e.g., struct/array)
 1397|     37|            match &const_value.kind {
 1398|       |                // Integer literals in MIR are typically used in integer-sized contexts
 1399|       |                // Default to I32 so common small integer constants (like `4`) match i32
 1400|       |                // places instead of being treated as 64-bit immediates.
 1401|      0|                ConstValueKind::Int(_) => Ok(types::I32),
 1402|      0|                ConstValueKind::Float(_) => Ok(types::F64),
 1403|      0|                ConstValueKind::Bool(_) => Ok(types::I32),
 1404|       |                // Null/Zero/Global addresses are pointer-sized
 1405|     37|                ConstValueKind::Null | ConstValueKind::Zero | ConstValueKind::GlobalAddress(_) => Ok(types::I64),
 1406|      0|                ConstValueKind::FunctionAddress(_) => Ok(types::I64),
 1407|      0|                ConstValueKind::StructLiteral(_) => Ok(types::I32),
 1408|      0|                ConstValueKind::ArrayLiteral(_) => Ok(types::I32),
 1409|       |            }
 1410|       |        }
 1411|     99|        Operand::Copy(place) => {
 1412|     99|            let place_type_id = lower_place_type_id(place, mir);
 1413|     99|            let place_type = mir.get_type(place_type_id);
 1414|     99|            if place_type.is_aggregate() {
 1415|      1|                return Ok(types::I64);
 1416|     98|            }
 1417|     98|            lower_type(place_type).ok_or_else(|| format!("Unsupported place type: {:?}", place_type))
                                                               ^0      ^0
 1418|       |        }
 1419|     83|        Operand::Cast(type_id, _) => {
 1420|     83|            let mir_type = mir.get_type(*type_id);
 1421|     83|            if mir_type.is_aggregate() {
 1422|      0|                return Ok(types::I64);
 1423|     83|            }
 1424|     83|            Ok(lower_type(mir_type).unwrap_or(types::I32))
 1425|       |        }
 1426|      4|        Operand::AddressOf(_) => Ok(types::I64), // AddressOf always returns a pointer
 1427|       |    }
 1428|    314|}
 1429|       |
 1430|       |/// Helper function to check if a MIR type is signed
 1431|    154|fn is_operand_signed(operand: &Operand, mir: &MirProgram) -> bool {
 1432|    154|    match operand {
 1433|     50|        Operand::Copy(place) => mir.get_type(lower_place_type_id(place, mir)).is_signed(),
 1434|      1|        Operand::Cast(type_id, _) => mir.get_type(*type_id).is_signed(),
 1435|    102|        Operand::Constant(const_id) => {
 1436|    102|            let const_val = mir.constants.get(const_id).expect("constant id not found");
 1437|    102|            mir.get_type(const_val.ty).is_signed()
 1438|       |        }
 1439|      1|        _ => false,
 1440|       |    }
 1441|    154|}
 1442|       |
 1443|       |/// Helper function to get the TypeId of an operand
 1444|    293|fn lower_operand_type_id(operand: &Operand, mir: &MirProgram) -> Result<TypeId, String> {
 1445|    293|    match operand {
 1446|     84|        Operand::Constant(const_id) => {
 1447|     84|            let const_value = mir.constants.get(const_id).expect("constant id not found");
 1448|     84|            Ok(const_value.ty)
 1449|       |        }
 1450|     83|        Operand::Copy(place) => Ok(lower_place_type_id(place, mir)),
 1451|    126|        Operand::Cast(type_id, _) => Ok(*type_id),
 1452|      0|        Operand::AddressOf(place) => {
 1453|       |            // AddressOf returns a pointer to the place's type.
 1454|       |            // We need to find or create this pointer type in MIR.
 1455|       |            // Actually, for PtrAdd scaling, we only care about the base type of the pointer.
 1456|      0|            let place_type_id = lower_place_type_id(place, mir);
 1457|       |            // We need the TypeId for ptr<place_type_id>
 1458|       |            // Let's see if we can find it in the type table.
 1459|      0|            for (id, ty) in &mir.types {
 1460|      0|                if let MirType::Pointer { pointee } = ty
 1461|      0|                    && *pointee == place_type_id
 1462|       |                {
 1463|      0|                    return Ok(*id);
 1464|      0|                }
 1465|       |            }
 1466|      0|            Err("Pointer type not found in MIR types".to_string())
 1467|       |        }
 1468|       |    }
 1469|    293|}
 1470|       |
 1471|       |/// Helper function to get the TypeId of a place
 1472|  1.21k|fn lower_place_type_id(place: &Place, mir: &MirProgram) -> TypeId {
 1473|  1.21k|    match place {
 1474|    784|        Place::Local(local_id) => mir.get_local(*local_id).type_id,
 1475|     94|        Place::Global(global_id) => mir.get_global(*global_id).type_id,
 1476|     10|        Place::Deref(operand) => {
 1477|       |            // To get the type of a dereference, we need the type of the operand,
 1478|       |            // which should be a pointer. The resulting type is the pointee.
 1479|     10|            let operand_type_id = lower_operand_type_id(operand, mir).unwrap();
 1480|     10|            let operand_type = mir.get_type(operand_type_id);
 1481|     10|            match operand_type {
 1482|     10|                MirType::Pointer { pointee } => *pointee,
 1483|      0|                _ => panic!("Cannot determine type for deref operand"),
 1484|       |            }
 1485|       |        }
 1486|    257|        Place::StructField(base_place, field_index) => {
 1487|    257|            let base_type_id = lower_place_type_id(base_place, mir);
 1488|    257|            let base_type = mir.get_type(base_type_id);
 1489|    257|            match base_type {
 1490|    257|                MirType::Record { field_types, .. } => field_types.get(*field_index).copied().unwrap(),
 1491|      0|                MirType::Pointer { pointee } => {
 1492|      0|                    let pointee_type = mir.get_type(*pointee);
 1493|      0|                    if let MirType::Record { field_types, .. } = pointee_type {
 1494|      0|                        field_types.get(*field_index).copied().unwrap()
 1495|       |                    } else {
 1496|      0|                        panic!("Base of StructField is not a struct type")
 1497|       |                    }
 1498|       |                }
 1499|      0|                _ => panic!("Base of StructField is not a struct type"),
 1500|       |            }
 1501|       |        }
 1502|     73|        Place::ArrayIndex(base_place, _) => {
 1503|     73|            let base_type_id = lower_place_type_id(base_place, mir);
 1504|     73|            let base_type = mir.get_type(base_type_id);
 1505|     73|            match base_type {
 1506|     73|                MirType::Array { element, .. } => *element,
 1507|      0|                MirType::Pointer { pointee } => *pointee,
 1508|      0|                _ => panic!("Base of ArrayIndex is not an array or pointer"),
 1509|       |            }
 1510|       |        }
 1511|       |    }
 1512|  1.21k|}
 1513|       |
 1514|       |/// Helper function to resolve a MIR place to a memory address
 1515|    235|fn emit_place_addr(place: &Place, ctx: &mut BodyEmitContext) -> Result<Value, String> {
 1516|    235|    match place {
 1517|    102|        Place::Local(local_id) => {
 1518|    102|            if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
 1519|    102|                Ok(ctx.builder.ins().stack_addr(types::I64, *stack_slot, 0))
 1520|       |            } else {
 1521|       |                // Zero-sized locals don't have stack slots. Return a null address.
 1522|       |                // This can happen with flexible array members or zero-length arrays.
 1523|      0|                Ok(ctx.builder.ins().iconst(types::I64, 0))
 1524|       |            }
 1525|       |        }
 1526|     27|        Place::Global(global_id) => {
 1527|     27|            let global = ctx.mir.get_global(*global_id);
 1528|       |            // Use local linkage for string literals to avoid conflicts
 1529|     27|            let linkage = if global.name.as_str().starts_with(".L.str") {
 1530|      0|                Linkage::Local
 1531|     27|            } else if global.initial_value.is_some() {
 1532|     27|                Linkage::Export
 1533|       |            } else {
 1534|      0|                Linkage::Import
 1535|       |            };
 1536|       |
 1537|     27|            let global_val = ctx
 1538|     27|                .module
 1539|     27|                .declare_data(global.name.as_str(), linkage, true, false)
 1540|     27|                .map_err(|e| format!("Failed to declare global data: {:?}", e))?;
                                           ^0      ^0                                        ^0
 1541|     27|            let local_id = ctx.module.declare_data_in_func(global_val, ctx.builder.func);
 1542|       |            // Use I64 for addresses
 1543|     27|            Ok(ctx.builder.ins().global_value(types::I64, local_id))
 1544|       |        }
 1545|      4|        Place::Deref(operand) => {
 1546|       |            // The address is the value of the operand itself (which should be a pointer).
 1547|      4|            emit_operand(operand, ctx, types::I64)
 1548|       |        }
 1549|     69|        Place::StructField(base_place, field_index) => {
 1550|       |            // Get the base address of the struct
 1551|     69|            let base_addr = emit_place_addr(base_place, ctx)?;
                                                                          ^0
 1552|       |
 1553|       |            // We need to find the type of the base_place to get the pre-computed field offset
 1554|     69|            let base_place_type_id = lower_place_type_id(base_place, ctx.mir);
 1555|     69|            let base_type = ctx.mir.get_type(base_place_type_id);
 1556|       |
 1557|     69|            let (field_offset, is_pointer) = match base_type {
 1558|     69|                MirType::Record { layout, .. } => {
 1559|     69|                    let offset = layout
 1560|     69|                        .field_offsets
 1561|     69|                        .get(*field_index)
 1562|     69|                        .copied()
 1563|     69|                        .ok_or_else(|| format!("Field index {} out of bounds", field_index))?;
                                                     ^0      ^0                                           ^0
 1564|     69|                    (offset, false)
 1565|       |                }
 1566|      0|                MirType::Pointer { pointee } => {
 1567|      0|                    let pointee_type = ctx.mir.get_type(*pointee);
 1568|      0|                    if let MirType::Record { layout, .. } = pointee_type {
 1569|      0|                        let offset = layout
 1570|      0|                            .field_offsets
 1571|      0|                            .get(*field_index)
 1572|      0|                            .copied()
 1573|      0|                            .ok_or_else(|| format!("Field index {} out of bounds", field_index))?;
 1574|      0|                        (offset, true)
 1575|       |                    } else {
 1576|      0|                        return Err("Base of StructField is not a struct type".to_string());
 1577|       |                    }
 1578|       |                }
 1579|      0|                _ => return Err("Base of StructField is not a struct type".to_string()),
 1580|       |            };
 1581|       |
 1582|     69|            let final_addr = if is_pointer {
 1583|       |                // If the base is a pointer, we need to load the address it points to first
 1584|      0|                ctx.builder.ins().load(types::I64, MemFlags::new(), base_addr, 0)
 1585|       |            } else {
 1586|     69|                base_addr
 1587|       |            };
 1588|       |
 1589|     69|            let offset_val = ctx.builder.ins().iconst(types::I64, field_offset as i64);
 1590|     69|            Ok(ctx.builder.ins().iadd(final_addr, offset_val))
 1591|       |        }
 1592|     33|        Place::ArrayIndex(base_place, index_operand) => {
 1593|       |            // Get the base address of the array/pointer
 1594|     33|            let base_addr = emit_place_addr(base_place, ctx)?;
                                                                          ^0
 1595|       |
 1596|       |            // Resolve the index operand to a value
 1597|     33|            let index_val = emit_operand(index_operand, ctx, types::I64)?;
                                                                                      ^0
 1598|       |
 1599|       |            // Determine the element size using pre-computed layout information
 1600|     33|            let base_place_type_id = lower_place_type_id(base_place, ctx.mir);
 1601|     33|            let base_type = ctx.mir.get_type(base_place_type_id);
 1602|       |
 1603|       |            // If the base is a pointer, we must load the pointer value from the base address
 1604|       |            // before adding the element offset. For arrays, the base address is already
 1605|       |            // the address of the first element.
 1606|     33|            let (element_size, final_base_addr) = match base_type {
 1607|     33|                MirType::Array { layout, .. } => (layout.stride as u32, base_addr),
 1608|      0|                MirType::Pointer { pointee } => {
 1609|      0|                    let pointee_type = ctx.mir.get_type(*pointee);
 1610|      0|                    let size = lower_type_size(pointee_type, ctx.mir)?;
 1611|      0|                    let loaded_ptr = ctx.builder.ins().load(types::I64, MemFlags::new(), base_addr, 0);
 1612|      0|                    (size, loaded_ptr)
 1613|       |                }
 1614|      0|                _ => return Err("Base of ArrayIndex is not an array or pointer".to_string()),
 1615|       |            };
 1616|       |
 1617|     33|            let element_size_val = ctx.builder.ins().iconst(types::I64, element_size as i64);
 1618|     33|            let offset = ctx.builder.ins().imul(index_val, element_size_val);
 1619|       |
 1620|     33|            Ok(ctx.builder.ins().iadd(final_base_addr, offset))
 1621|       |        }
 1622|       |    }
 1623|    235|}
 1624|       |/// Helper to lower a single MIR statement
 1625|    232|fn visit_statement(stmt: &MirStmt, ctx: &mut BodyEmitContext) -> Result<(), String> {
 1626|    232|    match stmt {
 1627|    179|        MirStmt::Assign(place, rvalue) => {
 1628|    179|            let place_type_id = lower_place_type_id(place, ctx.mir);
 1629|    179|            let place_mir_type = ctx.mir.get_type(place_type_id);
 1630|    179|            let expected_type = match lower_type(place_mir_type) {
 1631|    154|                Some(t) => t,
 1632|     25|                None if place_mir_type.is_aggregate() => types::I64,
 1633|      0|                None => return Err("Cannot assign to void type".to_string()),
 1634|       |            };
 1635|       |
 1636|       |            // Process the rvalue to get a Cranelift value first
 1637|    179|            let rvalue_result = match rvalue {
                              ^166
 1638|     99|                Rvalue::Use(operand) => emit_operand(operand, ctx, expected_type),
 1639|      0|                Rvalue::Cast(type_id, operand) => {
 1640|      0|                    let inner_clif_type = lower_operand_type(operand, ctx.mir)?;
 1641|      0|                    let inner_val = emit_operand(operand, ctx, inner_clif_type)?;
 1642|       |
 1643|      0|                    let target_mir_type = ctx.mir.get_type(*type_id);
 1644|      0|                    let target_clif_type =
 1645|      0|                        lower_type(target_mir_type).ok_or_else(|| "Cannot cast to void type".to_string())?;
 1646|       |
 1647|      0|                    let converted = emit_type_conversion(
 1648|      0|                        inner_val,
 1649|      0|                        inner_clif_type,
 1650|      0|                        target_clif_type,
 1651|      0|                        is_operand_signed(operand, ctx.mir),
 1652|      0|                        ctx.builder,
 1653|       |                    );
 1654|       |
 1655|      0|                    Ok(emit_type_conversion(
 1656|      0|                        converted,
 1657|      0|                        target_clif_type,
 1658|      0|                        expected_type,
 1659|      0|                        target_mir_type.is_signed(),
 1660|      0|                        ctx.builder,
 1661|      0|                    ))
 1662|       |                }
 1663|      3|                Rvalue::UnaryIntOp(op, operand) => {
 1664|      3|                    let operand_clif_type = lower_operand_type(operand, ctx.mir)?;
                                                                                              ^0
 1665|      3|                    let val = emit_operand(operand, ctx, operand_clif_type)?;
                                                                                         ^0
 1666|       |
 1667|      3|                    match op {
 1668|      0|                        UnaryIntOp::Neg => Ok(ctx.builder.ins().ineg(val)),
 1669|      0|                        UnaryIntOp::BitwiseNot => Ok(ctx.builder.ins().bnot(val)),
 1670|       |                        UnaryIntOp::LogicalNot => {
 1671|      3|                            let zero = ctx.builder.ins().iconst(operand_clif_type, 0i64);
 1672|      3|                            let is_zero = ctx.builder.ins().icmp(IntCC::Equal, val, zero);
 1673|      3|                            Ok(emit_bool_to_int(is_zero, expected_type, ctx.builder))
 1674|       |                        }
 1675|       |                    }
 1676|       |                }
 1677|      0|                Rvalue::UnaryFloatOp(op, operand) => {
 1678|      0|                    let operand_clif_type = lower_operand_type(operand, ctx.mir)?;
 1679|      0|                    let val = emit_operand(operand, ctx, operand_clif_type)?;
 1680|       |
 1681|      0|                    match op {
 1682|      0|                        UnaryFloatOp::Neg => Ok(ctx.builder.ins().fneg(val)),
 1683|       |                    }
 1684|       |                }
 1685|      2|                Rvalue::PtrAdd(base, offset) => {
 1686|      2|                    let base_type_id = lower_operand_type_id(base, ctx.mir)?;
                                                                                         ^0
 1687|      2|                    let base_type = ctx.mir.get_type(base_type_id);
 1688|      2|                    let MirType::Pointer { pointee } = base_type else {
 1689|      0|                        return Err("PtrAdd base is not a pointer type".to_string());
 1690|       |                    };
 1691|       |
 1692|      2|                    let pointee_type = ctx.mir.get_type(*pointee);
 1693|      2|                    let pointee_size = lower_type_size(pointee_type, ctx.mir)?;
                                                                                           ^0
 1694|       |
 1695|      2|                    let base_val = emit_operand(base, ctx, types::I64)?;
                                                                                    ^0
 1696|      2|                    let offset_val = emit_operand(offset, ctx, types::I64)?;
                                                                                        ^0
 1697|       |
 1698|      2|                    let scaled_offset = if pointee_size > 1 {
 1699|      2|                        let size_val = ctx.builder.ins().iconst(types::I64, pointee_size as i64);
 1700|      2|                        ctx.builder.ins().imul(offset_val, size_val)
 1701|       |                    } else {
 1702|      0|                        offset_val
 1703|       |                    };
 1704|       |
 1705|      2|                    Ok(ctx.builder.ins().iadd(base_val, scaled_offset))
 1706|       |                }
 1707|      2|                Rvalue::PtrSub(base, offset) => {
 1708|      2|                    let base_type_id = lower_operand_type_id(base, ctx.mir)?;
                                                                                         ^0
 1709|      2|                    let base_type = ctx.mir.get_type(base_type_id);
 1710|      2|                    let MirType::Pointer { pointee } = base_type else {
 1711|      0|                        return Err("PtrSub base is not a pointer type".to_string());
 1712|       |                    };
 1713|       |
 1714|      2|                    let pointee_type = ctx.mir.get_type(*pointee);
 1715|      2|                    let pointee_size = lower_type_size(pointee_type, ctx.mir)?;
                                                                                           ^0
 1716|       |
 1717|      2|                    let base_val = emit_operand(base, ctx, types::I64)?;
                                                                                    ^0
 1718|      2|                    let offset_val = emit_operand(offset, ctx, types::I64)?;
                                                                                        ^0
 1719|       |
 1720|      2|                    let scaled_offset = if pointee_size > 1 {
 1721|      2|                        let size_val = ctx.builder.ins().iconst(types::I64, pointee_size as i64);
 1722|      2|                        ctx.builder.ins().imul(offset_val, size_val)
 1723|       |                    } else {
 1724|      0|                        offset_val
 1725|       |                    };
 1726|       |
 1727|      2|                    Ok(ctx.builder.ins().isub(base_val, scaled_offset))
 1728|       |                }
 1729|      1|                Rvalue::PtrDiff(left, right) => {
 1730|      1|                    let left_type_id = lower_operand_type_id(left, ctx.mir)?;
                                                                                         ^0
 1731|      1|                    let left_type = ctx.mir.get_type(left_type_id);
 1732|      1|                    let pointee_size = if let MirType::Pointer { pointee } = left_type {
 1733|      1|                        let pointee_type = ctx.mir.get_type(*pointee);
 1734|      1|                        lower_type_size(pointee_type, ctx.mir)?
                                                                            ^0
 1735|       |                    } else {
 1736|      0|                        return Err("PtrDiff left operand is not a pointer type".to_string());
 1737|       |                    };
 1738|       |
 1739|      1|                    let left_val = emit_operand(left, ctx, types::I64)?;
                                                                                    ^0
 1740|      1|                    let right_val = emit_operand(right, ctx, types::I64)?;
                                                                                      ^0
 1741|       |
 1742|      1|                    let diff = ctx.builder.ins().isub(left_val, right_val);
 1743|      1|                    if pointee_size > 1 {
 1744|      0|                        let size_val = ctx.builder.ins().iconst(types::I64, pointee_size as i64);
 1745|      0|                        Ok(ctx.builder.ins().sdiv(diff, size_val))
 1746|       |                    } else {
 1747|      1|                        Ok(diff)
 1748|       |                    }
 1749|       |                }
 1750|      0|                Rvalue::Load(operand) => {
 1751|      0|                    let addr = emit_operand(operand, ctx, types::I64)?;
 1752|      0|                    Ok(ctx.builder.ins().load(expected_type, MemFlags::new(), addr, 0))
 1753|       |                }
 1754|       |
 1755|     52|                Rvalue::BinaryIntOp(op, left_operand, right_operand) => {
 1756|     52|                    let left_clif_type = lower_operand_type(left_operand, ctx.mir)
 1757|     52|                        .map_err(|e| format!("Failed to get left operand type: {}", e))?;
                                                   ^0      ^0                                        ^0
 1758|     52|                    let right_clif_type = lower_operand_type(right_operand, ctx.mir)
 1759|     52|                        .map_err(|e| format!("Failed to get right operand type: {}", e))?;
                                                   ^0      ^0                                         ^0
 1760|       |
 1761|       |                    // For Add/Sub operations on Pointers, we treat them as I64
 1762|     52|                    let (final_left_type, final_right_type) = match op {
 1763|       |                        BinaryIntOp::Add | BinaryIntOp::Sub => {
 1764|      8|                            if left_clif_type == types::I64 && right_clif_type == types::I32 {
                                                                             ^1
 1765|       |                                // Pointer + int constant
 1766|      0|                                (types::I64, types::I64)
 1767|      8|                            } else if left_clif_type == types::I32 && right_clif_type == types::I64 {
                                                                                    ^7
 1768|       |                                // int constant + pointer
 1769|      0|                                (types::I64, types::I64)
 1770|       |                            } else {
 1771|      8|                                (left_clif_type, right_clif_type)
 1772|       |                            }
 1773|       |                        }
 1774|     44|                        _ => (left_clif_type, right_clif_type),
 1775|       |                    };
 1776|       |
 1777|     52|                    let left_val = emit_operand(left_operand, ctx, final_left_type)?;
                                                                                                 ^0
 1778|     52|                    let right_val = emit_operand(right_operand, ctx, final_right_type)?;
                                                                                                    ^0
 1779|       |
 1780|     52|                    let result_val = match op {
 1781|      4|                        BinaryIntOp::Add => ctx.builder.ins().iadd(left_val, right_val),
 1782|      4|                        BinaryIntOp::Sub => ctx.builder.ins().isub(left_val, right_val),
 1783|      1|                        BinaryIntOp::Mul => ctx.builder.ins().imul(left_val, right_val),
 1784|       |                        BinaryIntOp::Div => {
 1785|      1|                            if is_operand_signed(left_operand, ctx.mir) {
 1786|      1|                                ctx.builder.ins().sdiv(left_val, right_val)
 1787|       |                            } else {
 1788|      0|                                ctx.builder.ins().udiv(left_val, right_val)
 1789|       |                            }
 1790|       |                        }
 1791|       |                        BinaryIntOp::Mod => {
 1792|      1|                            if is_operand_signed(left_operand, ctx.mir) {
 1793|      1|                                ctx.builder.ins().srem(left_val, right_val)
 1794|       |                            } else {
 1795|      0|                                ctx.builder.ins().urem(left_val, right_val)
 1796|       |                            }
 1797|       |                        }
 1798|      0|                        BinaryIntOp::BitAnd => ctx.builder.ins().band(left_val, right_val),
 1799|      0|                        BinaryIntOp::BitOr => ctx.builder.ins().bor(left_val, right_val),
 1800|      0|                        BinaryIntOp::BitXor => ctx.builder.ins().bxor(left_val, right_val),
 1801|      0|                        BinaryIntOp::LShift => ctx.builder.ins().ishl(left_val, right_val),
 1802|       |                        BinaryIntOp::RShift => {
 1803|      0|                            if is_operand_signed(left_operand, ctx.mir) {
 1804|      0|                                ctx.builder.ins().sshr(left_val, right_val)
 1805|       |                            } else {
 1806|      0|                                ctx.builder.ins().ushr(left_val, right_val)
 1807|       |                            }
 1808|       |                        }
 1809|       |                        BinaryIntOp::Eq => {
 1810|     14|                            let cond = ctx.builder.ins().icmp(IntCC::Equal, left_val, right_val);
 1811|     14|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1812|       |                        }
 1813|       |                        BinaryIntOp::Ne => {
 1814|     26|                            let cond = ctx.builder.ins().icmp(IntCC::NotEqual, left_val, right_val);
 1815|     26|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1816|       |                        }
 1817|       |                        BinaryIntOp::Lt => {
 1818|      1|                            let cond = if is_operand_signed(left_operand, ctx.mir) {
 1819|      1|                                ctx.builder.ins().icmp(IntCC::SignedLessThan, left_val, right_val)
 1820|       |                            } else {
 1821|      0|                                ctx.builder.ins().icmp(IntCC::UnsignedLessThan, left_val, right_val)
 1822|       |                            };
 1823|      1|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1824|       |                        }
 1825|       |                        BinaryIntOp::Le => {
 1826|      0|                            let cond = if is_operand_signed(left_operand, ctx.mir) {
 1827|      0|                                ctx.builder
 1828|      0|                                    .ins()
 1829|      0|                                    .icmp(IntCC::SignedLessThanOrEqual, left_val, right_val)
 1830|       |                            } else {
 1831|      0|                                ctx.builder
 1832|      0|                                    .ins()
 1833|      0|                                    .icmp(IntCC::UnsignedLessThanOrEqual, left_val, right_val)
 1834|       |                            };
 1835|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1836|       |                        }
 1837|       |                        BinaryIntOp::Gt => {
 1838|      0|                            let cond = if is_operand_signed(left_operand, ctx.mir) {
 1839|      0|                                ctx.builder.ins().icmp(IntCC::SignedGreaterThan, left_val, right_val)
 1840|       |                            } else {
 1841|      0|                                ctx.builder.ins().icmp(IntCC::UnsignedGreaterThan, left_val, right_val)
 1842|       |                            };
 1843|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1844|       |                        }
 1845|       |                        BinaryIntOp::Ge => {
 1846|      0|                            let cond = if is_operand_signed(left_operand, ctx.mir) {
 1847|      0|                                ctx.builder
 1848|      0|                                    .ins()
 1849|      0|                                    .icmp(IntCC::SignedGreaterThanOrEqual, left_val, right_val)
 1850|       |                            } else {
 1851|      0|                                ctx.builder
 1852|      0|                                    .ins()
 1853|      0|                                    .icmp(IntCC::UnsignedGreaterThanOrEqual, left_val, right_val)
 1854|       |                            };
 1855|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1856|       |                        }
 1857|       |                    };
 1858|     52|                    Ok(result_val)
 1859|       |                }
 1860|      0|                Rvalue::BinaryFloatOp(op, left_operand, right_operand) => {
 1861|      0|                    let left_cranelift_type = lower_operand_type(left_operand, ctx.mir)
 1862|      0|                        .map_err(|e| format!("Failed to get left operand type: {}", e))?;
 1863|      0|                    let right_cranelift_type = lower_operand_type(right_operand, ctx.mir)
 1864|      0|                        .map_err(|e| format!("Failed to get right operand type: {}", e))?;
 1865|       |
 1866|      0|                    let left_val = emit_operand(left_operand, ctx, left_cranelift_type)?;
 1867|      0|                    let right_val = emit_operand(right_operand, ctx, right_cranelift_type)?;
 1868|       |
 1869|      0|                    let result_val = match op {
 1870|      0|                        BinaryFloatOp::Add => ctx.builder.ins().fadd(left_val, right_val),
 1871|      0|                        BinaryFloatOp::Sub => ctx.builder.ins().fsub(left_val, right_val),
 1872|      0|                        BinaryFloatOp::Mul => ctx.builder.ins().fmul(left_val, right_val),
 1873|      0|                        BinaryFloatOp::Div => ctx.builder.ins().fdiv(left_val, right_val),
 1874|       |                        BinaryFloatOp::Eq => {
 1875|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::Equal, left_val, right_val);
 1876|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1877|       |                        }
 1878|       |                        BinaryFloatOp::Ne => {
 1879|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::NotEqual, left_val, right_val);
 1880|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1881|       |                        }
 1882|       |                        BinaryFloatOp::Lt => {
 1883|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::LessThan, left_val, right_val);
 1884|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1885|       |                        }
 1886|       |                        BinaryFloatOp::Le => {
 1887|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::LessThanOrEqual, left_val, right_val);
 1888|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1889|       |                        }
 1890|       |                        BinaryFloatOp::Gt => {
 1891|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::GreaterThan, left_val, right_val);
 1892|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1893|       |                        }
 1894|       |                        BinaryFloatOp::Ge => {
 1895|      0|                            let cond = ctx.builder.ins().fcmp(FloatCC::GreaterThanOrEqual, left_val, right_val);
 1896|      0|                            emit_bool_to_int(cond, expected_type, ctx.builder)
 1897|       |                        }
 1898|       |                    };
 1899|      0|                    Ok(result_val)
 1900|       |                }
 1901|      7|                Rvalue::BuiltinVaArg(ap, type_id) => {
 1902|       |                    // X86_64 SysV va_arg implementation
 1903|       |                    // va_list is struct { gp_offset, fp_offset, overflow_arg_area, reg_save_area }
 1904|       |                    // For GP types: if gp_offset < 48, fetch from reg_save_area + gp_offset
 1905|       |                    //               else fetch from overflow_arg_area
 1906|       |
 1907|      7|                    let ap_addr = emit_place_addr(ap, ctx)?;
                                                                        ^0
 1908|       |
 1909|       |                    // Load fields from va_list
 1910|      7|                    let gp_offset = ctx.builder.ins().load(types::I32, MemFlags::new(), ap_addr, 0);
 1911|      7|                    let _fp_offset = ctx.builder.ins().load(types::I32, MemFlags::new(), ap_addr, 4);
 1912|      7|                    let _overflow_area = ctx.builder.ins().load(types::I64, MemFlags::new(), ap_addr, 8);
 1913|      7|                    let reg_save_area = ctx.builder.ins().load(types::I64, MemFlags::new(), ap_addr, 16);
 1914|       |
 1915|      7|                    let mir_type = ctx.mir.get_type(*type_id);
 1916|      7|                    let cl_type = lower_type(mir_type).unwrap_or(types::I64);
 1917|       |
 1918|       |                    // Unified va_arg implementation for "Cendol" ABI (all args in spill_slot/reg_save_area)
 1919|       |                    // We ignore is_float and standard SystemV ABI register separation because our
 1920|       |                    // implementation flattens everything into a sequential spill slot pointed to by reg_save_area.
 1921|       |
 1922|      7|                    let size = lower_type_size(mir_type, ctx.mir)? as u32;
                                                                               ^0
 1923|      7|                    let size = size.max(8);
 1924|       |
 1925|      7|                    let needed_slots = size.div_ceil(8);
 1926|      7|                    let needed_gp = needed_slots * 8;
 1927|       |
 1928|       |                    // Address is always reg_save_area + gp_offset
 1929|      7|                    let offset_64 = ctx.builder.ins().uextend(types::I64, gp_offset);
 1930|      7|                    let addr = ctx.builder.ins().iadd(reg_save_area, offset_64);
 1931|       |
 1932|      7|                    let result = if mir_type.is_aggregate() {
 1933|      5|                        addr // Return address for aggregates
 1934|       |                    } else {
 1935|      2|                        ctx.builder.ins().load(cl_type, MemFlags::new(), addr, 0)
 1936|       |                    };
 1937|       |
 1938|       |                    // Increment gp_offset
 1939|      7|                    let next_gp_increment = ctx.builder.ins().iconst(types::I32, needed_gp as i64);
 1940|      7|                    let next_gp = ctx.builder.ins().iadd(gp_offset, next_gp_increment);
 1941|      7|                    ctx.builder.ins().store(MemFlags::new(), next_gp, ap_addr, 0);
 1942|       |
 1943|       |                    // Sync overflow_area to point to the next slot (needed if we pass ap to standard functions like vprintf)
 1944|       |                    // overflow_area = reg_save_area + next_gp
 1945|      7|                    let next_gp_64 = ctx.builder.ins().uextend(types::I64, next_gp);
 1946|      7|                    let next_overflow = ctx.builder.ins().iadd(reg_save_area, next_gp_64);
 1947|      7|                    ctx.builder.ins().store(MemFlags::new(), next_overflow, ap_addr, 8);
 1948|      7|                    Ok(result)
 1949|       |                }
 1950|      6|                Rvalue::ArrayLiteral(elements) => {
 1951|      6|                    let dest_addr = emit_place_addr(place, ctx)?;
                                                                             ^0
 1952|      6|                    let MirType::Array { element, layout, .. } = place_mir_type else {
 1953|      0|                        return Err("ArrayLiteral with non-array type".to_string());
 1954|       |                    };
 1955|      6|                    let element_mir_type = ctx.mir.get_type(*element);
 1956|      6|                    let element_clif_type = lower_type(element_mir_type);
 1957|      6|                    let stride = layout.stride as i64;
 1958|       |
 1959|     11|                    for (i, element_op) in elements.iter().enumerate() {
                                                         ^6              ^6
 1960|     11|                        let offset = i as i64 * stride;
 1961|     11|                        let element_dest_addr = if offset == 0 {
 1962|      6|                            dest_addr
 1963|       |                        } else {
 1964|      5|                            ctx.builder.ins().iadd_imm(dest_addr, offset)
 1965|       |                        };
 1966|       |
 1967|     11|                        if element_mir_type.is_aggregate() {
 1968|      2|                            let src_addr = emit_operand(element_op, ctx, types::I64)?;
                                                                                                  ^0
 1969|      2|                            let size = lower_type_size(element_mir_type, ctx.mir)? as i64;
                                                                                               ^0
 1970|      2|                            emit_memcpy(element_dest_addr, src_addr, size, ctx.builder, ctx.module)?;
                                                                                                                 ^0
 1971|       |                        } else {
 1972|      9|                            let val = emit_operand(element_op, ctx, element_clif_type.unwrap())?;
                                                                                                             ^0
 1973|      9|                            ctx.builder.ins().store(MemFlags::new(), val, element_dest_addr, 0);
 1974|       |                        }
 1975|       |                    }
 1976|      6|                    return Ok(());
 1977|       |                }
 1978|      7|                Rvalue::StructLiteral(fields) => {
 1979|      7|                    let dest_addr = emit_place_addr(place, ctx)?;
                                                                             ^0
 1980|       |                    let MirType::Record {
 1981|      7|                        layout, field_types, ..
 1982|      7|                    } = place_mir_type
 1983|       |                    else {
 1984|      0|                        return Err("StructLiteral with non-record type".to_string());
 1985|       |                    };
 1986|       |
 1987|       |                    // Zero-initialize the entire struct first to ensure uninitialized members are zero
 1988|      7|                    let struct_size = layout.size as i64;
 1989|      7|                    emit_memset(dest_addr, 0, struct_size, ctx.builder, ctx.module)?;
                                                                                                 ^0
 1990|       |
 1991|     14|                    for (field_idx, element_op) in fields.iter() {
                                                                 ^7     ^7
 1992|     14|                        let offset = layout.field_offsets[*field_idx] as i64;
 1993|     14|                        let field_dest_addr = if offset == 0 {
 1994|      7|                            dest_addr
 1995|       |                        } else {
 1996|      7|                            ctx.builder.ins().iadd_imm(dest_addr, offset)
 1997|       |                        };
 1998|       |
 1999|     14|                        let field_mir_type = ctx.mir.get_type(field_types[*field_idx]);
 2000|     14|                        if field_mir_type.is_aggregate() {
 2001|      4|                            let src_addr = emit_operand(element_op, ctx, types::I64)?;
                                                                                                  ^0
 2002|      4|                            let size = lower_type_size(field_mir_type, ctx.mir)? as i64;
                                                                                             ^0
 2003|      4|                            emit_memcpy(field_dest_addr, src_addr, size, ctx.builder, ctx.module)?;
                                                                                                               ^0
 2004|       |                        } else {
 2005|     10|                            let field_clif_type = lower_type(field_mir_type).unwrap();
 2006|     10|                            let val = emit_operand(element_op, ctx, field_clif_type)?;
                                                                                                  ^0
 2007|     10|                            ctx.builder.ins().store(MemFlags::new(), val, field_dest_addr, 0);
 2008|       |                        }
 2009|       |                    }
 2010|      7|                    return Ok(());
 2011|       |                }
 2012|      0|                Rvalue::AtomicLoad(ptr, _order) => {
 2013|      0|                    let ptr_val = emit_operand(ptr, ctx, types::I64)?;
 2014|      0|                    Ok(ctx.builder.ins().atomic_load(expected_type, MemFlags::new(), ptr_val))
 2015|       |                }
 2016|      0|                Rvalue::AtomicExchange(ptr, val, _order) => {
 2017|      0|                    let ptr_val = emit_operand(ptr, ctx, types::I64)?;
 2018|      0|                    let val_type = lower_operand_type(val, ctx.mir)?;
 2019|      0|                    let val_op = emit_operand(val, ctx, val_type)?;
 2020|      0|                    Ok(ctx
 2021|      0|                        .builder
 2022|      0|                        .ins()
 2023|      0|                        .atomic_rmw(expected_type, MemFlags::new(), AtomicRmwOp::Xchg, ptr_val, val_op))
 2024|       |                }
 2025|      0|                Rvalue::AtomicCompareExchange(ptr, expected, desired, _, _, _) => {
 2026|      0|                    let ptr_val = emit_operand(ptr, ctx, types::I64)?;
 2027|      0|                    let expected_val = emit_operand(expected, ctx, expected_type)?;
 2028|      0|                    let desired_val = emit_operand(desired, ctx, expected_type)?;
 2029|       |
 2030|      0|                    Ok(ctx
 2031|      0|                        .builder
 2032|      0|                        .ins()
 2033|      0|                        .atomic_cas(MemFlags::new(), ptr_val, expected_val, desired_val))
 2034|       |                }
 2035|      0|                Rvalue::AtomicFetchOp(op, ptr, val, _order) => {
 2036|      0|                    let ptr_val = emit_operand(ptr, ctx, types::I64)?;
 2037|      0|                    let val_type = lower_operand_type(val, ctx.mir)?;
 2038|      0|                    let val_op = emit_operand(val, ctx, val_type)?;
 2039|       |
 2040|      0|                    let rmw_op = match op {
 2041|      0|                        BinaryIntOp::Add => AtomicRmwOp::Add,
 2042|      0|                        BinaryIntOp::Sub => AtomicRmwOp::Sub,
 2043|      0|                        BinaryIntOp::BitAnd => AtomicRmwOp::And,
 2044|      0|                        BinaryIntOp::BitOr => AtomicRmwOp::Or,
 2045|      0|                        BinaryIntOp::BitXor => AtomicRmwOp::Xor,
 2046|      0|                        _ => return Err(format!("Unsupported atomic fetch op: {:?}", op)),
 2047|       |                    };
 2048|       |
 2049|      0|                    Ok(ctx
 2050|      0|                        .builder
 2051|      0|                        .ins()
 2052|      0|                        .atomic_rmw(expected_type, MemFlags::new(), rmw_op, ptr_val, val_op))
 2053|       |                }
 2054|       |            };
 2055|       |
 2056|       |            // Now, assign the resolved value to the place
 2057|    166|            if let Ok(value) = rvalue_result {
 2058|    166|                let place_type_id = lower_place_type_id(place, ctx.mir);
 2059|    166|                let mir_type = ctx.mir.get_type(place_type_id);
 2060|       |
 2061|    166|                if mir_type.is_aggregate() {
 2062|     12|                    let dest_addr = emit_place_addr(place, ctx)?;
                                                                             ^0
 2063|     12|                    let size = lower_type_size(mir_type, ctx.mir)? as i64;
                                                                               ^0
 2064|     12|                    emit_memcpy(dest_addr, value, size, ctx.builder, ctx.module)?;
                                                                                              ^0
 2065|       |                } else {
 2066|    154|                    match place {
 2067|    148|                        Place::Local(local_id) => {
 2068|       |                            // Check if this local has a stack slot (non-void types)
 2069|    148|                            if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
 2070|    148|                                ctx.builder.ins().stack_store(value, *stack_slot, 0);
 2071|    148|                            }
                                          ^0
 2072|       |                            // Else: This local doesn't have a stack slot (likely a void type)
 2073|       |                            // or it's optimized out. In MIR, we assume it's valid to ignore.
 2074|       |                        }
 2075|       |                        _ => {
 2076|       |                            // This covers StructField, ArrayIndex, Deref, and Global assignments
 2077|      6|                            match emit_place_addr(place, ctx) {
 2078|      6|                                Ok(addr) => {
 2079|      6|                                    ctx.builder.ins().store(MemFlags::new(), value, addr, 0);
 2080|      6|                                }
 2081|      0|                                Err(e) => return Err(format!("Failed to resolve place address: {}", e)),
 2082|       |                            }
 2083|       |                        }
 2084|       |                    }
 2085|       |                }
 2086|       |            } else {
 2087|      0|                return Err(format!("Failed to resolve rvalue: {:?}", rvalue_result.err()));
 2088|       |            }
 2089|    166|            Ok(())
 2090|       |        }
 2091|       |
 2092|      3|        MirStmt::Store(operand, place) => {
 2093|       |            // We need to determine the correct type for the operand
 2094|      3|            let place_type_id = lower_place_type_id(place, ctx.mir);
 2095|      3|            let place_type = ctx.mir.get_type(place_type_id);
 2096|      3|            let cranelift_type = lower_type(place_type).ok_or_else(|| "Cannot store to a void type".to_string())?;
                                                                                    ^0                            ^0          ^0
 2097|       |
 2098|      3|            let value = emit_operand(operand, ctx, cranelift_type)?;
                                                                                ^0
 2099|       |
 2100|       |            // Now, store the value into the place
 2101|      3|            match place {
 2102|      2|                Place::Local(local_id) => {
 2103|      2|                    let stack_slot = ctx.stack_slots.get(local_id).ok_or_else(|| {
                                                                                               ^0
 2104|      0|                        format!(
 2105|      0|                            "Stack slot not found for local {} in function {}",
 2106|      0|                            local_id.get(),
 2107|       |                            ctx.func.name
 2108|       |                        )
 2109|      0|                    })?;
 2110|      2|                    ctx.builder.ins().stack_store(value, *stack_slot, 0);
 2111|       |                }
 2112|       |                _ => {
 2113|       |                    // For other places, resolve to an address and store
 2114|      1|                    let addr = emit_place_addr(place, ctx)?;
                                                                        ^0
 2115|      1|                    ctx.builder.ins().store(MemFlags::new(), value, addr, 0);
 2116|       |                }
 2117|       |            }
 2118|      3|            Ok(())
 2119|       |        }
 2120|     42|        MirStmt::Call { target, args, dest } => {
 2121|     42|            if let Some(dest_place) = dest {
                                      ^1
 2122|       |                // Call with destination - need to store the result
 2123|      1|                let dest_type_id = lower_place_type_id(dest_place, ctx.mir);
 2124|      1|                let dest_mir_type = ctx.mir.get_type(dest_type_id);
 2125|      1|                let expected_type = match lower_type(dest_mir_type) {
 2126|      1|                    Some(t) => t,
 2127|      0|                    None if dest_mir_type.is_aggregate() => types::I64,
 2128|      0|                    None => return Err("Cannot assign to void type".to_string()),
 2129|       |                };
 2130|      1|                let result = emit_function_call(target, args, expected_type, ctx)?;
                                                                                               ^0
 2131|       |
 2132|       |                // Store the result in the destination place
 2133|      1|                let dest_mir_type = ctx.mir.get_type(dest_type_id);
 2134|      1|                if dest_mir_type.is_aggregate() {
 2135|       |                    // For aggregate types, result is an address, memcpy to dest
 2136|      0|                    let dest_addr = emit_place_addr(dest_place, ctx)?;
 2137|      0|                    let size = lower_type_size(dest_mir_type, ctx.mir)? as i64;
 2138|      0|                    emit_memcpy(dest_addr, result, size, ctx.builder, ctx.module)?;
 2139|       |                } else {
 2140|      1|                    match dest_place {
 2141|      1|                        Place::Local(local_id) => {
 2142|      1|                            if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
 2143|      1|                                ctx.builder.ins().stack_store(result, *stack_slot, 0);
 2144|      1|                            }
                                          ^0
 2145|       |                        }
 2146|       |                        _ => {
 2147|      0|                            let addr = emit_place_addr(dest_place, ctx)?;
 2148|      0|                            ctx.builder.ins().store(MemFlags::new(), result, addr, 0);
 2149|       |                        }
 2150|       |                    }
 2151|       |                }
 2152|       |            } else {
 2153|       |                // Call without destination - ignore return value (side-effect only)
 2154|     41|                let _ = emit_function_call(target, args, types::I32, ctx)?;
                                                                                       ^0
 2155|       |            }
 2156|     42|            Ok(())
 2157|       |        }
 2158|       |
 2159|      1|        MirStmt::Alloc(place, type_id) => {
 2160|       |            // Get the size of the type to be allocated
 2161|      1|            let alloc_type = ctx.mir.get_type(*type_id);
 2162|      1|            let size = lower_type_size(alloc_type, ctx.mir)?;
                                                                         ^0
 2163|       |
 2164|       |            // Define the `malloc` function signature (size_t -> void*)
 2165|       |            // In Cranelift, this would be (i64) -> i64 for a 64-bit target
 2166|      1|            let mut malloc_sig = Signature::new(ctx.builder.func.signature.call_conv);
 2167|      1|            malloc_sig.params.push(AbiParam::new(types::I64));
 2168|      1|            malloc_sig.returns.push(AbiParam::new(types::I64));
 2169|       |
 2170|       |            // Declare `malloc` if not already declared
 2171|      1|            let malloc_func = ctx
 2172|      1|                .module
 2173|      1|                .declare_function("malloc", Linkage::Import, &malloc_sig)
 2174|      1|                .map_err(|e| format!("Failed to declare malloc: {:?}", e))?;
                                           ^0      ^0                                   ^0
 2175|      1|            let local_malloc = ctx.module.declare_func_in_func(malloc_func, ctx.builder.func);
 2176|       |
 2177|       |            // Call `malloc` with the calculated size
 2178|      1|            let size_val = ctx.builder.ins().iconst(types::I64, size as i64);
 2179|      1|            let call_inst = ctx.builder.ins().call(local_malloc, &[size_val]);
 2180|      1|            let alloc_ptr = ctx.builder.inst_results(call_inst)[0];
 2181|       |
 2182|       |            // Store the returned pointer into the destination place
 2183|      1|            match place {
 2184|      1|                Place::Local(local_id) => {
 2185|      1|                    if let Some(stack_slot) = ctx.stack_slots.get(local_id) {
 2186|      1|                        ctx.builder.ins().stack_store(alloc_ptr, *stack_slot, 0);
 2187|      1|                    }
                                  ^0
 2188|       |                }
 2189|       |                _ => {
 2190|      0|                    let addr = emit_place_addr(place, ctx)?;
 2191|      0|                    ctx.builder.ins().store(MemFlags::new(), alloc_ptr, addr, 0);
 2192|       |                }
 2193|       |            }
 2194|      1|            Ok(())
 2195|       |        }
 2196|       |
 2197|      1|        MirStmt::Dealloc(operand) => {
 2198|       |            // Resolve the operand to get the pointer to be freed
 2199|      1|            let ptr_val = emit_operand(operand, ctx, types::I64)?;
                                                                              ^0
 2200|       |
 2201|       |            // Define the `free` function signature (void* -> void)
 2202|      1|            let mut free_sig = Signature::new(ctx.builder.func.signature.call_conv);
 2203|      1|            free_sig.params.push(AbiParam::new(types::I64));
 2204|       |
 2205|       |            // Declare `free` if not already declared
 2206|      1|            let free_func = ctx
 2207|      1|                .module
 2208|      1|                .declare_function("free", Linkage::Import, &free_sig)
 2209|      1|                .map_err(|e| format!("Failed to declare free: {:?}", e))?;
                                           ^0      ^0                                 ^0
 2210|      1|            let local_free = ctx.module.declare_func_in_func(free_func, ctx.builder.func);
 2211|       |
 2212|       |            // Call `free` with the pointer
 2213|      1|            ctx.builder.ins().call(local_free, &[ptr_val]);
 2214|      1|            Ok(())
 2215|       |        }
 2216|      4|        MirStmt::BuiltinVaStart(place, _operand) => {
 2217|      4|            let ap_addr = emit_place_addr(place, ctx)?;
                                                                   ^0
 2218|       |
 2219|      4|            if let Some(spill_slot) = ctx.va_spill_slot {
 2220|      4|                let spill_addr = ctx.builder.ins().stack_addr(types::I64, spill_slot, 0);
 2221|      4|
 2222|      4|                // 1. gp_offset
 2223|      4|                // Calculate how many bytes are consumed by fixed parameters
 2224|      4|                let fixed_count = ctx.func.params.len();
 2225|      4|                let gp_val = fixed_count * 8;
 2226|      4|
 2227|      4|                // Clamp to 48 (max GPR registers)
 2228|      4|                let effective_gp = std::cmp::min(gp_val, 48);
 2229|      4|                let gp_const = ctx.builder.ins().iconst(types::I32, effective_gp as i64);
 2230|      4|                ctx.builder.ins().store(MemFlags::new(), gp_const, ap_addr, 0);
 2231|      4|
 2232|      4|                // 2. fp_offset = 176 (unused as we map everything to I64 GPRs in current hack)
 2233|      4|                let fp_val = ctx.builder.ins().iconst(types::I32, 176);
 2234|      4|                ctx.builder.ins().store(MemFlags::new(), fp_val, ap_addr, 4);
 2235|      4|
 2236|      4|                // 3. overflow_arg_area
 2237|      4|                // If gp < 48, overflow starts at 48.
 2238|      4|                // If gp >= 48, overflow starts at gp.
 2239|      4|                let overflow_offset = std::cmp::max(gp_val, 48) as i64;
 2240|      4|                let overflow_ptr = ctx.builder.ins().iadd_imm(spill_addr, overflow_offset);
 2241|      4|                ctx.builder.ins().store(MemFlags::new(), overflow_ptr, ap_addr, 8);
 2242|      4|
 2243|      4|                // 4. reg_save_area
 2244|      4|                // Points to the start of spill slot where we saved all params
 2245|      4|                ctx.builder.ins().store(MemFlags::new(), spill_addr, ap_addr, 16);
 2246|      4|            } else {
 2247|      0|                // Fallback (should not happen for variadic functions)
 2248|      0|                let zero = ctx.builder.ins().iconst(types::I64, 0);
 2249|      0|                ctx.builder.ins().store(MemFlags::new(), zero, ap_addr, 8); // overflow
 2250|      0|                ctx.builder.ins().store(MemFlags::new(), zero, ap_addr, 16); // reg_save
 2251|      0|            }
 2252|       |
 2253|      4|            Ok(())
 2254|       |        }
 2255|      0|        MirStmt::AtomicStore(ptr, val, _order) => {
 2256|      0|            let ptr_val = emit_operand(ptr, ctx, types::I64)?;
 2257|      0|            let val_type = lower_operand_type(val, ctx.mir)?;
 2258|      0|            let val_op = emit_operand(val, ctx, val_type)?;
 2259|       |
 2260|      0|            ctx.builder.ins().atomic_store(MemFlags::new(), val_op, ptr_val);
 2261|      0|            Ok(())
 2262|       |        }
 2263|      2|        MirStmt::BuiltinVaEnd(_place) => {
 2264|       |            // No-op for x86_64
 2265|      2|            Ok(())
 2266|       |        }
 2267|      0|        MirStmt::BuiltinVaCopy(dest, src) => {
 2268|      0|            let dest_addr = emit_place_addr(dest, ctx)?;
 2269|      0|            let src_addr = emit_place_addr(src, ctx)?;
 2270|       |            // va_list is 24 bytes on x86_64
 2271|      0|            emit_memcpy(dest_addr, src_addr, 24, ctx.builder, ctx.module)?;
 2272|      0|            Ok(())
 2273|       |        }
 2274|       |    }
 2275|    232|}
 2276|       |
 2277|       |/// Helper to lower a terminator
 2278|    273|fn visit_terminator(terminator: &Terminator, ctx: &mut BodyEmitContext) -> Result<(), String> {
 2279|    273|    match terminator {
 2280|     90|        Terminator::Goto(target) => {
 2281|     90|            let target_cl_block = ctx
 2282|     90|                .clif_blocks
 2283|     90|                .get(target)
 2284|     90|                .ok_or_else(|| format!("Target block {} not found", target.get()))?;
                                             ^0      ^0                           ^0     ^0     ^0
 2285|     90|            ctx.builder.ins().jump(*target_cl_block, &[]);
 2286|     90|            ctx.worklist.push(*target);
 2287|       |        }
 2288|       |
 2289|     71|        Terminator::If(cond, then_bb, else_bb) => {
 2290|     71|            let cond_val = emit_operand(cond, ctx, types::I32)?;
                                                                            ^0
 2291|       |
 2292|     71|            let then_cl_block = ctx
 2293|     71|                .clif_blocks
 2294|     71|                .get(then_bb)
 2295|     71|                .ok_or_else(|| format!("'Then' block {} not found", then_bb.get()))?;
                                             ^0      ^0                           ^0      ^0     ^0
 2296|     71|            let else_cl_block = ctx
 2297|     71|                .clif_blocks
 2298|     71|                .get(else_bb)
 2299|     71|                .ok_or_else(|| format!("'Else' block {} not found", else_bb.get()))?;
                                             ^0      ^0                           ^0      ^0     ^0
 2300|       |
 2301|     71|            ctx.builder
 2302|     71|                .ins()
 2303|     71|                .brif(cond_val, *then_cl_block, &[], *else_cl_block, &[]);
 2304|       |
 2305|     71|            ctx.worklist.push(*then_bb);
 2306|     71|            ctx.worklist.push(*else_bb);
 2307|       |        }
 2308|       |
 2309|    112|        Terminator::Return(opt) => {
 2310|    112|            if let Some(operand) = opt {
                                      ^98
 2311|     98|                if let Some(ret_type) = ctx.return_type {
 2312|     98|                    let return_value = emit_operand(operand, ctx, ret_type)?;
                                                                                         ^0
 2313|     98|                    ctx.builder.ins().return_(&[return_value]);
 2314|       |                } else {
 2315|      0|                    return Err("Returning a value from a void function".to_string());
 2316|       |                }
 2317|     14|            } else {
 2318|     14|                ctx.builder.ins().return_(&[]);
 2319|     14|            }
 2320|       |        }
 2321|       |
 2322|       |        Terminator::Unreachable => {
 2323|       |            // For unreachable, default to appropriate return based on function type
 2324|      0|            if let Some(ret_type) = ctx.return_type {
 2325|      0|                let return_value = ctx.builder.ins().iconst(ret_type, 0i64);
 2326|      0|                ctx.builder.ins().return_(&[return_value]);
 2327|      0|            } else {
 2328|      0|                // Void function
 2329|      0|                ctx.builder.ins().return_(&[]);
 2330|      0|            }
 2331|       |        }
 2332|       |    }
 2333|    273|    Ok(())
 2334|    273|}
 2335|       |
 2336|    170|fn lower_function_signature(
 2337|    170|    func: &MirFunction,
 2338|    170|    mir: &MirProgram,
 2339|    170|    func_ctx: &mut Signature,
 2340|    170|) -> Result<(Option<Type>, Vec<Type>), String> {
 2341|       |    // Set up function signature using the actual return type from MIR
 2342|    170|    func_ctx.params.clear();
 2343|       |
 2344|       |    // Get the return type from MIR and convert to Cranelift type
 2345|    170|    let return_mir_type = mir.get_type(func.return_type);
 2346|    170|    let return_type_opt = match lower_type(return_mir_type) {
 2347|    141|        Some(t) => Some(t),
 2348|     29|        None if return_mir_type.is_aggregate() => Some(types::I64),
                                                           ^0   ^0
 2349|     29|        None => None, // Void
 2350|       |    };
 2351|       |
 2352|       |    // Add parameters from MIR function signature
 2353|    170|    let mut param_types = Vec::new();
 2354|    222|    for &param_id in &func.params {
                       ^52
 2355|     52|        let param_local = mir.get_local(param_id);
 2356|     52|        let mir_type = mir.get_type(param_local.type_id);
 2357|       |
 2358|     52|        if let Some(count) = get_struct_packing(mir_type, mir) {
                                  ^8
 2359|      8|            for _ in 0..count {
 2360|      8|                func_ctx.params.push(AbiParam::new(types::I64));
 2361|      8|                param_types.push(types::I64);
 2362|      8|            }
 2363|      8|            continue;
 2364|     44|        }
 2365|       |
 2366|     44|        if matches!(mir_type, MirType::F80 | MirType::F128) {
 2367|       |            // Split F128/F80 into 2 I64s for internal ABI
 2368|      0|            func_ctx.params.push(AbiParam::new(types::I64));
 2369|      0|            func_ctx.params.push(AbiParam::new(types::I64));
 2370|       |            // Track them as F128 in param_types for visit_function to know,
 2371|       |            // OR track split types? visit_function iterates MIR params.
 2372|       |            // It needs to know it consumes 2 slots.
 2373|       |            // We push F128 to param_types so visit_function knows the logic type.
 2374|       |            // BUT lower_function_signature return type `Vec<Type>` is used by visit_function
 2375|       |            // to append_block_param.
 2376|       |            // So we must push I64, I64 to param_types.
 2377|      0|            param_types.push(types::I64);
 2378|      0|            param_types.push(types::I64);
 2379|      0|            continue;
 2380|     44|        }
 2381|       |
 2382|     44|        let param_type = match lower_type(mir_type) {
 2383|     44|            Some(t) => t,
 2384|      0|            None if mir_type.is_aggregate() => types::I64,
 2385|      0|            None => return Err(format!("Unsupported parameter type for local {}", param_id.get())),
 2386|       |        };
 2387|     44|        func_ctx.params.push(AbiParam::new(param_type));
 2388|     44|        param_types.push(param_type);
 2389|       |    }
 2390|       |
 2391|    170|    if func.is_variadic && matches!(func.kind, MirFunctionKind::Defined) {
                                         ^23      ^33
 2392|       |        // Add 32 total I64 parameters to capture variadic arguments (6 GPRs + 26 stack slots)
 2393|       |        // This allows variadic functions to receive many struct args that expand to multiple I64s
 2394|     10|        let fixed_params_count = func.params.len();
 2395|     10|        let total_variadic_slots = 128; // Support up to 128 I64 slots for variadic args
 2396|     10|        if fixed_params_count < total_variadic_slots {
 2397|  1.27k|            for _ in 0..(total_variadic_slots - fixed_params_count) {
                                      ^10
 2398|  1.27k|                func_ctx.params.push(AbiParam::new(types::I64));
 2399|  1.27k|            }
 2400|      0|        }
 2401|    160|    }
 2402|       |
 2403|       |    // Only add return parameter if the function has a non-void return type
 2404|    170|    if let Some(return_type) = return_type_opt {
                              ^141
 2405|    141|        func_ctx.returns.push(AbiParam::new(return_type));
 2406|    141|    }
                  ^29
 2407|       |
 2408|    170|    Ok((return_type_opt, param_types))
 2409|    170|}
 2410|       |
 2411|     73|fn emit_stack_slots(
 2412|     73|    func: &MirFunction,
 2413|     73|    mir: &MirProgram,
 2414|     73|    builder: &mut FunctionBuilder,
 2415|     73|    clif_stack_slots: &mut HashMap<LocalId, StackSlot>,
 2416|     73|) -> Result<(), String> {
 2417|     73|    clif_stack_slots.clear(); // Clear for each function
 2418|       |
 2419|       |    // Combine locals and params for slot allocation
 2420|     73|    let all_locals: Vec<LocalId> = func.locals.iter().chain(func.params.iter()).cloned().collect();
 2421|       |
 2422|    237|    for &local_id in &all_locals {
                       ^164
 2423|    164|        let local = mir.get_local(local_id);
 2424|    164|        let local_type = mir.get_type(local.type_id);
 2425|    164|        let size = lower_type_size(local_type, mir)?;
                                                                 ^0
 2426|       |
 2427|       |        // Don't allocate space for zero-sized types
 2428|    164|        if size > 0 {
 2429|    164|            let slot = builder.create_sized_stack_slot(StackSlotData::new(StackSlotKind::ExplicitSlot, size, 0));
 2430|    164|            clif_stack_slots.insert(local_id, slot);
 2431|    164|        }
                      ^0
 2432|       |    }
 2433|     73|    Ok(())
 2434|     73|}
 2435|       |
 2436|     73|fn finalize_function_processing(
 2437|     73|    func: &MirFunction,
 2438|     73|    module: &mut ObjectModule,
 2439|     73|    func_ctx: &mut cranelift::codegen::Context,
 2440|     73|    emit_kind: EmitKind,
 2441|     73|    compiled_functions: &mut HashMap<String, String>,
 2442|     73|) -> Result<(), String> {
 2443|       |    // Now declare and define the function
 2444|     73|    let linkage = lower_linkage(func.kind);
 2445|       |
 2446|     73|    let id = module
 2447|     73|        .declare_function(func.name.as_str(), linkage, &func_ctx.func.signature)
 2448|     73|        .map_err(|e| format!("Failed to declare function {}: {:?}", func.name, e))?;
                                   ^0      ^0                                                   ^0
 2449|       |
 2450|       |    // Only define the function body if it's a defined function (not extern)
 2451|     73|    if matches!(func.kind, MirFunctionKind::Defined) {
                     ^0
 2452|     73|        module
 2453|     73|            .define_function(id, func_ctx)
 2454|     73|            .map_err(|e| format!("Failed to define function {}: {:?}", func.name, e))?;
                                       ^0      ^0                                                  ^0
 2455|      0|    }
 2456|       |
 2457|     73|    if emit_kind == EmitKind::Clif {
 2458|     31|        // Store the function IR string for dumping
 2459|     31|        let func_ir = func_ctx.func.to_string();
 2460|     31|        compiled_functions.insert(func.name.to_string(), func_ir);
 2461|     42|    }
 2462|       |
 2463|     73|    Ok(())
 2464|     73|}
 2465|       |
 2466|       |/// MIR to Cranelift IR Lowerer
 2467|       |pub struct ClifGen {
 2468|       |    pub(crate) builder_context: FunctionBuilderContext,
 2469|       |    pub(crate) module: ObjectModule,
 2470|       |    pub(crate) mir: MirProgram, // NOTE: need better nama
 2471|       |    pub(crate) clif_stack_slots: HashMap<LocalId, StackSlot>,
 2472|       |    // Store compiled functions for dumping
 2473|       |    pub(crate) compiled_functions: HashMap<String, String>,
 2474|       |
 2475|       |    pub(crate) emit_kind: EmitKind,
 2476|       |
 2477|       |    // Mappings for relocations
 2478|       |    pub(crate) func_id_map: HashMap<MirFunctionId, FuncId>,
 2479|       |    pub(crate) data_id_map: HashMap<GlobalId, DataId>,
 2480|       |
 2481|       |    // Variadic spill area for the current function
 2482|       |    va_spill_slot: Option<StackSlot>,
 2483|       |
 2484|       |    triple: Triple,
 2485|       |    set_al_func: Option<FuncId>,
 2486|       |}
 2487|       |
 2488|       |/// NOTE: we use panic!() to ICE because codegen rely on correct MIR, so if we give invalid MIR, then problem is in previous phase
 2489|       |impl ClifGen {
 2490|     68|    pub(crate) fn new(mir: MirProgram) -> Self {
 2491|     68|        let triple = Triple::host();
 2492|     68|        let mut flag_builder = cranelift::prelude::settings::builder();
 2493|     68|        flag_builder.set("is_pic", "true").unwrap();
 2494|     68|        let builder = ObjectBuilder::new(
 2495|     68|            cranelift::prelude::isa::lookup(triple.clone())
 2496|     68|                .unwrap()
 2497|     68|                .finish(cranelift::prelude::settings::Flags::new(flag_builder))
 2498|     68|                .unwrap(),
 2499|       |            "main",
 2500|     68|            cranelift_module::default_libcall_names(),
 2501|       |        )
 2502|     68|        .unwrap();
 2503|     68|        let module = ObjectModule::new(builder);
 2504|       |
 2505|     68|        Self {
 2506|     68|            builder_context: FunctionBuilderContext::new(),
 2507|     68|            // ctx: module.make_context(),
 2508|     68|            module,
 2509|     68|            mir,
 2510|     68|            clif_stack_slots: HashMap::new(),
 2511|     68|            compiled_functions: HashMap::new(),
 2512|     68|            emit_kind: EmitKind::Object,
 2513|     68|            func_id_map: HashMap::new(),
 2514|     68|            data_id_map: HashMap::new(),
 2515|     68|            va_spill_slot: None,
 2516|     68|            triple,
 2517|     68|            set_al_func: None,
 2518|     68|        }
 2519|     68|    }
 2520|       |
 2521|     68|    pub(crate) fn visit_module(mut self, emit_kind: EmitKind) -> Result<ClifOutput, String> {
 2522|     68|        self.emit_kind = emit_kind;
 2523|       |
 2524|       |        // Pass 1: Declare all global variables
 2525|    132|        for &global_id in &self.mir.module.globals {
                           ^64
 2526|     64|            let global = self.mir.globals.get(&global_id).unwrap();
 2527|       |            // Use local linkage for string literals to avoid multiple definition errors
 2528|     64|            let linkage = if global.name.as_str().starts_with(".L.str") {
 2529|     41|                Linkage::Local
 2530|     23|            } else if global.initial_value.is_some() {
 2531|     23|                Linkage::Export
 2532|       |            } else {
 2533|      0|                Linkage::Import
 2534|       |            };
 2535|       |
 2536|     64|            let data_id = self
 2537|     64|                .module
 2538|     64|                .declare_data(global.name.as_str(), linkage, true, false)
 2539|     64|                .map_err(|e| format!("Failed to declare global data: {:?}", e))?;
                                           ^0      ^0                                        ^0
 2540|       |
 2541|     64|            self.data_id_map.insert(global_id, data_id);
 2542|       |        }
 2543|       |
 2544|       |        // Pass 2: Declare all functions
 2545|    165|        for &func_id in &self.mir.module.functions {
                           ^97
 2546|     97|            let func = self.mir.functions.get(&func_id).unwrap();
 2547|     97|            let linkage = lower_linkage(func.kind);
 2548|       |
 2549|       |            // Calculate signature for declaration
 2550|     97|            let mut sig = self.module.make_signature();
 2551|     97|            lower_function_signature(func, &self.mir, &mut sig)?;
                                                                             ^0
 2552|       |
 2553|     97|            let clif_func_id = self
 2554|     97|                .module
 2555|     97|                .declare_function(func.name.as_str(), linkage, &sig)
 2556|     97|                .map_err(|e| format!("Failed to declare function {}: {:?}", func.name, e))?;
                                           ^0      ^0                                                   ^0
 2557|       |
 2558|     97|            self.func_id_map.insert(func_id, clif_func_id);
 2559|       |        }
 2560|       |
 2561|       |        // Pass 3: Define Global Variables (with relocations)
 2562|    132|        for &global_id in &self.mir.module.globals {
                           ^64
 2563|     64|            let global = self.mir.globals.get(&global_id).unwrap();
 2564|     64|            if let Some(const_id) = global.initial_value {
 2565|     64|                let data_id = *self.data_id_map.get(&global_id).unwrap();
 2566|     64|                let mut data_description = DataDescription::new();
 2567|     64|                let mut initial_value_bytes = Vec::new();
 2568|       |                // Enable relocations by passing data_description and maps
 2569|     64|                let ctx = EmitContext {
 2570|     64|                    mir: &self.mir,
 2571|     64|                    func_id_map: &self.func_id_map,
 2572|     64|                    data_id_map: &self.data_id_map,
 2573|     64|                };
 2574|     64|                emit_const(
 2575|     64|                    const_id,
 2576|     64|                    &mut initial_value_bytes,
 2577|     64|                    &ctx,
 2578|     64|                    Some(&mut self.module),
 2579|     64|                    Some(&mut data_description),
 2580|       |                    0,
 2581|      0|                )?;
 2582|       |
 2583|     64|                data_description.define(initial_value_bytes.into_boxed_slice());
 2584|       |
 2585|     64|                self.module
 2586|     64|                    .define_data(data_id, &data_description)
 2587|     64|                    .map_err(|e| format!("Failed to define global data: {:?}", e))?;
                                               ^0      ^0                                       ^0
 2588|      0|            }
 2589|       |        }
 2590|       |
 2591|       |        // Pass 4: Define Functions (Lower bodies)
 2592|       |        // We can't iterate on `&self.mir.module.functions` directly because `visit_function`
 2593|       |        // needs a mutable borrow of `self`. Instead, we iterate by index to avoid cloning the
 2594|       |        // function list, which would cause a heap allocation.
 2595|     97|        for i in 0..self.mir.module.functions.len() {
                                  ^68                       ^68
 2596|     97|            let func_id = self.mir.module.functions[i];
 2597|       |            // Only lower functions that are defined (have bodies)
 2598|     97|            if let Some(func) = self.mir.functions.get(&func_id)
 2599|     97|                && matches!(func.kind, MirFunctionKind::Defined)
                                 ^24
 2600|       |            {
 2601|     73|                self.visit_function(func_id)?;
                                                          ^0
 2602|     24|            }
 2603|       |        }
 2604|       |
 2605|       |        // Finalize and return the compiled code
 2606|     68|        let code = crate::codegen::ObjectGen::finalize(self.module)?;
                                                                                 ^0
 2607|       |
 2608|     68|        if emit_kind == EmitKind::Object {
 2609|     38|            Ok(ClifOutput::ObjectFile(code))
 2610|       |        } else {
 2611|       |            // For Clif dump, concatenate all function IRs
 2612|     30|            let mut clif_dump = String::new();
 2613|     30|            let mut func_names: Vec<_> = self.compiled_functions.keys().collect();
 2614|     30|            func_names.sort();
 2615|       |
 2616|     61|            for func_name in func_names {
                              ^31
 2617|     31|                let func_ir = self.compiled_functions.get(func_name).unwrap();
 2618|     31|                clif_dump.push_str(&format!("; Function: {}\n", func_name));
 2619|     31|                clif_dump.push_str(func_ir);
 2620|     31|                clif_dump.push_str("\n\n");
 2621|     31|            }
 2622|     30|            Ok(ClifOutput::ClifDump(clif_dump))
 2623|       |        }
 2624|     68|    }
 2625|       |
 2626|       |    /// Lower a MIR function to Cranelift IR using 3-phase algorithm
 2627|     73|    fn visit_function(&mut self, func_id: MirFunctionId) -> Result<(), String> {
 2628|     73|        let func = self.mir.get_function(func_id);
 2629|       |        // Create a fresh context for this function
 2630|     73|        let mut func_ctx = self.module.make_context();
 2631|       |
 2632|     73|        let (return_type_opt, param_types) = lower_function_signature(func, &self.mir, &mut func_ctx.func.signature)?;
                                                                                                                                  ^0
 2633|       |
 2634|       |        // Create a function builder with the fresh context
 2635|     73|        let mut builder = FunctionBuilder::new(&mut func_ctx.func, &mut self.builder_context);
 2636|       |
 2637|     73|        emit_stack_slots(func, &self.mir, &mut builder, &mut self.clif_stack_slots)?;
                                                                                                 ^0
 2638|       |
 2639|       |        // PHASE 1  Create all Cranelift blocks first (no instructions)
 2640|     73|        let mut clif_blocks = HashMap::new();
 2641|       |
 2642|    347|        for &block_id in &func.blocks {
                           ^274
 2643|    274|            clif_blocks.insert(block_id, builder.create_block());
 2644|    274|        }
 2645|       |
 2646|       |        // PHASE 2  Lower block content (without sealing)
 2647|     73|        let mut va_spill_slot = None;
 2648|       |
 2649|       |        // Use worklist algorithm for proper traversal
 2650|     73|        let mut worklist = vec![func.entry_block.expect("Defined function must have entry block")];
 2651|     73|        let mut visited = HashSet::new();
 2652|       |
 2653|    378|        while let Some(current_block_id) = worklist.pop() {
                                     ^305
 2654|    305|            if visited.contains(&current_block_id) {
 2655|     32|                continue;
 2656|    273|            }
 2657|    273|            visited.insert(current_block_id);
 2658|       |
 2659|    273|            let clif_block = clif_blocks
 2660|    273|                .get(&current_block_id)
 2661|    273|                .ok_or_else(|| format!("Block {} not found in mapping", current_block_id.get()))?;
                                             ^0      ^0                               ^0               ^0     ^0
 2662|    273|            builder.switch_to_block(*clif_block);
 2663|       |
 2664|       |            // Setup entry block parameters
 2665|    273|            if Some(current_block_id) == func.entry_block {
 2666|       |                // Step 1: Add ALL block parameters first (fixed params)
 2667|     87|                for &param_type in &param_types {
                                   ^14
 2668|     14|                    builder.append_block_param(*clif_block, param_type);
 2669|     14|                }
 2670|       |
 2671|       |                // Step 2: Add variadic block parameters if needed (still before any instructions)
 2672|     73|                if func.is_variadic {
 2673|      5|                    let fixed_param_count = func.params.len();
 2674|      5|                    let total_variadic_slots = 128; // Must match lower_function_signature
 2675|      5|                    if fixed_param_count < total_variadic_slots {
 2676|      5|                        let extra_count = total_variadic_slots - fixed_param_count;
 2677|    635|                        for _ in 0..extra_count {
                                                  ^5
 2678|    635|                            builder.append_block_param(*clif_block, types::I64);
 2679|    635|                        }
 2680|      0|                    }
 2681|     68|                }
 2682|       |
 2683|       |                // Step 3: NOW emit instructions - store fixed params to stack slots
 2684|     73|                let param_values: Vec<Value> = builder.block_params(*clif_block).to_vec();
 2685|     73|                let mut param_iter = param_values.iter().copied();
 2686|       |
 2687|     87|                for &param_id in &func.params {
                                   ^14
 2688|     14|                    let local = self.mir.get_local(param_id);
 2689|     14|                    let mir_type = self.mir.get_type(local.type_id);
 2690|       |
 2691|       |                    // Check for struct packing
 2692|     14|                    if let Some(count) = get_struct_packing(mir_type, &self.mir) {
                                              ^4
 2693|      4|                        if let Some(stack_slot) = self.clif_stack_slots.get(&param_id) {
 2694|      4|                            let size = lower_type_size(mir_type, &self.mir).unwrap_or(8);
 2695|      4|                            for i in 0..count {
 2696|      4|                                let val = param_iter.next().unwrap();
 2697|      4|                                let offset = (i * 8) as i32;
 2698|      4|                                let remaining = size.saturating_sub((i * 8) as u32);
 2699|       |
 2700|      4|                                if remaining >= 8 {
 2701|      3|                                    builder.ins().stack_store(val, *stack_slot, offset);
 2702|      3|                                } else {
 2703|       |                                    // Partial store
 2704|      1|                                    for b in 0..remaining {
 2705|      1|                                        let shift_amt = builder.ins().iconst(types::I64, (b * 8) as i64);
 2706|      1|                                        let shifted = builder.ins().ushr(val, shift_amt);
 2707|      1|                                        let byte_val = builder.ins().ireduce(types::I8, shifted);
 2708|      1|                                        builder.ins().stack_store(byte_val, *stack_slot, offset + b as i32);
 2709|      1|                                    }
 2710|       |                                }
 2711|       |                            }
 2712|       |                        } else {
 2713|       |                            // Consume even if no stack slot
 2714|      0|                            for _ in 0..count {
 2715|      0|                                let _ = param_iter.next();
 2716|      0|                            }
 2717|       |                        }
 2718|      4|                        continue;
 2719|     10|                    }
 2720|       |
 2721|     10|                    if matches!(mir_type, MirType::F80 | MirType::F128) {
 2722|       |                        // Consumes 2 slots
 2723|      0|                        let lo = param_iter.next().unwrap();
 2724|      0|                        let hi = param_iter.next().unwrap();
 2725|       |
 2726|      0|                        if let Some(stack_slot) = self.clif_stack_slots.get(&param_id) {
 2727|      0|                            builder.ins().stack_store(lo, *stack_slot, 0);
 2728|      0|                            builder.ins().stack_store(hi, *stack_slot, 8);
 2729|      0|                        }
 2730|      0|                        continue;
 2731|     10|                    }
 2732|       |
 2733|     10|                    let param_value = param_iter.next().unwrap();
 2734|     10|                    if let Some(stack_slot) = self.clif_stack_slots.get(&param_id) {
 2735|     10|                        if mir_type.is_aggregate() {
 2736|       |                            // Passed by pointer (I64), copy to stack slot
 2737|      0|                            let dest_addr = builder.ins().stack_addr(types::I64, *stack_slot, 0);
 2738|      0|                            let size = lower_type_size(mir_type, &self.mir)? as i64;
 2739|      0|                            emit_memcpy(dest_addr, param_value, size, &mut builder, &mut self.module)?;
 2740|     10|                        } else {
 2741|     10|                            builder.ins().stack_store(param_value, *stack_slot, 0);
 2742|     10|                        }
 2743|      0|                    }
 2744|       |                }
 2745|       |
 2746|       |                // Step 4: Handle variadic spill area - save all 32 slots
 2747|     73|                if func.is_variadic {
 2748|      5|                    let total_slots = 128;
 2749|      5|                    let spill_size = total_slots * 8; // 256 bytes for 32 I64 slots
 2750|      5|                    let spill_slot = builder.create_sized_stack_slot(StackSlotData::new(
 2751|      5|                        StackSlotKind::ExplicitSlot,
 2752|      5|                        spill_size as u32,
 2753|       |                        0,
 2754|       |                    ));
 2755|      5|                    let all_param_values = builder.block_params(*clif_block).to_vec();
 2756|    640|                    for (i, val) in all_param_values
 2757|      5|                        .iter()
 2758|      5|                        .enumerate()
 2759|      5|                        .take(total_slots.min(all_param_values.len()))
 2760|    640|                    {
 2761|    640|                        builder.ins().stack_store(*val, spill_slot, (i * 8) as i32);
 2762|    640|                    }
 2763|      5|                    va_spill_slot = Some(spill_slot);
 2764|     68|                }
 2765|    200|            }
 2766|       |
 2767|       |            // Get the MIR block
 2768|    273|            let mir_block = self
 2769|    273|                .mir
 2770|    273|                .blocks
 2771|    273|                .get(&current_block_id)
 2772|    273|                .ok_or_else(|| format!("Block {} not found in MIR", current_block_id.get()))?;
                                             ^0      ^0                           ^0               ^0     ^0
 2773|       |
 2774|       |            // ========================================================================
 2775|       |            // SECTION 1: Process statements within this block
 2776|       |            // ========================================================================
 2777|    273|            let statements_to_process: Vec<MirStmt> = mir_block
 2778|    273|                .statements
 2779|    273|                .iter()
 2780|    273|                .filter_map(|&stmt_id| self.mir.statements.get(&stmt_id).cloned())
                                                     ^232                ^232^232      ^232
 2781|    273|                .collect();
 2782|       |
 2783|    273|            let mut ctx = BodyEmitContext {
 2784|    273|                builder: &mut builder,
 2785|    273|                mir: &self.mir,
 2786|    273|                stack_slots: &self.clif_stack_slots,
 2787|    273|                module: &mut self.module,
 2788|    273|                va_spill_slot,
 2789|    273|                func,
 2790|    273|                clif_blocks: &clif_blocks,
 2791|    273|                worklist: &mut worklist,
 2792|    273|                return_type: return_type_opt,
 2793|    273|                func_id_map: &self.func_id_map,
 2794|    273|                data_id_map: &self.data_id_map,
 2795|    273|                triple: &self.triple,
 2796|    273|                set_al_func: &mut self.set_al_func,
 2797|    273|            };
 2798|       |
 2799|       |            // Process statements
 2800|    505|            for stmt in &statements_to_process {
                              ^232
 2801|    232|                visit_statement(stmt, &mut ctx)?;
                                                             ^0
 2802|       |            }
 2803|       |
 2804|       |            // ========================================================================
 2805|       |            // SECTION 2: Process terminator (control flow)
 2806|       |            // ========================================================================
 2807|    273|            visit_terminator(&mir_block.terminator, &mut ctx)?;
                                                                           ^0
 2808|       |
 2809|    273|            va_spill_slot = ctx.va_spill_slot;
 2810|       |        }
 2811|       |
 2812|       |        // PHASE 3  Seal blocks with correct order
 2813|    347|        for &mir_block_id in &func.blocks {
                           ^274
 2814|    274|            let cl_block = clif_blocks.get(&mir_block_id).expect("Block not found in mapping");
 2815|    274|            builder.seal_block(*cl_block);
 2816|    274|        }
 2817|       |
 2818|       |        // Finalize the function
 2819|     73|        builder.finalize();
 2820|     73|        self.va_spill_slot = va_spill_slot;
 2821|       |
 2822|     73|        finalize_function_processing(
 2823|     73|            func,
 2824|     73|            &mut self.module,
 2825|     73|            &mut func_ctx,
 2826|     73|            self.emit_kind,
 2827|     73|            &mut self.compiled_functions,
 2828|      0|        )?;
 2829|       |
 2830|     73|        Ok(())
 2831|     73|    }
 2832|       |}
 2833|       |
 2834|       |/// Internal helper for variadic calls on x86_64 SysV
 2835|     24|fn emit_cendol_set_al(module: &mut ObjectModule) -> Result<FuncId, String> {
 2836|     24|    let mut sig = Signature::new(cranelift::codegen::isa::CallConv::SystemV);
 2837|     24|    sig.params.push(AbiParam::new(types::I64)); // count
 2838|     24|    sig.params.push(AbiParam::new(types::I64)); // addr
 2839|     24|    sig.returns.push(AbiParam::new(types::I64)); // count (RAX)
 2840|     24|    sig.returns.push(AbiParam::new(types::I64)); // addr (RDX)
 2841|       |
 2842|     24|    let func_id = module
 2843|     24|        .declare_function("__cendol_set_al", Linkage::Local, &sig)
 2844|     24|        .map_err(|e| format!("Failed to declare __cendol_set_al: {:?}", e))?;
                                   ^0      ^0                                            ^0
 2845|       |
 2846|     24|    let mut ctx = cranelift::codegen::Context::new();
 2847|     24|    ctx.func.signature = sig;
 2848|       |
 2849|     24|    let mut func_ctx = FunctionBuilderContext::new();
 2850|     24|    let mut builder = FunctionBuilder::new(&mut ctx.func, &mut func_ctx);
 2851|       |
 2852|     24|    let block = builder.create_block();
 2853|     24|    builder.append_block_params_for_function_params(block);
 2854|     24|    builder.switch_to_block(block);
 2855|     24|    builder.seal_block(block);
 2856|       |
 2857|     24|    let count = builder.block_params(block)[0];
 2858|     24|    let addr = builder.block_params(block)[1];
 2859|     24|    builder.ins().return_(&[count, addr]);
 2860|       |
 2861|     24|    builder.finalize();
 2862|       |
 2863|     24|    module
 2864|     24|        .define_function(func_id, &mut ctx)
 2865|     24|        .map_err(|e| format!("Failed to define __cendol_set_al: {:?}", e))?;
                                   ^0      ^0                                           ^0
 2866|       |
 2867|     24|    Ok(func_id)
 2868|     24|}

/app/src/codegen/link_gen.rs:
    1|       |//! Linking executable/library from object files.
    2|       |//!
    3|       |//! This module provides functionality for linking compiled object files
    4|       |//! into final executables or libraries using an external linker (clang).
    5|       |
    6|       |use std::path::{Path, PathBuf};
    7|       |use std::process::Command;
    8|       |
    9|       |/// Configuration for the linker.
   10|       |#[derive(Debug, Clone, Default)]
   11|       |pub(crate) struct LinkConfig {
   12|       |    /// Output file path
   13|       |    pub output_path: PathBuf,
   14|       |    /// Library search paths (-L)
   15|       |    pub library_paths: Vec<PathBuf>,
   16|       |    /// Libraries to link (-l)
   17|       |    pub libraries: Vec<String>,
   18|       |    /// Optimization level (e.g., "0", "1", "2", "3", "s")
   19|       |    pub optimization: Option<String>,
   20|       |    /// Include debug info (-g)
   21|       |    pub debug_info: bool,
   22|       |    /// Verbose output
   23|       |    pub verbose: bool,
   24|       |    /// Use a specific linker
   25|       |    pub fuse_ld: Option<String>,
   26|       |}
   27|       |
   28|       |/// Error type for linking operations.
   29|       |#[derive(Debug)]
   30|       |pub(crate) enum LinkError {
   31|       |    /// IO error during linking
   32|       |    IoError(String),
   33|       |    /// Linker returned non-zero exit code
   34|       |    LinkFailed,
   35|       |}
   36|       |
   37|       |impl std::fmt::Display for LinkError {
   38|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   39|      0|        match self {
   40|      0|            LinkError::IoError(msg) => write!(f, "IO error: {}", msg),
   41|      0|            LinkError::LinkFailed => write!(f, "Linking failed"),
   42|       |        }
   43|      0|    }
   44|       |}
   45|       |
   46|       |impl std::error::Error for LinkError {}
   47|       |
   48|       |/// Links object files into an executable or library.
   49|       |pub(crate) struct LinkGen;
   50|       |
   51|       |impl LinkGen {
   52|       |    /// Link object files into an executable using clang.
   53|       |    ///
   54|       |    /// # Arguments
   55|       |    /// * `object_files` - Paths to object files to link
   56|       |    /// * `config` - Linking configuration
   57|       |    ///
   58|       |    /// # Returns
   59|       |    /// * `Ok(())` on success
   60|       |    /// * `Err(LinkError)` on failure
   61|     38|    pub(crate) fn link<P: AsRef<Path>>(object_files: &[P], config: &LinkConfig) -> Result<(), LinkError> {
   62|     38|        if object_files.is_empty() {
   63|      0|            return Ok(());
   64|     38|        }
   65|       |
   66|     38|        let mut clang_cmd = Command::new("clang");
   67|       |
   68|       |        // Add object files
   69|     76|        for obj in object_files {
                          ^38
   70|     38|            clang_cmd.arg(obj.as_ref());
   71|     38|        }
   72|       |
   73|       |        // Add library paths
   74|     38|        for path in &config.library_paths {
                          ^0
   75|      0|            clang_cmd.arg("-L").arg(path);
   76|      0|        }
   77|       |
   78|       |        // Add libraries
   79|     38|        for lib in &config.libraries {
                          ^0
   80|      0|            clang_cmd.arg(format!("-l{}", lib));
   81|      0|        }
   82|       |
   83|       |        // Add optimization flags if present
   84|     38|        if let Some(opt) = &config.optimization {
                                  ^0
   85|      0|            clang_cmd.arg(format!("-O{}", opt));
   86|     38|        }
   87|       |
   88|       |        // Add debug info if requested
   89|     38|        if config.debug_info {
   90|      0|            clang_cmd.arg("-g");
   91|     38|        }
   92|       |
   93|     38|        if let Some(linker) = &config.fuse_ld {
                                  ^0
   94|      0|            clang_cmd.arg(format!("-fuse-ld={}", linker));
   95|     38|        }
   96|       |
   97|       |        // Default to linking math library
   98|     38|        if !config.libraries.contains(&"m".to_string()) {
   99|     38|            clang_cmd.arg("-lm");
  100|     38|        }
                      ^0
  101|       |
  102|       |        // Suppress linker warnings about deprecated libc functions
  103|     38|        clang_cmd.arg("-Wl,-w");
  104|       |
  105|       |        // Set output path
  106|     38|        clang_cmd.arg("-o").arg(&config.output_path);
  107|       |
  108|     38|        if config.verbose {
  109|      0|            println!("Executing linker: {:?}", clang_cmd);
  110|     38|        }
  111|       |
  112|     38|        let status = clang_cmd
  113|     38|            .status()
  114|     38|            .map_err(|e| LinkError::IoError(format!("Failed to execute clang for linking: {}", e)))?;
                                                          ^0      ^0                                             ^0
  115|       |
  116|     38|        if !status.success() {
  117|      0|            return Err(LinkError::LinkFailed);
  118|     38|        }
  119|       |
  120|       |        // Set executable permissions on the output file (Unix only)
  121|       |        #[cfg(unix)]
  122|       |        {
  123|       |            use std::os::unix::fs::PermissionsExt;
  124|     38|            if let Ok(metadata) = std::fs::metadata(&config.output_path) {
  125|     38|                let mut permissions = metadata.permissions();
  126|     38|                permissions.set_mode(0o755); // rwxr-xr-x
  127|     38|                if let Err(e) = std::fs::set_permissions(&config.output_path, permissions) {
                                         ^0
  128|      0|                    eprintln!("Warning: Failed to set executable permissions: {}", e);
  129|     38|                }
  130|      0|            }
  131|       |        }
  132|       |
  133|     38|        Ok(())
  134|     38|    }
  135|       |}

/app/src/codegen/mir_gen.rs:
    1|       |use crate::ast::nodes;
    2|       |use crate::ast::*;
    3|       |use crate::mir::MirArrayLayout;
    4|       |use crate::mir::MirProgram;
    5|       |use crate::mir::MirRecordLayout;
    6|       |use crate::mir::{
    7|       |    self, BinaryIntOp, ConstValueId, ConstValueKind, LocalId, MirBlockId, MirBuilder, MirFunctionId, MirStmt, MirType,
    8|       |    Operand, Place, Rvalue, Terminator, TypeId,
    9|       |};
   10|       |use crate::semantic::ArraySizeType;
   11|       |use crate::semantic::BuiltinType;
   12|       |use crate::semantic::QualType;
   13|       |use crate::semantic::SymbolKind;
   14|       |use crate::semantic::SymbolRef;
   15|       |use crate::semantic::SymbolTable;
   16|       |use crate::semantic::TypeKind;
   17|       |
   18|       |use crate::semantic::const_eval::ConstEvalCtx;
   19|       |use crate::semantic::{Conversion, Namespace, ScopeId};
   20|       |use crate::semantic::{DefinitionState, TypeRef, TypeRegistry};
   21|       |use hashbrown::{HashMap, HashSet};
   22|       |use log::debug;
   23|       |use target_lexicon::Architecture;
   24|       |
   25|       |use crate::mir::GlobalId;
   26|       |
   27|       |pub(crate) struct MirGen<'a> {
   28|       |    pub(crate) ast: &'a Ast,
   29|       |    pub(crate) symbol_table: &'a SymbolTable, // Now immutable
   30|       |    pub(crate) mir_builder: MirBuilder,
   31|       |    pub(crate) current_function: Option<MirFunctionId>,
   32|       |    pub(crate) current_block: Option<MirBlockId>,
   33|       |    pub(crate) current_scope_id: ScopeId,
   34|       |    pub(crate) registry: &'a mut TypeRegistry,
   35|       |    pub(crate) local_map: HashMap<SymbolRef, LocalId>,
   36|       |    pub(crate) global_map: HashMap<SymbolRef, GlobalId>,
   37|       |    pub(crate) label_map: HashMap<NameId, MirBlockId>,
   38|       |    pub(crate) type_cache: HashMap<TypeRef, TypeId>,
   39|       |    pub(crate) type_conversion_in_progress: HashSet<TypeRef>,
   40|       |    pub(crate) break_target: Option<MirBlockId>,
   41|       |    pub(crate) continue_target: Option<MirBlockId>,
   42|       |    pub(crate) switch_case_map: HashMap<NodeRef, MirBlockId>,
   43|       |    pub(crate) valist_mir_id: Option<TypeId>,
   44|       |}
   45|       |
   46|       |impl<'a> MirGen<'a> {
   47|    209|    pub(crate) fn new(ast: &'a Ast, symbol_table: &'a SymbolTable, registry: &'a mut TypeRegistry) -> Self {
   48|    209|        let mir_builder = MirBuilder::new(mir::MirModuleId::new(1).unwrap(), 8);
   49|    209|        Self {
   50|    209|            ast,
   51|    209|            symbol_table,
   52|    209|            mir_builder,
   53|    209|            current_function: None,
   54|    209|            current_block: None,
   55|    209|            current_scope_id: ScopeId::GLOBAL,
   56|    209|            local_map: HashMap::new(),
   57|    209|            global_map: HashMap::new(),
   58|    209|            label_map: HashMap::new(),
   59|    209|            registry,
   60|    209|            type_cache: HashMap::new(),
   61|    209|            type_conversion_in_progress: HashSet::new(),
   62|    209|            break_target: None,
   63|    209|            continue_target: None,
   64|    209|            switch_case_map: HashMap::new(),
   65|    209|            valist_mir_id: None,
   66|    209|        }
   67|    209|    }
   68|       |
   69|    204|    pub(crate) fn const_ctx(&self) -> ConstEvalCtx<'_> {
   70|    204|        ConstEvalCtx {
   71|    204|            ast: self.ast,
   72|    204|            symbol_table: self.symbol_table,
   73|    204|            registry: self.registry,
   74|    204|            semantic_info: None,
   75|    204|        }
   76|    204|    }
   77|       |
   78|       |    // create dummy operand
   79|     72|    pub(crate) fn create_dummy_operand(&mut self) -> Operand {
   80|     72|        self.create_int_operand(9999)
   81|     72|    }
   82|       |
   83|    209|    pub(crate) fn visit_module(&mut self) -> MirProgram {
   84|    209|        debug!("Starting semantic analysis and MIR construction (complete)");
                             ^0
   85|    209|        let root = self.ast.get_root();
   86|    209|        self.visit_node(root);
   87|    209|        debug!("Semantic analysis complete");
                             ^0
   88|       |
   89|       |        // Take ownership of the builder to consume it, replacing it with a dummy.
   90|    209|        let builder = std::mem::replace(
   91|    209|            &mut self.mir_builder,
   92|    209|            MirBuilder::new(mir::MirModuleId::new(1).unwrap(), 8),
   93|       |        );
   94|    209|        let output = builder.consume();
   95|       |
   96|    209|        MirProgram {
   97|    209|            module: output.module,
   98|    209|            functions: output.functions,
   99|    209|            blocks: output.blocks,
  100|    209|            locals: output.locals,
  101|    209|            globals: output.globals,
  102|    209|            types: output.types,
  103|    209|            constants: output.constants,
  104|    209|            statements: output.statements,
  105|    209|            pointer_width: 8,
  106|    209|        }
  107|    209|    }
  108|       |
  109|  1.63k|    pub(crate) fn visit_node(&mut self, node_ref: NodeRef) {
  110|  1.63k|        let old_scope = self.current_scope_id;
  111|  1.63k|        let node_kind = *self.ast.get_kind(node_ref);
  112|       |
  113|    172|        match node_kind {
  114|    209|            NodeKind::TranslationUnit(tu_data) => {
  115|    209|                self.current_scope_id = self.ast.scope_of(node_ref);
  116|    209|                self.visit_translation_unit(&tu_data)
  117|       |            }
  118|    215|            NodeKind::Function(function_data) => {
  119|    215|                self.current_scope_id = self.ast.scope_of(node_ref);
  120|    215|                self.visit_function(&function_data)
  121|       |            }
  122|      4|            NodeKind::For(for_stmt) => {
  123|      4|                self.current_scope_id = self.ast.scope_of(node_ref);
  124|      4|                self.visit_for_stmt(&for_stmt)
  125|       |            }
  126|    237|            NodeKind::CompoundStatement(cs) => {
  127|    237|                self.current_scope_id = self.ast.scope_of(node_ref);
  128|    237|                self.visit_compound_statement(&cs)
  129|       |            }
  130|    310|            NodeKind::VarDecl(var_decl) => self.visit_var_decl(&var_decl),
  131|       |
  132|    229|            NodeKind::Return(expr) => self.visit_return_stmt(&expr),
  133|     63|            NodeKind::If(if_stmt) => self.visit_if_stmt(&if_stmt),
  134|      3|            NodeKind::While(while_stmt) => self.visit_while_stmt(&while_stmt),
  135|      3|            NodeKind::DoWhile(body, condition) => self.visit_do_while_stmt(body, condition),
  136|    172|            NodeKind::ExpressionStatement(Some(expr_ref)) => {
  137|    172|                // Expression statement: value not needed, only side-effects
  138|    172|                self.emit_expression(expr_ref, false);
  139|    172|            }
  140|      3|            NodeKind::Break => {
  141|      3|                let target = self.break_target.unwrap();
  142|      3|                self.mir_builder.set_terminator(Terminator::Goto(target));
  143|      3|            }
  144|      0|            NodeKind::Continue => {
  145|      0|                let target = self.continue_target.unwrap();
  146|      0|                self.mir_builder.set_terminator(Terminator::Goto(target));
  147|      0|            }
  148|      5|            NodeKind::Goto(label_name, _) => self.visit_goto_stmt(&label_name),
  149|      8|            NodeKind::Label(label_name, statement, _) => self.visit_label_stmt(&label_name, statement),
  150|      1|            NodeKind::Switch(cond, body) => self.visit_switch_stmt(cond, body),
  151|      2|            NodeKind::Case(_, stmt) => self.visit_case_default_stmt(node_ref, stmt),
  152|      1|            NodeKind::Default(stmt) => self.visit_case_default_stmt(node_ref, stmt),
  153|       |
  154|       |            // Expressions used as statements (without ExpressionStatement wrapper)
  155|       |            // This happens in For loop initializers/increments and potentially GnuStatementExpression results.
  156|       |            NodeKind::Literal(_)
  157|       |            | NodeKind::Ident(..)
  158|       |            | NodeKind::UnaryOp(..)
  159|       |            | NodeKind::BinaryOp(..)
  160|       |            | NodeKind::TernaryOp(..)
  161|       |            | NodeKind::PostIncrement(..)
  162|       |            | NodeKind::PostDecrement(..)
  163|       |            | NodeKind::Assignment(..)
  164|       |            | NodeKind::FunctionCall(..)
  165|       |            | NodeKind::MemberAccess(..)
  166|       |            | NodeKind::IndexAccess(..)
  167|       |            | NodeKind::Cast(..)
  168|       |            | NodeKind::SizeOfExpr(..)
  169|       |            | NodeKind::SizeOfType(..)
  170|       |            | NodeKind::AlignOf(..)
  171|       |            | NodeKind::CompoundLiteral(..)
  172|       |            | NodeKind::BuiltinVaArg(..)
  173|       |            | NodeKind::BuiltinExpect(..)
  174|       |            | NodeKind::BuiltinVaStart(..)
  175|       |            | NodeKind::BuiltinVaEnd(..)
  176|       |            | NodeKind::BuiltinVaCopy(..)
  177|       |            | NodeKind::GenericSelection(..)
  178|      1|            | NodeKind::GnuStatementExpression(..) => {
  179|      1|                self.emit_expression(node_ref, false);
  180|      1|            }
  181|       |
  182|    165|            _ => {}
  183|       |        }
  184|       |
  185|  1.63k|        self.current_scope_id = old_scope;
  186|  1.63k|    }
  187|       |
  188|    209|    fn visit_translation_unit(&mut self, tu_data: &nodes::TranslationUnitData) {
  189|    209|        self.predeclare_global_functions();
  190|    430|        for child_ref in tu_data.decl_start.range(tu_data.decl_len) {
                                       ^209               ^209  ^209
  191|    430|            self.visit_node(child_ref);
  192|    430|        }
  193|    209|    }
  194|       |
  195|    209|    fn predeclare_global_functions(&mut self) {
  196|       |        // Ensure all global functions (including declarations) have a MIR representation.
  197|       |        // This is done before traversing the AST to ensure that function calls
  198|       |        // can be resolved even if the function is defined later in the file or is external.
  199|    209|        let global_scope = self.symbol_table.get_scope(ScopeId::GLOBAL);
  200|    209|        let mut global_symbols: Vec<_> = global_scope.symbols.values().copied().collect();
  201|       |
  202|       |        // Sort by symbol name to ensure deterministic order for snapshot tests
  203|    554|        global_symbols.sort_by_key(|s| self.symbol_table.get_symbol(*s).name);
                      ^209           ^209
  204|       |
  205|    563|        for sym_ref in global_symbols {
                          ^354
  206|    354|            let (symbol_name, symbol_type_info, is_function, has_definition) = {
  207|    354|                let symbol = self.symbol_table.get_symbol(sym_ref);
  208|       |                (
  209|    354|                    symbol.name,
  210|    354|                    symbol.type_info,
  211|    354|                    matches!(symbol.kind, SymbolKind::Function { .. }),
                                  ^106
  212|    354|                    symbol.def_state == DefinitionState::Defined,
  213|       |                )
  214|       |            };
  215|       |
  216|    354|            if is_function {
  217|    248|                if self
  218|    248|                    .mir_builder
  219|    248|                    .get_functions()
  220|    248|                    .iter()
  221|    248|                    .any(|(_, f)| f.name == symbol_name)
                                                ^153      ^153
  222|       |                {
  223|      0|                    continue;
  224|    248|                }
  225|       |
  226|    248|                let func_type_kind = self.registry.get(symbol_type_info.ty()).kind.clone();
  227|       |                if let TypeKind::Function {
  228|    248|                    return_type,
  229|    248|                    parameters,
  230|    248|                    is_variadic,
  231|       |                    ..
  232|    248|                } = &func_type_kind
  233|       |                {
  234|    248|                    let return_mir_type = self.lower_type(*return_type);
  235|    248|                    let param_mir_types = parameters.iter().map(|p| self.lower_qual_type(p.param_type)).collect();
                                                                                  ^79  ^79             ^79
  236|       |
  237|    248|                    self.define_or_declare_function(
  238|    248|                        symbol_name,
  239|    248|                        param_mir_types,
  240|    248|                        return_mir_type,
  241|    248|                        *is_variadic,
  242|    248|                        has_definition,
  243|       |                    );
  244|      0|                } else {
  245|      0|                    // This case should ideally not be reached for a SymbolKind::Function
  246|      0|                    let return_mir_type = self.get_int_type();
  247|      0|                    self.define_or_declare_function(symbol_name, vec![], return_mir_type, false, has_definition);
  248|      0|                }
  249|    106|            }
  250|       |        }
  251|    209|    }
  252|       |
  253|    110|    pub(crate) fn operand_to_const_id_strict(&mut self, op: Operand, msg: &str) -> ConstValueId {
  254|    110|        if let Some(id) = self.operand_to_const_id(&op) {
  255|    110|            id
  256|       |        } else {
  257|      0|            panic!("{} - Operand: {:?}", msg, op);
  258|       |        }
  259|    110|    }
  260|       |
  261|     22|    pub(crate) fn evaluate_constant_usize(&mut self, expr: NodeRef, error_msg: &str) -> usize {
  262|     22|        let operand = self.emit_expression(expr, true);
  263|     22|        if let Some(const_id) = self.operand_to_const_id(&operand) {
  264|     22|            let const_val = self.mir_builder.get_constants().get(&const_id).unwrap();
  265|     22|            if let ConstValueKind::Int(val) = const_val.kind {
  266|     22|                val as usize
  267|       |            } else {
  268|      0|                panic!("{}", error_msg);
  269|       |            }
  270|       |        } else {
  271|      0|            panic!("{}", error_msg);
  272|       |        }
  273|     22|    }
  274|       |
  275|    101|    pub(crate) fn lower_condition(&mut self, condition: NodeRef) -> Operand {
  276|    101|        let cond_operand = self.emit_expression(condition, true);
  277|       |        // Apply conversions for condition (should be boolean)
  278|    101|        let cond_ty = self.ast.get_resolved_type(condition).unwrap();
  279|    101|        let cond_mir_ty = self.lower_qual_type(cond_ty);
  280|    101|        self.apply_conversions(cond_operand, condition, cond_mir_ty)
  281|    101|    }
  282|       |
  283|    237|    fn visit_compound_statement(&mut self, cs: &nodes::CompoundStmtData) {
  284|    682|        for stmt_ref in cs.stmt_start.range(cs.stmt_len) {
                                      ^237          ^237  ^237
  285|       |            // We visit all statements regardless of whether the current block is terminated.
  286|       |            // MirBuilder will suppress statement addition to terminated blocks, but we need
  287|       |            // to traverse to find nested labels/cases which start new reachable blocks.
  288|    682|            self.visit_node(stmt_ref)
  289|       |        }
  290|    237|    }
  291|       |
  292|    215|    fn visit_function(&mut self, function_data: &FunctionData) {
  293|    215|        let symbol_entry = self.symbol_table.get_symbol(function_data.symbol);
  294|    215|        let func_name = symbol_entry.name;
  295|       |
  296|       |        // Find the existing function in the MIR builder. It should have been created by the pre-pass.
  297|    215|        let func_id = self
  298|    215|            .mir_builder
  299|    215|            .get_functions()
  300|    215|            .iter()
  301|    349|            .find(|(_, f)| f.name == func_name)
                           ^215
  302|    215|            .map(|(id, _)| *id)
  303|    215|            .expect("Function not found in MIR builder, pre-pass failed?");
  304|       |
  305|    215|        self.current_function = Some(func_id);
  306|    215|        self.mir_builder.set_current_function(func_id);
  307|       |
  308|       |        // Since we use define_function for functions with bodies, we should always have a body here
  309|    215|        let entry_block_id = self.mir_builder.create_block();
  310|    215|        self.mir_builder.set_function_entry_block(func_id, entry_block_id);
  311|    215|        self.current_block = Some(entry_block_id);
  312|    215|        self.mir_builder.set_current_block(entry_block_id);
  313|       |
  314|       |        // Pre-scan for all labels in the function body to create their MIR blocks upfront.
  315|    215|        self.label_map.clear();
  316|    215|        self.scan_for_labels(function_data.body);
  317|       |
  318|       |        // Parameter locals are now created in `define_function`. We just need to
  319|       |        // map the SymbolRef to the LocalId.
  320|    215|        self.local_map.clear();
  321|    215|        let mir_params = self.mir_builder.get_functions().get(&func_id).unwrap().params.clone();
  322|       |
  323|    215|        for (i, param_ref) in function_data.param_start.range(function_data.param_len).enumerate() {
                           ^44^44
  324|     44|            if let NodeKind::Param(param_data) = self.ast.get_kind(param_ref) {
  325|     44|                let local_id = mir_params[i];
  326|     44|                self.local_map.insert(param_data.symbol, local_id);
  327|     44|            }
                          ^0
  328|       |        }
  329|       |
  330|    215|        self.visit_node(function_data.body);
  331|       |
  332|       |        // Handle implicit return if control falls off the end
  333|    215|        if !self.mir_builder.current_block_has_terminator() {
  334|     42|            let func_def = self.mir_builder.get_functions().get(&func_id).unwrap();
  335|     42|            let ret_ty_id = func_def.return_type;
  336|     42|            let ret_ty = self.mir_builder.get_type(ret_ty_id);
  337|       |
  338|     42|            if matches!(ret_ty, crate::mir::MirType::Void) {
                             ^3
  339|     39|                self.mir_builder.set_terminator(crate::mir::Terminator::Return(None));
  340|     39|            } else if func_name.to_string() == "main" && ret_ty.is_int() {
                                    ^3                                 ^3     ^3
  341|      3|                // main() implicitly returns 0
  342|      3|                let zero = self.create_int_operand(0);
  343|      3|                self.mir_builder
  344|      3|                    .set_terminator(crate::mir::Terminator::Return(Some(zero)));
  345|      3|            } else {
  346|      0|                // Falling off the end of a non-void function is undefined behavior.
  347|      0|                // We leave it as Unreachable (default) or explicitly set it.
  348|      0|                self.mir_builder.set_terminator(crate::mir::Terminator::Unreachable);
  349|      0|            }
  350|    173|        }
  351|       |
  352|    215|        self.current_function = None;
  353|    215|        self.current_block = None;
  354|    215|    }
  355|       |
  356|    310|    fn visit_var_decl(&mut self, var_decl: &VarDeclData) {
  357|    310|        let mir_type_id = self.lower_qual_type(var_decl.ty);
  358|    310|        let (entry_ref, _) = self
  359|    310|            .symbol_table
  360|    310|            .lookup(var_decl.name, self.current_scope_id, Namespace::Ordinary)
  361|    310|            .unwrap();
  362|       |
  363|    310|        self.visit_variable(entry_ref, mir_type_id);
  364|    310|    }
  365|       |
  366|    311|    pub(crate) fn visit_variable(&mut self, entry_ref: SymbolRef, mir_type_id: TypeId) {
  367|    311|        let symbol = self.symbol_table.get_symbol(entry_ref);
  368|    311|        let (is_global_sym, storage) = if let SymbolKind::Variable { is_global, storage, .. } = symbol.kind {
  369|    311|            (is_global, storage)
  370|       |        } else {
  371|      0|            panic!("visit_variable called on non-variable");
  372|       |        };
  373|       |
  374|       |        // Treat static locals as globals for MIR generation purposes (lifetime/storage)
  375|    311|        let is_global = self.current_function.is_none() || is_global_sym || storage == Some(StorageClass::Static);
                                                                         ^243             ^243
  376|       |
  377|    311|        if is_global {
  378|     69|            self.emit_global(entry_ref, mir_type_id);
  379|    242|        } else {
  380|    242|            self.emit_local(entry_ref, mir_type_id);
  381|    242|        }
  382|    311|    }
  383|       |
  384|     69|    fn emit_global(&mut self, entry_ref: SymbolRef, mir_type_id: TypeId) {
  385|     69|        let symbol = self.symbol_table.get_symbol(entry_ref);
  386|     69|        let (init, alignment, name, ty) = if let SymbolKind::Variable {
  387|     69|            initializer, alignment, ..
  388|     69|        } = &symbol.kind
  389|       |        {
  390|     69|            (*initializer, *alignment, symbol.name, symbol.type_info)
  391|       |        } else {
  392|      0|            unreachable!()
  393|       |        };
  394|       |
  395|     69|        let initial_value_id = init.and_then(|init_ref| self.eval_initializer_to_const(init_ref, ty));
                                                                      ^55  ^55                       ^55       ^55
  396|       |
  397|     69|        let final_init = initial_value_id.or_else(|| {
                                                                   ^14
  398|     14|            if symbol.def_state == DefinitionState::Tentative {
  399|     11|                Some(self.create_constant(mir_type_id, ConstValueKind::Zero))
  400|       |            } else {
  401|      3|                None
  402|       |            }
  403|     14|        });
  404|       |
  405|     69|        if let Some(global_id) = self.global_map.get(&entry_ref).copied() {
                                  ^6
  406|      6|            if let Some(init_id) = final_init {
                                      ^5
  407|      5|                self.mir_builder.set_global_initializer(global_id, init_id);
  408|      5|            }
                          ^1
  409|       |        } else {
  410|     63|            let global_name = if symbol.scope_id == ScopeId::GLOBAL {
  411|     62|                name
  412|       |            } else {
  413|       |                // Mangle name for static local to avoid collision
  414|      1|                crate::ast::NameId::new(format!("{}.{}", name, entry_ref.get()))
  415|       |            };
  416|       |
  417|     63|            let global_id =
  418|     63|                self.mir_builder
  419|     63|                    .create_global_with_init(global_name, mir_type_id, symbol.is_const(), final_init);
  420|       |
  421|     63|            if let Some(align) = alignment {
                                      ^0
  422|      0|                self.mir_builder.set_global_alignment(global_id, align);
  423|     63|            }
  424|       |
  425|     63|            self.global_map.insert(entry_ref, global_id);
  426|       |        }
  427|     69|    }
  428|       |
  429|    242|    fn emit_local(&mut self, entry_ref: SymbolRef, mir_type_id: TypeId) {
  430|    242|        let symbol = self.symbol_table.get_symbol(entry_ref);
  431|    242|        let (init, alignment, name, ty) = if let SymbolKind::Variable {
  432|    242|            initializer, alignment, ..
  433|    242|        } = &symbol.kind
  434|       |        {
  435|    242|            (*initializer, *alignment, symbol.name, symbol.type_info)
  436|       |        } else {
  437|      0|            unreachable!()
  438|       |        };
  439|       |
  440|    242|        let local_id = self.mir_builder.create_local(Some(name), mir_type_id, false);
  441|       |
  442|    242|        if let Some(align) = alignment {
                                  ^0
  443|      0|            self.mir_builder.set_local_alignment(local_id, align);
  444|    242|        }
  445|       |
  446|    242|        self.local_map.insert(entry_ref, local_id);
  447|       |
  448|    242|        if let Some(initializer) = init {
                                  ^145
  449|    145|            let init_operand = self.emit_initializer(initializer, ty, Some(Place::Local(local_id)));
  450|    145|            // If emit_initializer used the destination, it returns Operand::Copy(destination)
  451|    145|            // emit_assignment will then emit Place::Local(local_id) = Place::Local(local_id), which is fine or can be skipped.
  452|    145|            self.emit_assignment(Place::Local(local_id), init_operand);
  453|    145|        }
                      ^97
  454|    242|    }
  455|       |
  456|    229|    fn visit_return_stmt(&mut self, expr: &Option<NodeRef>) {
  457|    229|        let operand = expr.map(|expr_ref| {
                                                        ^227
  458|    227|            let expr_operand = self.emit_expression(expr_ref, true);
  459|       |            // Apply conversions for return value if needed
  460|    227|            if let Some(func_id) = self.current_function {
  461|    227|                let func = self.mir_builder.get_functions().get(&func_id).unwrap();
  462|    227|                let return_mir_ty = func.return_type;
  463|    227|                self.apply_conversions(expr_operand, expr_ref, return_mir_ty)
  464|       |            } else {
  465|      0|                expr_operand
  466|       |            }
  467|    227|        });
  468|    229|        self.mir_builder.set_terminator(Terminator::Return(operand));
  469|    229|    }
  470|       |
  471|     63|    fn visit_if_stmt(&mut self, if_stmt: &IfStmt) {
  472|     63|        let then_block = self.mir_builder.create_block();
  473|     63|        let else_block = self.mir_builder.create_block();
  474|     63|        let merge_block = self.mir_builder.create_block();
  475|       |
  476|     63|        let cond_converted = self.lower_condition(if_stmt.condition);
  477|     63|        self.mir_builder
  478|     63|            .set_terminator(Terminator::If(cond_converted, then_block, else_block));
  479|       |
  480|     63|        self.mir_builder.set_current_block(then_block);
  481|     63|        self.visit_node(if_stmt.then_branch);
  482|     63|        if !self.mir_builder.current_block_has_terminator() {
  483|      9|            self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  484|     54|        }
  485|       |
  486|     63|        self.mir_builder.set_current_block(else_block);
  487|     63|        if let Some(else_branch) = &if_stmt.else_branch {
                                  ^4
  488|      4|            self.visit_node(*else_branch);
  489|     59|        }
  490|     63|        if !self.mir_builder.current_block_has_terminator() {
  491|     62|            self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  492|     62|        }
                      ^1
  493|       |
  494|     63|        self.mir_builder.set_current_block(merge_block);
  495|     63|        self.current_block = Some(merge_block);
  496|     63|    }
  497|       |
  498|     10|    fn emit_loop_generic<I, C, B, Inc>(
  499|     10|        &mut self,
  500|     10|        init_fn: Option<I>,
  501|     10|        cond_fn: Option<C>,
  502|     10|        body_fn: B,
  503|     10|        inc_fn: Option<Inc>,
  504|     10|        is_do_while: bool,
  505|     10|    ) where
  506|     10|        I: FnOnce(&mut Self),
  507|     10|        C: FnOnce(&mut Self) -> Operand,
  508|     10|        B: FnOnce(&mut Self),
  509|     10|        Inc: FnOnce(&mut Self),
  510|       |    {
  511|     10|        let cond_block = self.mir_builder.create_block();
  512|     10|        let body_block = self.mir_builder.create_block();
  513|     10|        let increment_block = if inc_fn.is_some() {
  514|      3|            self.mir_builder.create_block()
  515|       |        } else {
  516|       |            // If there's no increment block (e.g. while/do-while), "continue" goes to condition
  517|      7|            cond_block
  518|       |        };
  519|     10|        let exit_block = self.mir_builder.create_block();
  520|       |
  521|       |        // Continue target depends on whether we have an increment step
  522|     10|        let continue_target = increment_block;
  523|       |
  524|     10|        self.with_loop_targets(exit_block, continue_target, |this| {
  525|     10|            if let Some(init) = init_fn {
                                      ^2
  526|      2|                init(this);
  527|      8|            }
  528|       |
  529|     10|            if is_do_while {
  530|      3|                // do-while: jump straight to body
  531|      3|                this.mir_builder.set_terminator(Terminator::Goto(body_block));
  532|      7|            } else {
  533|      7|                // for/while: jump to condition
  534|      7|                this.mir_builder.set_terminator(Terminator::Goto(cond_block));
  535|      7|            }
  536|       |
  537|       |            // Condition block
  538|     10|            this.mir_builder.set_current_block(cond_block);
  539|     10|            if let Some(cond) = cond_fn {
  540|     10|                let cond_val = cond(this);
  541|     10|                this.mir_builder
  542|     10|                    .set_terminator(Terminator::If(cond_val, body_block, exit_block));
  543|     10|            } else {
  544|      0|                // No condition (e.g. for(;;)) -> infinite loop
  545|      0|                this.mir_builder.set_terminator(Terminator::Goto(body_block));
  546|      0|            }
  547|       |
  548|       |            // Body block
  549|     10|            this.mir_builder.set_current_block(body_block);
  550|     10|            body_fn(this);
  551|       |
  552|       |            // After body, jump to increment (or condition if no increment)
  553|     10|            if !this.mir_builder.current_block_has_terminator() {
  554|     10|                this.mir_builder.set_terminator(Terminator::Goto(increment_block));
  555|     10|            }
                          ^0
  556|       |
  557|       |            // Increment block (only if it exists and is distinct from cond_block)
  558|     10|            if let Some(inc) = inc_fn {
                                      ^3
  559|      3|                this.mir_builder.set_current_block(increment_block);
  560|      3|                inc(this);
  561|      3|                this.mir_builder.set_terminator(Terminator::Goto(cond_block));
  562|      7|            }
  563|     10|        });
  564|       |
  565|     10|        self.mir_builder.set_current_block(exit_block);
  566|     10|        self.current_block = Some(exit_block);
  567|     10|    }
  568|       |
  569|      3|    fn visit_while_stmt(&mut self, while_stmt: &WhileStmt) {
  570|      3|        self.emit_loop_generic(
  571|      3|            None::<fn(&mut Self)>,
  572|      3|            Some(|this: &mut Self| this.lower_condition(while_stmt.condition)),
  573|      3|            |this| this.visit_node(while_stmt.body),
  574|      3|            None::<fn(&mut Self)>,
  575|       |            false,
  576|       |        );
  577|      3|    }
  578|       |
  579|      3|    fn visit_do_while_stmt(&mut self, body: NodeRef, condition: NodeRef) {
  580|      3|        self.emit_loop_generic(
  581|      3|            None::<fn(&mut Self)>,
  582|      3|            Some(|this: &mut Self| this.lower_condition(condition)),
  583|      3|            |this| this.visit_node(body),
  584|      3|            None::<fn(&mut Self)>,
  585|       |            true,
  586|       |        );
  587|      3|    }
  588|       |
  589|      4|    fn visit_for_stmt(&mut self, for_stmt: &ForStmt) {
  590|      4|        let init_fn = for_stmt.init.map(|init| move |this: &mut Self| this.visit_node(init));
                                                                                    ^2   ^2         ^2
  591|       |
  592|      4|        let cond_fn = for_stmt
  593|      4|            .condition
  594|      4|            .map(|cond| move |this: &mut Self| this.lower_condition(cond));
  595|       |
  596|      4|        let inc_fn = for_stmt.increment.map(|inc| {
                                                                ^3
  597|      3|            move |this: &mut Self| {
  598|      3|                this.emit_expression(inc, false);
  599|      3|            }
  600|      3|        });
  601|       |
  602|      4|        self.emit_loop_generic(init_fn, cond_fn, |this| this.visit_node(for_stmt.body), inc_fn, false);
  603|      4|    }
  604|       |
  605|      1|    fn visit_switch_stmt(&mut self, cond: NodeRef, body: NodeRef) {
  606|      1|        let cond_op = self.emit_expression(cond, true);
  607|       |
  608|       |        // Integer promotions on controlling expression are handled by emit_expression if sema did it?
  609|       |        // Semantic analysis should have inserted implicit conversions.
  610|       |        // But we might need to cast case values to this type.
  611|      1|        let cond_ty_id = self.get_operand_type(&cond_op);
  612|       |
  613|      1|        let merge_block = self.mir_builder.create_block();
  614|       |
  615|      1|        let saved_break = self.break_target;
  616|      1|        self.break_target = Some(merge_block);
  617|       |
  618|       |        // Collect cases
  619|      1|        let cases = self.collect_switch_cases(body);
  620|       |
  621|       |        // Create blocks for cases
  622|      1|        let mut case_blocks = Vec::new();
  623|      1|        let mut default_block = None;
  624|       |
  625|      4|        for (node, val_opt) in cases {
                           ^3    ^3
  626|      3|            let block = self.mir_builder.create_block();
  627|      3|            self.switch_case_map.insert(node, block);
  628|       |
  629|      3|            if let Some(val) = val_opt {
                                      ^2
  630|      2|                case_blocks.push((val, block));
  631|      2|            } else {
  632|      1|                default_block = Some(block);
  633|      1|            }
  634|       |        }
  635|       |
  636|       |        // Generate dispatch
  637|      1|        let fallback_block = default_block.unwrap_or(merge_block);
  638|       |
  639|      3|        for (val_id, target_block) in case_blocks {
                           ^2      ^2
  640|      2|            let next_test_block = self.mir_builder.create_block();
  641|      2|            let val_const = self.mir_builder.get_constants().get(&val_id).unwrap().clone();
  642|       |
  643|       |            // Re-create constant with the same type as condition to ensure safe comparison
  644|       |            // This assumes the values are compatible (integral).
  645|       |            // Sema should ensure they are compatible.
  646|       |            // We just cast the constant value to the condition type for the comparison operand.
  647|       |            // Note: `val_const` is already lowered to some type.
  648|       |
  649|      2|            let val_op = Operand::Constant(val_id);
  650|      2|            let cast_val_op = if val_const.ty != cond_ty_id {
  651|      0|                Operand::Cast(cond_ty_id, Box::new(val_op))
  652|       |            } else {
  653|      2|                val_op
  654|       |            };
  655|       |
  656|       |            // Use Eq comparison
  657|       |            // If condition is float (illegal in C switch), we panic?
  658|       |            // Switch only works on integers.
  659|      2|            let cmp_rvalue = Rvalue::BinaryIntOp(BinaryIntOp::Eq, cond_op.clone(), cast_val_op);
  660|      2|            let bool_type_id = self.lower_type(self.registry.type_bool);
  661|      2|            let (_cmp_local, cmp_place) = self.create_temp_local_with_assignment(cmp_rvalue, bool_type_id);
  662|      2|            let cmp_op = Operand::Copy(Box::new(cmp_place));
  663|       |
  664|      2|            self.mir_builder
  665|      2|                .set_terminator(Terminator::If(cmp_op, target_block, next_test_block));
  666|       |
  667|      2|            self.mir_builder.set_current_block(next_test_block);
  668|      2|            self.current_block = Some(next_test_block);
  669|       |        }
  670|       |
  671|       |        // Final jump to default or merge
  672|      1|        self.mir_builder.set_terminator(Terminator::Goto(fallback_block));
  673|       |
  674|       |        // Lower body
  675|       |        // Start a dummy unreachable block for the body entry (to catch unreachable statements)
  676|      1|        let body_entry_dummy = self.mir_builder.create_block();
  677|       |        // Do not jump to it. It is unreachable.
  678|       |
  679|      1|        self.mir_builder.set_current_block(body_entry_dummy);
  680|      1|        self.current_block = Some(body_entry_dummy);
  681|       |
  682|      1|        self.visit_node(body);
  683|       |
  684|       |        // If body falls through, go to merge
  685|      1|        if self.mir_builder.current_block_has_terminator() == false {
  686|      0|            // Check if terminator is Unreachable (default) - if so, we can replace it or just leave it?
  687|      0|            // `current_block_has_terminator` returns false if it is Unreachable.
  688|      0|            // But if we are in body_entry_dummy and it's empty, we shouldn't jump to merge.
  689|      0|            // Actually, if execution falls through the body, it should hit merge.
  690|      0|            // But valid C code falling through end of switch goes to next stmt (merge).
  691|      0|            self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  692|      1|        }
  693|       |
  694|      1|        self.break_target = saved_break;
  695|      1|        self.mir_builder.set_current_block(merge_block);
  696|      1|        self.current_block = Some(merge_block);
  697|      1|    }
  698|       |
  699|      3|    fn visit_case_default_stmt(&mut self, node: NodeRef, stmt: NodeRef) {
  700|      3|        let target_block = *self.switch_case_map.get(&node).expect("Case/Default not mapped");
  701|       |
  702|       |        // Fallthrough from previous block
  703|      3|        if !self.mir_builder.current_block_has_terminator() {
  704|      1|            self.mir_builder.set_terminator(Terminator::Goto(target_block));
  705|      2|        }
  706|       |
  707|      3|        self.mir_builder.set_current_block(target_block);
  708|      3|        self.current_block = Some(target_block);
  709|       |
  710|      3|        self.visit_node(stmt);
  711|      3|    }
  712|       |
  713|      1|    fn collect_switch_cases(&mut self, node: NodeRef) -> Vec<(NodeRef, Option<ConstValueId>)> {
  714|      1|        let mut cases = Vec::new();
  715|      1|        self.collect_switch_cases_recursive(node, &mut cases);
  716|      1|        cases
  717|      1|    }
  718|       |
  719|     19|    fn collect_switch_cases_recursive(&mut self, node: NodeRef, cases: &mut Vec<(NodeRef, Option<ConstValueId>)>) {
  720|     19|        let kind = *self.ast.get_kind(node);
  721|     19|        match kind {
  722|      2|            NodeKind::Case(expr, stmt) => {
  723|      2|                let op = self.emit_expression(expr, true);
  724|      2|                let val = self.operand_to_const_id_strict(op, "Case label must be constant");
  725|      2|                cases.push((node, Some(val)));
  726|      2|                self.collect_switch_cases_recursive(stmt, cases);
  727|      2|            }
  728|      1|            NodeKind::Default(stmt) => {
  729|      1|                cases.push((node, None));
  730|      1|                self.collect_switch_cases_recursive(stmt, cases);
  731|      1|            }
  732|      0|            NodeKind::Switch(..) => {
  733|      0|                // Do not recurse into nested switch
  734|      0|            }
  735|       |            _ => {
  736|     16|                kind.visit_children(|child| self.collect_switch_cases_recursive(child, cases));
                                                          ^15  ^15                            ^15    ^15
  737|       |            }
  738|       |        }
  739|     19|    }
  740|       |
  741|    254|    pub(crate) fn emit_assignment(&mut self, place: Place, operand: Operand) {
  742|    254|        if self.mir_builder.current_block_has_terminator() {
  743|      0|            return;
  744|    254|        }
  745|       |
  746|       |        // Avoid identity assignments like %x = %x
  747|    254|        if let Operand::Copy(box_place) = &operand
                                           ^105
  748|    105|            && **box_place == place
  749|       |        {
  750|     19|            return;
  751|    235|        }
  752|       |
  753|    235|        let rvalue = Rvalue::Use(operand);
  754|    235|        let stmt = MirStmt::Assign(place, rvalue);
  755|    235|        self.mir_builder.add_statement(stmt);
  756|    254|    }
  757|       |
  758|  4.36k|    pub(crate) fn lower_qual_type(&mut self, ty: QualType) -> TypeId {
  759|  4.36k|        self.lower_type(ty.ty())
  760|  4.36k|    }
  761|       |
  762|  5.74k|    pub(crate) fn lower_type(&mut self, type_ref: TypeRef) -> TypeId {
  763|  5.74k|        if let Some(type_id) = self.type_cache.get(&type_ref) {
                                  ^4.97k
  764|  4.97k|            return *type_id;
  765|    769|        }
  766|       |
  767|       |        // Return placeholder if already converting this type (recursion loop)
  768|    769|        if self.type_conversion_in_progress.contains(&type_ref) {
  769|      0|            return *self
  770|      0|                .type_cache
  771|      0|                .get(&type_ref)
  772|      0|                .expect("Placeholder must exist for recursive type");
  773|    769|        }
  774|       |
  775|    769|        let ast_type_kind = self.registry.get(type_ref).kind.clone();
  776|       |
  777|    769|        match ast_type_kind {
  778|       |            TypeKind::Record {
  779|     61|                tag,
  780|     61|                is_union,
  781|     61|                is_complete,
  782|       |                ..
  783|     61|            } => self.lower_recursive_record_pattern(type_ref, tag, is_union, is_complete),
  784|    420|            TypeKind::Builtin(b) => {
  785|    420|                let mir_type = if matches!(b, BuiltinType::VaList) {
                                                ^415
  786|      5|                    self.lower_valist_type()
  787|       |                } else {
  788|    415|                    self.lower_builtin_type(&b)
  789|       |                };
  790|    420|                self.cache_type(type_ref, mir_type)
  791|       |            }
  792|    106|            TypeKind::Pointer { pointee } => {
  793|    106|                let mir_type = self.lower_pointer_type(pointee);
  794|    106|                self.cache_type(type_ref, mir_type)
  795|       |            }
  796|    101|            TypeKind::Array { element_type, size } => {
  797|    101|                let mir_type = self.lower_array_type(type_ref, element_type, &size);
  798|    101|                self.cache_type(type_ref, mir_type)
  799|       |            }
  800|       |            TypeKind::Function {
  801|     58|                return_type,
  802|     58|                parameters,
  803|     58|                is_variadic,
  804|       |                ..
  805|       |            } => {
  806|     58|                let mir_type = self.lower_function_type(&return_type, &parameters, is_variadic);
  807|     58|                self.cache_type(type_ref, mir_type)
  808|       |            }
  809|     20|            TypeKind::Complex { base_type } => {
  810|     20|                let mir_type = self.lower_complex_type(base_type);
  811|     20|                self.cache_type(type_ref, mir_type)
  812|       |            }
  813|       |            _ => {
  814|      3|                let mir_type = MirType::I32;
  815|      3|                self.cache_type(type_ref, mir_type)
  816|       |            }
  817|       |        }
  818|  5.74k|    }
  819|       |
  820|     61|    fn lower_recursive_record_pattern(
  821|     61|        &mut self,
  822|     61|        type_ref: TypeRef,
  823|     61|        tag: Option<NameId>,
  824|     61|        is_union: bool,
  825|     61|        is_complete: bool,
  826|     61|    ) -> TypeId {
  827|       |        // Begin conversion: reserve a placeholder TypeId so recursive references can point to it.
  828|     61|        self.type_conversion_in_progress.insert(type_ref);
  829|     61|        let placeholder_name = NameId::new(format!("__recursive_placeholder_{}", type_ref.get()));
  830|     61|        let placeholder_type = MirType::Record {
  831|     61|            name: placeholder_name,
  832|     61|            field_types: Vec::new(),
  833|     61|            field_names: Vec::new(),
  834|     61|            is_union: false,
  835|     61|            layout: MirRecordLayout {
  836|     61|                size: 0,
  837|     61|                alignment: 0,
  838|     61|                field_offsets: Vec::new(),
  839|     61|            },
  840|     61|        };
  841|     61|        let placeholder_id = self.mir_builder.add_type(placeholder_type);
  842|     61|        self.type_cache.insert(type_ref, placeholder_id);
  843|       |
  844|     61|        let mir_type = self.lower_record_type(type_ref, &tag, is_union, is_complete);
  845|       |
  846|       |        // Remove from in-progress set
  847|     61|        self.type_conversion_in_progress.remove(&type_ref);
  848|       |
  849|       |        // Replace the placeholder entry with the real type
  850|     61|        self.mir_builder.update_type(placeholder_id, mir_type);
  851|     61|        placeholder_id
  852|     61|    }
  853|       |
  854|    708|    fn cache_type(&mut self, type_ref: TypeRef, mir_type: MirType) -> TypeId {
  855|    708|        let type_id = self.mir_builder.add_type(mir_type);
  856|    708|        self.type_cache.insert(type_ref, type_id);
  857|    708|        type_id
  858|    708|    }
  859|       |
  860|      5|    fn lower_valist_type(&mut self) -> MirType {
  861|      5|        let u32_id = self.lower_type(self.registry.type_int_unsigned);
  862|      5|        let u64_id = self.lower_type(self.registry.type_long_long_unsigned);
  863|       |
  864|      5|        let record_layout = MirRecordLayout {
  865|      5|            size: 24,
  866|      5|            alignment: 8,
  867|      5|            field_offsets: vec![0, 4, 8, 16],
  868|      5|        };
  869|       |
  870|       |        // Cache the __va_list_tag record type to ensure canonical type usage
  871|      5|        let record_id = if let Some(id) = self.valist_mir_id {
                                                  ^0
  872|      0|            id
  873|       |        } else {
  874|      5|            let record_type = MirType::Record {
  875|      5|                name: NameId::new("__va_list_tag"),
  876|      5|                field_types: vec![u32_id, u32_id, u64_id, u64_id],
  877|      5|                field_names: Vec::new(),
  878|      5|                is_union: false,
  879|      5|                layout: record_layout,
  880|      5|            };
  881|      5|            let id = self.mir_builder.add_type(record_type);
  882|      5|            self.valist_mir_id = Some(id);
  883|      5|            id
  884|       |        };
  885|       |
  886|      5|        let array_layout = MirArrayLayout {
  887|      5|            size: 24,
  888|      5|            align: 8,
  889|      5|            stride: 24,
  890|      5|        };
  891|       |
  892|      5|        MirType::Array {
  893|      5|            element: record_id,
  894|      5|            size: 1,
  895|      5|            layout: array_layout,
  896|      5|        }
  897|      5|    }
  898|       |
  899|    415|    fn lower_builtin_type(&self, b: &BuiltinType) -> MirType {
  900|    415|        match b {
  901|     47|            BuiltinType::Void => MirType::Void,
  902|      7|            BuiltinType::Bool => MirType::Bool,
  903|     51|            BuiltinType::Char | BuiltinType::SChar => MirType::I8,
  904|      9|            BuiltinType::UChar => MirType::U8,
  905|      4|            BuiltinType::Short => MirType::I16,
  906|      4|            BuiltinType::UShort => MirType::U16,
  907|    197|            BuiltinType::Int => MirType::I32,
  908|     10|            BuiltinType::UInt => MirType::U32,
  909|     15|            BuiltinType::Long | BuiltinType::LongLong => MirType::I64,
  910|     26|            BuiltinType::ULong | BuiltinType::ULongLong => MirType::U64,
  911|     17|            BuiltinType::Float => MirType::F32,
  912|     20|            BuiltinType::Double => MirType::F64,
  913|       |            BuiltinType::LongDouble => {
  914|      8|                if self.registry.target_triple.architecture == Architecture::X86_64 {
  915|      8|                    MirType::F80
  916|       |                } else {
  917|      0|                    MirType::F128
  918|       |                }
  919|       |            }
  920|      0|            BuiltinType::Signed => MirType::I32,
  921|      0|            BuiltinType::VaList => MirType::U64,   // Opaque handle
  922|      0|            BuiltinType::Complex => MirType::Void, // Should not happen in MIR
  923|       |        }
  924|    415|    }
  925|       |
  926|    106|    fn lower_pointer_type(&mut self, pointee: QualType) -> MirType {
  927|    106|        MirType::Pointer {
  928|    106|            pointee: self.lower_type(pointee.ty()),
  929|    106|        }
  930|    106|    }
  931|       |
  932|    101|    fn lower_array_type(&mut self, type_ref: TypeRef, element_type: TypeRef, size: &ArraySizeType) -> MirType {
  933|    101|        let element = self.lower_type(element_type);
  934|       |
  935|    101|        match size {
  936|     96|            ArraySizeType::Constant(s) => {
  937|     96|                let (layout_size, layout_align, element_ref, _) = self.registry.get_array_layout(type_ref);
  938|     96|                let element_layout = self.registry.get_layout(element_ref);
  939|       |
  940|     96|                MirType::Array {
  941|     96|                    element,
  942|     96|                    size: *s,
  943|     96|                    layout: MirArrayLayout {
  944|     96|                        size: layout_size,
  945|     96|                        align: layout_align,
  946|     96|                        stride: element_layout.size,
  947|     96|                    },
  948|     96|                }
  949|       |            }
  950|       |            _ => {
  951|       |                // For VLA or incomplete array, layout is not computed in registry.
  952|       |                // We use dummy layout (size 0) but try to preserve alignment/stride from element type.
  953|      5|                let (align, stride) = if element_type.is_inline_array()
  954|      5|                    || element_type.is_inline_pointer()
  955|      4|                    || self.registry.types[element_type.index()].layout.is_some()
  956|       |                {
  957|      5|                    let layout = self.registry.get_layout(element_type);
  958|      5|                    (layout.alignment, layout.size)
  959|       |                } else {
  960|       |                    // Element layout also unknown (e.g. nested VLA or incomplete)
  961|      0|                    (1, 0)
  962|       |                };
  963|       |
  964|      5|                MirType::Array {
  965|      5|                    element,
  966|      5|                    size: 0,
  967|      5|                    layout: MirArrayLayout { size: 0, align, stride },
  968|      5|                }
  969|       |            }
  970|       |        }
  971|    101|    }
  972|       |
  973|     58|    fn lower_function_type(
  974|     58|        &mut self,
  975|     58|        return_type: &TypeRef,
  976|     58|        parameters: &[crate::semantic::FunctionParameter],
  977|     58|        is_variadic: bool,
  978|     58|    ) -> MirType {
  979|     58|        let return_type = self.lower_type(*return_type);
  980|     58|        let mut params = Vec::new();
  981|    104|        for p in parameters {
                          ^46
  982|     46|            let param_ty_id = self.lower_qual_type(p.param_type);
  983|       |            // Adjust array parameters to pointers (C standard).
  984|       |            // This is especially important for VaList which treats itself as an array but is passed as a pointer.
  985|       |            // Sema handles explicit arrays, but BuiltinType::VaList is lowered to Array here.
  986|     46|            let param_ty = self.mir_builder.get_type(param_ty_id);
  987|     46|            let adjusted_ty_id = if let MirType::Array { element, .. } = param_ty {
                                                                       ^0
  988|      0|                self.mir_builder.add_type(MirType::Pointer { pointee: *element })
  989|       |            } else {
  990|     46|                param_ty_id
  991|       |            };
  992|     46|            params.push(adjusted_ty_id);
  993|       |        }
  994|     58|        MirType::Function {
  995|     58|            return_type,
  996|     58|            params,
  997|     58|            is_variadic,
  998|     58|        }
  999|     58|    }
 1000|       |
 1001|     20|    fn lower_complex_type(&mut self, base_type: TypeRef) -> MirType {
 1002|     20|        let element_id = self.lower_type(base_type);
 1003|     20|        let element_layout = self
 1004|     20|            .registry
 1005|     20|            .ensure_layout(base_type)
 1006|     20|            .expect("Layout computation failed");
 1007|     20|        let element_size = element_layout.size;
 1008|     20|        let element_align = element_layout.alignment;
 1009|       |
 1010|     20|        let name = NameId::new(format!("_Complex_{}", self.registry.display_type(base_type)));
 1011|       |
 1012|     20|        MirType::Record {
 1013|     20|            name,
 1014|     20|            field_types: vec![element_id, element_id],
 1015|     20|            field_names: vec![NameId::new("real"), NameId::new("imag")],
 1016|     20|            is_union: false,
 1017|     20|            layout: MirRecordLayout {
 1018|     20|                size: element_size * 2,
 1019|     20|                alignment: element_align,
 1020|     20|                field_offsets: vec![0, element_size],
 1021|     20|            },
 1022|     20|        }
 1023|     20|    }
 1024|       |
 1025|     61|    fn lower_record_type(
 1026|     61|        &mut self,
 1027|     61|        type_ref: TypeRef,
 1028|     61|        tag: &Option<NameId>,
 1029|     61|        is_union: bool,
 1030|     61|        is_complete: bool,
 1031|     61|    ) -> MirType {
 1032|     61|        let name = tag.unwrap_or_else(|| NameId::new("anonymous"));
                                                       ^6
 1033|       |
 1034|     61|        let (size, alignment, field_offsets, field_names, field_types) = if is_complete {
 1035|     60|            let mut flat_members = Vec::new();
 1036|     60|            let mut flat_offsets = Vec::new();
 1037|     60|            let ty = self.registry.get(type_ref).into_owned();
 1038|     60|            ty.flatten_members_with_layouts(self.registry, &mut flat_members, &mut flat_offsets, 0);
 1039|       |
 1040|     60|            let mut field_names = Vec::new();
 1041|     60|            let mut field_types = Vec::new();
 1042|       |
 1043|    114|            for (idx, m) in flat_members.iter().enumerate() {
                                          ^60                 ^60
 1044|    114|                let name = m.name.unwrap_or_else(|| NameId::new(format!("__anon_{}", idx)));
                                                                  ^0          ^0      ^0
 1045|    114|                field_names.push(name);
 1046|    114|                field_types.push(self.lower_qual_type(m.member_type));
 1047|       |            }
 1048|     60|            let layout = ty.layout.as_ref().unwrap();
 1049|     60|            (layout.size, layout.alignment, flat_offsets, field_names, field_types)
 1050|       |        } else {
 1051|      1|            (0, 1, Vec::new(), Vec::new(), Vec::new())
 1052|       |        };
 1053|       |
 1054|     61|        MirType::Record {
 1055|     61|            name,
 1056|     61|            field_types,
 1057|     61|            field_names,
 1058|     61|            is_union,
 1059|     61|            layout: MirRecordLayout {
 1060|     61|                size,
 1061|     61|                alignment,
 1062|     61|                field_offsets,
 1063|     61|            },
 1064|     61|        }
 1065|     61|    }
 1066|       |
 1067|  1.93k|    pub(crate) fn create_constant(&mut self, ty: TypeId, kind: ConstValueKind) -> ConstValueId {
 1068|  1.93k|        self.mir_builder.create_constant(ty, kind)
 1069|  1.93k|    }
 1070|       |
 1071|    193|    pub(crate) fn create_int_operand(&mut self, val: i64) -> Operand {
 1072|    193|        let ty_id = self.get_int_type();
 1073|    193|        Operand::Constant(self.create_constant(ty_id, ConstValueKind::Int(val)))
 1074|    193|    }
 1075|       |
 1076|      0|    pub(crate) fn create_float_operand(&mut self, val: f64, ty_id: TypeId) -> Operand {
 1077|      0|        Operand::Constant(self.create_constant(ty_id, ConstValueKind::Float(val)))
 1078|      0|    }
 1079|       |
 1080|    575|    fn emit_conversion(&mut self, operand: Operand, conv: &Conversion, target_type_id: TypeId) -> Operand {
 1081|    575|        let to_ty_ref = match conv {
 1082|    401|            Conversion::IntegerCast { to, .. }
 1083|     42|            | Conversion::IntegerPromotion { to, .. }
 1084|    504|            | Conversion::PointerCast { to, .. } => Some(*to),
                                                      ^61
 1085|     58|            Conversion::PointerDecay { to } => Some(*to),
 1086|     13|            _ => None,
 1087|       |        };
 1088|       |
 1089|    575|        let from_ty_ref = match conv {
 1090|    401|            Conversion::IntegerCast { from, .. }
 1091|     42|            | Conversion::IntegerPromotion { from, .. }
 1092|    504|            | Conversion::PointerCast { from, .. } => Some(*from),
                                                      ^61
 1093|     71|            _ => None,
 1094|       |        };
 1095|       |
 1096|    575|        if let Some(to) = to_ty_ref
                                  ^562
 1097|    562|            && (to.is_complex() || from_ty_ref.is_some_and(|f| f.is_complex()))
                                                 ^556        ^556            ^498^498
 1098|       |        {
 1099|      6|            return self.emit_complex_conversion(operand, from_ty_ref, to);
 1100|    569|        }
 1101|       |
 1102|    569|        let to_mir_type = match conv {
 1103|    395|            Conversion::IntegerCast { to, .. }
 1104|     42|            | Conversion::IntegerPromotion { to, .. }
 1105|    498|            | Conversion::PointerCast { to, .. } => self.lower_type(*to),
                                                      ^61
 1106|       |            Conversion::NullPointerConstant => {
 1107|       |                // Null pointer constant usually converts to void* first.
 1108|       |                // However, we can use target_type_id if it's already a pointer.
 1109|     12|                let void_ptr_mir = self.lower_type(self.registry.type_void_ptr);
 1110|     12|                if self.mir_builder.get_type(target_type_id).is_pointer() {
 1111|     12|                    target_type_id
 1112|       |                } else {
 1113|      0|                    void_ptr_mir
 1114|       |                }
 1115|       |            }
 1116|     58|            Conversion::PointerDecay { to } => self.lower_type(*to),
 1117|      0|            Conversion::LValueToRValue => target_type_id,
 1118|      1|            Conversion::QualifierAdjust { .. } => target_type_id,
 1119|       |        };
 1120|       |
 1121|       |        // Optimization: skip if already same type
 1122|    569|        let current_ty = self.get_operand_type(&operand);
 1123|    569|        if current_ty == to_mir_type && !matches!(conv, Conversion::PointerDecay { .. }) {
                                                       ^372     ^372
 1124|    372|            return operand;
 1125|    197|        }
 1126|       |
 1127|    197|        match conv {
 1128|       |            Conversion::IntegerCast { .. } | Conversion::IntegerPromotion { .. } | Conversion::PointerCast { .. } => {
 1129|    129|                Operand::Cast(to_mir_type, Box::new(operand))
 1130|       |            }
 1131|       |            Conversion::NullPointerConstant => {
 1132|     10|                let ty_id = self.lower_type(self.registry.type_int);
 1133|     10|                Operand::Cast(
 1134|     10|                    to_mir_type,
 1135|     10|                    Box::new(Operand::Constant(self.create_constant(ty_id, ConstValueKind::Int(0)))),
 1136|     10|                )
 1137|       |            }
 1138|       |            Conversion::PointerDecay { .. } => {
 1139|     58|                if let Operand::Copy(place) = &operand {
                                                   ^3
 1140|      3|                    let addr_of_array = Operand::AddressOf(place.clone());
 1141|      3|                    Operand::Cast(to_mir_type, Box::new(addr_of_array))
 1142|       |                } else {
 1143|       |                    // If it's not a place (e.g. String Literal might be lowered to Constant directly?)
 1144|       |                    // String literals usually LValue, so Copy(Place::Global/Local).
 1145|     55|                    Operand::Cast(to_mir_type, Box::new(operand))
 1146|       |                }
 1147|       |            }
 1148|      0|            _ => Operand::Cast(target_type_id, Box::new(operand)),
 1149|       |        }
 1150|    575|    }
 1151|       |
 1152|  1.50k|    pub(crate) fn get_operand_type(&mut self, operand: &Operand) -> TypeId {
 1153|  1.50k|        match operand {
 1154|    506|            Operand::Copy(place) => self.get_place_type(place),
 1155|    800|            Operand::Constant(const_id) => {
 1156|    800|                let const_val = self.mir_builder.get_constants().get(const_id).unwrap();
 1157|    800|                const_val.ty
 1158|       |            }
 1159|     18|            Operand::AddressOf(place) => {
 1160|     18|                let pointee = self.get_place_type(place);
 1161|     18|                self.mir_builder.add_type(MirType::Pointer { pointee })
 1162|       |            }
 1163|    183|            Operand::Cast(ty, _) => *ty,
 1164|       |        }
 1165|  1.50k|    }
 1166|       |
 1167|    688|    pub(crate) fn get_place_type(&mut self, place: &Place) -> TypeId {
 1168|    688|        match place {
 1169|    453|            Place::Local(local_id) => self.mir_builder.get_locals().get(local_id).unwrap().type_id,
 1170|     63|            Place::Global(global_id) => self.get_global_type(*global_id),
 1171|      8|            Place::Deref(operand) => {
 1172|      8|                let ptr_ty = self.get_operand_type(operand);
 1173|      8|                match self.mir_builder.get_type(ptr_ty) {
 1174|      8|                    MirType::Pointer { pointee } => *pointee,
 1175|      0|                    _ => panic!("Deref of non-pointer type"),
 1176|       |                }
 1177|       |            }
 1178|    102|            Place::StructField(base, field_idx) => {
 1179|    102|                let struct_ty = self.get_place_type(base);
 1180|    102|                match self.mir_builder.get_type(struct_ty) {
 1181|    102|                    MirType::Record { field_types, .. } => field_types[*field_idx],
 1182|      0|                    _ => panic!("StructField access on non-struct type"),
 1183|       |                }
 1184|       |            }
 1185|     62|            Place::ArrayIndex(base, _) => {
 1186|     62|                let base_ty = self.get_place_type(base);
 1187|     62|                match self.mir_builder.get_type(base_ty) {
 1188|     62|                    MirType::Array { element, .. } => *element,
 1189|      0|                    MirType::Pointer { pointee, .. } => *pointee,
 1190|      0|                    _ => panic!("ArrayIndex access on non-array, non-pointer type"),
 1191|       |                }
 1192|       |            }
 1193|       |        }
 1194|    688|    }
 1195|       |
 1196|     67|    fn get_global_type(&self, global_id: GlobalId) -> TypeId {
 1197|     67|        self.mir_builder.get_globals().get(&global_id).unwrap().type_id
 1198|     67|    }
 1199|       |
 1200|     79|    pub(crate) fn get_function_type(&mut self, func_id: MirFunctionId) -> TypeId {
 1201|     79|        let func = self.mir_builder.get_functions().get(&func_id).unwrap();
 1202|     79|        let ret_ty = func.return_type;
 1203|     79|        let mut param_types = Vec::new();
 1204|    145|        for &param_id in &func.params {
                           ^66
 1205|     66|            param_types.push(self.mir_builder.get_locals().get(&param_id).unwrap().type_id);
 1206|     66|        }
 1207|     79|        self.mir_builder.add_type(MirType::Function {
 1208|     79|            return_type: ret_ty,
 1209|     79|            params: param_types,
 1210|     79|            is_variadic: func.is_variadic,
 1211|     79|        })
 1212|     79|    }
 1213|       |
 1214|  1.06k|    pub(crate) fn apply_conversions(&mut self, operand: Operand, node_ref: NodeRef, target_type_id: TypeId) -> Operand {
 1215|       |        // Look up conversions for this node in semantic_info
 1216|  1.06k|        if let Some(semantic_info) = &self.ast.semantic_info {
 1217|  1.06k|            let idx = node_ref.index();
 1218|  1.06k|            if idx < semantic_info.conversions.len() {
 1219|  1.06k|                let mut result = operand;
 1220|  1.06k|                for conv in &semantic_info.conversions[idx] {
                                  ^575
 1221|    575|                    result = self.emit_conversion(result, conv, target_type_id);
 1222|    575|                }
 1223|  1.06k|                return result;
 1224|      0|            }
 1225|      0|        }
 1226|      0|        operand
 1227|  1.06k|    }
 1228|       |
 1229|    248|    pub(crate) fn get_int_type(&mut self) -> TypeId {
 1230|    248|        self.lower_type(self.registry.type_int)
 1231|    248|    }
 1232|       |
 1233|      6|    fn emit_complex_conversion(&mut self, operand: Operand, from_ty: Option<TypeRef>, to_ty: TypeRef) -> Operand {
 1234|      6|        let to_mir_ty = self.lower_type(to_ty);
 1235|      6|        let from_mir_ty = self.get_operand_type(&operand);
 1236|       |
 1237|      6|        if to_ty.is_complex() {
 1238|      6|            let to_element_ty = match &self.registry.get(to_ty).kind {
 1239|      6|                TypeKind::Complex { base_type } => *base_type,
 1240|      0|                _ => unreachable!(),
 1241|       |            };
 1242|      6|            let to_element_mir_ty = self.lower_type(to_element_ty);
 1243|       |
 1244|      6|            if from_ty.is_some_and(|f| f.is_complex()) {
 1245|       |                // Complex to Complex
 1246|      0|                let (real, imag) = self.get_complex_components(operand, from_mir_ty);
 1247|       |
 1248|      0|                let res_real = self.emit_rvalue_to_operand(Rvalue::Cast(to_element_mir_ty, real), to_element_mir_ty);
 1249|      0|                let res_imag = self.emit_rvalue_to_operand(Rvalue::Cast(to_element_mir_ty, imag), to_element_mir_ty);
 1250|       |
 1251|      0|                self.emit_complex_struct(res_real, res_imag, to_mir_ty)
 1252|       |            } else {
 1253|       |                // Real to Complex
 1254|      6|                let res_real = self.emit_rvalue_to_operand(Rvalue::Cast(to_element_mir_ty, operand), to_element_mir_ty);
 1255|      6|                let zero_const = self.create_constant(to_element_mir_ty, ConstValueKind::Float(0.0));
 1256|      6|                let res_imag =
 1257|      6|                    self.emit_rvalue_to_operand(Rvalue::Use(Operand::Constant(zero_const)), to_element_mir_ty);
 1258|       |
 1259|      6|                self.emit_complex_struct(res_real, res_imag, to_mir_ty)
 1260|       |            }
 1261|       |        } else {
 1262|       |            // Complex to Real
 1263|      0|            let (real, _) = self.get_complex_components(operand, from_mir_ty);
 1264|      0|            self.emit_rvalue_to_operand(Rvalue::Cast(to_mir_ty, real), to_mir_ty)
 1265|       |        }
 1266|      6|    }
 1267|       |
 1268|    320|    pub(crate) fn create_temp_local(&mut self, type_id: TypeId) -> (LocalId, Place) {
 1269|    320|        let local_id = self.mir_builder.create_local(None, type_id, false);
 1270|    320|        let place = Place::Local(local_id);
 1271|    320|        (local_id, place)
 1272|    320|    }
 1273|       |
 1274|     15|    pub(crate) fn deref_operand(&self, operand: Operand) -> Place {
 1275|     15|        Place::Deref(Box::new(operand))
 1276|     15|    }
 1277|       |
 1278|     13|    pub(crate) fn deref_place(&self, place: Place) -> Place {
 1279|     13|        self.deref_operand(Operand::Copy(Box::new(place)))
 1280|     13|    }
 1281|       |
 1282|    296|    pub(crate) fn create_temp_local_with_assignment(&mut self, rvalue: Rvalue, type_id: TypeId) -> (LocalId, Place) {
 1283|    296|        let (local_id, place) = self.create_temp_local(type_id);
 1284|    296|        let assign_stmt = MirStmt::Assign(place.clone(), rvalue);
 1285|    296|        self.mir_builder.add_statement(assign_stmt);
 1286|    296|        (local_id, place)
 1287|    296|    }
 1288|       |
 1289|    296|    pub(crate) fn ensure_place(&mut self, operand: Operand, type_id: TypeId) -> Place {
 1290|    296|        if let Operand::Copy(place) = operand {
 1291|    296|            *place
 1292|       |        } else {
 1293|      0|            if self.mir_builder.get_type(type_id).is_void() {
 1294|       |                // This shouldn't normally happen if the rest of the lowerer handles void correctly.
 1295|      0|                panic!("ICE: Cannot ensure_place for void type");
 1296|      0|            }
 1297|      0|            let (_, temp_place) = self.create_temp_local_with_assignment(Rvalue::Use(operand), type_id);
 1298|      0|            temp_place
 1299|       |        }
 1300|    296|    }
 1301|       |
 1302|    276|    pub(crate) fn emit_rvalue_to_operand(&mut self, rvalue: Rvalue, type_id: TypeId) -> Operand {
 1303|    276|        if self.mir_builder.get_type(type_id).is_void() {
 1304|       |            // For void expressions, just return a dummy operand.
 1305|       |            // Any side effects in the Rvalue's operands were already emitted.
 1306|      0|            return self.create_dummy_operand();
 1307|    276|        }
 1308|    276|        let (_, place) = self.create_temp_local_with_assignment(rvalue, type_id);
 1309|    276|        Operand::Copy(Box::new(place))
 1310|    276|    }
 1311|       |
 1312|     45|    pub(crate) fn get_complex_components(&mut self, operand: Operand, ty: TypeId) -> (Operand, Operand) {
 1313|     45|        let place = self.ensure_place(operand, ty);
 1314|     45|        let real = Operand::Copy(Box::new(Place::StructField(Box::new(place.clone()), 0)));
 1315|     45|        let imag = Operand::Copy(Box::new(Place::StructField(Box::new(place), 1)));
 1316|     45|        (real, imag)
 1317|     45|    }
 1318|       |
 1319|     81|    pub(crate) fn emit_float_binop(
 1320|     81|        &mut self,
 1321|     81|        op: crate::mir::BinaryFloatOp,
 1322|     81|        lhs: Operand,
 1323|     81|        rhs: Operand,
 1324|     81|        ty: TypeId,
 1325|     81|    ) -> Operand {
 1326|     81|        self.emit_rvalue_to_operand(Rvalue::BinaryFloatOp(op, lhs, rhs), ty)
 1327|     81|    }
 1328|       |
 1329|      7|    pub(crate) fn emit_float_unop(&mut self, op: crate::mir::UnaryFloatOp, operand: Operand, ty: TypeId) -> Operand {
 1330|      7|        self.emit_rvalue_to_operand(Rvalue::UnaryFloatOp(op, operand), ty)
 1331|      7|    }
 1332|       |
 1333|     26|    pub(crate) fn emit_complex_struct(&mut self, real: Operand, imag: Operand, ty: TypeId) -> Operand {
 1334|     26|        self.emit_rvalue_to_operand(Rvalue::StructLiteral(vec![(0, real), (1, imag)]), ty)
 1335|     26|    }
 1336|       |
 1337|    218|    pub(crate) fn operand_to_const_id(&mut self, operand: &Operand) -> Option<ConstValueId> {
 1338|    218|        match operand {
 1339|    186|            Operand::Constant(id) => Some(*id),
 1340|     28|            Operand::Cast(ty, inner) => {
 1341|       |                // Recursively try to get constant from inner operand
 1342|     28|                if let Some(inner_const_id) = self.operand_to_const_id(inner) {
 1343|     28|                    let inner_const = self.mir_builder.get_constants().get(&inner_const_id).unwrap();
 1344|       |                    // Create a new constant with the target type but same kind
 1345|     28|                    Some(self.create_constant(*ty, inner_const.kind.clone()))
 1346|       |                } else {
 1347|      0|                    None
 1348|       |                }
 1349|       |            }
 1350|      1|            Operand::AddressOf(place) => {
 1351|      1|                if let Place::Global(global_id) = **place {
 1352|      1|                    let global_type = self.get_global_type(global_id);
 1353|      1|                    let ptr_ty = self.mir_builder.add_type(MirType::Pointer { pointee: global_type });
 1354|      1|                    Some(self.create_constant(ptr_ty, ConstValueKind::GlobalAddress(global_id)))
 1355|       |                } else {
 1356|      0|                    None
 1357|       |                }
 1358|       |            }
 1359|      3|            Operand::Copy(place) => {
 1360|      3|                if let Place::Global(global_id) = **place {
 1361|       |                    // If it is an array, using it in an expression decays to a pointer (GlobalAddress)
 1362|      3|                    let global_ty_id = self.get_global_type(global_id);
 1363|      3|                    let global_mir_ty = self.mir_builder.get_type(global_ty_id);
 1364|      3|                    if matches!(global_mir_ty, MirType::Array { .. }) {
 1365|      0|                        let ptr_ty = self.mir_builder.add_type(MirType::Pointer { pointee: global_ty_id });
 1366|      0|                        return Some(self.create_constant(ptr_ty, ConstValueKind::GlobalAddress(global_id)));
 1367|      3|                    }
 1368|       |
 1369|       |                    // If we are copying a global, and it has a constant initializer, return that value.
 1370|       |                    // This handles compound literals which are lowered to globals.
 1371|      3|                    let global = self.mir_builder.get_globals().get(&global_id).unwrap();
 1372|      3|                    global.initial_value
 1373|       |                } else {
 1374|      0|                    None
 1375|       |                }
 1376|       |            }
 1377|       |        }
 1378|    218|    }
 1379|       |
 1380|     10|    fn with_loop_targets<F>(&mut self, break_target: MirBlockId, continue_target: MirBlockId, f: F)
 1381|     10|    where
 1382|     10|        F: FnOnce(&mut Self),
 1383|       |    {
 1384|     10|        let old_break = self.break_target.replace(break_target);
 1385|     10|        let old_continue = self.continue_target.replace(continue_target);
 1386|       |
 1387|     10|        f(self);
 1388|       |
 1389|     10|        self.break_target = old_break;
 1390|     10|        self.continue_target = old_continue;
 1391|     10|    }
 1392|       |
 1393|  3.07k|    fn scan_for_labels(&mut self, node_ref: NodeRef) {
 1394|  3.07k|        let node_kind = *self.ast.get_kind(node_ref);
 1395|  3.07k|        if let NodeKind::Label(name, _, _) = node_kind
                                             ^8
 1396|      8|            && !self.label_map.contains_key(&name)
 1397|      8|        {
 1398|      8|            let block_id = self.mir_builder.create_block();
 1399|      8|            self.label_map.insert(name, block_id);
 1400|  3.06k|        }
 1401|  3.07k|        node_kind.visit_children(|child| self.scan_for_labels(child));
                                                       ^2.85k^2.85k          ^2.85k
 1402|  3.07k|    }
 1403|       |
 1404|      5|    fn visit_goto_stmt(&mut self, label_name: &NameId) {
 1405|      5|        if let Some(target_block) = self.label_map.get(label_name).copied() {
 1406|      5|            self.mir_builder.set_terminator(Terminator::Goto(target_block));
 1407|      5|        } else {
 1408|       |            // This should be caught by semantic analysis, but we panic as a safeguard
 1409|      0|            panic!("Goto to undefined label '{}'", label_name.as_str());
 1410|       |        }
 1411|      5|    }
 1412|       |
 1413|      8|    fn visit_label_stmt(&mut self, label_name: &NameId, statement: NodeRef) {
 1414|      8|        if let Some(label_block) = self.label_map.get(label_name).copied() {
 1415|       |            // Make sure the current block is terminated before switching
 1416|      8|            if !self.mir_builder.current_block_has_terminator() {
 1417|      4|                self.mir_builder.set_terminator(Terminator::Goto(label_block));
 1418|      4|            }
 1419|       |
 1420|      8|            self.mir_builder.set_current_block(label_block);
 1421|      8|            self.current_block = Some(label_block);
 1422|       |
 1423|       |            // Now, lower the statement that follows the label
 1424|      8|            self.visit_node(statement);
 1425|       |        } else {
 1426|      0|            panic!("Label '{}' was not pre-scanned", label_name.as_str());
 1427|       |        }
 1428|      8|    }
 1429|       |
 1430|    248|    fn define_or_declare_function(
 1431|    248|        &mut self,
 1432|    248|        name: NameId,
 1433|    248|        params: Vec<TypeId>,
 1434|    248|        ret: TypeId,
 1435|    248|        variadic: bool,
 1436|    248|        is_def: bool,
 1437|    248|    ) {
 1438|    248|        if is_def {
 1439|    215|            self.mir_builder.define_function(name, params, ret, variadic);
 1440|    215|        } else {
 1441|     33|            self.mir_builder.declare_function(name, params, ret, variadic);
 1442|     33|        }
 1443|    248|    }
 1444|       |}

/app/src/codegen/mir_gen_expression.rs:
    1|       |use crate::ast::nodes::AtomicOp;
    2|       |use crate::ast::{BinaryOp, NodeKind, NodeRef, UnaryOp};
    3|       |use crate::codegen::mir_gen::MirGen;
    4|       |use crate::codegen::mir_gen_ops;
    5|       |use crate::mir::{
    6|       |    AtomicMemOrder, BinaryIntOp, CallTarget, ConstValue, ConstValueKind, MirStmt, Operand, Place, Rvalue, Terminator,
    7|       |    TypeId,
    8|       |};
    9|       |use crate::semantic::const_eval::eval_const_expr;
   10|       |use crate::semantic::{QualType, SymbolKind, SymbolRef, TypeKind, ValueCategory};
   11|       |use crate::{ast, semantic};
   12|       |
   13|       |impl<'a> MirGen<'a> {
   14|    251|    fn emit_expression_as_place(&mut self, expr_ref: NodeRef) -> Place {
   15|    251|        let op = self.emit_expression(expr_ref, true);
   16|    251|        let ty = self.ast.get_resolved_type(expr_ref).unwrap();
   17|    251|        let mir_ty = self.lower_qual_type(ty);
   18|    251|        self.ensure_place(op, mir_ty)
   19|    251|    }
   20|       |
   21|  1.73k|    pub(crate) fn emit_expression(&mut self, expr_ref: NodeRef, need_value: bool) -> Operand {
   22|  1.73k|        let ty = self.ast.get_resolved_type(expr_ref).unwrap_or_else(|| {
                                                                                      ^0
   23|      0|            let node_kind = self.ast.get_kind(expr_ref);
   24|      0|            let node_span = self.ast.get_span(expr_ref);
   25|      0|            panic!("Type not resolved for node {:?} at {:?}", node_kind, node_span);
   26|       |        });
   27|  1.73k|        let node_kind = *self.ast.get_kind(expr_ref);
   28|       |
   29|  1.73k|        let mir_ty = self.lower_qual_type(ty);
   30|       |
   31|  1.73k|        if let Some(const_op) = self.try_constant_fold(expr_ref, &node_kind, ty) {
                                  ^30
   32|     30|            return const_op;
   33|  1.70k|        }
   34|       |
   35|  1.70k|        match &node_kind {
   36|    640|            NodeKind::Literal(_) => self.emit_literal(&node_kind, ty).expect("Failed to lower literal"),
   37|    478|            NodeKind::Ident(_, symbol_ref) => self.emit_ident(*symbol_ref),
   38|     46|            NodeKind::UnaryOp(op, operand_ref) => self.emit_unary_op_expr(op, *operand_ref, mir_ty),
   39|      9|            NodeKind::PostIncrement(operand_ref) => self.emit_inc_dec_expression(*operand_ref, true, true, need_value),
   40|      4|            NodeKind::PostDecrement(operand_ref) => self.emit_inc_dec_expression(*operand_ref, false, true, need_value),
   41|    113|            NodeKind::BinaryOp(op, left_ref, right_ref) => self.emit_binary_op_expr(op, *left_ref, *right_ref, mir_ty),
   42|     91|            NodeKind::Assignment(op, left_ref, right_ref) => {
   43|     91|                self.emit_assignment_expr(expr_ref, op, *left_ref, *right_ref, mir_ty)
   44|       |            }
   45|     76|            NodeKind::FunctionCall(call_expr) => {
   46|       |                // Check for builtin float constant functions
   47|     76|                if let Some(builtin_op) = self.try_emit_builtin_float_const(call_expr, mir_ty) {
                                          ^0
   48|      0|                    return builtin_op;
   49|     76|                }
   50|       |
   51|     76|                let is_void = self.mir_builder.get_type(mir_ty).is_void();
   52|     76|                let temp_place = if need_value && !is_void {
                                                                ^8
   53|      8|                    let (_, temp_place) = self.create_temp_local(mir_ty);
   54|      8|                    Some(temp_place)
   55|       |                } else {
   56|     68|                    None
   57|       |                };
   58|       |
   59|     76|                self.emit_function_call(call_expr, temp_place.clone());
   60|       |
   61|     76|                if need_value {
   62|      8|                    if is_void {
   63|      0|                        self.create_dummy_operand()
   64|       |                    } else {
   65|      8|                        Operand::Copy(Box::new(temp_place.unwrap()))
   66|       |                    }
   67|       |                } else {
   68|     68|                    self.create_dummy_operand()
   69|       |                }
   70|       |            }
   71|    109|            NodeKind::MemberAccess(obj_ref, field_name, is_arrow) => {
   72|    109|                self.emit_member_access(*obj_ref, field_name, *is_arrow)
   73|       |            }
   74|     38|            NodeKind::IndexAccess(arr_ref, idx_ref) => self.emit_index_access(*arr_ref, *idx_ref),
   75|      5|            NodeKind::TernaryOp(cond, then, else_expr) => self.emit_ternary_op(*cond, *then, *else_expr, mir_ty),
   76|      4|            NodeKind::SizeOfExpr(expr) => {
   77|      4|                let ty = self
   78|      4|                    .ast
   79|      4|                    .get_resolved_type(*expr)
   80|      4|                    .expect("SizeOf operand type missing")
   81|      4|                    .ty();
   82|      4|                self.emit_type_query(ty, true)
   83|       |            }
   84|      2|            NodeKind::SizeOfType(ty) => self.emit_type_query(ty.ty(), true),
   85|      1|            NodeKind::AlignOf(ty) => self.emit_type_query(ty.ty(), false),
   86|       |            NodeKind::BuiltinOffsetof(..) => {
   87|     10|                let val = eval_const_expr(&self.const_ctx(), expr_ref).expect("offsetof should be constant");
   88|     10|                self.create_int_operand(val)
   89|       |            }
   90|     21|            NodeKind::GenericSelection(gs) => self.emit_generic_selection(gs, need_value, expr_ref),
   91|      2|            NodeKind::GnuStatementExpression(stmt, result_expr) => {
   92|      2|                self.emit_gnu_stmt_expr(*stmt, *result_expr, need_value)
   93|       |            }
   94|     20|            NodeKind::Cast(_ty, operand_ref) => self.emit_cast(*operand_ref, mir_ty),
   95|      5|            NodeKind::CompoundLiteral(ty, init_ref) => self.emit_compound_literal(*ty, *init_ref),
   96|      7|            NodeKind::BuiltinVaArg(ty, expr) => self.emit_builtin_va_arg(*ty, *expr),
   97|      3|            NodeKind::BuiltinExpect(exp, c) => {
   98|      3|                let _ = self.emit_expression(*c, true); // lower 'c' for side effects or just to process it
   99|      3|                self.emit_expression(*exp, need_value)
  100|       |            }
  101|     10|            NodeKind::AtomicOp(op, args_start, args_len) => self.emit_atomic_op(*op, *args_start, *args_len, mir_ty),
  102|       |            NodeKind::BuiltinVaStart(..) | NodeKind::BuiltinVaEnd(..) | NodeKind::BuiltinVaCopy(..) => {
  103|      6|                self.emit_builtin_void(&node_kind)
  104|       |            }
  105|       |            NodeKind::InitializerList(_) | NodeKind::InitializerItem(_) => {
  106|      0|                panic!("InitializerList or InitializerItem not implemented");
  107|       |            }
  108|      0|            _ => unreachable!(),
  109|       |        }
  110|  1.73k|    }
  111|       |
  112|  1.73k|    fn try_constant_fold(&mut self, expr_ref: NodeRef, node_kind: &NodeKind, ty: QualType) -> Option<Operand> {
  113|       |        // Attempt constant folding for arithmetic/logical operations that are not simple literals
  114|  1.53k|        if matches!(
  115|  1.73k|            node_kind,
  116|       |            NodeKind::BinaryOp(..) | NodeKind::UnaryOp(..) | NodeKind::TernaryOp(..)
  117|    194|        ) && let Some(val) = eval_const_expr(&self.const_ctx(), expr_ref)
                                    ^30
  118|       |        {
  119|     30|            let ty_id = self.lower_qual_type(ty);
  120|     30|            return Some(Operand::Constant(self.create_constant(ty_id, ConstValueKind::Int(val))));
  121|  1.70k|        }
  122|  1.70k|        None
  123|  1.73k|    }
  124|       |
  125|      2|    fn emit_gnu_stmt_expr(&mut self, stmt: NodeRef, result_expr: NodeRef, need_value: bool) -> Operand {
  126|      2|        let stmt_kind = self.ast.get_kind(stmt);
  127|      2|        if let NodeKind::CompoundStatement(cs) = stmt_kind {
  128|      2|            let old_scope = self.current_scope_id;
  129|      2|            self.current_scope_id = cs.scope_id;
  130|       |
  131|      5|            for stmt_ref in cs.stmt_start.range(cs.stmt_len) {
                                          ^2            ^2    ^2
  132|      5|                let is_last_stmt_expr = if let NodeKind::ExpressionStatement(Some(e)) = self.ast.get_kind(stmt_ref) {
                                                                                                ^1
  133|      1|                    *e == result_expr
  134|       |                } else {
  135|      4|                    false
  136|       |                };
  137|       |
  138|      5|                if is_last_stmt_expr {
  139|      1|                    continue;
  140|      4|                }
  141|       |
  142|      4|                let node_kind = self.ast.get_kind(stmt_ref);
  143|      4|                if self.mir_builder.current_block_has_terminator() {
  144|      0|                    if let NodeKind::Label(..) = node_kind {
  145|      0|                        // OK
  146|      0|                    } else {
  147|      0|                        continue;
  148|       |                    }
  149|      4|                }
  150|      4|                self.visit_node(stmt_ref);
  151|       |            }
  152|       |
  153|      2|            let op = if let NodeKind::Dummy = self.ast.get_kind(result_expr) {
  154|      1|                self.create_dummy_operand()
  155|       |            } else {
  156|      1|                self.emit_expression(result_expr, need_value)
  157|       |            };
  158|       |
  159|      2|            self.current_scope_id = old_scope;
  160|      2|            op
  161|       |        } else {
  162|      0|            panic!("GnuStatementExpression stmt is not CompoundStatement");
  163|       |        }
  164|      2|    }
  165|       |
  166|      5|    fn emit_ternary_op(&mut self, cond: NodeRef, then_expr: NodeRef, else_expr: NodeRef, mir_ty: TypeId) -> Operand {
  167|      5|        let is_void = matches!(self.mir_builder.get_type(mir_ty), crate::mir::MirType::Void);
                                    ^4
  168|       |
  169|      5|        let cond_op = self.emit_expression(cond, true);
  170|       |
  171|      5|        let then_block = self.mir_builder.create_block();
  172|      5|        let else_block = self.mir_builder.create_block();
  173|      5|        let exit_block = self.mir_builder.create_block();
  174|       |
  175|      5|        self.mir_builder
  176|      5|            .set_terminator(Terminator::If(cond_op, then_block, else_block));
  177|       |
  178|       |        // Result local
  179|      5|        let result_local = if !is_void {
  180|      4|            Some(self.mir_builder.create_local(None, mir_ty, false))
  181|       |        } else {
  182|      1|            None
  183|       |        };
  184|       |
  185|     10|        for (target_block, expr_ref) in [(then_block, then_expr), (else_block, else_expr)] {
                                                       ^5                       ^5
  186|     10|            self.mir_builder.set_current_block(target_block);
  187|     10|            let val = self.emit_expression(expr_ref, !is_void);
  188|     10|            if let Some(local) = result_local {
                                      ^8
  189|      8|                let val_conv = self.apply_conversions(val, expr_ref, mir_ty);
  190|      8|                self.emit_assignment(Place::Local(local), val_conv);
  191|      8|            }
                          ^2
  192|     10|            self.mir_builder.set_terminator(Terminator::Goto(exit_block));
  193|       |        }
  194|       |
  195|      5|        self.mir_builder.set_current_block(exit_block);
  196|       |
  197|      5|        if let Some(local) = result_local {
                                  ^4
  198|      4|            Operand::Copy(Box::new(Place::Local(local)))
  199|       |        } else {
  200|      1|            self.create_dummy_operand()
  201|       |        }
  202|      5|    }
  203|       |
  204|      7|    fn emit_type_query(&mut self, ty: semantic::TypeRef, is_size: bool) -> Operand {
  205|      7|        let layout = self.registry.get_layout(ty);
  206|      7|        let val = if is_size { layout.size } else { layout.alignment };
                                             ^6                   ^1
  207|      7|        self.create_int_operand(val as i64)
  208|      7|    }
  209|       |
  210|     21|    fn emit_generic_selection(
  211|     21|        &mut self,
  212|     21|        _gs: &ast::nodes::GenericSelectionData,
  213|     21|        need_value: bool,
  214|     21|        node_ref: NodeRef,
  215|     21|    ) -> Operand {
  216|     21|        let expr_to_lower = *self
  217|     21|            .ast
  218|     21|            .semantic_info
  219|     21|            .as_ref()
  220|     21|            .unwrap()
  221|     21|            .generic_selections
  222|     21|            .get(&node_ref.index())
  223|     21|            .expect("Generic selection failed (should be caught by Analyzer)");
  224|     21|        self.emit_expression(expr_to_lower, need_value)
  225|     21|    }
  226|       |
  227|     20|    fn emit_cast(&mut self, operand_ref: NodeRef, mir_ty: TypeId) -> Operand {
  228|     20|        let is_void = self.mir_builder.get_type(mir_ty).is_void();
  229|     20|        if is_void {
  230|      1|            self.emit_expression(operand_ref, false);
  231|      1|            return self.create_dummy_operand();
  232|     19|        }
  233|     19|        let operand = self.emit_expression(operand_ref, true);
  234|     19|        if self.get_operand_type(&operand) == mir_ty {
  235|     11|            return operand;
  236|      8|        }
  237|      8|        Operand::Cast(mir_ty, Box::new(operand))
  238|     20|    }
  239|       |
  240|    640|    fn emit_literal(&mut self, node_kind: &NodeKind, ty: QualType) -> Option<Operand> {
  241|    640|        let mir_ty = self.lower_qual_type(ty);
  242|    640|        match node_kind {
  243|    640|            NodeKind::Literal(literal) => match literal {
  244|    549|                crate::ast::literal::Literal::Int { val, .. } => Some(Operand::Constant(
  245|    549|                    self.create_constant(mir_ty, ConstValueKind::Int(*val)),
  246|    549|                )),
  247|     24|                crate::ast::literal::Literal::Float { val, .. } => Some(Operand::Constant(
  248|     24|                    self.create_constant(mir_ty, ConstValueKind::Float(*val)),
  249|     24|                )),
  250|     11|                crate::ast::literal::Literal::Char(val) => Some(Operand::Constant(
  251|     11|                    self.create_constant(mir_ty, ConstValueKind::Int(*val as i64)),
  252|     11|                )),
  253|     56|                crate::ast::literal::Literal::String(val) => Some(self.emit_literal_string(val, ty)),
  254|       |            },
  255|      0|            _ => None,
  256|       |        }
  257|    640|    }
  258|       |
  259|     46|    fn emit_unary_op_expr(&mut self, op: &UnaryOp, operand_ref: NodeRef, mir_ty: TypeId) -> Operand {
  260|     46|        let ty = self.ast.get_resolved_type(operand_ref).unwrap();
  261|     46|        if ty.is_complex() && !matches!(op, UnaryOp::AddrOf | UnaryOp::Deref) {
                                             ^7       ^7
  262|      7|            return self.emit_complex_unary_op(op, operand_ref, mir_ty);
  263|     39|        }
  264|       |
  265|     39|        match op {
  266|       |            UnaryOp::PreIncrement | UnaryOp::PreDecrement => {
  267|      2|                let is_inc = matches!(op, UnaryOp::PreIncrement);
                                           ^1
  268|      2|                self.emit_inc_dec_expression(operand_ref, is_inc, false, true)
  269|       |            }
  270|     18|            UnaryOp::AddrOf => self.emit_unary_addrof(operand_ref),
  271|      2|            UnaryOp::Deref => self.emit_unary_deref(operand_ref),
  272|       |            UnaryOp::Real => {
  273|      1|                let operand = self.emit_expression(operand_ref, true);
  274|      1|                self.apply_conversions(operand, operand_ref, mir_ty)
  275|       |            }
  276|       |            UnaryOp::Imag => {
  277|      1|                let _ = self.emit_expression(operand_ref, false);
  278|      1|                let kind = if self.mir_builder.get_type(mir_ty).is_float() {
  279|      1|                    ConstValueKind::Float(0.0)
  280|       |                } else {
  281|      0|                    ConstValueKind::Int(0)
  282|       |                };
  283|      1|                Operand::Constant(self.create_constant(mir_ty, kind))
  284|       |            }
  285|       |            _ => {
  286|     15|                let operand = self.emit_expression(operand_ref, true);
  287|     15|                let operand_converted = self.apply_conversions(operand, operand_ref, mir_ty);
  288|     15|                let operand_ty = self.get_operand_type(&operand_converted);
  289|     15|                let mir_type_info = self.mir_builder.get_type(operand_ty);
  290|       |
  291|     15|                let rval = mir_gen_ops::emit_unary_rvalue(op, operand_converted, mir_type_info.is_float());
  292|     15|                self.emit_rvalue_to_operand(rval, mir_ty)
  293|       |            }
  294|       |        }
  295|     46|    }
  296|       |
  297|     18|    fn emit_unary_addrof(&mut self, operand_ref: NodeRef) -> Operand {
  298|     18|        let operand = self.emit_expression(operand_ref, true);
  299|     18|        if let Operand::Copy(place) = operand {
                                           ^17
  300|     17|            Operand::AddressOf(place)
  301|      1|        } else if let Operand::Constant(const_id) = operand
  302|      1|            && self.ast.get_value_category(operand_ref) == Some(ValueCategory::LValue)
  303|      0|            && matches!(
  304|      1|                self.mir_builder.get_constants().get(&const_id),
  305|       |                Some(ConstValue {
  306|       |                    kind: ConstValueKind::FunctionAddress(_),
  307|       |                    ..
  308|       |                })
  309|       |            )
  310|       |        {
  311|      1|            Operand::Constant(const_id)
  312|       |        } else {
  313|      0|            panic!("Cannot take address of a non-lvalue");
  314|       |        }
  315|     18|    }
  316|       |
  317|      2|    fn emit_unary_deref(&mut self, operand_ref: NodeRef) -> Operand {
  318|      2|        let operand = self.emit_expression(operand_ref, true);
  319|      2|        let operand_ty = self.ast.get_resolved_type(operand_ref).unwrap();
  320|      2|        let target_mir_ty = self.lower_qual_type(operand_ty);
  321|      2|        let operand_converted = self.apply_conversions(operand, operand_ref, target_mir_ty);
  322|       |
  323|      2|        let place = self.deref_operand(operand_converted);
  324|      2|        Operand::Copy(Box::new(place))
  325|      2|    }
  326|       |
  327|    478|    fn emit_ident(&mut self, resolved_ref: SymbolRef) -> Operand {
  328|    478|        let entry = self.symbol_table.get_symbol(resolved_ref);
  329|       |
  330|    478|        match &entry.kind {
  331|    397|            SymbolKind::Variable { is_global, storage, .. } => {
  332|    397|                let is_static_local = *storage == Some(crate::ast::StorageClass::Static);
  333|    397|                if *is_global || is_static_local {
                                               ^352
  334|       |                    // Lazy lowering for globals/statics (e.g. __func__) that might not be lowered yet
  335|     46|                    if !self.global_map.contains_key(&resolved_ref) {
  336|      1|                        let ty_info = entry.type_info;
  337|      1|                        let mir_type_id = self.lower_qual_type(ty_info);
  338|      1|                        self.visit_variable(resolved_ref, mir_type_id);
  339|     45|                    }
  340|       |
  341|     46|                    let global_id = match self.global_map.get(&resolved_ref) {
  342|     46|                        Some(id) => id,
  343|       |                        None => {
  344|      0|                            panic!(
  345|      0|                                "Global variable '{}' not found in MIR map even after lazy lowering attempt. Visited? {:?}",
  346|       |                                entry.name,
  347|      0|                                self.global_map.keys()
  348|       |                            );
  349|       |                        }
  350|       |                    };
  351|     46|                    Operand::Copy(Box::new(Place::Global(*global_id)))
  352|       |                } else {
  353|    351|                    let local_id = self.local_map.get(&resolved_ref).unwrap();
  354|    351|                    Operand::Copy(Box::new(Place::Local(*local_id)))
  355|       |                }
  356|       |            }
  357|       |            SymbolKind::Function { .. } => {
  358|     79|                let func_id = self
  359|     79|                    .mir_builder
  360|     79|                    .get_functions()
  361|     79|                    .iter()
  362|    214|                    .find(|(_, f)| f.name == entry.name)
                                   ^79
  363|     79|                    .map(|(id, _)| *id)
  364|     79|                    .unwrap();
  365|     79|                let func_type = self.get_function_type(func_id);
  366|     79|                Operand::Constant(self.create_constant(func_type, ConstValueKind::FunctionAddress(func_id)))
  367|       |            }
  368|      2|            SymbolKind::EnumConstant { value } => self.create_int_operand(*value),
  369|      0|            _ => panic!("Unexpected symbol kind"),
  370|       |        }
  371|    478|    }
  372|       |
  373|     83|    fn unify_binary_operands(
  374|     83|        &mut self,
  375|     83|        mut lhs: Operand,
  376|     83|        mut rhs: Operand,
  377|     83|        lhs_mir_ty: TypeId,
  378|     83|        rhs_mir_ty: TypeId,
  379|     83|    ) -> (Operand, Operand) {
  380|     83|        if lhs_mir_ty != rhs_mir_ty {
  381|      0|            let lhs_mir = self.mir_builder.get_type(lhs_mir_ty);
  382|      0|            let rhs_mir = self.mir_builder.get_type(rhs_mir_ty);
  383|       |
  384|      0|            if lhs_mir.is_int() && rhs_mir.is_int() {
  385|      0|                let w1 = lhs_mir.width();
  386|      0|                let w2 = rhs_mir.width();
  387|      0|                if w1 > w2 {
  388|      0|                    rhs = Operand::Cast(lhs_mir_ty, Box::new(rhs));
  389|      0|                } else if w2 > w1 {
  390|      0|                    lhs = Operand::Cast(rhs_mir_ty, Box::new(lhs));
  391|      0|                }
  392|      0|            } else if lhs_mir.is_pointer() && rhs_mir.is_int() {
  393|      0|                rhs = Operand::Cast(lhs_mir_ty, Box::new(rhs));
  394|      0|            } else if lhs_mir.is_int() && rhs_mir.is_pointer() {
  395|      0|                lhs = Operand::Cast(rhs_mir_ty, Box::new(lhs));
  396|      0|            } else if lhs_mir.is_float() && rhs_mir.is_float() {
  397|      0|                let w1 = lhs_mir.width();
  398|      0|                let w2 = rhs_mir.width();
  399|      0|                if w1 > w2 {
  400|      0|                    rhs = Operand::Cast(lhs_mir_ty, Box::new(rhs));
  401|      0|                } else if w2 > w1 {
  402|      0|                    lhs = Operand::Cast(rhs_mir_ty, Box::new(lhs));
  403|      0|                }
  404|      0|            } else if lhs_mir.is_float() && rhs_mir.is_int() {
  405|      0|                rhs = Operand::Cast(lhs_mir_ty, Box::new(rhs));
  406|      0|            } else if lhs_mir.is_int() && rhs_mir.is_float() {
  407|      0|                lhs = Operand::Cast(rhs_mir_ty, Box::new(lhs));
  408|      0|            }
  409|     83|        }
  410|     83|        (lhs, rhs)
  411|     83|    }
  412|       |
  413|    113|    fn emit_binary_op_expr(&mut self, op: &BinaryOp, left_ref: NodeRef, right_ref: NodeRef, mir_ty: TypeId) -> Operand {
  414|    113|        debug_assert!(
  415|    113|            !op.is_assignment(),
  416|      0|            "emit_binary_op_expr called with assignment operator: {:?}",
  417|       |            op
  418|       |        );
  419|    113|        if matches!(op, BinaryOp::LogicAnd | BinaryOp::LogicOr) {
                         ^99
  420|     14|            return self.emit_logical_op(op, left_ref, right_ref, mir_ty);
  421|     99|        }
  422|       |
  423|     99|        if matches!(op, BinaryOp::Comma) {
                         ^96
  424|      3|            self.emit_expression(left_ref, false);
  425|      3|            let rhs = self.emit_expression(right_ref, true);
  426|       |            // Apply conversions for RHS to match result type (comma result type is RHS type)
  427|      3|            let rhs_converted = self.apply_conversions(rhs, right_ref, mir_ty);
  428|      3|            return self.ensure_explicit_cast(rhs_converted, right_ref);
  429|     96|        }
  430|       |
  431|     96|        let lhs = self.emit_expression(left_ref, true);
  432|     96|        let rhs = self.emit_expression(right_ref, true);
  433|       |
  434|     96|        let (rval, _op_ty) = self.emit_binary_arithmetic_logic(op, lhs, rhs, left_ref, right_ref, mir_ty);
  435|     96|        self.emit_rvalue_to_operand(rval, mir_ty)
  436|    113|    }
  437|       |
  438|    107|    fn emit_binary_arithmetic_logic(
  439|    107|        &mut self,
  440|    107|        op: &BinaryOp,
  441|    107|        lhs: Operand,
  442|    107|        rhs: Operand,
  443|    107|        left_ref: NodeRef,
  444|    107|        right_ref: NodeRef,
  445|    107|        context_ty: TypeId,
  446|    107|    ) -> (Rvalue, TypeId) {
  447|       |        // Handle pointer arithmetic
  448|    107|        if let Some(rval) = self.emit_pointer_arithmetic(op, lhs.clone(), rhs.clone(), left_ref, right_ref) {
                                  ^5
  449|      5|            let res_ty = match &rval {
  450|      4|                Rvalue::PtrAdd(base, _) | Rvalue::PtrSub(base, _) => self.get_operand_type(base),
                                             ^2                        ^2
  451|      1|                Rvalue::PtrDiff(..) => self.lower_type(self.registry.type_long),
  452|      0|                _ => unreachable!(),
  453|       |            };
  454|      5|            return (rval, res_ty);
  455|    102|        }
  456|       |
  457|       |        // Apply implicit conversions from semantic info first to match AST
  458|    102|        let lhs_converted = self.apply_conversions(lhs, left_ref, context_ty);
  459|    102|        let rhs_converted = self.apply_conversions(rhs, right_ref, context_ty);
  460|       |
  461|    102|        let lhs_mir_ty = self.get_operand_type(&lhs_converted);
  462|    102|        let rhs_mir_ty = self.get_operand_type(&rhs_converted);
  463|       |
  464|    102|        let lhs_is_complex = self.mir_builder.get_type(lhs_mir_ty).is_aggregate()
  465|     19|            && self.ast.get_resolved_type(left_ref).is_some_and(|t| t.is_complex());
  466|    102|        let rhs_is_complex = self.mir_builder.get_type(rhs_mir_ty).is_aggregate()
  467|     19|            && self.ast.get_resolved_type(right_ref).is_some_and(|t| t.is_complex());
  468|       |
  469|    102|        if lhs_is_complex || rhs_is_complex {
                                           ^84
  470|     19|            let op = self.emit_complex_binary_op(op, lhs_converted, rhs_converted, context_ty);
  471|     19|            return (Rvalue::Use(op), context_ty);
  472|     83|        }
  473|       |
  474|       |        // Ensure both operands have the same type for MIR operations.
  475|     83|        let (lhs_unified, rhs_unified) =
  476|     83|            self.unify_binary_operands(lhs_converted, rhs_converted, lhs_mir_ty, rhs_mir_ty);
  477|       |
  478|     83|        let lhs_final = self.ensure_explicit_cast(lhs_unified, left_ref);
  479|     83|        let rhs_final = self.ensure_explicit_cast(rhs_unified, right_ref);
  480|       |
  481|     83|        let common_ty = self.get_operand_type(&lhs_final);
  482|       |
  483|     83|        let common_mir_type = self.mir_builder.get_type(common_ty);
  484|     83|        let rval = mir_gen_ops::emit_binary_rvalue(op, lhs_final, rhs_final, common_mir_type.is_float());
  485|       |
  486|     83|        let result_ty = match op {
  487|       |            BinaryOp::Equal
  488|       |            | BinaryOp::NotEqual
  489|       |            | BinaryOp::Less
  490|       |            | BinaryOp::LessEqual
  491|       |            | BinaryOp::Greater
  492|     55|            | BinaryOp::GreaterEqual => self.get_int_type(),
  493|     28|            _ => common_ty,
  494|       |        };
  495|       |
  496|     83|        (rval, result_ty)
  497|    107|    }
  498|       |
  499|    169|    fn ensure_explicit_cast(&mut self, operand: Operand, node_ref: NodeRef) -> Operand {
  500|    169|        match operand {
  501|       |            Operand::Constant(_) => {
  502|     56|                if let Some(ty) = self.ast.get_resolved_type(node_ref) {
  503|     56|                    let mir_type_id = self.lower_qual_type(ty);
  504|     56|                    Operand::Cast(mir_type_id, Box::new(operand))
  505|       |                } else {
  506|      0|                    operand
  507|       |                }
  508|       |            }
  509|    113|            _ => operand,
  510|       |        }
  511|    169|    }
  512|       |
  513|     14|    fn emit_bool_normalization(&mut self, value_op: Operand, result_place: Place, merge_block: crate::mir::MirBlockId) {
  514|     14|        let true_block = self.mir_builder.create_block();
  515|     14|        let false_block = self.mir_builder.create_block();
  516|       |
  517|     14|        self.mir_builder
  518|     14|            .set_terminator(Terminator::If(value_op, true_block, false_block));
  519|       |
  520|     14|        self.mir_builder.set_current_block(true_block);
  521|     14|        let one_op = self.create_int_operand(1);
  522|     14|        self.mir_builder
  523|     14|            .add_statement(MirStmt::Assign(result_place.clone(), Rvalue::Use(one_op)));
  524|     14|        self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  525|       |
  526|     14|        self.mir_builder.set_current_block(false_block);
  527|     14|        let zero_op = self.create_int_operand(0);
  528|     14|        self.mir_builder
  529|     14|            .add_statement(MirStmt::Assign(result_place.clone(), Rvalue::Use(zero_op)));
  530|     14|        self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  531|     14|    }
  532|       |
  533|     14|    fn emit_logical_op(&mut self, op: &BinaryOp, left_ref: NodeRef, right_ref: NodeRef, mir_ty: TypeId) -> Operand {
  534|       |        // Short-circuiting logic for && and ||
  535|     14|        let (_res_local, res_place) = self.create_temp_local(mir_ty);
  536|       |
  537|     14|        let eval_rhs_block = self.mir_builder.create_block();
  538|     14|        let merge_block = self.mir_builder.create_block();
  539|     14|        let short_circuit_block = self.mir_builder.create_block();
  540|       |
  541|       |        // 1. Evaluate LHS
  542|     14|        let lhs_op = self.lower_condition(left_ref);
  543|       |
  544|       |        // Pre-create constants to avoid double borrow
  545|     14|        let zero_op = self.create_int_operand(0);
  546|     14|        let one_op = self.create_int_operand(1);
  547|       |
  548|     14|        let (short_circuit_val, true_target, false_target) = match op {
  549|      7|            BinaryOp::LogicAnd => (zero_op.clone(), eval_rhs_block, short_circuit_block),
  550|      7|            BinaryOp::LogicOr => (one_op.clone(), short_circuit_block, eval_rhs_block),
  551|      0|            _ => unreachable!(),
  552|       |        };
  553|       |
  554|       |        // if lhs { goto true_target } else { goto false_target }
  555|     14|        self.mir_builder
  556|     14|            .set_terminator(Terminator::If(lhs_op, true_target, false_target));
  557|       |
  558|       |        // Short circuit case
  559|     14|        self.mir_builder.set_current_block(short_circuit_block);
  560|     14|        self.mir_builder
  561|     14|            .add_statement(MirStmt::Assign(res_place.clone(), Rvalue::Use(short_circuit_val)));
  562|     14|        self.mir_builder.set_terminator(Terminator::Goto(merge_block));
  563|       |
  564|       |        // 2. Evaluate RHS
  565|     14|        self.mir_builder.set_current_block(eval_rhs_block);
  566|     14|        let rhs_val = self.lower_condition(right_ref);
  567|       |
  568|     14|        self.emit_bool_normalization(rhs_val, res_place.clone(), merge_block);
  569|       |
  570|       |        // Merge
  571|     14|        self.mir_builder.set_current_block(merge_block);
  572|     14|        self.current_block = Some(merge_block);
  573|       |
  574|     14|        Operand::Copy(Box::new(res_place))
  575|     14|    }
  576|       |
  577|      9|    fn unwrap_cast_if_int(&mut self, op: Operand) -> Operand {
  578|      9|        match op {
  579|      6|            Operand::Cast(ty, inner) => {
  580|      6|                let inner_ty = self.get_operand_type(&inner);
  581|      6|                if self.mir_builder.get_type(inner_ty).is_int() {
  582|      4|                    return *inner;
  583|      2|                }
  584|       |
  585|      2|                let unwrapped = self.unwrap_cast_if_int(*inner.clone());
  586|      2|                let unwrapped_ty = self.get_operand_type(&unwrapped);
  587|      2|                if self.mir_builder.get_type(unwrapped_ty).is_int() {
  588|      0|                    return unwrapped;
  589|      2|                }
  590|       |
  591|      2|                Operand::Cast(ty, inner)
  592|       |            }
  593|      0|            Operand::Constant(const_id) => {
  594|      0|                let val_opt = {
  595|      0|                    let const_val = self.mir_builder.get_constants().get(&const_id).unwrap();
  596|      0|                    if let ConstValueKind::Int(val) = const_val.kind {
  597|      0|                        Some(val)
  598|       |                    } else {
  599|      0|                        None
  600|       |                    }
  601|       |                };
  602|       |
  603|      0|                if let Some(val) = val_opt {
  604|      0|                    return self.create_int_operand(val);
  605|      0|                }
  606|      0|                Operand::Constant(const_id)
  607|       |            }
  608|      3|            _ => op,
  609|       |        }
  610|      9|    }
  611|       |
  612|    107|    fn emit_pointer_arithmetic(
  613|    107|        &mut self,
  614|    107|        op: &BinaryOp,
  615|    107|        lhs: Operand,
  616|    107|        rhs: Operand,
  617|    107|        left_ref: NodeRef,
  618|    107|        right_ref: NodeRef,
  619|    107|    ) -> Option<Rvalue> {
  620|       |        // Lower types and apply conversions locally to check for pointer arithmetic
  621|       |        // We use the operand's own type as the target for conversion to avoid forcing
  622|       |        // implicit casts to the result type (which causes issues for Ptr + Int -> Ptr)
  623|    107|        let lhs_ty = self.ast.get_resolved_type(left_ref).unwrap();
  624|    107|        let rhs_ty = self.ast.get_resolved_type(right_ref).unwrap();
  625|       |
  626|    107|        let lhs_mir_target = self.lower_qual_type(lhs_ty);
  627|    107|        let rhs_mir_target = self.lower_qual_type(rhs_ty);
  628|       |
  629|    107|        let lhs_converted = self.apply_conversions(lhs, left_ref, lhs_mir_target);
  630|    107|        let rhs_converted = self.apply_conversions(rhs, right_ref, rhs_mir_target);
  631|       |
  632|    107|        let lhs_mir_ty = self.get_operand_type(&lhs_converted);
  633|    107|        let rhs_mir_ty = self.get_operand_type(&rhs_converted);
  634|       |
  635|    107|        let lhs_type_info = self.mir_builder.get_type(lhs_mir_ty);
  636|    107|        let rhs_type_info = self.mir_builder.get_type(rhs_mir_ty);
  637|       |
  638|    107|        match op {
  639|       |            BinaryOp::Add => {
  640|     20|                if lhs_type_info.is_pointer() && rhs_type_info.is_int() {
                                                               ^2            ^2
  641|      0|                    Some(self.create_pointer_arithmetic_rvalue(lhs_converted, rhs_converted, BinaryOp::Add))
  642|     20|                } else if rhs_type_info.is_pointer() && lhs_type_info.is_int() {
                                                                      ^2            ^2
  643|      0|                    Some(self.create_pointer_arithmetic_rvalue(rhs_converted, lhs_converted, BinaryOp::Add))
  644|     20|                } else if lhs_type_info.is_pointer() && rhs_type_info.is_pointer() {
                                                                      ^2            ^2
  645|       |                    // Try unwrapping implicit casts (Analyzer might have casted Int to Ptr)
  646|      2|                    let lhs_unwrapped = self.unwrap_cast_if_int(lhs_converted.clone());
  647|      2|                    let rhs_unwrapped = self.unwrap_cast_if_int(rhs_converted.clone());
  648|       |
  649|      2|                    let lhs_u_ty = self.get_operand_type(&lhs_unwrapped);
  650|      2|                    let rhs_u_ty = self.get_operand_type(&rhs_unwrapped);
  651|       |
  652|      2|                    if self.mir_builder.get_type(lhs_u_ty).is_pointer() && self.mir_builder.get_type(rhs_u_ty).is_int()
  653|       |                    {
  654|      2|                        Some(self.create_pointer_arithmetic_rvalue(lhs_unwrapped, rhs_unwrapped, BinaryOp::Add))
  655|      0|                    } else if self.mir_builder.get_type(rhs_u_ty).is_pointer()
  656|      0|                        && self.mir_builder.get_type(lhs_u_ty).is_int()
  657|       |                    {
  658|      0|                        Some(self.create_pointer_arithmetic_rvalue(rhs_unwrapped, lhs_unwrapped, BinaryOp::Add))
  659|       |                    } else {
  660|      0|                        None
  661|       |                    }
  662|       |                } else {
  663|     18|                    None
  664|       |                }
  665|       |            }
  666|       |            BinaryOp::Sub => {
  667|     16|                if lhs_type_info.is_pointer() {
  668|      3|                    if rhs_type_info.is_pointer() {
  669|       |                        // Check if rhs is casted from int (Analyzer might have casted Int to Ptr)
  670|      3|                        let rhs_unwrapped = self.unwrap_cast_if_int(rhs_converted.clone());
  671|      3|                        let rhs_u_ty_id = self.get_operand_type(&rhs_unwrapped);
  672|       |
  673|      3|                        if self.mir_builder.get_type(rhs_u_ty_id).is_int() {
  674|      2|                            Some(self.create_pointer_arithmetic_rvalue(lhs_converted, rhs_unwrapped, BinaryOp::Sub))
  675|       |                        } else {
  676|      1|                            Some(Rvalue::PtrDiff(lhs_converted, rhs_converted))
  677|       |                        }
  678|      0|                    } else if rhs_type_info.is_int() {
  679|      0|                        Some(self.create_pointer_arithmetic_rvalue(lhs_converted, rhs_converted, BinaryOp::Sub))
  680|       |                    } else {
  681|      0|                        None
  682|       |                    }
  683|       |                } else {
  684|     13|                    None
  685|       |                }
  686|       |            }
  687|     71|            _ => None,
  688|       |        }
  689|    107|    }
  690|       |
  691|     91|    fn emit_assignment_expr(
  692|     91|        &mut self,
  693|     91|        node_ref: NodeRef,
  694|     91|        op: &BinaryOp,
  695|     91|        left_ref: NodeRef,
  696|     91|        right_ref: NodeRef,
  697|     91|        mir_ty: TypeId,
  698|     91|    ) -> Operand {
  699|     91|        debug_assert!(
  700|     91|            op.is_assignment(),
  701|      0|            "emit_assignment_expr called with non-assignment operator: {:?}",
  702|       |            op
  703|       |        );
  704|       |
  705|       |        // Ensure the LHS is a place. If not, this is a semantic error.
  706|     91|        if self.ast.get_value_category(left_ref) != Some(ValueCategory::LValue) {
  707|      0|            panic!("LHS of assignment must be an lvalue");
  708|     91|        }
  709|       |
  710|       |        // Use emit_expression_as_place to properly resolve the destination place
  711|     91|        let place = self.emit_expression_as_place(left_ref);
  712|       |
  713|     91|        let rhs_op = self.emit_expression(right_ref, true);
  714|       |
  715|     91|        let final_rhs = if let Some(compound_op) = op.without_assignment() {
                                                  ^11
  716|     11|            self.emit_compound_assignment(
  717|     11|                node_ref,
  718|     11|                compound_op,
  719|     11|                place.clone(),
  720|     11|                rhs_op,
  721|     11|                left_ref,
  722|     11|                right_ref,
  723|     11|                mir_ty,
  724|       |            )
  725|       |        } else {
  726|       |            // Simple assignment, just use the RHS
  727|     80|            self.apply_conversions(rhs_op, right_ref, mir_ty)
  728|       |        };
  729|       |
  730|     91|        self.emit_assignment(place, final_rhs.clone());
  731|     91|        final_rhs // C assignment expressions evaluate to the assigned value
  732|     91|    }
  733|       |
  734|     11|    fn emit_compound_assignment(
  735|     11|        &mut self,
  736|     11|        node_ref: NodeRef,
  737|     11|        compound_op: BinaryOp,
  738|     11|        place: Place,
  739|     11|        rhs_op: Operand,
  740|     11|        left_ref: NodeRef,
  741|     11|        right_ref: NodeRef,
  742|     11|        mir_ty: TypeId,
  743|     11|    ) -> Operand {
  744|       |        // This is a compound assignment, e.g., a += b
  745|       |        // Use the already-evaluated place to read the current value.
  746|     11|        let lhs_copy = Operand::Copy(Box::new(place));
  747|       |
  748|     11|        let (rval, op_ty) =
  749|     11|            self.emit_binary_arithmetic_logic(&compound_op, lhs_copy, rhs_op, left_ref, right_ref, mir_ty);
  750|     11|        let result_op = self.emit_rvalue_to_operand(rval, op_ty);
  751|     11|        self.apply_conversions(result_op, node_ref, mir_ty)
  752|     11|    }
  753|       |
  754|     76|    fn emit_function_call(&mut self, call_expr: &ast::nodes::CallExpr, dest_place: Option<Place>) {
  755|     76|        let callee = self.emit_expression(call_expr.callee, true);
  756|       |
  757|     76|        let arg_operands = self.emit_function_call_args(call_expr);
  758|       |
  759|     76|        let call_target = if let Operand::Constant(const_id) = callee {
                                                                 ^74
  760|       |            if let ConstValue {
  761|     74|                kind: ConstValueKind::FunctionAddress(func_id),
  762|       |                ..
  763|     74|            } = self.mir_builder.get_constants().get(&const_id).unwrap()
  764|       |            {
  765|     74|                CallTarget::Direct(*func_id)
  766|       |            } else {
  767|      0|                panic!("Expected function address");
  768|       |            }
  769|       |        } else {
  770|      2|            CallTarget::Indirect(callee)
  771|       |        };
  772|       |
  773|     76|        let stmt = MirStmt::Call {
  774|     76|            target: call_target,
  775|     76|            args: arg_operands,
  776|     76|            dest: dest_place,
  777|     76|        };
  778|     76|        self.mir_builder.add_statement(stmt);
  779|     76|    }
  780|       |
  781|     76|    fn emit_function_call_args(&mut self, call_expr: &ast::nodes::CallExpr) -> Vec<Operand> {
  782|     76|        let mut arg_operands = Vec::new();
  783|       |
  784|       |        // Get the function type to determine parameter types for conversions
  785|     76|        let func_node_kind = self.ast.get_kind(call_expr.callee);
  786|     76|        let func_type_kind = if let NodeKind::Ident(_, symbol_ref) = func_node_kind {
                                                                     ^75
  787|     75|            let resolved_symbol = *symbol_ref;
  788|     75|            let func_entry = self.symbol_table.get_symbol(resolved_symbol);
  789|     75|            Some(self.registry.get(func_entry.type_info.ty()).kind.clone())
  790|       |        } else {
  791|      1|            None
  792|       |        };
  793|       |
  794|     76|        let param_types = if let Some(TypeKind::Function { parameters, .. }) = func_type_kind.as_ref() {
                                                                         ^74
  795|       |            Some(
  796|     74|                parameters
  797|     74|                    .iter()
  798|     74|                    .map(|param| self.lower_qual_type(param.param_type))
                                               ^65  ^65             ^65
  799|     74|                    .collect::<Vec<_>>(),
  800|       |            )
  801|       |        } else {
  802|      2|            None
  803|       |        };
  804|       |
  805|    133|        for (i, arg_ref) in call_expr.arg_start.range(call_expr.arg_len).enumerate() {
                                          ^76                 ^76   ^76                ^76
  806|       |            // Note: emit_expression(CallArg) will just lower the inner expression.
  807|       |            // But we use arg_ref (the CallArg node) for implicit conversion lookup.
  808|    133|            let arg_operand = self.emit_expression(arg_ref, true);
  809|       |
  810|       |            // Apply conversions for function arguments if needed
  811|       |            // The resolved type of CallArg is same as inner expr.
  812|    133|            let arg_ty = self.ast.get_resolved_type(arg_ref).unwrap();
  813|    133|            let arg_mir_ty = self.lower_qual_type(arg_ty);
  814|       |
  815|       |            // Use the parameter type as the target type for conversions, if available
  816|    133|            let target_mir_ty = if let Some(ref param_types_vec) = param_types {
                                                          ^130
  817|    130|                if i < param_types_vec.len() {
  818|     65|                    param_types_vec[i]
  819|       |                } else {
  820|       |                    // Variadic argument: Logic handled by implicit conversions (Promotion/Decay) calculated in analyzer.rs
  821|       |                    // We just need a placeholder type, or the promoted type if we could calculate it.
  822|       |                    // Since semantic analysis has inserted promoted type casts/conversions, we can start with the argument's own type.
  823|     65|                    arg_mir_ty
  824|       |                }
  825|       |            } else {
  826|       |                // Unprototyped function: Logic handled by implicit conversions
  827|      3|                arg_mir_ty
  828|       |            };
  829|       |
  830|    133|            let converted_arg = self.apply_conversions(arg_operand, arg_ref, target_mir_ty);
  831|       |
  832|    133|            arg_operands.push(converted_arg);
  833|       |        }
  834|     76|        arg_operands
  835|     76|    }
  836|       |
  837|    109|    fn find_member_path(&self, record_ty: semantic::TypeRef, field_name: ast::NameId) -> Option<Vec<usize>> {
  838|    109|        let mut flat_members = Vec::new();
  839|    109|        let ty = self.registry.get(record_ty);
  840|    109|        ty.flatten_members(self.registry, &mut flat_members);
  841|       |
  842|    185|        if let Some(idx) = flat_members.iter().position(|m| m.name == Some(field_name)) {
                                  ^109   ^109                ^109
  843|    109|            return Some(vec![idx]);
  844|      0|        }
  845|      0|        None
  846|    109|    }
  847|       |
  848|    109|    fn emit_member_access(&mut self, obj_ref: NodeRef, field_name: &ast::NameId, is_arrow: bool) -> Operand {
  849|    109|        let obj_ty = self.ast.get_resolved_type(obj_ref).unwrap();
  850|    109|        let record_ty = if is_arrow {
  851|     13|            self.registry
  852|     13|                .get_pointee(obj_ty.ty())
  853|     13|                .expect("Arrow access on non-pointer type")
  854|     13|                .ty()
  855|       |        } else {
  856|     96|            obj_ty.ty()
  857|       |        };
  858|       |
  859|    109|        if record_ty.is_record() {
  860|       |            // Validate that the field exists and get its layout information
  861|    109|            let path = self
  862|    109|                .find_member_path(record_ty, *field_name)
  863|    109|                .expect("Field not found - should be caught by semantic analysis");
  864|       |
  865|       |            // Apply the chain of field accesses
  866|       |
  867|       |            // Resolve base place
  868|    109|            let mut current_place = self.emit_expression_as_place(obj_ref);
  869|       |
  870|    109|            if is_arrow {
  871|     13|                // Dereference: *ptr
  872|     13|                current_place = self.deref_place(current_place);
  873|     96|            }
  874|       |
  875|    218|            for field_idx in path {
                              ^109
  876|    109|                current_place = Place::StructField(Box::new(current_place), field_idx);
  877|    109|            }
  878|       |
  879|    109|            Operand::Copy(Box::new(current_place))
  880|       |        } else {
  881|      0|            panic!("Member access on non-record type");
  882|       |        }
  883|    109|    }
  884|       |
  885|     38|    fn emit_index_access(&mut self, arr_ref: NodeRef, idx_ref: NodeRef) -> Operand {
  886|     38|        let arr_ty = self.ast.get_resolved_type(arr_ref).unwrap();
  887|       |
  888|       |        // Handle both array and pointer types for index access
  889|       |        // In C, arr[idx] is equivalent to *(arr + idx)
  890|     38|        if arr_ty.is_array() || arr_ty.is_pointer() {
                                              ^0     ^0
  891|     38|            let arr_place = self.emit_expression_as_place(arr_ref);
  892|     38|            let idx_operand = self.emit_expression(idx_ref, true);
  893|       |
  894|     38|            Operand::Copy(Box::new(Place::ArrayIndex(Box::new(arr_place), Box::new(idx_operand))))
  895|       |        } else {
  896|      0|            panic!("Index access on non-array, non-pointer type");
  897|       |        }
  898|     38|    }
  899|       |
  900|     15|    fn emit_inc_dec_expression(
  901|     15|        &mut self,
  902|     15|        operand_ref: NodeRef,
  903|     15|        is_inc: bool,
  904|     15|        is_post: bool,
  905|     15|        need_value: bool,
  906|     15|    ) -> Operand {
  907|     15|        let operand = self.emit_expression(operand_ref, true);
  908|     15|        let operand_ty = self.ast.get_resolved_type(operand_ref).unwrap();
  909|     15|        let mir_ty = self.lower_qual_type(operand_ty);
  910|       |
  911|     15|        if self.ast.get_value_category(operand_ref) != Some(ValueCategory::LValue) {
  912|      0|            panic!("Inc/Dec operand must be an lvalue");
  913|     15|        }
  914|       |
  915|     15|        let place = if let Operand::Copy(place) = operand.clone() {
  916|     15|            place
  917|       |        } else {
  918|      0|            panic!("Inc/Dec operand is not a place");
  919|       |        };
  920|       |
  921|       |        // If it's post-inc/dec and we need the value, save the old value
  922|     15|        let old_value = if is_post && need_value {
                                                    ^13
  923|      6|            let rval = Rvalue::Use(operand.clone());
  924|      6|            let (_, temp_place) = self.create_temp_local_with_assignment(rval, mir_ty);
  925|      6|            Some(Operand::Copy(Box::new(temp_place)))
  926|       |        } else {
  927|      9|            None
  928|       |        };
  929|       |
  930|       |        // Determine MIR operation and Rvalue
  931|     15|        let rval = self.create_inc_dec_rvalue(operand.clone(), operand_ty, is_inc);
  932|       |
  933|       |        // Perform the assignment
  934|     15|        if is_post && !need_value {
                                    ^13
  935|      7|            // Optimization: assign directly to place if old value not needed
  936|      7|            self.mir_builder.add_statement(MirStmt::Assign(*place.clone(), rval));
  937|      7|        } else {
  938|       |            // If we needed old value (is_post), or if it is pre-inc (need new value),
  939|       |            // we compute to a temp first to ensure correctness and return the right value.
  940|      8|            let (_, new_place) = self.create_temp_local_with_assignment(rval, mir_ty);
  941|      8|            self.emit_assignment(*place.clone(), Operand::Copy(Box::new(new_place.clone())));
  942|       |
  943|      8|            if !is_post {
  944|       |                // Pre-inc: return the new value
  945|      2|                return Operand::Copy(Box::new(new_place));
  946|      6|            }
  947|       |        }
  948|       |
  949|     13|        if is_post {
  950|     13|            if need_value {
  951|      6|                old_value.unwrap()
  952|       |            } else {
  953|      7|                self.create_int_operand(0)
  954|       |            }
  955|       |        } else {
  956|       |            // Pre-inc: we already returned inside the block above.
  957|       |            // RE-FETCH from place as a fallback (should not be reached)
  958|      0|            Operand::Copy(place)
  959|       |        }
  960|     15|    }
  961|       |
  962|     15|    fn create_inc_dec_rvalue(&mut self, operand: Operand, operand_ty: QualType, is_inc: bool) -> Rvalue {
  963|     15|        let one_const = self.create_int_operand(1);
  964|     15|        let minus_one_const = self.create_int_operand(-1);
  965|       |
  966|     15|        if operand_ty.is_pointer() {
  967|      4|            let op = if is_inc { BinaryOp::Add } else { BinaryOp::Sub };
                                                                      ^0
  968|      4|            self.create_pointer_arithmetic_rvalue(operand, one_const, op)
  969|       |        } else {
  970|     11|            let mir_ty_id = self.lower_qual_type(operand_ty);
  971|     11|            let mir_ty = self.mir_builder.get_type(mir_ty_id);
  972|       |
  973|     11|            if mir_ty.is_float() {
  974|      0|                let val = if is_inc { 1.0 } else { -1.0 };
  975|      0|                let const_val = self.create_constant(mir_ty_id, ConstValueKind::Float(val));
  976|      0|                let rhs = Operand::Constant(const_val);
  977|      0|                Rvalue::BinaryFloatOp(crate::mir::BinaryFloatOp::Add, operand, rhs)
  978|       |            } else {
  979|       |                // For Integers: Add(delta) (Note: we use Add with negative delta for decrement
  980|       |                // to support proper wrapping arithmetic and fix previous bugs)
  981|     11|                let rhs = if is_inc { one_const } else { minus_one_const };
                                                    ^6                 ^5
  982|     11|                Rvalue::BinaryIntOp(BinaryIntOp::Add, operand, rhs)
  983|       |            }
  984|       |        }
  985|     15|    }
  986|       |
  987|      8|    fn create_pointer_arithmetic_rvalue(&mut self, lhs: Operand, rhs: Operand, op: BinaryOp) -> Rvalue {
  988|      8|        match op {
  989|      6|            BinaryOp::Add => Rvalue::PtrAdd(lhs, rhs),
  990|      2|            BinaryOp::Sub => Rvalue::PtrSub(lhs, rhs),
  991|      0|            _ => panic!("Invalid pointer arithmetic op"),
  992|       |        }
  993|      8|    }
  994|       |
  995|      7|    fn emit_builtin_va_arg(&mut self, ty: QualType, expr_ref: NodeRef) -> Operand {
  996|      7|        let ap = self.emit_expression_as_place(expr_ref);
  997|      7|        let mir_ty = self.lower_qual_type(ty);
  998|      7|        let rval = Rvalue::BuiltinVaArg(ap, mir_ty);
  999|      7|        self.emit_rvalue_to_operand(rval, mir_ty)
 1000|      7|    }
 1001|       |
 1002|      6|    fn emit_builtin_void(&mut self, kind: &NodeKind) -> Operand {
 1003|      6|        let stmt = match kind {
 1004|      4|            NodeKind::BuiltinVaStart(ap_ref, last_ref) => {
 1005|      4|                let ap = self.emit_expression_as_place(*ap_ref);
 1006|      4|                let last = self.emit_expression(*last_ref, true);
 1007|      4|                MirStmt::BuiltinVaStart(ap, last)
 1008|       |            }
 1009|      2|            NodeKind::BuiltinVaEnd(ap_ref) => {
 1010|      2|                let ap = self.emit_expression_as_place(*ap_ref);
 1011|      2|                MirStmt::BuiltinVaEnd(ap)
 1012|       |            }
 1013|      0|            NodeKind::BuiltinVaCopy(dst_ref, src_ref) => {
 1014|      0|                let dst = self.emit_expression_as_place(*dst_ref);
 1015|      0|                let src = self.emit_expression_as_place(*src_ref);
 1016|      0|                MirStmt::BuiltinVaCopy(dst, src)
 1017|       |            }
 1018|      0|            _ => unreachable!(),
 1019|       |        };
 1020|      6|        self.mir_builder.add_statement(stmt);
 1021|      6|        self.create_int_operand(0)
 1022|      6|    }
 1023|       |
 1024|     10|    fn emit_atomic_op(&mut self, op: AtomicOp, args_start: NodeRef, args_len: u16, mir_ty: TypeId) -> Operand {
 1025|     10|        let args = self.get_atomic_args(args_start, args_len);
 1026|     10|        let order = AtomicMemOrder::SeqCst; // Default to SeqCst for now
 1027|       |
 1028|     10|        match op {
 1029|       |            AtomicOp::LoadN => {
 1030|      1|                let ptr = args[0].clone();
 1031|       |                // args[1] is memorder, ignored
 1032|      1|                let rval = Rvalue::AtomicLoad(ptr, order);
 1033|      1|                self.emit_rvalue_to_operand(rval, mir_ty)
 1034|       |            }
 1035|       |            AtomicOp::StoreN => {
 1036|      1|                let ptr = args[0].clone();
 1037|      1|                let val = args[1].clone();
 1038|       |                // args[2] is memorder, ignored
 1039|      1|                self.mir_builder.add_statement(MirStmt::AtomicStore(ptr, val, order));
 1040|      1|                self.create_dummy_operand()
 1041|       |            }
 1042|       |            AtomicOp::ExchangeN => {
 1043|      1|                let ptr = args[0].clone();
 1044|      1|                let val = args[1].clone();
 1045|       |                // args[2] is memorder, ignored
 1046|      1|                let rval = Rvalue::AtomicExchange(ptr, val, order);
 1047|      1|                self.emit_rvalue_to_operand(rval, mir_ty)
 1048|       |            }
 1049|      2|            AtomicOp::CompareExchangeN => self.emit_atomic_cmpxchg(&args, order, mir_ty),
 1050|      1|            AtomicOp::FetchAdd => self.emit_atomic_fetch_op(BinaryIntOp::Add, &args, order, mir_ty),
 1051|      1|            AtomicOp::FetchSub => self.emit_atomic_fetch_op(BinaryIntOp::Sub, &args, order, mir_ty),
 1052|      1|            AtomicOp::FetchAnd => self.emit_atomic_fetch_op(BinaryIntOp::BitAnd, &args, order, mir_ty),
 1053|      1|            AtomicOp::FetchOr => self.emit_atomic_fetch_op(BinaryIntOp::BitOr, &args, order, mir_ty),
 1054|      1|            AtomicOp::FetchXor => self.emit_atomic_fetch_op(BinaryIntOp::BitXor, &args, order, mir_ty),
 1055|       |        }
 1056|     10|    }
 1057|       |
 1058|     10|    fn get_atomic_args(&mut self, args_start: NodeRef, args_len: u16) -> Vec<Operand> {
 1059|     10|        args_start
 1060|     10|            .range(args_len)
 1061|     35|            .map(|arg_ref| self.emit_expression(arg_ref, true))
                           ^10
 1062|     10|            .collect()
 1063|     10|    }
 1064|       |
 1065|      2|    fn emit_atomic_cmpxchg(&mut self, args: &[Operand], order: AtomicMemOrder, mir_ty: TypeId) -> Operand {
 1066|      2|        let ptr = args[0].clone();
 1067|      2|        let expected_ptr = args[1].clone();
 1068|      2|        let desired = args[2].clone();
 1069|       |        // args[3] weak, args[4] success, args[5] failure (ignored side effects were handled by lowering args)
 1070|       |
 1071|      2|        let expected_place = match expected_ptr {
 1072|      1|            Operand::Copy(p) => Place::Deref(Box::new(Operand::Copy(p))),
 1073|      1|            _ => Place::Deref(Box::new(expected_ptr)),
 1074|       |        };
 1075|      2|        let expected_val_op = Operand::Copy(Box::new(expected_place.clone()));
 1076|       |
 1077|      2|        let weak = false;
 1078|      2|        let cas_rval = Rvalue::AtomicCompareExchange(ptr, expected_val_op.clone(), desired.clone(), weak, order, order);
 1079|       |
 1080|      2|        let val_ty = self.get_operand_type(&desired);
 1081|      2|        let (_, old_val_place) = self.create_temp_local_with_assignment(cas_rval, val_ty);
 1082|      2|        let old_val = Operand::Copy(Box::new(old_val_place));
 1083|       |
 1084|      2|        let mir_type_info = self.mir_builder.get_type(val_ty);
 1085|      2|        let cmp_rval = if mir_type_info.is_float() {
 1086|      0|            Rvalue::BinaryFloatOp(crate::mir::BinaryFloatOp::Eq, old_val.clone(), expected_val_op)
 1087|       |        } else {
 1088|      2|            Rvalue::BinaryIntOp(BinaryIntOp::Eq, old_val.clone(), expected_val_op)
 1089|       |        };
 1090|       |
 1091|      2|        let (_, success_place) = self.create_temp_local_with_assignment(cmp_rval, mir_ty);
 1092|      2|        let success_op = Operand::Copy(Box::new(success_place));
 1093|       |
 1094|      2|        let update_block = self.mir_builder.create_block();
 1095|      2|        let end_block = self.mir_builder.create_block();
 1096|       |
 1097|      2|        self.mir_builder
 1098|      2|            .set_terminator(Terminator::If(success_op.clone(), end_block, update_block));
 1099|       |
 1100|      2|        self.mir_builder.set_current_block(update_block);
 1101|      2|        self.mir_builder
 1102|      2|            .add_statement(MirStmt::Assign(expected_place, Rvalue::Use(old_val)));
 1103|      2|        self.mir_builder.set_terminator(Terminator::Goto(end_block));
 1104|       |
 1105|      2|        self.mir_builder.set_current_block(end_block);
 1106|      2|        success_op
 1107|      2|    }
 1108|       |
 1109|      5|    fn emit_atomic_fetch_op(
 1110|      5|        &mut self,
 1111|      5|        bin_op: BinaryIntOp,
 1112|      5|        args: &[Operand],
 1113|      5|        order: AtomicMemOrder,
 1114|      5|        mir_ty: TypeId,
 1115|      5|    ) -> Operand {
 1116|      5|        let ptr = args[0].clone();
 1117|      5|        let val = args[1].clone();
 1118|       |        // args[2] memorder
 1119|       |
 1120|      5|        let rval = Rvalue::AtomicFetchOp(bin_op, ptr, val, order);
 1121|      5|        self.emit_rvalue_to_operand(rval, mir_ty)
 1122|      5|    }
 1123|       |
 1124|     19|    fn emit_complex_binary_op(&mut self, op: &BinaryOp, lhs: Operand, rhs: Operand, mir_ty: TypeId) -> Operand {
 1125|     19|        let lhs_ty = self.get_operand_type(&lhs);
 1126|     19|        let rhs_ty = self.get_operand_type(&rhs);
 1127|       |
 1128|     19|        let (lhs_real, lhs_imag) = self.get_complex_components(lhs, lhs_ty);
 1129|     19|        let (rhs_real, rhs_imag) = self.get_complex_components(rhs, rhs_ty);
 1130|       |
 1131|     19|        let element_ty = match self.mir_builder.get_type(lhs_ty) {
 1132|     19|            crate::mir::MirType::Record { field_types, .. } => field_types[0],
 1133|      0|            _ => panic!("Expected complex record type"),
 1134|       |        };
 1135|       |
 1136|       |        use crate::mir::BinaryFloatOp::*;
 1137|       |
 1138|     19|        match op {
 1139|       |            BinaryOp::Add | BinaryOp::Sub => {
 1140|      8|                let mir_op = if *op == BinaryOp::Add { Add } else { Sub };
                                                                     ^5           ^3
 1141|      8|                let res_real = self.emit_float_binop(mir_op, lhs_real, rhs_real, element_ty);
 1142|      8|                let res_imag = self.emit_float_binop(mir_op, lhs_imag, rhs_imag, element_ty);
 1143|      8|                self.emit_complex_struct(res_real, res_imag, mir_ty)
 1144|       |            }
 1145|       |            BinaryOp::Mul => {
 1146|      4|                let ac = self.emit_float_binop(Mul, lhs_real.clone(), rhs_real.clone(), element_ty);
 1147|      4|                let bd = self.emit_float_binop(Mul, lhs_imag.clone(), rhs_imag.clone(), element_ty);
 1148|      4|                let real = self.emit_float_binop(Sub, ac, bd, element_ty);
 1149|       |
 1150|      4|                let ad = self.emit_float_binop(Mul, lhs_real, rhs_imag.clone(), element_ty);
 1151|      4|                let bc = self.emit_float_binop(Mul, lhs_imag, rhs_real, element_ty);
 1152|      4|                let imag = self.emit_float_binop(Add, ad, bc, element_ty);
 1153|       |
 1154|      4|                self.emit_complex_struct(real, imag, mir_ty)
 1155|       |            }
 1156|       |            BinaryOp::Div => {
 1157|      3|                let cc = self.emit_float_binop(Mul, rhs_real.clone(), rhs_real.clone(), element_ty);
 1158|      3|                let dd = self.emit_float_binop(Mul, rhs_imag.clone(), rhs_imag.clone(), element_ty);
 1159|      3|                let denom = self.emit_float_binop(Add, cc, dd, element_ty);
 1160|       |
 1161|      3|                let ac = self.emit_float_binop(Mul, lhs_real.clone(), rhs_real.clone(), element_ty);
 1162|      3|                let bd = self.emit_float_binop(Mul, lhs_imag.clone(), rhs_imag.clone(), element_ty);
 1163|      3|                let num_real = self.emit_float_binop(Add, ac, bd, element_ty);
 1164|      3|                let real = self.emit_float_binop(Div, num_real, denom.clone(), element_ty);
 1165|       |
 1166|      3|                let bc = self.emit_float_binop(Mul, lhs_imag, rhs_real, element_ty);
 1167|      3|                let ad = self.emit_float_binop(Mul, lhs_real, rhs_imag, element_ty);
 1168|      3|                let num_imag = self.emit_float_binop(Sub, bc, ad, element_ty);
 1169|      3|                let imag = self.emit_float_binop(Div, num_imag, denom, element_ty);
 1170|       |
 1171|      3|                self.emit_complex_struct(real, imag, mir_ty)
 1172|       |            }
 1173|       |            BinaryOp::Equal | BinaryOp::NotEqual => {
 1174|      4|                let bool_ty = self.lower_type(self.registry.type_bool);
 1175|      4|                if *op == BinaryOp::Equal {
 1176|      2|                    let real_eq = self.emit_float_binop(Eq, lhs_real, rhs_real, bool_ty);
 1177|      2|                    let imag_eq = self.emit_float_binop(Eq, lhs_imag, rhs_imag, bool_ty);
 1178|      2|                    self.emit_rvalue_to_operand(Rvalue::BinaryIntOp(BinaryIntOp::BitAnd, real_eq, imag_eq), mir_ty)
 1179|       |                } else {
 1180|      2|                    let real_ne = self.emit_float_binop(Ne, lhs_real, rhs_real, bool_ty);
 1181|      2|                    let imag_ne = self.emit_float_binop(Ne, lhs_imag, rhs_imag, bool_ty);
 1182|      2|                    self.emit_rvalue_to_operand(Rvalue::BinaryIntOp(BinaryIntOp::BitOr, real_ne, imag_ne), mir_ty)
 1183|       |                }
 1184|       |            }
 1185|      0|            _ => panic!("Unsupported complex binary operator: {:?}", op),
 1186|       |        }
 1187|     19|    }
 1188|       |
 1189|      7|    fn emit_complex_unary_op(&mut self, op: &UnaryOp, operand_ref: NodeRef, mir_ty: TypeId) -> Operand {
 1190|      7|        let operand = self.emit_expression(operand_ref, true);
 1191|      7|        let operand_ty = self.get_operand_type(&operand);
 1192|       |
 1193|      7|        let (real, imag) = self.get_complex_components(operand, operand_ty);
 1194|       |
 1195|      7|        let element_ty = match self.mir_builder.get_type(operand_ty) {
 1196|      7|            crate::mir::MirType::Record { field_types, .. } => field_types[0],
 1197|      0|            _ => panic!("Expected complex record type"),
 1198|       |        };
 1199|       |
 1200|       |        use crate::mir::UnaryFloatOp::*;
 1201|       |
 1202|      7|        match op {
 1203|       |            UnaryOp::Minus => {
 1204|      2|                let res_real = self.emit_float_unop(Neg, real, element_ty);
 1205|      2|                let res_imag = self.emit_float_unop(Neg, imag, element_ty);
 1206|      2|                self.emit_complex_struct(res_real, res_imag, mir_ty)
 1207|       |            }
 1208|       |            UnaryOp::BitNot => {
 1209|       |                // conjugate
 1210|      3|                let res_imag = self.emit_float_unop(Neg, imag, element_ty);
 1211|      3|                self.emit_complex_struct(real, res_imag, mir_ty)
 1212|       |            }
 1213|       |            UnaryOp::LogicNot => {
 1214|      0|                let zero = self.create_constant(element_ty, ConstValueKind::Float(0.0));
 1215|      0|                let zero_op = Operand::Constant(zero);
 1216|      0|                let bool_ty = self.lower_type(self.registry.type_bool);
 1217|       |
 1218|       |                use crate::mir::BinaryFloatOp::Eq;
 1219|      0|                let real_eq = self.emit_float_binop(Eq, real, zero_op.clone(), bool_ty);
 1220|      0|                let imag_eq = self.emit_float_binop(Eq, imag, zero_op, bool_ty);
 1221|      0|                self.emit_rvalue_to_operand(Rvalue::BinaryIntOp(BinaryIntOp::BitAnd, real_eq, imag_eq), mir_ty)
 1222|       |            }
 1223|      0|            UnaryOp::Plus => self.emit_complex_struct(real, imag, mir_ty),
 1224|      1|            UnaryOp::Real => real,
 1225|      1|            UnaryOp::Imag => imag,
 1226|      0|            _ => panic!("Unsupported complex unary operator: {:?}", op),
 1227|       |        }
 1228|      7|    }
 1229|       |
 1230|       |    /// Try to lower builtin float constant functions like `__builtin_inff`, `__builtin_nanf`, etc.
 1231|       |    /// Returns Some(Operand) if the call is a builtin float constant, None otherwise.
 1232|     76|    fn try_emit_builtin_float_const(&mut self, call_expr: &ast::nodes::CallExpr, mir_ty: TypeId) -> Option<Operand> {
 1233|       |        // Check if callee is an identifier
 1234|     76|        let callee_kind = self.ast.get_kind(call_expr.callee);
 1235|     76|        let name = match callee_kind {
                          ^75
 1236|     75|            NodeKind::Ident(name_id, _) => name_id.as_str(),
 1237|      1|            _ => return None,
 1238|       |        };
 1239|       |
 1240|     75|        match name {
 1241|     75|            "__builtin_inff" | "__builtin_huge_valf" => {
 1242|      0|                let val = f32::INFINITY as f64;
 1243|      0|                Some(self.create_float_operand(val, mir_ty))
 1244|       |            }
 1245|     75|            "__builtin_inf" | "__builtin_huge_val" => {
 1246|      0|                let val = f64::INFINITY;
 1247|      0|                Some(self.create_float_operand(val, mir_ty))
 1248|       |            }
 1249|     75|            "__builtin_nanf" => {
 1250|      0|                let val = f32::NAN as f64;
 1251|      0|                Some(self.create_float_operand(val, mir_ty))
 1252|       |            }
 1253|     75|            "__builtin_nan" => {
 1254|      0|                let val = f64::NAN;
 1255|      0|                Some(self.create_float_operand(val, mir_ty))
 1256|       |            }
 1257|     75|            _ => None,
 1258|       |        }
 1259|     76|    }
 1260|       |}

/app/src/codegen/mir_gen_initializer.rs:
    1|       |use std::iter::Peekable;
    2|       |
    3|       |use crate::ast;
    4|       |use crate::ast::{Designator, NodeKind, NodeRef, literal};
    5|       |use crate::codegen::mir_gen::MirGen;
    6|       |use crate::mir::{ConstValueKind, MirArrayLayout, MirType, Operand, Place, Rvalue};
    7|       |use crate::semantic::{ArraySizeType, QualType, StructMember, TypeKind};
    8|       |
    9|       |impl<'a> MirGen<'a> {
   10|     36|    fn emit_initializer_list(
   11|     36|        &mut self,
   12|     36|        list_data: &ast::nodes::InitializerListData,
   13|     36|        target_ty: QualType,
   14|     36|        destination: Option<Place>,
   15|     36|    ) -> Operand {
   16|     36|        let range = list_data.init_start.range(list_data.init_len);
   17|     36|        let mut iter = range.peekable();
   18|     36|        let fields = self.emit_struct_fields_recursive(&mut iter, None, target_ty);
   19|     36|        self.finalize_struct_initializer(fields, target_ty, destination)
   20|     36|    }
   21|       |
   22|      1|    fn get_flattened_type_info(&self, ty_ref: crate::semantic::TypeRef) -> (Vec<StructMember>, Vec<u16>) {
   23|      1|        let mut members = Vec::new();
   24|      1|        let mut offsets = Vec::new();
   25|      1|        let ty = self.registry.get(ty_ref);
   26|      1|        ty.flatten_members_with_layouts(self.registry, &mut members, &mut offsets, 0);
   27|      1|        (members, offsets)
   28|      1|    }
   29|       |
   30|     44|    fn emit_struct_fields_recursive(
   31|     44|        &mut self,
   32|     44|        iter: &mut Peekable<impl Iterator<Item = NodeRef>>,
   33|     44|        pending_initializer: Option<NodeRef>,
   34|     44|        target_ty: QualType,
   35|     44|    ) -> Vec<(usize, Operand)> {
   36|     44|        let TypeKind::Record { members, .. } = &self.registry.get(target_ty.ty()).kind else {
   37|      0|            return Vec::new();
   38|       |        };
   39|     44|        let is_union = self.registry.get(target_ty.ty()).is_union();
   40|     44|        let members = members.clone();
   41|       |
   42|       |        // Precalculate flattened offsets for hierarchical members
   43|     44|        let mut hierarchical_offsets = Vec::with_capacity(members.len());
   44|     44|        let mut offset = 0;
   45|     85|        for m in members.iter() {
                               ^44     ^44
   46|     85|            hierarchical_offsets.push(offset);
   47|     85|            if !is_union {
   48|     79|                offset += self.count_flattened_members(m);
   49|     79|            }
                          ^6
   50|       |        }
   51|       |
   52|     44|        let mut field_operands = Vec::new();
   53|     44|        let mut current_pos = 0;
   54|     44|        let mut first_item_processed = false;
   55|       |
   56|       |        loop {
   57|    124|            let (item_ref, is_pending) = if let Some(pending) = pending_initializer
                               ^83       ^83                       ^14
   58|     14|                && !first_item_processed
   59|       |            {
   60|      6|                first_item_processed = true;
   61|      6|                (pending, true)
   62|    118|            } else if let Some(r) = iter.peek() {
                                             ^77
   63|     77|                (*r, false)
   64|       |            } else {
   65|     41|                break;
   66|       |            };
   67|       |
   68|     83|            let (initializer, designator) = match (is_pending, self.ast.get_kind(item_ref)) {
   69|      6|                (true, _) => (item_ref, None),
   70|     77|                (false, NodeKind::InitializerItem(init)) => (
   71|     77|                    init.initializer,
   72|     77|                    (init.designator_len > 0).then_some((init.designator_start, init.designator_len)),
   73|     77|                ),
   74|       |                _ => {
   75|      0|                    iter.next();
   76|      0|                    continue;
   77|       |                }
   78|       |            };
   79|       |
   80|     83|            let (field_idx, nested_path) = match designator {
                               ^82        ^82
   81|     20|                Some((d_start, _)) => {
   82|     20|                    if let NodeKind::Designator(Designator::FieldName(name)) = self.ast.get_kind(d_start) {
   83|     20|                        if let Some(res) = self.find_member_recursive(&members, *name) {
                                                  ^19
   84|     19|                            res
   85|       |                        } else {
   86|      1|                            break;
   87|       |                        }
   88|       |                    } else {
   89|      0|                        if is_pending {
   90|      0|                            panic!("Array designator in struct initializer");
   91|      0|                        }
   92|      0|                        break;
   93|       |                    }
   94|       |                }
   95|     63|                None => (current_pos, Vec::new()),
   96|       |            };
   97|       |
   98|     82|            if field_idx >= members.len() {
   99|      2|                break;
  100|     80|            }
  101|       |
  102|     80|            if !is_pending {
  103|     74|                iter.next();
  104|     74|            }
                          ^6
  105|       |
  106|     80|            let m = &members[field_idx];
  107|     80|            let flat_base = hierarchical_offsets[field_idx];
  108|       |
  109|     80|            let value = if !nested_path.is_empty() || designator.is_some_and(|(_, len)| len > 1) {
                                                                    ^78        ^78                    ^17
  110|      3|                let (d_start, d_len) = designator.unwrap_or((NodeRef::ROOT, 0));
  111|      3|                let mut extra_iter = (d_len > 1).then(|| d_start.range(d_len).skip(1));
                                                                       ^1      ^1    ^1     ^1
  112|      3|                self.emit_initializer_with_path_recursive(
  113|      3|                    &nested_path,
  114|      3|                    extra_iter.as_mut().map(|i| i as &mut dyn Iterator<Item = NodeRef>),
                                                              ^1   ^1
  115|      3|                    initializer,
  116|      3|                    m.member_type,
  117|       |                )
  118|     77|            } else if self.should_recurse_aggregate(m.member_type, initializer) {
  119|      8|                match &self.registry.get(m.member_type.ty()).kind {
  120|       |                    TypeKind::Record { .. } => {
  121|      5|                        let fields = self.emit_struct_fields_recursive(iter, Some(initializer), m.member_type);
  122|      5|                        if m.name.is_none() {
  123|      1|                            fields
  124|       |                        } else {
  125|      4|                            vec![(0, self.finalize_struct_initializer(fields, m.member_type, None))]
  126|       |                        }
  127|       |                    }
  128|      3|                    TypeKind::Array { element_type, size } => {
  129|      3|                        let array_size = if let ArraySizeType::Constant(s) = size { *s } else { 0 };
                                                                                                              ^0
  130|      3|                        let op = self.emit_array_initializer_from_iter(
  131|      3|                            iter,
  132|      3|                            Some(initializer),
  133|      3|                            QualType::unqualified(*element_type),
  134|      3|                            array_size,
  135|      3|                            m.member_type,
  136|      3|                            None,
  137|       |                        );
  138|      3|                        vec![(0, op)]
  139|       |                    }
  140|      0|                    _ => unreachable!(),
  141|       |                }
  142|     69|            } else if matches!(self.ast.get_kind(initializer), NodeKind::InitializerList(_))
                                    ^61
  143|      8|                && m.name.is_none()
  144|      2|                && m.member_type.ty().is_record()
  145|       |            {
  146|       |                // Anonymous member initialized with braces
  147|      2|                let NodeKind::InitializerList(list) = self.ast.get_kind(initializer) else {
  148|      0|                    unreachable!()
  149|       |                };
  150|      2|                let range = list.init_start.range(list.init_len);
  151|      2|                let mut sub_iter = range.peekable();
  152|      2|                self.emit_struct_fields_recursive(&mut sub_iter, None, m.member_type)
  153|       |            } else {
  154|     67|                vec![(0, self.emit_initializer(initializer, m.member_type, None))]
  155|       |            };
  156|       |
  157|    163|            for (sub_idx, op) in value {
                               ^83      ^83
  158|     83|                field_operands.push((flat_base + sub_idx, op));
  159|     83|            }
  160|       |
  161|     80|            current_pos = if is_union { members.len() } else { field_idx + 1 };
                                                      ^4                     ^76
  162|       |        }
  163|     44|        field_operands
  164|     44|    }
  165|       |
  166|    133|    fn should_recurse_aggregate(&self, target_ty: QualType, initializer: NodeRef) -> bool {
  167|    133|        let kind = &self.registry.get(target_ty.ty()).kind;
  168|    133|        if !matches!(kind, TypeKind::Record { .. } | TypeKind::Array { .. }) {
                          ^105
  169|    105|            return false;
  170|     28|        }
  171|       |
  172|     28|        let init_kind = self.ast.get_kind(initializer);
  173|     28|        if matches!(init_kind, NodeKind::InitializerList(_)) {
                         ^15
  174|     13|            return false;
  175|     15|        }
  176|       |
  177|     11|        if let NodeKind::Literal(literal::Literal::String(_)) = init_kind
  178|      2|            && let TypeKind::Array { element_type, .. } = kind
                                                   ^1
  179|      1|            && self.registry.is_char_type(*element_type)
  180|       |        {
  181|      1|            return false;
  182|     14|        }
  183|       |
  184|     14|        let is_compatible = self.ast.get_resolved_type(initializer).is_some_and(|ty| {
  185|     14|            self.registry
  186|     14|                .is_compatible(QualType::unqualified(ty.ty()), QualType::unqualified(target_ty.ty()))
  187|     14|        });
  188|       |
  189|     14|        !is_compatible
  190|    133|    }
  191|       |
  192|      5|    fn emit_initializer_with_path_recursive(
  193|      5|        &mut self,
  194|      5|        path: &[usize],
  195|      5|        extra_designators: Option<&mut dyn Iterator<Item = NodeRef>>,
  196|      5|        initializer: NodeRef,
  197|      5|        target_ty: QualType,
  198|      5|    ) -> Vec<(usize, Operand)> {
  199|      5|        if path.is_empty() {
  200|      3|            let op = if let Some(designators) = extra_designators {
                                               ^1
  201|      1|                self.emit_initializer_with_designators(designators, initializer, target_ty, None)
  202|       |            } else {
  203|      2|                self.emit_initializer(initializer, target_ty, None)
  204|       |            };
  205|      3|            return vec![(0, op)];
  206|      2|        }
  207|       |
  208|      2|        let target_type = self.registry.get(target_ty.ty()).into_owned();
  209|      2|        let members = match &target_type.kind {
  210|      2|            TypeKind::Record { members, .. } => members.clone(),
  211|      0|            _ => panic!("Expected record type for designator path"),
  212|       |        };
  213|       |
  214|      2|        let field_idx = path[0];
  215|      2|        let mut flat_offset = 0;
  216|      2|        for member in members.iter().take(field_idx) {
                          ^1
  217|      1|            flat_offset += self.count_flattened_members(member);
  218|      1|        }
  219|       |
  220|      2|        let sub_fields = self.emit_initializer_with_path_recursive(
  221|      2|            &path[1..],
  222|      2|            extra_designators,
  223|      2|            initializer,
  224|      2|            members[field_idx].member_type,
  225|       |        );
  226|       |
  227|      2|        sub_fields
  228|      2|            .into_iter()
  229|      2|            .map(|(idx, op)| (flat_offset + idx, op))
  230|      2|            .collect()
  231|      5|    }
  232|       |
  233|     20|    fn resolve_designator_range(&mut self, designator_ref: NodeRef) -> (usize, usize) {
  234|     20|        match self.ast.get_kind(designator_ref) {
  235|     18|            NodeKind::Designator(Designator::ArrayIndex(idx_expr)) => {
  236|     18|                let idx = self.evaluate_constant_usize(*idx_expr, "Array designator must be constant");
  237|     18|                (idx, idx)
  238|       |            }
  239|      2|            NodeKind::Designator(Designator::GnuArrayRange(start, end)) => {
  240|      2|                let s = self.evaluate_constant_usize(*start, "Range start must be constant");
  241|      2|                let e = self.evaluate_constant_usize(*end, "Range end must be constant");
  242|      2|                if e < s {
  243|      0|                    panic!("Array range end < start");
  244|      2|                }
  245|      2|                (s, e)
  246|       |            }
  247|      0|            _ => panic!("Invalid designator for array"),
  248|       |        }
  249|     20|    }
  250|       |
  251|     25|    fn emit_array_initializer(
  252|     25|        &mut self,
  253|     25|        list_data: &ast::nodes::InitializerListData,
  254|     25|        element_ty: QualType,
  255|     25|        size: usize,
  256|     25|        target_ty: QualType,
  257|     25|        destination: Option<Place>,
  258|     25|    ) -> Operand {
  259|     25|        let range = list_data.init_start.range(list_data.init_len);
  260|     25|        let mut iter = range.peekable();
  261|     25|        self.emit_array_initializer_from_iter(&mut iter, None, element_ty, size, target_ty, destination)
  262|     25|    }
  263|       |
  264|     30|    fn emit_array_initializer_from_iter(
  265|     30|        &mut self,
  266|     30|        iter: &mut Peekable<impl Iterator<Item = NodeRef>>,
  267|     30|        pending_initializer: Option<NodeRef>,
  268|     30|        element_ty: QualType,
  269|     30|        size: usize,
  270|     30|        target_ty: QualType,
  271|     30|        destination: Option<Place>,
  272|     30|    ) -> Operand {
  273|     30|        let mut elements: Vec<Option<Operand>> = vec![None; size];
  274|     30|        let mut current_idx = 0;
  275|     30|        let mut first_item_processed = false;
  276|       |
  277|       |        loop {
  278|       |            // Determine next item
  279|     86|            let (item_ref, is_pending) = if let Some(pending) = pending_initializer
                               ^57       ^57                       ^12
  280|     12|                && !first_item_processed
  281|       |            {
  282|      5|                first_item_processed = true;
  283|      5|                (pending, true)
  284|     81|            } else if let Some(r) = iter.peek() {
                                             ^52
  285|     52|                (*r, false)
  286|       |            } else {
  287|     29|                break;
  288|       |            };
  289|       |
  290|     57|            let (initializer, designator_info) = if is_pending {
  291|      5|                (item_ref, None)
  292|       |            } else {
  293|     52|                let NodeKind::InitializerItem(init) = self.ast.get_kind(item_ref) else {
  294|      0|                    iter.next();
  295|      0|                    continue;
  296|       |                };
  297|       |                (
  298|     52|                    init.initializer,
  299|     52|                    if init.designator_len > 0 {
  300|     20|                        Some((init.designator_start, init.designator_len))
  301|       |                    } else {
  302|     32|                        None
  303|       |                    },
  304|       |                )
  305|       |            };
  306|       |
  307|       |            // Stop if we have filled the array with positional initializers
  308|     57|            if designator_info.is_none() && size > 0 && current_idx >= size {
                                                          ^37         ^35
  309|      1|                break;
  310|     56|            }
  311|       |
  312|     56|            let (start, end) = if let Some((d_start, _)) = designator_info {
                                                          ^20
  313|     20|                match self.ast.get_kind(d_start) {
  314|       |                    NodeKind::Designator(Designator::ArrayIndex(_))
  315|     20|                    | NodeKind::Designator(Designator::GnuArrayRange(_, _)) => self.resolve_designator_range(d_start),
  316|       |                    _ => {
  317|       |                        // Field designator or other. Not for array.
  318|      0|                        if !is_pending {
  319|      0|                            break;
  320|      0|                        }
  321|      0|                        panic!("Field designator in array initializer");
  322|       |                    }
  323|       |                }
  324|       |            } else {
  325|     36|                (current_idx, current_idx)
  326|       |            };
  327|       |
  328|     56|            if !is_pending {
  329|     51|                iter.next();
  330|     51|            }
                          ^5
  331|       |
  332|     56|            let operand = if let Some((d_start, d_len)) = designator_info
                                                     ^20      ^20
  333|     20|                && d_len > 1
  334|       |            {
  335|      0|                let range = d_start.range(d_len);
  336|      0|                let sub_iter = range.skip(1);
  337|      0|                self.emit_initializer_with_designators(sub_iter, initializer, element_ty, None)
  338|     56|            } else if self.should_recurse_aggregate(element_ty, initializer) {
  339|      3|                match &self.registry.get(element_ty.ty()).kind {
  340|       |                    TypeKind::Record { .. } => {
  341|      1|                        let fields = self.emit_struct_fields_recursive(iter, Some(initializer), element_ty);
  342|      1|                        self.finalize_struct_initializer(fields, element_ty, None)
  343|       |                    }
  344|       |                    TypeKind::Array {
  345|      2|                        element_type: inner_elem,
  346|      2|                        size: inner_size,
  347|       |                    } => {
  348|      2|                        let array_size = if let ArraySizeType::Constant(s) = inner_size {
  349|      2|                            *s
  350|       |                        } else {
  351|      0|                            0
  352|       |                        };
  353|      2|                        self.emit_array_initializer_from_iter(
  354|      2|                            iter,
  355|      2|                            Some(initializer),
  356|      2|                            QualType::unqualified(*inner_elem),
  357|      2|                            array_size,
  358|      2|                            element_ty,
  359|      2|                            None,
  360|       |                        )
  361|       |                    }
  362|      0|                    _ => unreachable!(),
  363|       |                }
  364|       |            } else {
  365|     53|                self.emit_initializer(initializer, element_ty, None)
  366|       |            };
  367|     56|            if end >= elements.len() {
  368|      2|                elements.resize(end + 1, None);
  369|     54|            }
  370|     59|            for item in elements.iter_mut().take(end + 1).skip(start) {
                                      ^56                 ^56  ^56      ^56  ^56
  371|     59|                *item = Some(operand.clone());
  372|     59|            }
  373|     56|            current_idx = end + 1;
  374|       |        }
  375|       |
  376|     30|        let mir_elem_ty = self.lower_qual_type(element_ty);
  377|     30|        let final_elements = elements
  378|     30|            .into_iter()
  379|     93|            .map(|op| op.unwrap_or_else(|| Operand::Constant(self.create_constant(mir_elem_ty, ConstValueKind::Zero))))
                           ^30                                             ^35  ^35             ^35          ^35
  380|     30|            .collect();
  381|       |
  382|     30|        self.finalize_array_initializer(final_elements, target_ty, destination)
  383|     30|    }
  384|       |
  385|     72|    fn finalize_initializer_generic<T, C, R>(
  386|     72|        &mut self,
  387|     72|        target_ty: QualType,
  388|     72|        data: T,
  389|     72|        create_const: C,
  390|     72|        create_rvalue: R,
  391|     72|        destination: Option<Place>,
  392|     72|    ) -> Operand
  393|     72|    where
  394|     72|        C: FnOnce(&mut Self, T) -> ConstValueKind,
  395|     72|        R: FnOnce(T) -> Rvalue,
  396|       |    {
  397|     72|        let mir_ty = self.lower_qual_type(target_ty);
  398|     72|        if self.current_function.is_none() {
  399|     43|            let const_kind = create_const(self, data);
  400|     43|            Operand::Constant(self.create_constant(mir_ty, const_kind))
  401|     29|        } else if let Some(place) = destination {
                                         ^19
  402|     19|            let rval = create_rvalue(data);
  403|     19|            self.mir_builder
  404|     19|                .add_statement(crate::mir::MirStmt::Assign(place.clone(), rval));
  405|     19|            Operand::Copy(Box::new(place))
  406|       |        } else {
  407|     10|            let rval = create_rvalue(data);
  408|     10|            self.emit_rvalue_to_operand(rval, mir_ty)
  409|       |        }
  410|     72|    }
  411|       |
  412|     42|    fn finalize_struct_initializer(
  413|     42|        &mut self,
  414|     42|        field_operands: Vec<(usize, Operand)>,
  415|     42|        target_ty: QualType,
  416|     42|        destination: Option<Place>,
  417|     42|    ) -> Operand {
  418|       |        // Dedup by index, taking the last one for each index
  419|     42|        let mut final_fields: Vec<(usize, Operand)> = Vec::new();
  420|    120|        for (idx, op) in field_operands {
                           ^78  ^78
  421|     78|            if let Some(existing) = final_fields.iter_mut().find(|(i, _)| *i == idx) {
                                      ^0                                                ^53   ^53
  422|      0|                existing.1 = op;
  423|     78|            } else {
  424|     78|                final_fields.push((idx, op));
  425|     78|            }
  426|       |        }
  427|     42|        final_fields.sort_by_key(|(idx, _)| *idx);
  428|       |
  429|     42|        self.finalize_initializer_generic(
  430|     42|            target_ty,
  431|     42|            final_fields,
  432|     28|            |this, fields| {
  433|     28|                let const_fields = fields
  434|     28|                    .into_iter()
  435|     51|                    .map(|(idx, op)| (idx, this.operand_to_const_id_strict(op, "Global struct init error")))
                                   ^28
  436|     28|                    .collect();
  437|     28|                ConstValueKind::StructLiteral(const_fields)
  438|     28|            },
  439|       |            Rvalue::StructLiteral,
  440|     42|            destination,
  441|       |        )
  442|     42|    }
  443|       |
  444|     30|    fn finalize_array_initializer(
  445|     30|        &mut self,
  446|     30|        elements: Vec<Operand>,
  447|     30|        target_ty: QualType,
  448|     30|        destination: Option<Place>,
  449|     30|    ) -> Operand {
  450|     30|        self.finalize_initializer_generic(
  451|     30|            target_ty,
  452|     30|            elements,
  453|     15|            |this, elems| {
  454|     15|                let const_elements = elems
  455|     15|                    .into_iter()
  456|     57|                    .map(|op| this.operand_to_const_id_strict(op, "Global array init error"))
                                   ^15
  457|     15|                    .collect();
  458|     15|                ConstValueKind::ArrayLiteral(const_elements)
  459|     15|            },
  460|       |            Rvalue::ArrayLiteral,
  461|     30|            destination,
  462|       |        )
  463|     30|    }
  464|       |
  465|    330|    pub(crate) fn emit_initializer(
  466|    330|        &mut self,
  467|    330|        init_ref: NodeRef,
  468|    330|        target_ty: QualType,
  469|    330|        destination: Option<Place>,
  470|    330|    ) -> Operand {
  471|    330|        let kind = *self.ast.get_kind(init_ref);
  472|    330|        let target_type = self.registry.get(target_ty.ty()).into_owned();
  473|       |
  474|    330|        match (&kind, &target_type.kind) {
  475|     36|            (NodeKind::InitializerList(list), TypeKind::Record { .. }) => {
  476|     36|                self.emit_initializer_list(list, target_ty, destination)
  477|       |            }
  478|     25|            (NodeKind::InitializerList(list), TypeKind::Array { element_type, size }) => {
  479|     25|                let array_size = if let ArraySizeType::Constant(s) = size { *s } else { 0 };
                                                                              ^24         ^24         ^1
  480|     25|                self.emit_array_initializer(
  481|     25|                    list,
  482|     25|                    QualType::unqualified(*element_type),
  483|     25|                    array_size,
  484|     25|                    target_ty,
  485|     25|                    destination,
  486|       |                )
  487|       |            }
  488|       |            // ...
  489|     13|            (NodeKind::Literal(literal::Literal::String(val)), TypeKind::Array { element_type, size }) => {
  490|     13|                let fixed_size = if let ArraySizeType::Constant(s) = size {
  491|     13|                    Some(*s)
  492|       |                } else {
  493|      0|                    None
  494|       |                };
  495|     13|                Operand::Constant(self.create_array_const_from_string(
  496|     13|                    val,
  497|     13|                    fixed_size,
  498|     13|                    Some(QualType::unqualified(*element_type)),
  499|     13|                ))
  500|       |            }
  501|      3|            (NodeKind::InitializerList(list), _) => {
  502|      3|                if list.init_len == 0 {
  503|      1|                    let mir_ty = self.lower_qual_type(target_ty);
  504|      1|                    return Operand::Constant(self.create_constant(mir_ty, ConstValueKind::Zero));
  505|      2|                }
  506|      2|                let NodeKind::InitializerItem(item) = self.ast.get_kind(list.init_start) else {
  507|      0|                    unreachable!()
  508|       |                };
  509|      2|                self.emit_initializer(item.initializer, target_ty, destination)
  510|       |            }
  511|       |            _ => {
  512|    253|                let operand = self.emit_expression(init_ref, true);
  513|    253|                let mir_target_ty = self.lower_qual_type(target_ty);
  514|       |
  515|    253|                if self.get_operand_type(&operand) == mir_target_ty {
  516|    184|                    return operand;
  517|     69|                }
  518|       |
  519|       |                // Brace elision: scalar -> aggregate
  520|     69|                self.emit_brace_elision(operand, init_ref, target_ty, destination)
  521|       |            }
  522|       |        }
  523|    330|    }
  524|       |
  525|     69|    pub(crate) fn create_array_const_from_string(
  526|     69|        &mut self,
  527|     69|        val: &ast::NameId,
  528|     69|        fixed_size: Option<usize>,
  529|     69|        elem_ty: Option<QualType>,
  530|     69|    ) -> crate::mir::ConstValueId {
  531|     69|        let parsed = crate::semantic::literal_utils::parse_string_literal(*val);
  532|     69|        let size = fixed_size.unwrap_or(parsed.size);
  533|       |
  534|     69|        let (mir_elem_ty, layout) = if let Some(qt) = elem_ty {
  535|     69|            (self.lower_qual_type(qt), self.registry.get_layout(qt.ty()).into_owned())
  536|       |        } else {
  537|      0|            let ty_ref = self.registry.get_builtin_type(parsed.builtin_type);
  538|      0|            (
  539|      0|                self.lower_qual_type(QualType::unqualified(ty_ref)),
  540|      0|                self.registry.get_layout(ty_ref).into_owned(),
  541|      0|            )
  542|       |        };
  543|       |
  544|     69|        let constants = (0..size)
  545|    792|            .map(|i| {
                           ^69
  546|    792|                let v = parsed.values.get(i).cloned().unwrap_or(0);
  547|    792|                self.create_constant(mir_elem_ty, ConstValueKind::Int(v))
  548|    792|            })
  549|     69|            .collect();
  550|       |
  551|     69|        let array_ty = self.mir_builder.add_type(MirType::Array {
  552|     69|            element: mir_elem_ty,
  553|     69|            size,
  554|     69|            layout: MirArrayLayout {
  555|     69|                size: 0,
  556|     69|                align: layout.alignment,
  557|     69|                stride: layout.size,
  558|     69|            },
  559|     69|        });
  560|       |
  561|     69|        self.create_constant(array_ty, ConstValueKind::ArrayLiteral(constants))
  562|     69|    }
  563|       |
  564|     56|    pub(crate) fn emit_literal_string(&mut self, val: &ast::NameId, ty: QualType) -> Operand {
  565|     56|        let mir_ty = self.lower_qual_type(ty);
  566|     56|        let elem_ty = match &self.registry.get(ty.ty()).kind {
  567|     56|            TypeKind::Array { element_type, .. } => *element_type,
  568|      0|            _ => self.registry.type_char,
  569|       |        };
  570|       |
  571|     56|        let array_const = self.create_array_const_from_string(val, None, Some(QualType::unqualified(elem_ty)));
  572|     56|        let name = self.mir_builder.get_next_anonymous_global_name();
  573|     56|        let global = self
  574|     56|            .mir_builder
  575|     56|            .create_global_with_init(name, mir_ty, true, Some(array_const));
  576|       |
  577|     56|        Operand::Constant(self.create_constant(mir_ty, ConstValueKind::GlobalAddress(global)))
  578|     56|    }
  579|       |
  580|      5|    pub(crate) fn emit_compound_literal(&mut self, ty: QualType, init_ref: NodeRef) -> Operand {
  581|      5|        let mir_ty = self.lower_qual_type(ty);
  582|       |
  583|      5|        if self.current_function.is_none() {
  584|      3|            let init_const = self
  585|      3|                .eval_initializer_to_const(init_ref, ty)
  586|      3|                .expect("Global compound literal init must be const");
  587|      3|            let name = self.mir_builder.get_next_anonymous_global_name();
  588|      3|            let global = self
  589|      3|                .mir_builder
  590|      3|                .create_global_with_init(name, mir_ty, false, Some(init_const));
  591|      3|            Operand::Copy(Box::new(Place::Global(global)))
  592|       |        } else {
  593|      2|            let (_, place) = self.create_temp_local(mir_ty);
  594|      2|            let init_op = self.emit_initializer(init_ref, ty, Some(place.clone()));
  595|      2|            self.emit_assignment(place.clone(), init_op);
  596|      2|            Operand::Copy(Box::new(place))
  597|       |        }
  598|      5|    }
  599|       |
  600|     58|    pub(crate) fn eval_initializer_to_const(
  601|     58|        &mut self,
  602|     58|        init_ref: NodeRef,
  603|     58|        ty: QualType,
  604|     58|    ) -> Option<crate::mir::ConstValueId> {
  605|     58|        let operand = self.emit_initializer(init_ref, ty, None);
  606|     58|        self.operand_to_const_id(&operand)
  607|     58|    }
  608|       |
  609|      2|    fn emit_initializer_with_designators(
  610|      2|        &mut self,
  611|      2|        mut designators: impl Iterator<Item = NodeRef>,
  612|      2|        initializer: NodeRef,
  613|      2|        target_ty: QualType,
  614|      2|        destination: Option<Place>,
  615|      2|    ) -> Operand {
  616|      2|        let designator_ref = if let Some(d) = designators.next() {
                          ^1                           ^1
  617|      1|            d
  618|       |        } else {
  619|      1|            return self.emit_initializer(initializer, target_ty, destination);
  620|       |        };
  621|       |
  622|      1|        let target_type = self.registry.get(target_ty.ty()).into_owned();
  623|       |
  624|      1|        match &target_type.kind {
  625|      0|            TypeKind::Array { element_type, size } => {
  626|      0|                let (start, end) = self.resolve_designator_range(designator_ref);
  627|      0|                let array_size = if let ArraySizeType::Constant(s) = size { *s } else { 0 };
  628|       |
  629|      0|                let sub_op = self.emit_initializer_with_designators(
  630|      0|                    designators,
  631|      0|                    initializer,
  632|      0|                    QualType::unqualified(*element_type),
  633|      0|                    None,
  634|       |                );
  635|       |
  636|      0|                let mut elements = vec![None; array_size];
  637|      0|                for (i, element) in elements.iter_mut().enumerate().take(end + 1).skip(start) {
  638|      0|                    if i < array_size {
  639|      0|                        *element = Some(sub_op.clone());
  640|      0|                    }
  641|       |                }
  642|       |
  643|      0|                let mir_elem_ty = self.lower_qual_type(QualType::unqualified(*element_type));
  644|      0|                let zero_op = Operand::Constant(self.create_constant(mir_elem_ty, ConstValueKind::Zero));
  645|       |
  646|      0|                self.finalize_array_initializer(
  647|      0|                    elements.into_iter().map(|e| e.unwrap_or(zero_op.clone())).collect(),
  648|      0|                    target_ty,
  649|      0|                    destination,
  650|       |                )
  651|       |            }
  652|       |            TypeKind::Record { .. } => {
  653|      1|                let (flat_members, _) = self.get_flattened_type_info(target_ty.ty());
  654|      1|                let NodeKind::Designator(Designator::FieldName(name)) = self.ast.get_kind(designator_ref) else {
  655|      0|                    panic!("Expected field name designator for record");
  656|       |                };
  657|       |
  658|      1|                let field_idx = flat_members
  659|      1|                    .iter()
  660|      2|                    .position(|m| m.name == Some(*name))
                                   ^1
  661|      1|                    .expect("Unknown field in designator");
  662|       |
  663|      1|                let value = self.emit_initializer_with_designators(
  664|      1|                    designators,
  665|      1|                    initializer,
  666|      1|                    flat_members[field_idx].member_type,
  667|      1|                    None,
  668|       |                );
  669|       |
  670|      1|                self.finalize_struct_initializer(vec![(field_idx, value)], target_ty, destination)
  671|       |            }
  672|      0|            _ => panic!("Designator on non-aggregate type"),
  673|       |        }
  674|      2|    }
  675|     69|    fn emit_brace_elision(
  676|     69|        &mut self,
  677|     69|        operand: Operand,
  678|     69|        init_ref: NodeRef,
  679|     69|        target_ty: QualType,
  680|     69|        destination: Option<Place>,
  681|     69|    ) -> Operand {
  682|     69|        let target_type = self.registry.get(target_ty.ty()).into_owned();
  683|      0|        match &target_type.kind {
  684|      0|            TypeKind::Array { element_type, size } => {
  685|      0|                let elem_ty = QualType::unqualified(*element_type);
  686|      0|                let final_op = self.emit_brace_elision(operand, init_ref, elem_ty, None);
  687|      0|                let mir_elem_ty = self.lower_qual_type(elem_ty);
  688|      0|                let len = if let ArraySizeType::Constant(l) = size { *l } else { 1 };
  689|      0|                let mut elements = vec![final_op];
  690|      0|                while elements.len() < len {
  691|      0|                    elements.push(Operand::Constant(
  692|      0|                        self.create_constant(mir_elem_ty, ConstValueKind::Zero),
  693|      0|                    ));
  694|      0|                }
  695|      0|                self.finalize_array_initializer(elements, target_ty, destination)
  696|       |            }
  697|      0|            TypeKind::Record { .. } if !target_type.is_record_empty() => {
  698|      0|                let (flat_members, _) = self.get_flattened_type_info(target_ty.ty());
  699|      0|                if flat_members.is_empty() {
  700|      0|                    let mir_target_ty = self.lower_qual_type(target_ty);
  701|      0|                    return Operand::Constant(self.create_constant(mir_target_ty, ConstValueKind::Zero));
  702|      0|                }
  703|      0|                let member_ty = flat_members[0].member_type;
  704|      0|                let final_op = self.emit_brace_elision(operand, init_ref, member_ty, None);
  705|      0|                self.finalize_struct_initializer(vec![(0, final_op)], target_ty, destination)
  706|       |            }
  707|       |            _ => {
  708|     69|                let mir_target_ty = self.lower_qual_type(target_ty);
  709|     69|                let conv_op = self.apply_conversions(operand, init_ref, mir_target_ty);
  710|     69|                if self.get_operand_type(&conv_op) != mir_target_ty {
  711|     41|                    Operand::Cast(mir_target_ty, Box::new(conv_op))
  712|       |                } else {
  713|     28|                    conv_op
  714|       |                }
  715|       |            }
  716|       |        }
  717|     69|    }
  718|       |
  719|     80|    fn count_flattened_members(&self, m: &StructMember) -> usize {
  720|     80|        if m.name.is_some() {
  721|     79|            return 1;
  722|      1|        }
  723|      1|        let ty_ref = m.member_type.ty();
  724|      1|        if !ty_ref.is_record() {
  725|      0|            return 1;
  726|      1|        }
  727|      1|        let mut flat_members = Vec::new();
  728|      1|        let mut flat_offsets = Vec::new();
  729|      1|        let type_obj = self.registry.get(ty_ref);
  730|      1|        type_obj.flatten_members_with_layouts(self.registry, &mut flat_members, &mut flat_offsets, 0);
  731|      1|        flat_members.len()
  732|     80|    }
  733|       |
  734|     22|    fn find_member_recursive(&self, members: &[StructMember], name: crate::ast::NameId) -> Option<(usize, Vec<usize>)> {
  735|     32|        for (i, m) in members.iter().enumerate() {
                                    ^22     ^22    ^22
  736|     32|            if m.name == Some(name) {
  737|     19|                return Some((i, Vec::new()));
  738|     13|            }
  739|     13|            if m.name.is_none() {
  740|       |                // Anonymous member: look inside
  741|      2|                let sub_ty = self.registry.get(m.member_type.ty());
  742|       |                if let TypeKind::Record {
  743|      2|                    members: sub_members, ..
  744|      2|                } = &sub_ty.kind
  745|      2|                    && let Some((sub_idx, mut path)) = self.find_member_recursive(sub_members, name)
  746|       |                {
  747|      2|                    path.insert(0, sub_idx);
  748|      2|                    return Some((i, path));
  749|      0|                }
  750|     11|            }
  751|       |        }
  752|      1|        None
  753|     22|    }
  754|       |}

/app/src/codegen/mir_gen_ops.rs:
    1|       |use crate::ast::{BinaryOp, UnaryOp};
    2|       |use crate::mir::{BinaryFloatOp, BinaryIntOp, Operand, Rvalue, UnaryFloatOp, UnaryIntOp};
    3|       |
    4|     85|pub(crate) fn emit_binary_rvalue(op: &BinaryOp, lhs: Operand, rhs: Operand, is_float: bool) -> Rvalue {
    5|     85|    if is_float {
    6|      1|        let mir_op = map_ast_binary_op_to_mir_float(op);
    7|      1|        Rvalue::BinaryFloatOp(mir_op, lhs, rhs)
    8|       |    } else {
    9|     84|        let mir_op = map_ast_binary_op_to_mir_int(op);
   10|     84|        Rvalue::BinaryIntOp(mir_op, lhs, rhs)
   11|       |    }
   12|     85|}
   13|       |
   14|     17|pub(crate) fn emit_unary_rvalue(op: &UnaryOp, operand: Operand, is_float: bool) -> Rvalue {
   15|       |    // Unary plus is a no-op in MIR (conversions handled by caller)
   16|     17|    if matches!(op, UnaryOp::Plus) {
   17|      0|        return Rvalue::Use(operand);
   18|     17|    }
   19|       |
   20|     17|    if is_float {
   21|      1|        let mir_op = map_ast_unary_op_to_mir_float(op);
   22|      1|        Rvalue::UnaryFloatOp(mir_op, operand)
   23|       |    } else {
   24|     16|        let mir_op = map_ast_unary_op_to_mir_int(op);
   25|     16|        Rvalue::UnaryIntOp(mir_op, operand)
   26|       |    }
   27|     17|}
   28|       |
   29|    102|fn map_ast_binary_op_to_mir_int(ast_op: &BinaryOp) -> BinaryIntOp {
   30|    102|    let op = ast_op.without_assignment().unwrap_or(*ast_op);
   31|    102|    match op {
   32|     16|        BinaryOp::Add => BinaryIntOp::Add,
   33|     12|        BinaryOp::Sub => BinaryIntOp::Sub,
   34|      2|        BinaryOp::Mul => BinaryIntOp::Mul,
   35|      2|        BinaryOp::Div => BinaryIntOp::Div,
   36|      3|        BinaryOp::Mod => BinaryIntOp::Mod,
   37|      2|        BinaryOp::BitAnd => BinaryIntOp::BitAnd,
   38|      1|        BinaryOp::BitOr => BinaryIntOp::BitOr,
   39|      1|        BinaryOp::BitXor => BinaryIntOp::BitXor,
   40|      1|        BinaryOp::LShift => BinaryIntOp::LShift,
   41|      1|        BinaryOp::RShift => BinaryIntOp::RShift,
   42|     16|        BinaryOp::Equal => BinaryIntOp::Eq,
   43|     37|        BinaryOp::NotEqual => BinaryIntOp::Ne,
   44|      3|        BinaryOp::Less => BinaryIntOp::Lt,
   45|      1|        BinaryOp::LessEqual => BinaryIntOp::Le,
   46|      3|        BinaryOp::Greater => BinaryIntOp::Gt,
   47|      1|        BinaryOp::GreaterEqual => BinaryIntOp::Ge,
   48|       |        // Logic ops are handled separately (short-circuit)
   49|      0|        BinaryOp::LogicAnd | BinaryOp::LogicOr => panic!("Logic ops should be handled separately"),
   50|      0|        BinaryOp::Comma => panic!("Comma op should be handled separately"), // Comma usually handled in expression lowering
   51|      0|        _ => panic!("Unsupported integer binary operator: {:?}", ast_op),
   52|       |    }
   53|    102|}
   54|       |
   55|     11|fn map_ast_binary_op_to_mir_float(ast_op: &BinaryOp) -> BinaryFloatOp {
   56|     11|    let op = ast_op.without_assignment().unwrap_or(*ast_op);
   57|     11|    match op {
   58|      2|        BinaryOp::Add => BinaryFloatOp::Add,
   59|      1|        BinaryOp::Sub => BinaryFloatOp::Sub,
   60|      1|        BinaryOp::Mul => BinaryFloatOp::Mul,
   61|      1|        BinaryOp::Div => BinaryFloatOp::Div,
   62|      1|        BinaryOp::Equal => BinaryFloatOp::Eq,
   63|      1|        BinaryOp::NotEqual => BinaryFloatOp::Ne,
   64|      1|        BinaryOp::Less => BinaryFloatOp::Lt,
   65|      1|        BinaryOp::LessEqual => BinaryFloatOp::Le,
   66|      1|        BinaryOp::Greater => BinaryFloatOp::Gt,
   67|      1|        BinaryOp::GreaterEqual => BinaryFloatOp::Ge,
   68|      0|        _ => panic!("Unsupported float binary operator: {:?}", ast_op),
   69|       |    }
   70|     11|}
   71|       |
   72|     19|fn map_ast_unary_op_to_mir_int(ast_op: &UnaryOp) -> UnaryIntOp {
   73|     19|    match ast_op {
   74|      2|        UnaryOp::Minus => UnaryIntOp::Neg,
   75|      2|        UnaryOp::BitNot => UnaryIntOp::BitwiseNot,
   76|     15|        UnaryOp::LogicNot => UnaryIntOp::LogicalNot,
   77|      0|        _ => panic!("Unsupported integer unary operator: {:?}", ast_op),
   78|       |    }
   79|     19|}
   80|       |
   81|      2|fn map_ast_unary_op_to_mir_float(ast_op: &UnaryOp) -> UnaryFloatOp {
   82|      2|    match ast_op {
   83|      2|        UnaryOp::Minus => UnaryFloatOp::Neg,
   84|      0|        _ => panic!("Unsupported float unary operator: {:?}", ast_op),
   85|       |    }
   86|      2|}
   87|       |
   88|       |#[cfg(test)]
   89|       |mod tests {
   90|       |    use super::*;
   91|       |    use crate::ast::{BinaryOp, UnaryOp};
   92|       |    use crate::mir::{BinaryFloatOp, BinaryIntOp, Operand, Rvalue, UnaryFloatOp, UnaryIntOp};
   93|       |    use std::num::NonZeroU32;
   94|       |
   95|       |    #[test]
   96|      1|    fn test_mir_ops_mapping() {
   97|       |        // Test map_ast_binary_op_to_mir_int
   98|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::Add), BinaryIntOp::Add);
   99|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::Sub), BinaryIntOp::Sub);
  100|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::Mul), BinaryIntOp::Mul);
  101|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::Div), BinaryIntOp::Div);
  102|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::Mod), BinaryIntOp::Mod);
  103|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::BitAnd), BinaryIntOp::BitAnd);
  104|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::BitOr), BinaryIntOp::BitOr);
  105|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::BitXor), BinaryIntOp::BitXor);
  106|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::LShift), BinaryIntOp::LShift);
  107|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::RShift), BinaryIntOp::RShift);
  108|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::Equal), BinaryIntOp::Eq);
  109|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::NotEqual), BinaryIntOp::Ne);
  110|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::Less), BinaryIntOp::Lt);
  111|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::LessEqual), BinaryIntOp::Le);
  112|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::Greater), BinaryIntOp::Gt);
  113|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::GreaterEqual), BinaryIntOp::Ge);
  114|       |
  115|       |        // Test assignment stripping
  116|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::AssignAdd), BinaryIntOp::Add);
  117|      1|        assert_eq!(map_ast_binary_op_to_mir_int(&BinaryOp::AssignSub), BinaryIntOp::Sub);
  118|       |
  119|       |        // Test map_ast_binary_op_to_mir_float
  120|      1|        assert_eq!(map_ast_binary_op_to_mir_float(&BinaryOp::Add), BinaryFloatOp::Add);
  121|      1|        assert_eq!(map_ast_binary_op_to_mir_float(&BinaryOp::Sub), BinaryFloatOp::Sub);
  122|      1|        assert_eq!(map_ast_binary_op_to_mir_float(&BinaryOp::Mul), BinaryFloatOp::Mul);
  123|      1|        assert_eq!(map_ast_binary_op_to_mir_float(&BinaryOp::Div), BinaryFloatOp::Div);
  124|      1|        assert_eq!(map_ast_binary_op_to_mir_float(&BinaryOp::Equal), BinaryFloatOp::Eq);
  125|      1|        assert_eq!(map_ast_binary_op_to_mir_float(&BinaryOp::NotEqual), BinaryFloatOp::Ne);
  126|      1|        assert_eq!(map_ast_binary_op_to_mir_float(&BinaryOp::Less), BinaryFloatOp::Lt);
  127|      1|        assert_eq!(map_ast_binary_op_to_mir_float(&BinaryOp::LessEqual), BinaryFloatOp::Le);
  128|      1|        assert_eq!(map_ast_binary_op_to_mir_float(&BinaryOp::Greater), BinaryFloatOp::Gt);
  129|      1|        assert_eq!(
  130|      1|            map_ast_binary_op_to_mir_float(&BinaryOp::GreaterEqual),
  131|       |            BinaryFloatOp::Ge
  132|       |        );
  133|       |
  134|       |        // Test map_ast_unary_op_to_mir_int
  135|      1|        assert_eq!(map_ast_unary_op_to_mir_int(&UnaryOp::Minus), UnaryIntOp::Neg);
  136|      1|        assert_eq!(map_ast_unary_op_to_mir_int(&UnaryOp::BitNot), UnaryIntOp::BitwiseNot);
  137|      1|        assert_eq!(map_ast_unary_op_to_mir_int(&UnaryOp::LogicNot), UnaryIntOp::LogicalNot);
  138|       |
  139|       |        // Test map_ast_unary_op_to_mir_float
  140|      1|        assert_eq!(map_ast_unary_op_to_mir_float(&UnaryOp::Minus), UnaryFloatOp::Neg);
  141|       |
  142|       |        // Test emit_binary_rvalue
  143|      1|        let op1 = Operand::Constant(NonZeroU32::new(1).unwrap());
  144|      1|        let op2 = Operand::Constant(NonZeroU32::new(2).unwrap());
  145|       |
  146|       |        // Integer emission
  147|      1|        match emit_binary_rvalue(&BinaryOp::Add, op1.clone(), op2.clone(), false) {
  148|      1|            Rvalue::BinaryIntOp(op, _, _) => assert_eq!(op, BinaryIntOp::Add),
  149|      0|            _ => panic!("Expected BinaryIntOp"),
  150|       |        }
  151|       |
  152|       |        // Float emission
  153|      1|        match emit_binary_rvalue(&BinaryOp::Add, op1.clone(), op2.clone(), true) {
  154|      1|            Rvalue::BinaryFloatOp(op, _, _) => assert_eq!(op, BinaryFloatOp::Add),
  155|      0|            _ => panic!("Expected BinaryFloatOp"),
  156|       |        }
  157|       |
  158|       |        // Unary emission
  159|      1|        match emit_unary_rvalue(&UnaryOp::Minus, op1.clone(), false) {
  160|      1|            Rvalue::UnaryIntOp(op, _) => assert_eq!(op, UnaryIntOp::Neg),
  161|      0|            _ => panic!("Expected UnaryIntOp"),
  162|       |        }
  163|       |
  164|      1|        match emit_unary_rvalue(&UnaryOp::Minus, op1.clone(), true) {
  165|      1|            Rvalue::UnaryFloatOp(op, _) => assert_eq!(op, UnaryFloatOp::Neg),
  166|      0|            _ => panic!("Expected UnaryFloatOp"),
  167|       |        }
  168|      1|    }
  169|       |}

/app/src/codegen/object_gen.rs:
    1|       |//! Object file generation from Cranelift IR.
    2|       |//!
    3|       |//! This module provides functionality for generating object files
    4|       |//! from compiled Cranelift IR. Currently, the object generation logic
    5|       |//! is integrated within `ClifGen::compile_module`, but this module
    6|       |//! provides a future extension point for more advanced object file manipulation.
    7|       |
    8|       |use cranelift_object::ObjectModule;
    9|       |
   10|       |/// Object file generator.
   11|       |///
   12|       |/// This struct wraps the Cranelift ObjectModule finalization process.
   13|       |pub(crate) struct ObjectGen;
   14|       |
   15|       |impl ObjectGen {
   16|       |    /// Finalize an ObjectModule and produce the raw object file bytes.
   17|     68|    pub(crate) fn finalize(module: ObjectModule) -> Result<Vec<u8>, String> {
   18|     68|        let product = module.finish();
   19|     68|        product
   20|     68|            .object
   21|     68|            .write()
   22|     68|            .map_err(|e| format!("Failed to write object file: {:?}", e))
                                       ^0      ^0
   23|     68|    }
   24|       |}

/app/src/diagnostic.rs:
    1|       |use crate::ast::NameId;
    2|       |use crate::parser::TokenKind;
    3|       |use crate::semantic::TypeRef;
    4|       |use crate::source_manager::{SourceManager, SourceSpan};
    5|       |use annotate_snippets::renderer::DecorStyle;
    6|       |use annotate_snippets::{AnnotationKind, Level, Renderer, Snippet};
    7|       |
    8|       |/// Diagnostic severity levels
    9|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
   10|       |pub enum DiagnosticLevel {
   11|       |    #[default]
   12|       |    Error,
   13|       |    Warning,
   14|       |    Note,
   15|       |}
   16|       |
   17|       |/// Individual diagnostic with rich context
   18|       |#[derive(Debug, Clone, Default)]
   19|       |pub struct Diagnostic {
   20|       |    pub level: DiagnosticLevel,
   21|       |    pub message: String,
   22|       |    pub span: SourceSpan,
   23|       |    pub code: Option<String>,     // Error code like "E001"
   24|       |    pub hints: Vec<String>,       // Suggestions for fixing
   25|       |    pub related: Vec<SourceSpan>, // Related locations
   26|       |}
   27|       |
   28|       |/// Parse errors
   29|       |#[derive(Debug, thiserror::Error)]
   30|       |pub enum ParseError {
   31|       |    #[error("Unexpected token: expected {expected_tokens}, found {found:?}")]
   32|       |    UnexpectedToken {
   33|       |        expected_tokens: String,
   34|       |        found: TokenKind,
   35|       |        span: SourceSpan,
   36|       |    },
   37|       |
   38|       |    #[error("Unexpected End of File")]
   39|       |    UnexpectedEof { span: SourceSpan },
   40|       |
   41|       |    #[error("Invalid unary operator")]
   42|       |    InvalidUnaryOperator { span: SourceSpan },
   43|       |
   44|       |    #[error("Declaration not allowed in this context")]
   45|       |    DeclarationNotAllowed { span: SourceSpan },
   46|       |}
   47|       |
   48|       |impl ParseError {
   49|      3|    pub(crate) fn span(&self) -> SourceSpan {
   50|      3|        match self {
   51|      3|            ParseError::UnexpectedToken { span, .. } => *span,
   52|      0|            ParseError::UnexpectedEof { span } => *span,
   53|      0|            ParseError::InvalidUnaryOperator { span } => *span,
   54|      0|            ParseError::DeclarationNotAllowed { span } => *span,
   55|       |        }
   56|      3|    }
   57|       |}
   58|       |/// Diagnostic engine for collecting and reporting semantic errors and warnings
   59|       |#[derive(Default)]
   60|       |pub struct DiagnosticEngine {
   61|       |    pub diagnostics: Vec<Diagnostic>,
   62|       |    pub warnings_as_errors: bool,
   63|       |    pub disable_all_warnings: bool,
   64|       |}
   65|       |
   66|       |impl DiagnosticEngine {
   67|    852|    pub(crate) fn from_warnings(warnings: &[String]) -> Self {
   68|    852|        let warnings_as_errors = warnings.iter().any(|w| w == "error");
                                                                       ^0   ^0
   69|    852|        let disable_all_warnings = warnings.iter().any(|w| w == "no-warnings");
                                                                         ^0   ^0
   70|    852|        Self {
   71|    852|            diagnostics: Vec::new(),
   72|    852|            warnings_as_errors,
   73|    852|            disable_all_warnings,
   74|    852|        }
   75|    852|    }
   76|       |
   77|    224|    pub(crate) fn report_diagnostic(&mut self, diagnostic: Diagnostic) {
   78|    224|        self.diagnostics.push(diagnostic);
   79|    224|    }
   80|       |
   81|  1.87k|    pub(crate) fn has_errors(&self) -> bool {
   82|  1.87k|        self.diagnostics.iter().any(|d| d.level == DiagnosticLevel::Error)
                                                      ^160       ^160
   83|  1.87k|    }
   84|       |
   85|    276|    pub(crate) fn diagnostics(&self) -> &[Diagnostic] {
   86|    276|        &self.diagnostics
   87|    276|    }
   88|       |
   89|    179|    pub(crate) fn report<T: IntoDiagnostic>(&mut self, error: T) {
   90|    211|        for diagnostic in error.into_diagnostic() {
                                        ^179  ^179
   91|    211|            self.report_diagnostic(diagnostic);
   92|    211|        }
   93|    179|    }
   94|       |}
   95|       |
   96|       |pub trait IntoDiagnostic {
   97|       |    fn into_diagnostic(self) -> Vec<Diagnostic>;
   98|       |}
   99|       |
  100|       |impl IntoDiagnostic for ParseError {
  101|      3|    fn into_diagnostic(self) -> Vec<Diagnostic> {
  102|      3|        vec![Diagnostic {
  103|      3|            level: DiagnosticLevel::Error,
  104|      3|            message: self.to_string(),
  105|      3|            span: self.span(),
  106|      3|            ..Default::default()
  107|      3|        }]
  108|      3|    }
  109|       |}
  110|       |
  111|       |impl IntoDiagnostic for SemanticError {
  112|    176|    fn into_diagnostic(self) -> Vec<Diagnostic> {
  113|    176|        let mut diagnostics = vec![Diagnostic {
  114|    176|            level: DiagnosticLevel::Error,
  115|    176|            message: self.to_string(),
  116|    176|            span: self.span(),
  117|    176|            ..Default::default()
  118|    176|        }];
  119|       |
  120|     17|        if let SemanticError::Redefinition { first_def, .. }
  121|    176|        | SemanticError::RedefinitionWithDifferentType { first_def, .. } = &self
                                                                       ^1
  122|     18|        {
  123|     18|            diagnostics.push(Diagnostic {
  124|     18|                level: DiagnosticLevel::Note,
  125|     18|                message: "previous definition is here".to_string(),
  126|     18|                span: *first_def,
  127|     18|                ..Default::default()
  128|     18|            });
  129|    158|        }
  130|       |
  131|    176|        if let SemanticError::GenericMultipleDefault { first_def, .. } = &self {
                                                                     ^1
  132|      1|            diagnostics.push(Diagnostic {
  133|      1|                level: DiagnosticLevel::Note,
  134|      1|                message: "previous default association is here".to_string(),
  135|      1|                span: *first_def,
  136|      1|                ..Default::default()
  137|      1|            });
  138|    175|        }
  139|       |
  140|    176|        if let SemanticError::GenericDuplicateMatch { first_def, .. } = &self {
                                                                    ^2
  141|      2|            diagnostics.push(Diagnostic {
  142|      2|                level: DiagnosticLevel::Note,
  143|      2|                message: "previous association is here".to_string(),
  144|      2|                span: *first_def,
  145|      2|                ..Default::default()
  146|      2|            });
  147|    174|        }
  148|       |
  149|    176|        if let SemanticError::ConflictingLinkage { first_def, .. } = &self {
                                                                 ^4
  150|      4|            diagnostics.push(Diagnostic {
  151|      4|                level: DiagnosticLevel::Note,
  152|      4|                message: "previous declaration is here".to_string(),
  153|      4|                span: *first_def,
  154|      4|                ..Default::default()
  155|      4|            });
  156|    172|        }
  157|       |
  158|    176|        if let SemanticError::DuplicateMember { first_def, .. } = &self {
                                                              ^3
  159|      3|            diagnostics.push(Diagnostic {
  160|      3|                level: DiagnosticLevel::Note,
  161|      3|                message: "previous declaration is here".to_string(),
  162|      3|                span: *first_def,
  163|      3|                ..Default::default()
  164|      3|            });
  165|    173|        }
  166|       |
  167|    176|        if let SemanticError::ConflictingTypes { first_def, .. } = &self {
                                                               ^4
  168|      4|            diagnostics.push(Diagnostic {
  169|      4|                level: DiagnosticLevel::Note,
  170|      4|                message: "previous declaration is here".to_string(),
  171|      4|                span: *first_def,
  172|      4|                ..Default::default()
  173|      4|            });
  174|    172|        }
  175|       |
  176|       |        // Handle warnings
  177|    176|        if matches!(self, SemanticError::IncompatiblePointerComparison { .. }) {
                         ^175
  178|      1|            diagnostics[0].level = DiagnosticLevel::Warning;
  179|    175|        }
  180|       |
  181|    176|        diagnostics
  182|    176|    }
  183|       |}
  184|       |/// Semantic errors
  185|       |#[derive(Debug, thiserror::Error)]
  186|       |pub enum SemanticError {
  187|       |    #[error("variable has incomplete type 'void'")]
  188|       |    VariableOfVoidType { span: SourceSpan },
  189|       |    #[error("called object type '{ty}' is not a function or function pointer")]
  190|       |    CalledNonFunctionType { ty: String, span: SourceSpan },
  191|       |    #[error("Undeclared identifier '{name}'")]
  192|       |    UndeclaredIdentifier { name: NameId, span: SourceSpan },
  193|       |    #[error("redefinition of '{name}'")]
  194|       |    Redefinition {
  195|       |        name: NameId,
  196|       |        first_def: SourceSpan,
  197|       |        span: SourceSpan,
  198|       |    },
  199|       |    #[error("redefinition of '{name}' with a different type")]
  200|       |    RedefinitionWithDifferentType {
  201|       |        name: NameId,
  202|       |        first_def: SourceSpan,
  203|       |        span: SourceSpan,
  204|       |    },
  205|       |    #[error("type mismatch: expected {expected}, found {found}")]
  206|       |    TypeMismatch {
  207|       |        expected: String,
  208|       |        found: String,
  209|       |        span: SourceSpan,
  210|       |    },
  211|       |    #[error("Expression is not assignable (not an lvalue)")]
  212|       |    NotAnLvalue { span: SourceSpan },
  213|       |    #[error("Invalid operands for binary operation: have '{left_ty}' and '{right_ty}'")]
  214|       |    InvalidBinaryOperands {
  215|       |        left_ty: String,
  216|       |        right_ty: String,
  217|       |        span: SourceSpan,
  218|       |    },
  219|       |    #[error("Invalid operand for unary operation: have '{ty}'")]
  220|       |    InvalidUnaryOperand { ty: String, span: SourceSpan },
  221|       |    #[error("Initializer element is not a compile-time constant")]
  222|       |    NonConstantInitializer { span: SourceSpan },
  223|       |    #[error("invalid initializer")]
  224|       |    InvalidInitializer { span: SourceSpan },
  225|       |    #[error("Invalid use of void type in expression")]
  226|       |    InvalidUseOfVoid { span: SourceSpan },
  227|       |    #[error("conflicting types for '{name}'")]
  228|       |    ConflictingTypes {
  229|       |        name: String,
  230|       |        span: SourceSpan,
  231|       |        first_def: SourceSpan,
  232|       |    },
  233|       |    #[error("void function '{name}' should not return a value")]
  234|       |    VoidReturnWithValue { name: String, span: SourceSpan },
  235|       |    #[error("non-void function '{name}' should return a value")]
  236|       |    NonVoidReturnWithoutValue { name: String, span: SourceSpan },
  237|       |
  238|       |    #[error("invalid number of arguments: expected {expected}, found {found}")]
  239|       |    InvalidNumberOfArguments {
  240|       |        expected: usize,
  241|       |        found: usize,
  242|       |        span: SourceSpan,
  243|       |    },
  244|       |
  245|       |    #[error("invalid argument type for atomic builtin: {ty}")]
  246|       |    InvalidAtomicArgument { ty: String, span: SourceSpan },
  247|       |
  248|       |    #[error("excess elements in {kind} initializer")]
  249|       |    ExcessElements { kind: String, span: SourceSpan },
  250|       |
  251|       |    #[error("Unsupported feature: {feature}")]
  252|       |    UnsupportedFeature { feature: String, span: SourceSpan },
  253|       |
  254|       |    #[error("size of array has non-positive value")]
  255|       |    InvalidArraySize { span: SourceSpan },
  256|       |
  257|       |    #[error("invalid bit-field width")]
  258|       |    InvalidBitfieldWidth { span: SourceSpan },
  259|       |
  260|       |    #[error("bit-field width is not a constant expression")]
  261|       |    NonConstantBitfieldWidth { span: SourceSpan },
  262|       |
  263|       |    #[error("width of bit-field ({width} bits) exceeds width of its type ({type_width} bits)")]
  264|       |    BitfieldWidthExceedsType {
  265|       |        width: u16,
  266|       |        type_width: u16,
  267|       |        span: SourceSpan,
  268|       |    },
  269|       |
  270|       |    #[error("zero-width bit-field shall not specify a declarator")]
  271|       |    NamedZeroWidthBitfield { span: SourceSpan },
  272|       |
  273|       |    #[error("bit-field type '{ty}' is invalid")]
  274|       |    InvalidBitfieldType { ty: String, span: SourceSpan },
  275|       |
  276|       |    // Errors related to declaration specifiers
  277|       |    #[error("conflicting storage class specifiers")]
  278|       |    ConflictingStorageClasses { span: SourceSpan },
  279|       |    #[error("conflicting linkage for '{name}'")]
  280|       |    ConflictingLinkage {
  281|       |        name: String,
  282|       |        span: SourceSpan,
  283|       |        first_def: SourceSpan,
  284|       |    },
  285|       |    #[error("cannot combine with previous '{prev}' declaration specifier")]
  286|       |    ConflictingTypeSpecifiers { prev: String, span: SourceSpan },
  287|       |    #[error("'{spec}' function specifier appears on non-function declaration")]
  288|       |    InvalidFunctionSpecifier { spec: String, span: SourceSpan },
  289|       |    #[error("duplicate member '{name}'")]
  290|       |    DuplicateMember {
  291|       |        name: NameId,
  292|       |        span: SourceSpan,
  293|       |        first_def: SourceSpan,
  294|       |    },
  295|       |    #[error("member reference base type '{ty}' is not a structure or union")]
  296|       |    MemberAccessOnNonRecord { ty: String, span: SourceSpan },
  297|       |    #[error("no member named '{name}' in '{ty}'")]
  298|       |    MemberNotFound { name: NameId, ty: String, span: SourceSpan },
  299|       |    #[error("expected a typedef name, found {found}")]
  300|       |    ExpectedTypedefName { found: String, span: SourceSpan },
  301|       |    #[error("missing type specifier in declaration")]
  302|       |    MissingTypeSpecifier { span: SourceSpan },
  303|       |    #[error("static assertion failed: {message}")]
  304|       |    StaticAssertFailed { message: String, span: SourceSpan },
  305|       |    #[error("expression in static assertion is not constant")]
  306|       |    StaticAssertNotConstant { span: SourceSpan },
  307|       |    #[error("recursive type definition")]
  308|       |    RecursiveType { ty: TypeRef },
  309|       |    #[error("Invalid application of 'sizeof' to an incomplete type")]
  310|       |    SizeOfIncompleteType { ty: TypeRef, span: SourceSpan },
  311|       |    #[error("Invalid application of 'sizeof' to a function type")]
  312|       |    SizeOfFunctionType { span: SourceSpan },
  313|       |    #[error("Invalid application of '_Alignof' to an incomplete type")]
  314|       |    AlignOfIncompleteType { ty: TypeRef, span: SourceSpan },
  315|       |    #[error("Invalid application of '_Alignof' to a function type")]
  316|       |    AlignOfFunctionType { span: SourceSpan },
  317|       |    #[error("controlling expression type '{ty}' not compatible with any generic association")]
  318|       |    GenericNoMatch { ty: String, span: SourceSpan },
  319|       |
  320|       |    #[error("cannot take address of bit-field")]
  321|       |    AddressOfBitfield { span: SourceSpan },
  322|       |
  323|       |    #[error("cannot take address of 'register' variable")]
  324|       |    AddressOfRegister { span: SourceSpan },
  325|       |
  326|       |    #[error("cannot apply 'sizeof' to a bit-field")]
  327|       |    SizeOfBitfield { span: SourceSpan },
  328|       |
  329|       |    #[error("controlling expression type '{ty}' is an incomplete type")]
  330|       |    GenericIncompleteControl { ty: String, span: SourceSpan },
  331|       |
  332|       |    #[error("generic association specifies incomplete type '{ty}'")]
  333|       |    GenericIncompleteAssociation { ty: String, span: SourceSpan },
  334|       |
  335|       |    #[error("duplicate default association in generic selection")]
  336|       |    GenericMultipleDefault { span: SourceSpan, first_def: SourceSpan },
  337|       |
  338|       |    #[error("type '{ty}' in generic association compatible with previously specified type '{prev_ty}'")]
  339|       |    GenericDuplicateMatch {
  340|       |        ty: String,
  341|       |        prev_ty: String,
  342|       |        span: SourceSpan,
  343|       |        first_def: SourceSpan,
  344|       |    },
  345|       |
  346|       |    #[error("requested alignment is not a positive power of 2")]
  347|       |    InvalidAlignment { value: i64, span: SourceSpan },
  348|       |
  349|       |    #[error("requested alignment is not a constant expression")]
  350|       |    NonConstantAlignment { span: SourceSpan },
  351|       |
  352|       |    #[error("cannot assign to read-only location")]
  353|       |    AssignmentToReadOnly { span: SourceSpan },
  354|       |
  355|       |    #[error("incomplete type '{ty}'")]
  356|       |    IncompleteType { ty: String, span: SourceSpan },
  357|       |
  358|       |    #[error("function has incomplete return type")]
  359|       |    IncompleteReturnType { span: SourceSpan },
  360|       |
  361|       |    #[error("comparison of incompatible pointer types '{lhs}' and '{rhs}'")]
  362|       |    IncompatiblePointerComparison { lhs: String, rhs: String, span: SourceSpan },
  363|       |
  364|       |    #[error("'case' or 'default' label not in switch statement")]
  365|       |    CaseNotInSwitch { span: SourceSpan },
  366|       |
  367|       |    #[error("duplicate case value '{value}'")]
  368|       |    DuplicateCase { value: String, span: SourceSpan },
  369|       |
  370|       |    #[error("multiple default labels in one switch")]
  371|       |    MultipleDefaultLabels { span: SourceSpan },
  372|       |
  373|       |    #[error("flexible array member must be the last member of a structure")]
  374|       |    FlexibleArrayNotLast { span: SourceSpan },
  375|       |
  376|       |    #[error("flexible array member in otherwise empty structure")]
  377|       |    FlexibleArrayInEmptyStruct { span: SourceSpan },
  378|       |
  379|       |    #[error("restrict requires a pointer type")]
  380|       |    InvalidRestrict { span: SourceSpan },
  381|       |    #[error("invalid storage class for function parameter")]
  382|       |    InvalidStorageClassForParameter { span: SourceSpan },
  383|       |    #[error("function '{name}' declared '_Noreturn' contains a return statement")]
  384|       |    NoreturnFunctionHasReturn { name: String, span: SourceSpan },
  385|       |    #[error("function '{name}' declared '_Noreturn' can fall off the end")]
  386|       |    NoreturnFunctionFallsOff { name: String, span: SourceSpan },
  387|       |    #[error("unreachable code")]
  388|       |    UnreachableCode { span: SourceSpan },
  389|       |
  390|       |    #[error("alignment specifier cannot be used in a {context}")]
  391|       |    AlignmentNotAllowed { context: String, span: SourceSpan },
  392|       |
  393|       |    #[error("alignment specifier specifies {requested}-byte alignment, but {natural}-byte alignment is required")]
  394|       |    AlignmentTooLoose {
  395|       |        requested: u32,
  396|       |        natural: u32,
  397|       |        span: SourceSpan,
  398|       |    },
  399|       |
  400|       |    #[error("_Atomic qualifier cannot be used with {type_kind} type")]
  401|       |    InvalidAtomicQualifier { type_kind: String, span: SourceSpan },
  402|       |
  403|       |    #[error("_Atomic(type-name) specifier cannot be used with {reason}")]
  404|       |    InvalidAtomicSpecifier { reason: String, span: SourceSpan },
  405|       |
  406|       |    #[error("static in array declarator only allowed in function parameters")]
  407|       |    ArrayStaticOutsideParameter { span: SourceSpan },
  408|       |
  409|       |    #[error("type qualifiers in array declarator only allowed in function parameters")]
  410|       |    ArrayQualifierOutsideParameter { span: SourceSpan },
  411|       |
  412|       |    #[error("static in array declarator only allowed in outermost array type")]
  413|       |    ArrayStaticNotOutermost { span: SourceSpan },
  414|       |
  415|       |    #[error("type qualifiers in array declarator only allowed in outermost array type")]
  416|       |    ArrayQualifierNotOutermost { span: SourceSpan },
  417|       |
  418|       |    #[error("break statement not in loop or switch")]
  419|       |    BreakNotInLoop { span: SourceSpan },
  420|       |
  421|       |    #[error("continue statement not in loop statement")]
  422|       |    ContinueNotInLoop { span: SourceSpan },
  423|       |
  424|       |    #[error("subscripted value is not an array (have '{found}')")]
  425|       |    ExpectedArrayType { found: String, span: SourceSpan },
  426|       |
  427|       |    #[error("invalid designator in 'offsetof'")]
  428|       |    InvalidOffsetofDesignator { span: SourceSpan },
  429|       |}
  430|       |
  431|       |impl SemanticError {
  432|    176|    pub(crate) fn span(&self) -> SourceSpan {
  433|    176|        match self {
  434|      2|            SemanticError::InvalidAtomicQualifier { span, .. } => *span,
  435|      7|            SemanticError::InvalidAtomicSpecifier { span, .. } => *span,
  436|      1|            SemanticError::VariableOfVoidType { span } => *span,
  437|      1|            SemanticError::CalledNonFunctionType { span, .. } => *span,
  438|      3|            SemanticError::InvalidRestrict { span } => *span,
  439|     10|            SemanticError::InvalidStorageClassForParameter { span } => *span,
  440|      3|            SemanticError::UndeclaredIdentifier { span, .. } => *span,
  441|     17|            SemanticError::Redefinition { span, .. } => *span,
  442|      1|            SemanticError::RedefinitionWithDifferentType { span, .. } => *span,
  443|     10|            SemanticError::TypeMismatch { span, .. } => *span,
  444|      9|            SemanticError::NotAnLvalue { span } => *span,
  445|      2|            SemanticError::InvalidBinaryOperands { span, .. } => *span,
  446|      1|            SemanticError::InvalidUnaryOperand { span, .. } => *span,
  447|      0|            SemanticError::NonConstantInitializer { span } => *span,
  448|      1|            SemanticError::InvalidInitializer { span } => *span,
  449|      0|            SemanticError::InvalidUseOfVoid { span } => *span,
  450|      4|            SemanticError::ConflictingTypes { span, .. } => *span,
  451|      1|            SemanticError::VoidReturnWithValue { span, .. } => *span,
  452|      0|            SemanticError::NonVoidReturnWithoutValue { span, .. } => *span,
  453|      0|            SemanticError::InvalidNumberOfArguments { span, .. } => *span,
  454|      3|            SemanticError::InvalidAtomicArgument { span, .. } => *span,
  455|      1|            SemanticError::ExcessElements { span, .. } => *span,
  456|      1|            SemanticError::UnsupportedFeature { span, .. } => *span,
  457|      1|            SemanticError::InvalidArraySize { span } => *span,
  458|      0|            SemanticError::InvalidBitfieldWidth { span } => *span,
  459|      1|            SemanticError::NonConstantBitfieldWidth { span } => *span,
  460|      1|            SemanticError::InvalidBitfieldType { span, .. } => *span,
  461|      1|            SemanticError::BitfieldWidthExceedsType { span, .. } => *span,
  462|      2|            SemanticError::NamedZeroWidthBitfield { span } => *span,
  463|      3|            SemanticError::ConflictingStorageClasses { span } => *span,
  464|      4|            SemanticError::ConflictingLinkage { span, .. } => *span,
  465|      0|            SemanticError::ConflictingTypeSpecifiers { span, .. } => *span,
  466|      4|            SemanticError::InvalidFunctionSpecifier { span, .. } => *span,
  467|      3|            SemanticError::DuplicateMember { span, .. } => *span,
  468|      1|            SemanticError::MemberAccessOnNonRecord { span, .. } => *span,
  469|      1|            SemanticError::MemberNotFound { span, .. } => *span,
  470|      0|            SemanticError::ExpectedTypedefName { span, .. } => *span,
  471|      0|            SemanticError::MissingTypeSpecifier { span } => *span,
  472|      3|            SemanticError::StaticAssertFailed { span, .. } => *span,
  473|      1|            SemanticError::StaticAssertNotConstant { span } => *span,
  474|       |            SemanticError::RecursiveType { .. } => {
  475|       |                // For recursive types, we don't have a specific span, so use a dummy span
  476|      1|                SourceSpan::dummy()
  477|       |            }
  478|      3|            SemanticError::SizeOfIncompleteType { span, .. } => *span,
  479|      2|            SemanticError::SizeOfFunctionType { span } => *span,
  480|      2|            SemanticError::AlignOfIncompleteType { span, .. } => *span,
  481|      1|            SemanticError::AlignOfFunctionType { span } => *span,
  482|      1|            SemanticError::GenericNoMatch { span, .. } => *span,
  483|      2|            SemanticError::AddressOfBitfield { span } => *span,
  484|      2|            SemanticError::AddressOfRegister { span } => *span,
  485|      2|            SemanticError::SizeOfBitfield { span } => *span,
  486|      2|            SemanticError::GenericIncompleteControl { span, .. } => *span,
  487|      2|            SemanticError::GenericIncompleteAssociation { span, .. } => *span,
  488|      1|            SemanticError::GenericMultipleDefault { span, .. } => *span,
  489|      2|            SemanticError::GenericDuplicateMatch { span, .. } => *span,
  490|      1|            SemanticError::InvalidAlignment { span, .. } => *span,
  491|      1|            SemanticError::NonConstantAlignment { span } => *span,
  492|      8|            SemanticError::AssignmentToReadOnly { span } => *span,
  493|     11|            SemanticError::IncompleteType { span, .. } => *span,
  494|      1|            SemanticError::IncompatiblePointerComparison { span, .. } => *span,
  495|      2|            SemanticError::IncompleteReturnType { span } => *span,
  496|      1|            SemanticError::CaseNotInSwitch { span } => *span,
  497|      1|            SemanticError::DuplicateCase { span, .. } => *span,
  498|      0|            SemanticError::MultipleDefaultLabels { span } => *span,
  499|      1|            SemanticError::FlexibleArrayNotLast { span } => *span,
  500|      1|            SemanticError::FlexibleArrayInEmptyStruct { span } => *span,
  501|      2|            SemanticError::NoreturnFunctionHasReturn { span, .. } => *span,
  502|      1|            SemanticError::NoreturnFunctionFallsOff { span, .. } => *span,
  503|      0|            SemanticError::UnreachableCode { span } => *span,
  504|      6|            SemanticError::AlignmentNotAllowed { span, .. } => *span,
  505|      1|            SemanticError::AlignmentTooLoose { span, .. } => *span,
  506|      1|            SemanticError::ArrayStaticOutsideParameter { span } => *span,
  507|      1|            SemanticError::ArrayQualifierOutsideParameter { span } => *span,
  508|      4|            SemanticError::ArrayStaticNotOutermost { span } => *span,
  509|      2|            SemanticError::ArrayQualifierNotOutermost { span } => *span,
  510|      2|            SemanticError::BreakNotInLoop { span } => *span,
  511|      1|            SemanticError::ContinueNotInLoop { span } => *span,
  512|      0|            SemanticError::ExpectedArrayType { span, .. } => *span,
  513|      0|            SemanticError::InvalidOffsetofDesignator { span } => *span,
  514|       |        }
  515|    176|    }
  516|       |}
  517|       |
  518|       |/// Configurable error formatter using annotate_snippets
  519|       |pub struct ErrorFormatter {
  520|       |    pub show_source: bool,
  521|       |    pub show_hints: bool,
  522|       |    pub use_colors: bool,
  523|       |    pub max_context: usize,
  524|       |}
  525|       |
  526|       |impl Default for ErrorFormatter {
  527|     39|    fn default() -> Self {
  528|     39|        ErrorFormatter {
  529|     39|            show_source: true,
  530|     39|            show_hints: true,
  531|     39|            use_colors: true,
  532|     39|            max_context: 3,
  533|     39|        }
  534|     39|    }
  535|       |}
  536|       |
  537|       |impl ErrorFormatter {
  538|      0|    fn format_location(&self, diag: &Diagnostic, source_manager: &SourceManager) -> String {
  539|      0|        let path = source_manager
  540|      0|            .get_file_info(diag.span.source_id())
  541|      0|            .map(|fi| fi.path.to_str().unwrap_or("<unknown>"))
  542|      0|            .unwrap_or("<unknown>");
  543|       |
  544|       |        // Get line and column information
  545|      0|        let line_col = source_manager.get_line_column(diag.span.start());
  546|      0|        if let Some((line, col)) = line_col {
  547|      0|            format!("{}:{}:{}", path, line, col)
  548|       |        } else {
  549|      0|            path.to_string()
  550|       |        }
  551|      0|    }
  552|       |
  553|      1|    fn level<'a>(&self, diag: &Diagnostic) -> Level<'a> {
  554|      1|        match diag.level {
  555|      1|            DiagnosticLevel::Error => Level::ERROR,
  556|      0|            DiagnosticLevel::Warning => Level::WARNING,
  557|      0|            DiagnosticLevel::Note => Level::NOTE,
  558|       |        }
  559|      1|    }
  560|       |
  561|      1|    fn create_snippet<'a>(
  562|      1|        &self,
  563|      1|        span: SourceSpan,
  564|      1|        message: &'a str,
  565|      1|        source_manager: &'a SourceManager,
  566|      1|    ) -> Snippet<'a, annotate_snippets::Annotation<'a>> {
  567|      1|        let source_buffer = source_manager.get_buffer(span.source_id());
  568|      1|        let source = std::str::from_utf8(source_buffer).unwrap_or("");
  569|      1|        let path = source_manager
  570|      1|            .get_file_info(span.source_id())
  571|      1|            .map(|fi| fi.path.to_str().unwrap_or("<unknown>"))
  572|      1|            .unwrap_or("<unknown>");
  573|       |
  574|      1|        let mut snippet = Snippet::source(source).line_start(1).path(path);
  575|       |
  576|      1|        let annotation_kind = AnnotationKind::Primary;
  577|       |
  578|      1|        snippet = snippet.annotation(
  579|      1|            annotation_kind
  580|      1|                .span(span.start().offset() as usize..span.end().offset() as usize)
  581|      1|                .label(message),
  582|       |        );
  583|       |
  584|      1|        snippet
  585|      1|    }
  586|       |
  587|       |    /// Format a single diagnostic with rich source code context
  588|      1|    fn format_diagnostic(&self, diag: &Diagnostic, source_manager: &SourceManager) -> String {
  589|      1|        let renderer = if self.use_colors {
  590|      1|            Renderer::styled().decor_style(DecorStyle::Unicode)
  591|       |        } else {
  592|      0|            Renderer::plain()
  593|       |        };
  594|       |
  595|       |        // If it's a built-in source ID (e.g. command line define), simple print
  596|      1|        if diag.span.is_source_id_builtin() {
  597|      0|            return format!("{}: {}", self.format_location(diag, source_manager), diag.message);
  598|      1|        }
  599|       |
  600|       |        // Primary error snippet
  601|      1|        let snippet = self.create_snippet(diag.span, &diag.message, source_manager);
  602|       |        // Use primary_title instead of title
  603|      1|        let mut group = self.level(diag).primary_title(&diag.message).element(snippet);
  604|       |
  605|      1|        for hint in &diag.hints {
                          ^0
  606|      0|            group = group.element(Level::HELP.message(hint));
  607|      0|        }
  608|       |
  609|       |        // Handle macro expansion history
  610|       |        // We must collect strings first to ensure they live long enough for the snippets
  611|      1|        let mut expansion_history = Vec::new();
  612|      1|        let mut current_id = diag.span.source_id();
  613|       |
  614|      1|        while let Some(file_info) = source_manager.get_file_info(current_id) {
  615|      1|            if let Some(include_loc) = file_info.include_loc {
                                      ^0
  616|       |                // Determine if this is a macro expansion (virtual file) or an include
  617|      0|                let is_macro = file_info.path.to_str().is_some_and(|s| s.starts_with("<macro_"));
  618|      0|                let note_msg = if is_macro {
  619|      0|                    let macro_name = file_info
  620|      0|                        .path
  621|      0|                        .to_str()
  622|      0|                        .unwrap()
  623|      0|                        .trim_start_matches("<macro_")
  624|      0|                        .trim_end_matches('>');
  625|      0|                    format!("expanded from macro '{}'", macro_name)
  626|       |                } else {
  627|      0|                    "included from here".to_string()
  628|       |                };
  629|       |
  630|       |                // For visualization, use a 1-char span at the include/expansion location
  631|      0|                let exp_span = SourceSpan::new_with_length(include_loc.source_id(), include_loc.offset(), 1);
  632|      0|                expansion_history.push((exp_span, note_msg));
  633|       |
  634|      0|                current_id = include_loc.source_id();
  635|       |            } else {
  636|      1|                break;
  637|       |            }
  638|       |        }
  639|       |
  640|      1|        for (span, msg) in &expansion_history {
                           ^0    ^0
  641|      0|            let exp_snippet = self.create_snippet(*span, msg, source_manager);
  642|      0|            group = group.element(exp_snippet);
  643|      0|        }
  644|       |
  645|      1|        let report = &[group];
  646|      1|        renderer.render(report).to_string()
  647|      1|    }
  648|       |
  649|       |    /// Print all diagnostics to stderr
  650|     39|    pub(crate) fn print_diagnostics(&self, diagnostics: &[Diagnostic], source_manager: &SourceManager) {
  651|     40|        for diag in diagnostics {
                          ^1
  652|      1|            let formatted = self.format_diagnostic(diag, source_manager);
  653|      1|            eprintln!("{}", formatted);
  654|      1|        }
  655|     39|    }
  656|       |}

/app/src/driver/cli.rs:
    1|       |//! CLI parsing and configuration module
    2|       |//!
    3|       |//! This module handles command-line argument parsing using clap and
    4|       |//! provides configuration structures for the compiler driver.
    5|       |
    6|       |use clap::{Args, Parser as CliParser};
    7|       |use std::path::PathBuf;
    8|       |use target_lexicon::Triple;
    9|       |
   10|       |use crate::{
   11|       |    driver::artifact::CompilePhase,
   12|       |    lang_options::{CStandard, LangOptions},
   13|       |};
   14|       |
   15|       |/// CLI interface using clap
   16|       |#[derive(CliParser, Debug)]
   17|       |#[clap(name = "cendol", about = "C11 Compiler written in Rust")]
   18|       |pub struct Cli {
   19|       |    /// Input C source files
   20|       |    #[clap(value_parser, required = true)]
   21|       |    pub input_files: Vec<PathBuf>,
   22|       |
   23|       |    /// Output file for AST dump
   24|       |    #[clap(short, long, value_name = "FILE")]
   25|       |    pub output: Option<PathBuf>,
   26|       |
   27|       |    /// Enable verbose diagnostic output
   28|       |    #[clap(short, long)]
   29|       |    pub verbose: bool,
   30|       |
   31|       |    /// Dump AST after parser phase
   32|       |    #[clap(long)]
   33|       |    pub dump_ast_after_parser: bool,
   34|       |
   35|       |    /// Dump AST after semantic lowering phase
   36|       |    #[clap(long)]
   37|       |    pub dump_ast_after_semantic_lowering: bool,
   38|       |
   39|       |    /// Dump MIR (Mid-level Intermediate Representation) to console
   40|       |    #[clap(long)]
   41|       |    pub dump_mir: bool,
   42|       |
   43|       |    /// Dump Cranelift IR (Intermediate Representation) to console
   44|       |    #[clap(long)]
   45|       |    pub dump_cranelift: bool,
   46|       |
   47|       |    /// Preprocess only, output preprocessed source to stdout
   48|       |    #[clap(short = 'E')]
   49|       |    pub preprocess_only: bool,
   50|       |
   51|       |    /// Preprocessor options
   52|       |    #[clap(flatten)]
   53|       |    pub preprocessor: PreprocessorOptions,
   54|       |
   55|       |    /// Suppress line markers in preprocessor output
   56|       |    #[clap(short = 'P')]
   57|       |    pub suppress_line_markers: bool,
   58|       |
   59|       |    /// Include search paths
   60|       |    #[clap(short = 'I', long = "include-path", value_name = "DIR", action = clap::ArgAction::Append)]
   61|       |    pub include_paths: Vec<PathBuf>,
   62|       |
   63|       |    /// Preprocessor macro definitions
   64|       |    #[clap(short = 'D', long = "define", value_name = "NAME[=VALUE]", action = clap::ArgAction::Append)]
   65|       |    pub defines: Vec<String>,
   66|       |
   67|       |    /// Compiler warnings (e.g., -Wall, -Wshadow)
   68|       |    #[clap(short = 'W', action = clap::ArgAction::Append)]
   69|       |    pub warnings: Vec<String>,
   70|       |
   71|       |    /// Issue all the warnings demanded by strict ISO C
   72|       |    #[clap(long)]
   73|       |    pub pedantic: bool,
   74|       |
   75|       |    /// Issue all the warnings demanded by strict ISO C as errors
   76|       |    #[clap(long)]
   77|       |    pub pedantic_errors: bool,
   78|       |
   79|       |    /// Set C language standard (e.g., c99, c11)
   80|       |    #[clap(long = "std", value_name = "STANDARD")]
   81|       |    pub c_standard: Option<CStandard>,
   82|       |
   83|       |    /// Target triple (e.g. x86_64-unknown-linux-gnu)
   84|       |    #[clap(long = "target", value_name = "TRIPLE")]
   85|       |    pub target: Option<String>,
   86|       |
   87|       |    /// Optimization level (e.g., -O0, -O1, -O2, -O3, -Os, -Oz)
   88|       |    #[clap(short = 'O', action = clap::ArgAction::Set)]
   89|       |    pub optimization: Option<String>,
   90|       |
   91|       |    /// Linked libraries (e.g., -lm)
   92|       |    #[clap(short = 'l', action = clap::ArgAction::Append)]
   93|       |    pub libraries: Vec<String>,
   94|       |
   95|       |    /// Library search paths (e.g., -L/usr/local/lib)
   96|       |    #[clap(short = 'L', action = clap::ArgAction::Append)]
   97|       |    pub library_paths: Vec<PathBuf>,
   98|       |
   99|       |    /// Compile only, do not link
  100|       |    #[clap(short = 'c')]
  101|       |    pub compile_only: bool,
  102|       |
  103|       |    /// Generate debug information
  104|       |    #[clap(short = 'g')]
  105|       |    pub debug_info: bool,
  106|       |
  107|       |    /// Use a specific linker
  108|       |    #[clap(long = "fuse-ld", value_name = "LINKER")]
  109|       |    pub fuse_ld: Option<String>,
  110|       |}
  111|       |
  112|       |#[derive(Args, Debug)]
  113|       |pub struct PreprocessorOptions {
  114|       |    /// Maximum include depth
  115|       |    #[clap(long, default_value = "100")]
  116|       |    pub max_include_depth: usize,
  117|       |}
  118|       |
  119|       |/// input file can be path to file or string buffer pair (filename, buffer)
  120|       |#[derive(Debug, Clone)]
  121|       |pub enum PathOrBuffer {
  122|       |    Path(PathBuf),
  123|       |    Buffer(String, Vec<u8>),
  124|       |}
  125|       |
  126|       |/// Configuration for compilation
  127|       |#[derive(Debug)]
  128|       |pub struct CompileConfig {
  129|       |    pub input_files: Vec<PathOrBuffer>,
  130|       |    pub output_path: Option<PathBuf>,
  131|       |    pub stop_after: CompilePhase,
  132|       |
  133|       |    pub verbose: bool,
  134|       |    pub preprocessor: crate::pp::PPConfig,
  135|       |    pub suppress_line_markers: bool,
  136|       |    pub defines: Vec<(String, Option<String>)>, // NAME -> VALUE
  137|       |    pub warnings: Vec<String>,
  138|       |    pub lang_options: LangOptions,
  139|       |    pub target: Triple,
  140|       |
  141|       |    pub optimization: Option<String>,
  142|       |    pub libraries: Vec<String>,
  143|       |    pub library_paths: Vec<PathBuf>,
  144|       |    pub compile_only: bool,
  145|       |    pub debug_info: bool,
  146|       |    pub fuse_ld: Option<String>,
  147|       |}
  148|       |
  149|       |impl Default for CompileConfig {
  150|    813|    fn default() -> Self {
  151|    813|        Self {
  152|    813|            input_files: Vec::new(),
  153|    813|            output_path: None,
  154|    813|            stop_after: CompilePhase::EmitObject,
  155|    813|            verbose: false,
  156|    813|            preprocessor: crate::pp::PPConfig::default(),
  157|    813|            suppress_line_markers: false,
  158|    813|            defines: Vec::new(),
  159|    813|            warnings: Vec::new(),
  160|    813|            lang_options: LangOptions::default(),
  161|    813|            target: Triple::host(),
  162|    813|            optimization: None,
  163|    813|            libraries: Vec::new(),
  164|    813|            library_paths: Vec::new(),
  165|    813|            compile_only: false,
  166|    813|            debug_info: false,
  167|    813|            fuse_ld: None,
  168|    813|        }
  169|    813|    }
  170|       |}
  171|       |
  172|       |impl CompileConfig {
  173|       |    /// Create a new CompileConfig from a string of source code
  174|       |    /// it used by tests infrastructure
  175|       |    #[cfg(test)]
  176|    775|    pub(crate) fn from_virtual_file(source: String, stop_after: CompilePhase) -> Self {
  177|    775|        let filename = "example.c";
  178|    775|        let source = source.into_bytes();
  179|       |
  180|    775|        Self {
  181|    775|            input_files: vec![PathOrBuffer::Buffer(filename.to_string(), source)],
  182|    775|            stop_after,
  183|    775|            target: Triple::host(),
  184|    775|            ..Default::default()
  185|    775|        }
  186|    775|    }
  187|       |}
  188|       |
  189|       |impl Cli {
  190|       |    /// Validate input files and check for option-like filenames
  191|      2|    fn validate_input_files(&self) -> Result<(), String> {
  192|      3|        for input_file in &self.input_files {
                          ^2
  193|      2|            let file_name = input_file.to_string_lossy();
  194|       |            // Allow files starting with '-' if they exist, or if they have an extension that looks like a C file
  195|      2|            if file_name.starts_with('-') && !input_file.exists() {
                                                           ^1
  196|       |                // If it starts with - and doesn't exist, it might be an unrecognized flag
  197|       |                // but clap should have handled it if it was a valid flag.
  198|       |                // However, some flags like -O2 or -Wshadow might not be explicitly defined in clap yet.
  199|       |                // So we should only error if it's definitely NOT meant to be a flag.
  200|       |
  201|       |                // For now, let's keep it but maybe we should allow it if we want to ignore unknown flags?
  202|       |                // Actually, the user wants us to support these flags.
  203|      1|                return Err(format!("File '{}' not found: No such file or directory", file_name)
  204|      1|                    + "\n"
  205|      1|                    + "If this is meant to be a command-line option, place it before the filename.\n"
  206|      1|                    + &format!(
  207|      1|                        "Example: {} -o output_file",
  208|      1|                        std::env::args().next().unwrap_or("cendol".to_string())
  209|      1|                    ));
  210|      1|            }
  211|       |        }
  212|      1|        Ok(())
  213|      2|    }
  214|       |
  215|       |    /// Convert CLI arguments into compilation configuration
  216|      2|    pub(crate) fn into_config(self) -> Result<CompileConfig, String> {
  217|       |        // Validate input files first
  218|      2|        self.validate_input_files()?;
                                                 ^1
  219|       |
  220|       |        // Parse defines
  221|      1|        let defines = self
  222|      1|            .defines
  223|      1|            .iter()
  224|      2|            .map(|def| {
                           ^1
  225|      2|                if let Some(eq_pos) = def.find('=') {
                                          ^1
  226|      1|                    let name = def[..eq_pos].to_string();
  227|      1|                    let value = Some(def[eq_pos + 1..].to_string());
  228|      1|                    (name, value)
  229|       |                } else {
  230|      1|                    (def.clone(), None)
  231|       |                }
  232|      2|            })
  233|      1|            .collect();
  234|       |
  235|       |        // Handle -Wall flag by adding "all" to warnings if -Wall is specified
  236|       |        // Actually, with short='W' and append, -Wall will result in "all" in warnings.
  237|       |        // Handle -Wall flag by adding "all" to warnings if -Wall is specified
  238|       |        // Actually, with short='W' and append, -Wall will result in "all" in warnings.
  239|      1|        let mut warnings = self.warnings;
  240|       |
  241|      1|        if self.pedantic {
  242|      0|            warnings.push("pedantic".to_string());
  243|      1|        }
  244|      1|        if self.pedantic_errors {
  245|      0|            warnings.push("pedantic-errors".to_string());
  246|      1|        }
  247|       |
  248|       |        // Build language options
  249|       |
  250|      1|        let lang_options = LangOptions {
  251|      1|            c_standard: self.c_standard,
  252|      1|        };
  253|       |
  254|       |        // Build preprocessor configuration with include paths
  255|      1|        let mut system_include_paths = Vec::new();
  256|       |
  257|       |        // Add user-specified include paths as system include paths
  258|      2|        for path in &self.include_paths {
                          ^1
  259|      1|            system_include_paths.push(path.clone());
  260|      1|        }
  261|       |
  262|       |        // Add default system include paths
  263|      1|        if std::path::Path::new("custom-include").exists() {
  264|      1|            system_include_paths.push(PathBuf::from("custom-include"));
  265|      1|        }
                      ^0
  266|      1|        system_include_paths.push(PathBuf::from("/usr/include"));
  267|       |
  268|       |        // Add architecture-specific include paths
  269|      1|        let arch_paths = ["/usr/include/x86_64-linux-gnu"];
  270|       |
  271|      2|        for arch_path in &arch_paths {
                          ^1
  272|      1|            let path = PathBuf::from(arch_path);
  273|      1|            if path.exists() {
  274|      1|                system_include_paths.push(path);
  275|      1|            }
                          ^0
  276|       |        }
  277|       |
  278|      1|        let stop_after = if self.preprocess_only {
  279|      0|            CompilePhase::Preprocess
  280|      1|        } else if self.dump_ast_after_parser {
  281|      0|            CompilePhase::Parse
  282|      1|        } else if self.dump_ast_after_semantic_lowering {
  283|      0|            CompilePhase::SemanticLowering
  284|      1|        } else if self.dump_mir {
  285|      1|            CompilePhase::Mir
  286|      0|        } else if self.dump_cranelift {
  287|      0|            CompilePhase::Cranelift
  288|       |        } else {
  289|      0|            CompilePhase::EmitObject
  290|       |        };
  291|       |
  292|      1|        let target_triple = if let Some(t) = self.target {
  293|      1|            t.parse::<Triple>()
  294|      1|                .map_err(|e| format!("Invalid target triple: {}", e))?
                                           ^0      ^0                              ^0
  295|       |        } else {
  296|      0|            Triple::host()
  297|       |        };
  298|       |
  299|      1|        Ok(CompileConfig {
  300|      1|            input_files: self.input_files.into_iter().map(PathOrBuffer::Path).collect(),
  301|      1|            output_path: self.output,
  302|      1|            stop_after,
  303|      1|            verbose: self.verbose,
  304|      1|            preprocessor: crate::pp::PPConfig {
  305|      1|                max_include_depth: self.preprocessor.max_include_depth,
  306|      1|                system_include_paths,
  307|      1|                target: target_triple.clone(),
  308|      1|                ..Default::default()
  309|      1|            },
  310|      1|            suppress_line_markers: self.suppress_line_markers,
  311|      1|            defines,
  312|      1|            warnings,
  313|      1|            lang_options,
  314|      1|            target: target_triple,
  315|      1|            optimization: self.optimization,
  316|      1|            libraries: self.libraries,
  317|      1|            library_paths: self.library_paths,
  318|      1|            compile_only: self.compile_only,
  319|      1|            debug_info: self.debug_info,
  320|      1|            fuse_ld: self.fuse_ld,
  321|      1|        })
  322|      2|    }
  323|       |}
  324|       |
  325|       |#[cfg(test)]
  326|       |mod tests {
  327|       |    use super::*;
  328|       |    use std::path::PathBuf;
  329|       |
  330|       |    #[test]
  331|      1|    fn test_cli_into_config_and_validation() {
  332|       |        // Test case: Valid configuration with defines and specific stop_after
  333|      1|        let cli = Cli {
  334|      1|            input_files: vec![PathBuf::from("test.c")],
  335|      1|            output: Some(PathBuf::from("out")),
  336|      1|            verbose: true,
  337|      1|            dump_ast_after_parser: false,
  338|      1|            dump_ast_after_semantic_lowering: false,
  339|      1|            dump_mir: true,
  340|      1|            dump_cranelift: false,
  341|      1|            preprocess_only: false,
  342|      1|            preprocessor: PreprocessorOptions { max_include_depth: 50 },
  343|      1|            suppress_line_markers: true,
  344|      1|            include_paths: vec![PathBuf::from("inc")],
  345|      1|            defines: vec!["FOO=1".to_string(), "BAR".to_string()],
  346|      1|            warnings: vec!["all".to_string()],
  347|      1|            pedantic: false,
  348|      1|            pedantic_errors: false,
  349|      1|            c_standard: None,
  350|      1|            target: Some("x86_64-unknown-linux-gnu".to_string()),
  351|      1|            optimization: Some("2".to_string()),
  352|      1|            libraries: vec!["m".to_string()],
  353|      1|            library_paths: vec![PathBuf::from("/lib")],
  354|      1|            compile_only: true,
  355|      1|            debug_info: true,
  356|      1|            fuse_ld: Some("lld".to_string()),
  357|      1|        };
  358|       |
  359|      1|        let config = cli.into_config().expect("Failed to create config");
  360|       |
  361|      1|        assert_eq!(config.fuse_ld, Some("lld".to_string()));
  362|      1|        assert_eq!(config.stop_after, CompilePhase::Mir);
  363|      1|        assert!(config.verbose);
  364|      1|        assert!(config.suppress_line_markers);
  365|      1|        assert_eq!(config.preprocessor.max_include_depth, 50);
  366|      1|        assert_eq!(config.target.to_string(), "x86_64-unknown-linux-gnu");
  367|       |
  368|      1|        let defines: Vec<_> = config.defines.into_iter().collect();
  369|      1|        assert!(defines.contains(&("FOO".to_string(), Some("1".to_string()))));
  370|      1|        assert!(defines.contains(&("BAR".to_string(), None)));
  371|       |
  372|       |        // Test error case: Input file starting with '-' that does not exist
  373|      1|        let cli_error = Cli {
  374|      1|            input_files: vec![PathBuf::from("-nonexistent")],
  375|      1|            output: None,
  376|      1|            verbose: false,
  377|      1|            dump_ast_after_parser: false,
  378|      1|            dump_ast_after_semantic_lowering: false,
  379|      1|            dump_mir: false,
  380|      1|            dump_cranelift: false,
  381|      1|            preprocess_only: false,
  382|      1|            preprocessor: PreprocessorOptions { max_include_depth: 100 },
  383|      1|            suppress_line_markers: false,
  384|      1|            include_paths: vec![],
  385|      1|            defines: vec![],
  386|      1|            warnings: vec![],
  387|      1|            pedantic: false,
  388|      1|            pedantic_errors: false,
  389|      1|            c_standard: None,
  390|      1|            target: None,
  391|      1|            optimization: None,
  392|      1|            libraries: vec![],
  393|      1|            library_paths: vec![],
  394|      1|            compile_only: false,
  395|      1|            debug_info: false,
  396|      1|            fuse_ld: None,
  397|      1|        };
  398|       |
  399|      1|        let err = cli_error.into_config().unwrap_err();
  400|      1|        assert!(err.contains("File '-nonexistent' not found"));
  401|      1|        assert!(err.contains("meant to be a command-line option"));
  402|      1|    }
  403|       |}

/app/src/driver/compiler.rs:
    1|       |//! Core compilation pipeline orchestration module
    2|       |//!
    3|       |//! This module contains the main compiler driver that orchestrates
    4|       |//! the compilation pipeline including preprocessing, lexing, parsing,
    5|       |//! semantic analysis, and output generation.
    6|       |
    7|       |use indexmap::IndexMap;
    8|       |
    9|       |use crate::ast::dumper::AstDumper;
   10|       |use crate::ast::{Ast, NodeKind, NodeRef, ParsedAst, SourceId};
   11|       |use crate::codegen::{ClifGen, ClifOutput, EmitKind};
   12|       |use crate::diagnostic::{Diagnostic, DiagnosticEngine, DiagnosticLevel};
   13|       |use crate::driver::cli::PathOrBuffer;
   14|       |use crate::mir::validation::MirValidator;
   15|       |use crate::parser::{Lexer, Token};
   16|       |
   17|       |use super::artifact::{CompileArtifact, CompilePhase, PipelineOutputs};
   18|       |use crate::codegen::MirGen;
   19|       |use crate::mir::MirProgram;
   20|       |use crate::mir::dumper::{MirDumpConfig, MirDumper};
   21|       |use crate::parser::Parser;
   22|       |use crate::pp::{PPToken, Preprocessor, dumper::PPDumper};
   23|       |use crate::semantic::{SymbolTable, TypeRegistry};
   24|       |use crate::source_manager::SourceManager;
   25|       |
   26|       |use super::cli::CompileConfig;
   27|       |
   28|       |/// Main compiler driver
   29|       |pub struct CompilerDriver {
   30|       |    config: CompileConfig,
   31|       |    pub(crate) diagnostics: DiagnosticEngine,
   32|       |    pub(crate) source_manager: SourceManager,
   33|       |}
   34|       |
   35|       |impl CompilerDriver {
   36|       |    /// Create a new compiler driver from CLI arguments
   37|      0|    pub fn new(cli: super::cli::Cli) -> Result<Self, String> {
   38|      0|        let config = cli.into_config()?;
   39|      0|        Ok(Self::from_config(config))
   40|      0|    }
   41|       |
   42|       |    /// Create a new compiler driver from configuration
   43|    813|    pub(crate) fn from_config(config: CompileConfig) -> Self {
   44|    813|        let diagnostics = DiagnosticEngine::from_warnings(&config.warnings);
   45|    813|        CompilerDriver {
   46|    813|            diagnostics,
   47|    813|            source_manager: SourceManager::new(),
   48|    813|            config,
   49|    813|        }
   50|    813|    }
   51|       |
   52|    813|    pub(crate) fn run_pipeline(&mut self, stop_after: CompilePhase) -> Result<PipelineOutputs, PipelineError> {
   53|    813|        let mut outputs = PipelineOutputs {
   54|    813|            units: IndexMap::new(),
   55|    813|            external_object_files: Vec::new(),
   56|    813|        };
   57|       |
   58|       |        // Process each input file
   59|    813|        let input_files = std::mem::take(&mut self.config.input_files);
   60|  1.46k|        for input_file in input_files {
                          ^813
   61|       |            // Check if input file is an object file or library that should be passed to linker directly
   62|    813|            let is_external_object = match &input_file {
   63|      0|                PathOrBuffer::Path(path) => {
   64|      0|                    if let Some(ext) = path.extension().and_then(|s| s.to_str()) {
   65|      0|                        matches!(ext, "o" | "obj" | "a" | "so" | "dylib" | "dll")
   66|       |                    } else {
   67|      0|                        false
   68|       |                    }
   69|       |                }
   70|    813|                PathOrBuffer::Buffer(_, _) => false,
   71|       |            };
   72|       |
   73|    813|            if is_external_object && let PathOrBuffer::Path(path) = input_file {
                                                                          ^0      ^0
   74|      0|                outputs.external_object_files.push(path);
   75|      0|                continue;
   76|    813|            }
   77|       |
   78|    813|            let source_id = match input_file {
   79|      0|                PathOrBuffer::Path(path) => match self.source_manager.add_file_from_path(&path, None) {
   80|      0|                    Ok(id) => id,
   81|      0|                    Err(e) => return Err(PipelineError::IoError(e)),
   82|       |                },
   83|    813|                PathOrBuffer::Buffer(path, buffer) => self.source_manager.add_buffer(buffer, &path, None),
   84|       |            };
   85|       |
   86|    813|            let unit_output = self.run_translation_unit(source_id, stop_after)?;
                              ^655                                                          ^158
   87|    655|            outputs.units.insert(source_id, unit_output);
   88|       |        }
   89|       |
   90|    655|        Ok(outputs)
   91|    813|    }
   92|       |
   93|    813|    fn run_translation_unit(
   94|    813|        &mut self,
   95|    813|        source_id: SourceId,
   96|    813|        stop_after: CompilePhase,
   97|    813|    ) -> Result<CompileArtifact, PipelineError> {
   98|    813|        let mut out = CompileArtifact::default();
   99|       |
  100|       |        // Preprocessing phase
  101|    813|        let pp_tokens = self.run_preprocessor(source_id)?;
                                                                      ^0
  102|    813|        if stop_after == CompilePhase::Preprocess {
  103|      0|            out.preprocessed = Some(pp_tokens);
  104|      0|            return Ok(out);
  105|    813|        }
  106|       |
  107|       |        // Lexing phase
  108|    813|        let tokens = self.run_lexer(&pp_tokens)?;
                                                             ^0
  109|    813|        if stop_after == CompilePhase::Lex {
  110|    251|            out.lexed = Some(tokens);
  111|    251|            return Ok(out);
  112|    562|        }
  113|       |
  114|       |        // parsing phase
  115|    562|        let parsed_ast = self.run_parser(&tokens)?;
                                                               ^0
  116|    562|        if stop_after == CompilePhase::Parse {
  117|     28|            out.parsed_ast = Some(parsed_ast);
  118|     28|            return Ok(out);
  119|    534|        }
  120|       |
  121|       |        // semantic lowering (Symbol Resolution & AST Construction)
  122|    534|        let (ast, symbol_table, registry) = self.visit_parsed_ast(parsed_ast)?;
                           ^451 ^451          ^451                                         ^83
  123|    451|        if stop_after == CompilePhase::SemanticLowering {
  124|    167|            out.ast = Some(ast);
  125|    167|            out.type_registry = Some(registry);
  126|    167|            out.symbol_table = Some(symbol_table);
  127|    167|            return Ok(out);
  128|    284|        }
  129|       |
  130|       |        // semantic analyzer & MIR generation phase
  131|    284|        let mir_program = self.visit_ast(ast, symbol_table, registry)?;
                          ^209                                                     ^75
  132|    209|        if stop_after == CompilePhase::Mir {
  133|    147|            out.mir_program = Some(mir_program);
  134|    147|            return Ok(out);
  135|     62|        }
  136|       |
  137|       |        // Cranelift code generation phase
  138|     62|        let emit_kind = if stop_after == CompilePhase::Cranelift {
  139|     24|            EmitKind::Clif
  140|       |        } else {
  141|     38|            EmitKind::Object
  142|       |        };
  143|     62|        let cl_output = self.run_codegen(mir_program, emit_kind)?;
                                                                              ^0
  144|       |
  145|     62|        match cl_output {
  146|     24|            ClifOutput::ClifDump(dump) => {
  147|     24|                out.clif_dump = Some(dump);
  148|     24|            }
  149|     38|            ClifOutput::ObjectFile(obj) => {
  150|     38|                out.object_file = Some(obj);
  151|     38|            }
  152|       |        }
  153|       |
  154|     62|        Ok(out)
  155|    813|    }
  156|       |
  157|    813|    fn run_preprocessor(&mut self, source_id: SourceId) -> Result<Vec<PPToken>, PipelineError> {
  158|    813|        let mut preprocessor = Preprocessor::new(
  159|    813|            &mut self.source_manager,
  160|    813|            &mut self.diagnostics,
  161|    813|            &self.config.preprocessor,
  162|       |        );
  163|       |
  164|       |        // Preprocessor is dropped here, releasing the borrow on diagnostics
  165|    813|        match preprocessor.process(source_id, &self.config.preprocessor) {
  166|    813|            Ok(t) => Ok(t),
  167|      0|            Err(e) => {
  168|       |                // Report the specific preprocessor error
  169|      0|                self.diagnostics.report_diagnostic(e.into());
  170|      0|                Err(PipelineError::Fatal)
  171|       |            }
  172|       |        }
  173|    813|    }
  174|       |
  175|    813|    fn run_lexer(&mut self, pp_tokens: &[PPToken]) -> Result<Vec<Token>, PipelineError> {
  176|    813|        let tokens = {
  177|    813|            let mut lexer = Lexer::new(pp_tokens);
  178|    813|            lexer.tokenize_all()
  179|       |        };
  180|       |
  181|       |        // Check for lexing errors and stop if any
  182|    813|        self.check_diagnostics_and_return_if_error()?;
                                                                  ^0
  183|       |
  184|    813|        Ok(tokens)
  185|    813|    }
  186|       |
  187|    562|    fn run_parser(&mut self, tokens: &[Token]) -> Result<ParsedAst, PipelineError> {
  188|       |        // Parsing phase
  189|    562|        let mut parsed_ast = ParsedAst::new();
  190|    562|        let mut parser = Parser::new(tokens, &mut parsed_ast, &mut self.diagnostics);
  191|    562|        match parser.parse_translation_unit() {
  192|    562|            Ok(_) => Ok(parsed_ast),
  193|      0|            Err(e) => {
  194|      0|                self.diagnostics.report(e);
  195|      0|                Err(PipelineError::Fatal)
  196|       |            }
  197|       |        }
  198|    562|    }
  199|       |
  200|    534|    fn visit_parsed_ast(&mut self, parsed_ast: ParsedAst) -> Result<(Ast, SymbolTable, TypeRegistry), PipelineError> {
  201|    534|        let mut symbol_table = SymbolTable::new();
  202|       |        // Use the target triple from configuration to initialize TypeRegistry
  203|    534|        let mut registry = TypeRegistry::new(self.config.target.clone());
  204|    534|        let mut ast = Ast::new();
  205|       |
  206|       |        use crate::semantic::lowering::visit_ast;
  207|    534|        visit_ast(
  208|    534|            &parsed_ast,
  209|    534|            &mut ast,
  210|    534|            &mut self.diagnostics,
  211|    534|            &mut symbol_table,
  212|    534|            &mut registry,
  213|       |        );
  214|       |
  215|    534|        self.check_diagnostics_and_return_if_error()?;
                                                                  ^83
  216|       |
  217|       |        // Validate that parsing-only node kinds have been lowered (actually they shouldn't exist in Ast now)
  218|       |        // But for safety/debugging:
  219|       |        #[cfg(debug_assertions)]
  220|  6.64k|        for kind in &ast.kinds {
                          ^6.19k
  221|    218|            match kind {
  222|    218|                NodeKind::BinaryOp(op, ..) if op.is_assignment() => {
                                                                             ^0
  223|      0|                    panic!(
  224|      0|                        "ICE: NodeKind::BinaryOp with assignment operator {:?}, use NodeKind::Assignment instead",
  225|       |                        op
  226|       |                    );
  227|       |                }
  228|    118|                NodeKind::Assignment(op, ..) if !op.is_assignment() => {
                                                                                ^0
  229|      0|                    panic!(
  230|      0|                        "ICE: NodeKind::Assignment with non-assignment operator {:?}, use NodeKind::BinaryOp instead",
  231|       |                        op
  232|       |                    );
  233|       |                }
  234|       |                // Check if any legacy variants slipped in (NodeKind shouldn't have them anymore so compile error if we match them)
  235|  6.19k|                _ => {}
  236|       |            }
  237|       |        }
  238|       |
  239|       |        #[cfg(debug_assertions)]
  240|  6.19k|        for (i, kind) in ast.kinds.iter().enumerate() {
                                       ^451             ^451
  241|  6.19k|            let parent_idx = i + 1;
  242|  6.19k|            kind.visit_children(|child| {
                                                      ^5.27k
  243|  5.27k|                let child_idx = child.get() as usize;
  244|  5.27k|                if child_idx <= parent_idx {
  245|      0|                    panic!(
  246|      0|                        "ICE: AST invariant violation: parent index ({}) >= child index ({}) for node {:?}",
  247|       |                        parent_idx, child_idx, kind
  248|       |                    );
  249|  5.27k|                }
  250|  5.27k|            });
  251|       |        }
  252|       |
  253|    451|        Ok((ast, symbol_table, registry))
  254|    534|    }
  255|       |
  256|    284|    fn visit_ast(
  257|    284|        &mut self,
  258|    284|        mut ast: Ast,
  259|    284|        symbol_table: SymbolTable,
  260|    284|        mut registry: TypeRegistry,
  261|    284|    ) -> Result<MirProgram, PipelineError> {
  262|       |        use crate::semantic::analyzer::visit_ast;
  263|    284|        let semantic_info = visit_ast(&ast, &mut self.diagnostics, &symbol_table, &mut registry);
  264|    284|        self.check_diagnostics_and_return_if_error()?;
                                                                  ^75
  265|       |
  266|       |        // Attach semantic info to AST (like scope_map)
  267|    209|        ast.attach_semantic_info(semantic_info);
  268|       |
  269|       |        // invariant validations
  270|       |        // all expression must have resolved_type set
  271|  4.46k|        for (i, kind) in ast.kinds.iter().enumerate() {
                                       ^209             ^209
  272|  4.46k|            let node_ref = NodeRef::new((i as u32) + 1).unwrap();
  273|    547|            match kind {
  274|    547|                NodeKind::Ident(name, ..) if ast.get_resolved_type(node_ref).is_none() => {
                                                                                                   ^0
  275|      0|                    let span = ast.get_span(node_ref);
  276|      0|                    panic!(
  277|      0|                        "ICE: ident '{}' still not have resolved type: {:?}",
  278|       |                        name,
  279|      0|                        self.source_manager.get_line_column(span.start())
  280|       |                    );
  281|       |                }
  282|  4.46k|                _ => {}
  283|       |            }
  284|       |        }
  285|       |
  286|    209|        let mut sema = MirGen::new(&ast, &symbol_table, &mut registry);
  287|    209|        let mir_program = sema.visit_module();
  288|    209|        self.check_diagnostics_and_return_if_error()?;
                                                                  ^0
  289|       |
  290|    209|        Ok(mir_program)
  291|    284|    }
  292|       |
  293|     62|    fn run_codegen(&mut self, mir_program: MirProgram, emit_kind: EmitKind) -> Result<ClifOutput, PipelineError> {
  294|       |        // Validate MIR before code generation
  295|     62|        log::debug!("Running MIR validation");
                                  ^0
  296|     62|        let validator = MirValidator::new(&mir_program);
  297|     62|        if let Err(errors) = validator.validate() {
                                 ^0
  298|      0|            panic!("MIR validation failed: {:?}", errors);
  299|     62|        }
  300|       |
  301|       |        // Use MIR codegen instead of AST codegen
  302|     62|        let mir_codegen = ClifGen::new(mir_program);
  303|     62|        match mir_codegen.visit_module(emit_kind) {
  304|     62|            Ok(output) => Ok(output),
  305|      0|            Err(e) => {
  306|      0|                self.diagnostics.report_diagnostic(Diagnostic {
  307|      0|                    level: DiagnosticLevel::Error,
  308|      0|                    message: e.to_string(),
  309|      0|                    ..Default::default()
  310|      0|                });
  311|      0|                Err(PipelineError::Fatal)
  312|       |            }
  313|       |        }
  314|     62|    }
  315|       |
  316|       |    /// Check if there are any diagnostics errors and return PipelineError::Fatal if there are
  317|  1.84k|    fn check_diagnostics_and_return_if_error(&self) -> Result<(), PipelineError> {
  318|  1.84k|        if self.diagnostics.has_errors() {
  319|    158|            Err(PipelineError::Fatal)
  320|       |        } else {
  321|  1.68k|            Ok(())
  322|       |        }
  323|  1.84k|    }
  324|       |
  325|       |    /// Run the compilation process for all input files
  326|       |    /// this function handles the full pipeline from source to executable
  327|       |    /// and emit diagnostics if any error occurs
  328|     38|    pub fn run(&mut self) -> Result<(), DriverError> {
  329|     38|        let result = self.run_pipeline(self.config.stop_after);
  330|     38|        match result {
  331|     38|            Ok(outputs) => {
  332|     38|                self.print_diagnostics();
  333|     38|                let mut object_files_to_link = Vec::new();
  334|       |                // Add any external object files to the link list
  335|     38|                object_files_to_link.extend(outputs.external_object_files);
  336|       |
  337|       |                // We need to keep the temp files alive until the linking process is complete
  338|     38|                let mut temp_files = Vec::new();
  339|       |
  340|       |                // Process outputs if needed
  341|     76|                for (_source_id, artifact) in outputs.units {
                                   ^38         ^38
  342|     38|                    if let Some(object_file) = artifact.object_file {
  343|     38|                        if self.config.compile_only {
  344|       |                            // Write directly to output path when compile_only is set
  345|      0|                            let output_path = if let Some(ref path) = self.config.output_path {
  346|      0|                                path.clone()
  347|       |                            } else {
  348|       |                                // Default output name when -c but no -o
  349|      0|                                std::path::PathBuf::from("a.o")
  350|       |                            };
  351|       |                            use std::io::Write;
  352|      0|                            let mut file = std::fs::File::create(&output_path)
  353|      0|                                .map_err(|e| DriverError::IoError(format!("Failed to create output file: {}", e)))?;
  354|      0|                            file.write_all(&object_file)
  355|      0|                                .map_err(|e| DriverError::IoError(format!("Failed to write object file: {}", e)))?;
  356|       |                        } else {
  357|       |                            // Write the object file to a temporary file for linking
  358|     38|                            let mut temp_file = tempfile::Builder::new()
  359|     38|                                .suffix(".o")
  360|     38|                                .tempfile()
  361|     38|                                .map_err(|e| DriverError::IoError(format!("Failed to create temp file: {}", e)))?;
                                                                                ^0      ^0                                    ^0
  362|       |
  363|       |                            use std::io::Write;
  364|     38|                            temp_file
  365|     38|                                .write_all(&object_file)
  366|     38|                                .map_err(|e| DriverError::IoError(format!("Failed to write object file: {}", e)))?;
                                                                                ^0      ^0                                     ^0
  367|       |
  368|     38|                            object_files_to_link.push(temp_file.path().to_path_buf());
  369|     38|                            temp_files.push(temp_file);
  370|       |                        }
  371|      0|                    } else if let Some(clif_dump) = artifact.clif_dump {
  372|      0|                        // Output Cranelift IR dump to console
  373|      0|                        println!("{}", clif_dump);
  374|      0|                    } else if let Some(mir_program) = artifact.mir_program {
  375|       |                        // Output MIR dump to console
  376|      0|                        let dump_config = MirDumpConfig { include_header: true };
  377|       |
  378|      0|                        let dumper = MirDumper::new(&mir_program, &dump_config);
  379|      0|                        match dumper.generate_mir_dump() {
  380|      0|                            Ok(mir_dump) => {
  381|      0|                                println!("{}", mir_dump);
  382|      0|                            }
  383|      0|                            Err(_e) => {
  384|      0|                                self.print_diagnostics();
  385|      0|                                return Err(DriverError::CompilationFailed);
  386|       |                            }
  387|       |                        }
  388|      0|                    } else if let Some(ast) = artifact.ast {
  389|      0|                        print!("{}", AstDumper::dump_parser(&ast, artifact.symbol_table.as_ref()));
  390|      0|                        if let Some(registry) = artifact.type_registry {
  391|      0|                            print!("{}", AstDumper::dump_type_registry(&ast, &registry));
  392|      0|                        }
  393|      0|                    } else if let Some(parsed_ast) = artifact.parsed_ast {
  394|      0|                        print!("{}", AstDumper::dump_parsed_ast(&parsed_ast));
  395|      0|                    } else if let Some(preprocessed) = artifact.preprocessed {
  396|      0|                        let dumper =
  397|      0|                            PPDumper::new(&preprocessed, &self.source_manager, self.config.suppress_line_markers);
  398|      0|                        dumper
  399|      0|                            .dump(&mut std::io::stdout())
  400|      0|                            .map_err(|e| DriverError::IoError(e.to_string()))?;
  401|      0|                    }
  402|       |                }
  403|       |
  404|       |                // Link if we have object files and NOT compile_only
  405|     38|                if !object_files_to_link.is_empty() && !self.config.compile_only {
  406|       |                    // Determine the output path
  407|     38|                    let output_path = if let Some(output_path) = &self.config.output_path {
  408|     38|                        output_path.clone()
  409|       |                    } else {
  410|       |                        // Default to a.out if no output path is specified
  411|      0|                        "a.out".into()
  412|       |                    };
  413|       |
  414|       |                    // Configure linker
  415|     38|                    let link_config = crate::codegen::LinkConfig {
  416|     38|                        output_path,
  417|     38|                        library_paths: self.config.library_paths.clone(),
  418|     38|                        libraries: self.config.libraries.clone(),
  419|     38|                        optimization: self.config.optimization.clone(),
  420|     38|                        debug_info: self.config.debug_info,
  421|     38|                        verbose: self.config.verbose,
  422|     38|                        fuse_ld: self.config.fuse_ld.clone(),
  423|     38|                    };
  424|       |
  425|       |                    // Link using LinkGen
  426|     38|                    crate::codegen::LinkGen::link(&object_files_to_link, &link_config)
  427|     38|                        .map_err(|e| DriverError::IoError(e.to_string()))?;
                                                                        ^0^0           ^0
  428|      0|                }
  429|       |            }
  430|      0|            Err(e) => match e {
  431|      0|                PipelineError::IoError(io_err) => {
  432|      0|                    let message = format!("I/O Error: {}", io_err);
  433|      0|                    return Err(DriverError::IoError(message));
  434|       |                }
  435|       |                PipelineError::Fatal => {
  436|      0|                    self.print_diagnostics();
  437|      0|                    return Err(DriverError::CompilationFailed);
  438|       |                }
  439|       |            },
  440|       |        }
  441|       |
  442|     38|        Ok(())
  443|     38|    }
  444|       |
  445|       |    /// Get diagnostics for testing
  446|       |    #[cfg(test)]
  447|    155|    pub(crate) fn get_diagnostics(&self) -> Vec<Diagnostic> {
  448|    155|        self.diagnostics.diagnostics().to_vec()
  449|    155|    }
  450|       |
  451|       |    /// Print accumulated diagnostics without returning an error
  452|     39|    pub(crate) fn print_diagnostics(&self) {
  453|     39|        let formatter = crate::diagnostic::ErrorFormatter::default();
  454|     39|        formatter.print_diagnostics(self.diagnostics.diagnostics(), &self.source_manager);
  455|     39|    }
  456|       |}
  457|       |
  458|       |/// Error types for the compiler driver
  459|       |#[derive(Debug, thiserror::Error)]
  460|       |pub enum DriverError {
  461|       |    #[error("I/O error: {0}")]
  462|       |    IoError(String),
  463|       |
  464|       |    #[error("Compilation failed due to errors")]
  465|       |    CompilationFailed,
  466|       |}
  467|       |
  468|       |/// Error that will stop the compilation pipeline
  469|       |#[derive(Debug)]
  470|       |pub enum PipelineError {
  471|       |    Fatal,
  472|       |    IoError(std::io::Error),
  473|       |}

/app/src/lang_options.rs:
    1|       |/// supported C standards
    2|       |#[derive(Copy, Clone, Debug, PartialEq, Eq)]
    3|       |pub enum CStandard {
    4|       |    C89,
    5|       |    C99,
    6|       |    C11,
    7|       |}
    8|       |
    9|       |impl From<&str> for CStandard {
   10|      0|    fn from(s: &str) -> Self {
   11|      0|        match s {
   12|      0|            "c89" | "c90" => CStandard::C89,
   13|      0|            "c99" => CStandard::C99,
   14|      0|            "c11" => CStandard::C11,
   15|      0|            _ => CStandard::C11, // default to C11
   16|       |        }
   17|      0|    }
   18|       |}
   19|       |
   20|       |/// Language options affecting compilation behavior
   21|       |#[derive(Copy, Clone, Debug, Default)]
   22|       |pub struct LangOptions {
   23|       |    pub c_standard: Option<CStandard>, // C standard version (e.g., "c99", "c11")
   24|       |}
   25|       |
   26|       |impl LangOptions {
   27|       |    #[cfg(test)]
   28|      2|    pub(crate) fn c11() -> Self {
   29|      2|        LangOptions {
   30|      2|            c_standard: Some(CStandard::C11),
   31|      2|        }
   32|      2|    }
   33|       |
   34|       |    /// Check if C11 standard is enabled
   35|    921|    pub(crate) fn is_c11(&self) -> bool {
   36|    919|        matches!(self.c_standard, Some(CStandard::C11))
                               ^2
   37|    921|    }
   38|       |}
   39|       |
   40|       |#[cfg(test)]
   41|       |mod tests {
   42|       |    use super::*;
   43|       |
   44|       |    #[test]
   45|      1|    fn test_lang_options_c11() {
   46|      1|        let options = LangOptions::c11();
   47|      1|        assert!(options.is_c11());
   48|      1|        assert_eq!(options.c_standard, Some(CStandard::C11));
   49|      1|    }
   50|       |
   51|       |    #[test]
   52|      1|    fn test_lang_options_default() {
   53|      1|        let options = LangOptions::default();
   54|      1|        assert!(!options.is_c11());
   55|      1|        assert_eq!(options.c_standard, None);
   56|      1|    }
   57|       |}

/app/src/main.rs:
    1|       |use cendol::driver::{Cli, CompilerDriver, DriverError};
    2|       |use clap::Parser;
    3|       |
    4|      0|fn main() {
    5|      0|    env_logger::init();
    6|       |
    7|       |    // Preprocess arguments to support single-dash long options specific to GCC/Clang compatibility.
    8|       |    // Clap does not strictly support single-dash long options (e.g. -std=c99), so we manually
    9|       |    // map them to double-dash options (e.g. --std=c99) before parsing.
   10|      0|    let args = std::env::args().map(|arg| {
   11|      0|        if arg.starts_with("-std=") || arg.starts_with("-target=") || arg.starts_with("-fuse-ld=") {
   12|      0|            format!("-{}", arg)
   13|      0|        } else if arg == "-pedantic" {
   14|      0|            "--pedantic".to_string()
   15|      0|        } else if arg == "-pedantic-errors" {
   16|      0|            "--pedantic-errors".to_string()
   17|       |        } else {
   18|      0|            arg
   19|       |        }
   20|      0|    });
   21|       |
   22|      0|    let cli = Cli::parse_from(args);
   23|       |
   24|      0|    match CompilerDriver::new(cli) {
   25|      0|        Ok(mut driver) => {
   26|      0|            match driver.run() {
   27|      0|                Ok(_) => std::process::exit(0),
   28|      0|                Err(e) => {
   29|      0|                    match e {
   30|      0|                        DriverError::IoError(e) => eprintln!("I/O error: {:?}", e),
   31|      0|                        DriverError::CompilationFailed => (), // diagnostic already printed by driver.run()
   32|       |                    };
   33|      0|                    std::process::exit(1);
   34|       |                }
   35|       |            }
   36|       |        }
   37|      0|        Err(e) => {
   38|      0|            eprintln!("Failed to initialize compiler: {}", e);
   39|      0|            std::process::exit(1);
   40|       |        }
   41|       |    }
   42|       |}

/app/src/mir.rs:
    1|       |//! Mid-level Intermediate Representation (MIR) for C11 compiler.
    2|       |//!
    3|       |//! This module provides the MIR data structures and APIs for representing
    4|       |//! C11 programs after semantic analysis. The MIR is designed to be:
    5|       |//! - Typed: All entities have explicit types
    6|       |//! - Explicit: All C semantics are made explicit
    7|       |//! - Cranelift-friendly: Easy to lower to Cranelift IR
    8|       |//! - Non-SSA: Uses basic blocks with explicit control flow
    9|       |
   10|       |use hashbrown::HashMap;
   11|       |use serde::Serialize;
   12|       |use std::fmt;
   13|       |use std::num::NonZeroU32;
   14|       |
   15|       |use crate::ast::NameId;
   16|       |
   17|       |pub mod dumper;
   18|       |pub mod validation;
   19|       |
   20|       |/// Unique identifier for MIR global variables
   21|       |pub type GlobalId = NonZeroU32;
   22|       |
   23|       |/// Unique identifier for MIR modules
   24|       |pub type MirModuleId = NonZeroU32;
   25|       |
   26|       |/// Unique identifier for MIR functions
   27|       |pub type MirFunctionId = NonZeroU32;
   28|       |
   29|       |/// Unique identifier for MIR blocks
   30|       |pub type MirBlockId = NonZeroU32;
   31|       |
   32|       |/// Unique identifier for MIR statements
   33|       |pub type MirStmtId = NonZeroU32;
   34|       |
   35|       |/// Unique identifier for MIR locals
   36|       |pub type LocalId = NonZeroU32;
   37|       |
   38|       |/// Unique identifier for MIR types
   39|       |pub type TypeId = NonZeroU32;
   40|       |
   41|       |/// Unique identifier for MIR constant values
   42|       |pub type ConstValueId = NonZeroU32;
   43|       |
   44|       |/// Function kind - distinguishes between defined and extern functions
   45|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
   46|       |pub enum MirFunctionKind {
   47|       |    Defined,
   48|       |    Extern,
   49|       |}
   50|       |
   51|       |/// MIR Module - Top-level container for MIR
   52|       |#[derive(Debug, Clone, PartialEq, Serialize)]
   53|       |pub struct MirModule {
   54|       |    pub id: MirModuleId,
   55|       |    pub functions: Vec<MirFunctionId>,
   56|       |    pub globals: Vec<GlobalId>,
   57|       |    pub types: Vec<MirType>,
   58|       |    pub constants: Vec<ConstValue>,
   59|       |    pub pointer_width: u8, // Width of a pointer in bytes (e.g., 4 or 8)
   60|       |}
   61|       |
   62|       |impl MirModule {
   63|    449|    pub(crate) fn new(id: MirModuleId) -> Self {
   64|    449|        Self {
   65|    449|            id,
   66|    449|            functions: Vec::new(),
   67|    449|            globals: Vec::new(),
   68|    449|            types: Vec::new(),
   69|    449|            constants: Vec::new(),
   70|    449|            pointer_width: 8, // Default to 64-bit pointers
   71|    449|        }
   72|    449|    }
   73|       |}
   74|       |
   75|       |/// MIR Function - Represents a C function in MIR
   76|       |#[derive(Debug, Clone, PartialEq, Serialize)]
   77|       |pub struct MirFunction {
   78|       |    pub id: MirFunctionId,
   79|       |    pub name: NameId,
   80|       |    pub return_type: TypeId,
   81|       |    pub params: Vec<LocalId>,
   82|       |
   83|       |    pub kind: MirFunctionKind,
   84|       |    pub is_variadic: bool, // Track if this function is variadic
   85|       |
   86|       |    // Only valid if kind is Defined
   87|       |    pub locals: Vec<LocalId>,
   88|       |    pub blocks: Vec<MirBlockId>,
   89|       |    pub entry_block: Option<MirBlockId>,
   90|       |}
   91|       |
   92|       |impl MirFunction {
   93|    280|    pub(crate) fn new(id: MirFunctionId, name: NameId, return_type: TypeId, kind: MirFunctionKind) -> Self {
   94|    280|        Self {
   95|    280|            id,
   96|    280|            name,
   97|    280|            return_type,
   98|    280|            params: Vec::new(),
   99|    280|            kind,
  100|    280|            is_variadic: false,
  101|    280|            locals: Vec::new(),
  102|    280|            blocks: Vec::new(),
  103|    280|            entry_block: None,
  104|    280|        }
  105|    280|    }
  106|       |
  107|    247|    pub(crate) fn new_defined(id: MirFunctionId, name: NameId, return_type: TypeId) -> Self {
  108|    247|        Self::new(id, name, return_type, MirFunctionKind::Defined)
  109|    247|    }
  110|       |
  111|     33|    pub(crate) fn new_extern(id: MirFunctionId, name: NameId, return_type: TypeId) -> Self {
  112|     33|        Self::new(id, name, return_type, MirFunctionKind::Extern)
  113|     33|    }
  114|       |}
  115|       |
  116|       |/// MIR Block - Basic block with statements and terminator
  117|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  118|       |pub struct MirBlock {
  119|       |    pub id: MirBlockId,
  120|       |    pub statements: Vec<MirStmtId>,
  121|       |    pub terminator: Terminator,
  122|       |}
  123|       |
  124|       |impl MirBlock {
  125|    574|    pub(crate) fn new(id: MirBlockId) -> Self {
  126|    574|        Self {
  127|    574|            id,
  128|    574|            statements: Vec::new(),
  129|    574|            terminator: Terminator::Unreachable,
  130|    574|        }
  131|    574|    }
  132|       |}
  133|       |
  134|       |/// MIR Statement - Individual operations within a block
  135|       |/// Only contains side-effect operations, no control flow
  136|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  137|       |pub enum MirStmt {
  138|       |    Assign(Place, Rvalue),
  139|       |    Store(Operand, Place),
  140|       |    // Function calls - dest is None if void or result is ignored
  141|       |    Call {
  142|       |        target: CallTarget,
  143|       |        args: Vec<Operand>,
  144|       |        dest: Option<Place>,
  145|       |    },
  146|       |    // Memory operations
  147|       |    Alloc(Place, TypeId),
  148|       |    Dealloc(Operand),
  149|       |    BuiltinVaStart(Place, Operand),
  150|       |    BuiltinVaEnd(Place),
  151|       |    BuiltinVaCopy(Place, Place),
  152|       |    AtomicStore(Operand, Operand, AtomicMemOrder),
  153|       |}
  154|       |
  155|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  156|       |pub enum AtomicMemOrder {
  157|       |    Relaxed,
  158|       |    Consume,
  159|       |    Acquire,
  160|       |    Release,
  161|       |    AcqRel,
  162|       |    SeqCst,
  163|       |}
  164|       |
  165|       |/// Terminator - Control flow terminators for basic blocks
  166|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  167|       |pub enum Terminator {
  168|       |    Goto(MirBlockId),
  169|       |    If(Operand, MirBlockId, MirBlockId),
  170|       |    Return(Option<Operand>),
  171|       |    Unreachable,
  172|       |}
  173|       |
  174|       |/// Place - Represents a storage location (local variable or memory)
  175|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  176|       |pub enum Place {
  177|       |    Local(LocalId),
  178|       |    Deref(Box<Operand>),
  179|       |    Global(GlobalId),
  180|       |    // Aggregate access
  181|       |    StructField(Box<Place>, /* struct index */ usize),
  182|       |    ArrayIndex(Box<Place>, Box<Operand>),
  183|       |}
  184|       |
  185|       |/// Operand - Represents values used in MIR operations
  186|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  187|       |pub enum Operand {
  188|       |    Copy(Box<Place>),
  189|       |    Constant(ConstValueId),
  190|       |    // Address operations
  191|       |    AddressOf(Box<Place>),
  192|       |    // Type conversion
  193|       |    Cast(TypeId, Box<Operand>),
  194|       |}
  195|       |
  196|       |/// Rvalue - Right-hand side values in assignments
  197|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  198|       |pub enum Rvalue {
  199|       |    Use(Operand),
  200|       |    BinaryIntOp(BinaryIntOp, Operand, Operand),
  201|       |    BinaryFloatOp(BinaryFloatOp, Operand, Operand),
  202|       |    UnaryIntOp(UnaryIntOp, Operand),
  203|       |    UnaryFloatOp(UnaryFloatOp, Operand),
  204|       |    Cast(TypeId, Operand),
  205|       |    PtrAdd(Operand, Operand),
  206|       |    PtrSub(Operand, Operand),
  207|       |    PtrDiff(Operand, Operand),
  208|       |    // Aggregate construction
  209|       |    StructLiteral(Vec<(usize, Operand)>),
  210|       |    ArrayLiteral(Vec<Operand>),
  211|       |    // Memory operations
  212|       |    Load(Operand),
  213|       |    BuiltinVaArg(Place, TypeId),
  214|       |    AtomicLoad(Operand, AtomicMemOrder),
  215|       |    AtomicExchange(Operand, Operand, AtomicMemOrder),
  216|       |    AtomicCompareExchange(Operand, Operand, Operand, bool, AtomicMemOrder, AtomicMemOrder),
  217|       |    AtomicFetchOp(BinaryIntOp, Operand, Operand, AtomicMemOrder),
  218|       |}
  219|       |
  220|       |/// Call target - represents how a function is called
  221|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  222|       |pub enum CallTarget {
  223|       |    Direct(MirFunctionId), // Direct call to a known function
  224|       |    Indirect(Operand),     // Indirect call via function pointer
  225|       |}
  226|       |
  227|       |/// Integer binary operations
  228|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  229|       |#[repr(u8)]
  230|       |pub enum BinaryIntOp {
  231|       |    Add,
  232|       |    Sub,
  233|       |    Mul,
  234|       |    Div,
  235|       |    Mod,
  236|       |    BitAnd,
  237|       |    BitOr,
  238|       |    BitXor,
  239|       |    LShift,
  240|       |    RShift,
  241|       |    Eq,
  242|       |    Ne,
  243|       |    Lt,
  244|       |    Le,
  245|       |    Gt,
  246|       |    Ge,
  247|       |}
  248|       |
  249|       |impl BinaryIntOp {
  250|     69|    pub(crate) fn is_comparison(&self) -> bool {
  251|     69|        matches!(self, Self::Eq | Self::Ne | Self::Lt | Self::Le | Self::Gt | Self::Ge)
                      ^21
  252|     69|    }
  253|       |}
  254|       |
  255|       |/// Floating-point binary operations
  256|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  257|       |#[repr(u8)]
  258|       |pub enum BinaryFloatOp {
  259|       |    Add,
  260|       |    Sub,
  261|       |    Mul,
  262|       |    Div,
  263|       |    Eq,
  264|       |    Ne,
  265|       |    Lt,
  266|       |    Le,
  267|       |    Gt,
  268|       |    Ge,
  269|       |}
  270|       |
  271|       |impl BinaryFloatOp {
  272|     10|    pub(crate) fn is_comparison(&self) -> bool {
  273|     10|        matches!(self, Self::Eq | Self::Ne | Self::Lt | Self::Le | Self::Gt | Self::Ge)
                      ^4
  274|     10|    }
  275|       |}
  276|       |
  277|       |/// Integer unary operations
  278|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  279|       |#[repr(u8)]
  280|       |pub enum UnaryIntOp {
  281|       |    Neg,
  282|       |    BitwiseNot,
  283|       |    LogicalNot,
  284|       |}
  285|       |
  286|       |/// Floating-point unary operations
  287|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
  288|       |#[repr(u8)]
  289|       |pub enum UnaryFloatOp {
  290|       |    Neg,
  291|       |}
  292|       |
  293|       |/// Type - MIR type system
  294|       |// - All Struct/Union have a stable NameId
  295|       |// - No anonymous record types exist in MIR
  296|       |// - No anonymous members exist in MIR
  297|       |// - Field names are unique within a record
  298|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  299|       |pub enum MirType {
  300|       |    Void,
  301|       |    Bool,
  302|       |
  303|       |    I8,
  304|       |    I16,
  305|       |    I32,
  306|       |    I64,
  307|       |    U8,
  308|       |    U16,
  309|       |    U32,
  310|       |    U64,
  311|       |    F32,
  312|       |    F64,
  313|       |    F80, // x87 extended precision (padded to 128 bits)
  314|       |    F128,
  315|       |    Pointer {
  316|       |        pointee: TypeId,
  317|       |    },
  318|       |    Array {
  319|       |        element: TypeId,
  320|       |        size: usize,
  321|       |        layout: MirArrayLayout,
  322|       |    },
  323|       |    Function {
  324|       |        return_type: TypeId,
  325|       |        params: Vec<TypeId>,
  326|       |        is_variadic: bool,
  327|       |    },
  328|       |    Record {
  329|       |        name: NameId,
  330|       |        field_types: Vec<TypeId>,
  331|       |        field_names: Vec<NameId>,
  332|       |        is_union: bool,
  333|       |        layout: MirRecordLayout,
  334|       |    },
  335|       |}
  336|       |impl MirType {
  337|    507|    pub(crate) fn is_signed(&self) -> bool {
  338|    507|        matches!(self, MirType::I8 | MirType::I16 | MirType::I32 | MirType::I64)
                      ^220
  339|    507|    }
  340|       |
  341|    372|    pub(crate) fn is_void(&self) -> bool {
  342|    372|        matches!(self, MirType::Void)
                      ^363
  343|    372|    }
  344|       |
  345|    106|    pub(crate) fn is_pointer(&self) -> bool {
  346|    106|        matches!(self, MirType::Pointer { .. })
                      ^76
  347|    106|    }
  348|       |
  349|    125|    pub(crate) fn is_float(&self) -> bool {
  350|    125|        matches!(self, MirType::F32 | MirType::F64 | MirType::F80 | MirType::F128)
                      ^119
  351|    125|    }
  352|       |
  353|  1.19k|    pub(crate) fn is_aggregate(&self) -> bool {
  354|  1.19k|        matches!(self, MirType::Record { .. } | MirType::Array { .. })
                      ^1.05k
  355|  1.19k|    }
  356|       |
  357|     42|    pub(crate) fn is_int(&self) -> bool {
  358|     17|        matches!(
  359|     42|            self,
  360|       |            MirType::I8
  361|       |                | MirType::I16
  362|       |                | MirType::I32
  363|       |                | MirType::I64
  364|       |                | MirType::U8
  365|       |                | MirType::U16
  366|       |                | MirType::U32
  367|       |                | MirType::U64
  368|       |                | MirType::Bool
  369|       |        )
  370|     42|    }
  371|       |
  372|     16|    pub(crate) fn width(&self) -> u32 {
  373|     16|        match self {
  374|      3|            MirType::I8 | MirType::U8 | MirType::Bool => 8,
  375|      2|            MirType::I16 | MirType::U16 => 16,
  376|      3|            MirType::I32 | MirType::U32 | MirType::F32 => 32,
  377|      3|            MirType::I64 | MirType::U64 | MirType::F64 => 64,
  378|      2|            MirType::F80 | MirType::F128 => 128,
  379|      1|            MirType::Pointer { .. } => 64, // Assume 64-bit pointers
  380|      2|            _ => 0,                        // Others have no intrinsic "width" in this context
  381|       |        }
  382|     16|    }
  383|       |}
  384|       |
  385|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  386|       |pub struct MirRecordLayout {
  387|       |    pub size: u16,
  388|       |    pub alignment: u16,
  389|       |    pub field_offsets: Vec<u16>,
  390|       |}
  391|       |
  392|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
  393|       |pub struct MirArrayLayout {
  394|       |    pub size: u16,
  395|       |    pub align: u16,
  396|       |    pub stride: u16,
  397|       |}
  398|       |
  399|       |/// Constant Value Kind - discriminant for ConstValue
  400|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  401|       |pub enum ConstValueKind {
  402|       |    Int(i64),
  403|       |    Float(f64),
  404|       |    Bool(bool),
  405|       |    Null, // pointer null
  406|       |    Zero, // memset / padding / zero-init
  407|       |    // Aggregate constants
  408|       |    StructLiteral(Vec<(usize, ConstValueId)>),
  409|       |    ArrayLiteral(Vec<ConstValueId>),
  410|       |    // Address constants
  411|       |    GlobalAddress(GlobalId),
  412|       |    FunctionAddress(MirFunctionId),
  413|       |}
  414|       |
  415|       |/// Constant Value - Literal values in MIR
  416|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  417|       |pub struct ConstValue {
  418|       |    pub ty: TypeId,
  419|       |    pub kind: ConstValueKind,
  420|       |}
  421|       |
  422|       |/// Local - Represents a local variable or parameter
  423|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
  424|       |pub struct Local {
  425|       |    pub id: LocalId,
  426|       |    pub name: Option<NameId>,
  427|       |    pub type_id: TypeId,
  428|       |    pub is_param: bool,
  429|       |    pub alignment: Option<u32>, // Alignment in bytes
  430|       |}
  431|       |
  432|       |impl Local {
  433|    673|    pub(crate) fn new(id: LocalId, name: Option<NameId>, type_id: TypeId, is_param: bool) -> Self {
  434|    673|        Self {
  435|    673|            id,
  436|    673|            name,
  437|    673|            type_id,
  438|    673|            is_param,
  439|    673|            alignment: None,
  440|    673|        }
  441|    673|    }
  442|       |}
  443|       |
  444|       |/// Global - Represents a global variable
  445|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
  446|       |pub struct Global {
  447|       |    pub id: GlobalId,
  448|       |    pub name: NameId,
  449|       |    pub type_id: TypeId,
  450|       |    pub is_constant: bool,
  451|       |    pub initial_value: Option<ConstValueId>,
  452|       |    pub alignment: Option<u32>, // Max alignment in bytes
  453|       |}
  454|       |
  455|       |impl Global {
  456|    124|    pub(crate) fn new(id: GlobalId, name: NameId, type_id: TypeId, is_constant: bool) -> Self {
  457|    124|        Self {
  458|    124|            id,
  459|    124|            name,
  460|    124|            type_id,
  461|    124|            is_constant,
  462|    124|            initial_value: None,
  463|    124|            alignment: None,
  464|    124|        }
  465|    124|    }
  466|       |}
  467|       |
  468|       |/// MIR Builder - Builds MIR from AST
  469|       |pub(crate) struct MirBuilder {
  470|       |    module: MirModule,
  471|       |    current_function: Option<MirFunctionId>,
  472|       |    current_block: Option<MirBlockId>,
  473|       |    next_local_id: u32,
  474|       |    next_block_id: u32,
  475|       |    next_stmt_id: u32,
  476|       |    next_global_id: u32,
  477|       |    next_type_id: u32,
  478|       |    next_const_id: u32,
  479|       |    anonymous_global_counter: u32,
  480|       |    // State tracking
  481|       |    functions: HashMap<MirFunctionId, MirFunction>,
  482|       |    blocks: HashMap<MirBlockId, MirBlock>,
  483|       |    locals: HashMap<LocalId, Local>,
  484|       |    globals: HashMap<GlobalId, Global>,
  485|       |    types: HashMap<TypeId, MirType>,
  486|       |    constants: HashMap<ConstValueId, ConstValue>,
  487|       |    // Statement storage with ID mapping
  488|       |    statements: HashMap<MirStmtId, MirStmt>,
  489|       |}
  490|       |
  491|       |/// Complete semantic analysis output containing the full MIR program representation
  492|       |/// Includes all functions, blocks, instructions, and type definitions.
  493|       |#[derive(Debug, Clone, PartialEq, Serialize)]
  494|       |pub struct MirProgram {
  495|       |    pub module: MirModule,
  496|       |    pub functions: HashMap<MirFunctionId, MirFunction>,
  497|       |    pub blocks: HashMap<MirBlockId, MirBlock>,
  498|       |    pub locals: HashMap<LocalId, Local>,
  499|       |    pub globals: HashMap<GlobalId, Global>,
  500|       |    pub types: HashMap<TypeId, MirType>,
  501|       |    pub constants: HashMap<ConstValueId, ConstValue>,
  502|       |    pub statements: HashMap<MirStmtId, MirStmt>,
  503|       |    pub pointer_width: u8,
  504|       |}
  505|       |
  506|       |impl MirProgram {
  507|       |    /// get type or panic if not found
  508|  3.33k|    pub(crate) fn get_type(&self, id: TypeId) -> &MirType {
  509|  3.33k|        match self.types.get(&id) {
  510|  3.33k|            Some(id) => id,
  511|      0|            None => panic!("ICE: Type ID {id} not found"),
  512|       |        }
  513|  3.33k|    }
  514|  1.05k|    pub(crate) fn get_local(&self, id: LocalId) -> &Local {
  515|  1.05k|        match self.locals.get(&id) {
  516|  1.05k|            Some(id) => id,
  517|      0|            None => panic!("ICE: Local ID {id} not found"),
  518|       |        }
  519|  1.05k|    }
  520|    113|    pub(crate) fn get_function(&self, id: MirFunctionId) -> &MirFunction {
  521|    113|        match self.functions.get(&id) {
  522|    113|            Some(id) => id,
  523|      0|            None => panic!("ICE: Function ID {id} not found"),
  524|       |        }
  525|    113|    }
  526|    158|    pub(crate) fn get_global(&self, id: GlobalId) -> &Global {
  527|    158|        match self.globals.get(&id) {
  528|    158|            Some(id) => id,
  529|      0|            None => panic!("ICE: Global ID {id} not found"),
  530|       |        }
  531|    158|    }
  532|       |}
  533|       |
  534|       |impl MirBuilder {
  535|    449|    pub(crate) fn new(module_id: MirModuleId, pointer_width: u8) -> Self {
  536|    449|        let mut module = MirModule::new(module_id);
  537|    449|        module.pointer_width = pointer_width;
  538|    449|        Self {
  539|    449|            module,
  540|    449|            current_function: None,
  541|    449|            current_block: None,
  542|    449|            next_local_id: 1,
  543|    449|            next_block_id: 1,
  544|    449|            next_stmt_id: 1,
  545|    449|            next_global_id: 1,
  546|    449|            next_type_id: 1,
  547|    449|            next_const_id: 1,
  548|    449|            anonymous_global_counter: 0,
  549|    449|            functions: HashMap::new(),
  550|    449|            blocks: HashMap::new(),
  551|    449|            locals: HashMap::new(),
  552|    449|            globals: HashMap::new(),
  553|    449|            types: HashMap::new(),
  554|    449|            constants: HashMap::new(),
  555|    449|            statements: HashMap::new(),
  556|    449|        }
  557|    449|    }
  558|       |
  559|       |    /// Create a new local variable
  560|    663|    pub(crate) fn create_local(&mut self, name: Option<NameId>, type_id: TypeId, is_param: bool) -> LocalId {
  561|    663|        let local_id = LocalId::new(self.next_local_id).unwrap();
  562|    663|        self.next_local_id += 1;
  563|       |
  564|    663|        let local = Local::new(local_id, name, type_id, is_param);
  565|    663|        self.locals.insert(local_id, local);
  566|       |
  567|    663|        if let Some(func_id) = self.current_function
                                  ^580
  568|    580|            && let Some(func) = self.functions.get_mut(&func_id)
  569|       |        {
  570|    580|            if is_param {
  571|      0|                func.params.push(local_id);
  572|    580|            } else {
  573|    580|                func.locals.push(local_id);
  574|    580|            }
  575|     83|        }
  576|       |
  577|    663|        local_id
  578|    663|    }
  579|       |
  580|      0|    pub(crate) fn set_local_alignment(&mut self, local_id: LocalId, alignment: u32) {
  581|      0|        if let Some(local) = self.locals.get_mut(&local_id) {
  582|      0|            local.alignment = Some(alignment);
  583|      0|        }
  584|      0|    }
  585|       |
  586|       |    /// Create a new basic block
  587|    573|    pub(crate) fn create_block(&mut self) -> MirBlockId {
  588|    573|        let func_id = self.current_function.expect("no current function");
  589|    573|        let func = self.functions.get(&func_id).unwrap();
  590|       |
  591|    573|        assert!(
  592|    573|            matches!(func.kind, MirFunctionKind::Defined),
                          ^0
  593|      0|            "cannot create blocks for extern function"
  594|       |        );
  595|       |
  596|    573|        let block_id = MirBlockId::new(self.next_block_id).unwrap();
  597|    573|        self.next_block_id += 1;
  598|       |
  599|    573|        let block = MirBlock::new(block_id);
  600|    573|        self.blocks.insert(block_id, block);
  601|       |
  602|    573|        if let Some(func) = self.functions.get_mut(&func_id) {
  603|    573|            func.blocks.push(block_id);
  604|    573|        }
                      ^0
  605|       |
  606|    573|        block_id
  607|    573|    }
  608|       |
  609|       |    /// Add a statement to the current block
  610|    722|    pub(crate) fn add_statement(&mut self, stmt: MirStmt) -> MirStmtId {
  611|    722|        let stmt_id = MirStmtId::new(self.next_stmt_id).unwrap();
  612|    722|        self.next_stmt_id += 1;
  613|       |
  614|       |        // Store statement in the HashMap
  615|    722|        self.statements.insert(stmt_id, stmt.clone());
  616|       |
  617|    722|        if let Some(block_id) = self.current_block
  618|    722|            && let Some(block) = self.blocks.get_mut(&block_id)
  619|       |        {
  620|       |            // Only add statement if the block is not yet terminated
  621|    722|            if matches!(block.terminator, Terminator::Unreachable) {
                             ^0
  622|    722|                block.statements.push(stmt_id);
  623|    722|            }
                          ^0
  624|      0|        }
  625|       |
  626|    722|        stmt_id
  627|    722|    }
  628|       |
  629|       |    /// Set the terminator for the current block
  630|    574|    pub(crate) fn set_terminator(&mut self, terminator: Terminator) {
  631|    574|        if let Some(block_id) = self.current_block
  632|    574|            && let Some(block) = self.blocks.get_mut(&block_id)
  633|       |        {
  634|       |            // Only overwrite if the current terminator is Unreachable (default)
  635|       |            // This preserves existing control flow (e.g. from goto) and prevents
  636|       |            // overwriting it with subsequent unreachable terminators.
  637|    574|            if matches!(block.terminator, Terminator::Unreachable) {
                             ^2
  638|    572|                block.terminator = terminator;
  639|    572|            }
                          ^2
  640|      0|        }
  641|    574|    }
  642|       |
  643|       |    /// Set the current block
  644|    573|    pub(crate) fn set_current_block(&mut self, block_id: MirBlockId) {
  645|    573|        self.current_block = Some(block_id);
  646|    573|    }
  647|       |
  648|       |    /// Check if the current block has a non-unreachable terminator
  649|       |    /// Since terminators always exist, this checks if the terminator is meaningful
  650|       |    /// (i.e., not just the default Unreachable terminator)
  651|    621|    pub(crate) fn current_block_has_terminator(&self) -> bool {
  652|    621|        if let Some(block_id) = self.current_block
  653|    621|            && let Some(block) = self.blocks.get(&block_id)
  654|       |        {
  655|    621|            return !matches!(block.terminator, Terminator::Unreachable);
                                  ^235
  656|      0|        }
  657|      0|        false
  658|    621|    }
  659|       |
  660|       |    /// Declare a function (extern - no body)
  661|     33|    pub(crate) fn declare_function(
  662|     33|        &mut self,
  663|     33|        name: NameId,
  664|     33|        param_types: Vec<TypeId>,
  665|     33|        return_type: TypeId,
  666|     33|        is_variadic: bool,
  667|     33|    ) -> MirFunctionId {
  668|     33|        let func_id = MirFunctionId::new(self.module.functions.len() as u32 + 1).unwrap();
  669|     33|        let mut func = MirFunction::new_extern(func_id, name, return_type);
  670|     33|        func.is_variadic = is_variadic;
  671|       |
  672|       |        // Create locals for each parameter
  673|     35|        for (i, &param_type) in param_types.iter().enumerate() {
                                              ^33                ^33
  674|     35|            let param_name = Some(NameId::new(format!("param{}", i)));
  675|     35|            let local_id = self.create_local(param_name, param_type, true);
  676|     35|            func.params.push(local_id);
  677|     35|        }
  678|       |
  679|     33|        self.functions.insert(func_id, func);
  680|     33|        self.module.functions.push(func_id);
  681|       |
  682|     33|        func_id
  683|     33|    }
  684|       |
  685|       |    /// Define a function (has body)
  686|    246|    pub(crate) fn define_function(
  687|    246|        &mut self,
  688|    246|        name: NameId,
  689|    246|        param_types: Vec<TypeId>,
  690|    246|        return_type: TypeId,
  691|    246|        is_variadic: bool,
  692|    246|    ) -> MirFunctionId {
  693|    246|        let func_id = MirFunctionId::new(self.module.functions.len() as u32 + 1).unwrap();
  694|    246|        let mut func = MirFunction::new_defined(func_id, name, return_type);
  695|    246|        func.is_variadic = is_variadic;
  696|       |
  697|       |        // Create locals for each parameter
  698|    246|        for (i, &param_type) in param_types.iter().enumerate() {
                           ^48 ^48
  699|     48|            let param_name = Some(NameId::new(format!("param{}", i)));
  700|     48|            let local_id = self.create_local(param_name, param_type, true);
  701|     48|            func.params.push(local_id);
  702|     48|        }
  703|       |
  704|    246|        self.functions.insert(func_id, func);
  705|    246|        self.module.functions.push(func_id);
  706|       |
  707|    246|        func_id
  708|    246|    }
  709|       |
  710|       |    /// Set current function
  711|    246|    pub(crate) fn set_current_function(&mut self, func_id: MirFunctionId) {
  712|    246|        self.current_function = Some(func_id);
  713|    246|        if let Some(func) = self.functions.get(&func_id)
  714|    246|            && let Some(entry_block) = func.entry_block
                                      ^0
  715|      0|        {
  716|      0|            self.current_block = Some(entry_block);
  717|    246|        }
  718|    246|    }
  719|       |
  720|       |    /// Create a new global variable with initial value
  721|    124|    pub(crate) fn create_global_with_init(
  722|    124|        &mut self,
  723|    124|        name: NameId,
  724|    124|        type_id: TypeId,
  725|    124|        is_constant: bool,
  726|    124|        initial_value: Option<ConstValueId>,
  727|    124|    ) -> GlobalId {
  728|    124|        let global_id = GlobalId::new(self.next_global_id).unwrap();
  729|    124|        self.next_global_id += 1;
  730|       |
  731|    124|        let mut global = Global::new(global_id, name, type_id, is_constant);
  732|    124|        global.initial_value = initial_value;
  733|    124|        self.globals.insert(global_id, global);
  734|    124|        self.module.globals.push(global_id);
  735|       |
  736|    124|        global_id
  737|    124|    }
  738|       |
  739|      5|    pub(crate) fn set_global_initializer(&mut self, global_id: GlobalId, init_id: ConstValueId) {
  740|      5|        if let Some(global) = self.globals.get_mut(&global_id) {
  741|      5|            global.initial_value = Some(init_id);
  742|      5|        }
                      ^0
  743|      5|    }
  744|       |
  745|      0|    pub(crate) fn set_global_alignment(&mut self, global_id: GlobalId, alignment: u32) {
  746|      0|        if let Some(global) = self.globals.get_mut(&global_id) {
  747|      0|            global.alignment = Some(alignment);
  748|      0|        }
  749|      0|    }
  750|       |
  751|       |    /// Add a type to the module with interning
  752|    992|    pub(crate) fn add_type(&mut self, mir_type: MirType) -> TypeId {
  753|       |        // Check if type already exists (type interning)
  754|  3.82k|        for (existing_id, existing_type) in &self.types {
                           ^2.98k       ^2.98k
  755|  2.98k|            if existing_type == &mir_type {
  756|    151|                return *existing_id;
  757|  2.83k|            }
  758|       |        }
  759|       |
  760|       |        // Type doesn't exist, create new one
  761|    841|        let type_id = TypeId::new(self.next_type_id).unwrap();
  762|    841|        self.next_type_id += 1;
  763|       |
  764|    841|        self.types.insert(type_id, mir_type.clone());
  765|    841|        self.module.types.push(mir_type);
  766|       |
  767|    841|        type_id
  768|    992|    }
  769|       |
  770|       |    /// Update an existing type previously inserted with `add_type`.
  771|       |    /// This replaces the type entry in both the internal map and the module vector.
  772|     61|    pub(crate) fn update_type(&mut self, type_id: TypeId, mir_type: MirType) {
  773|     61|        self.types.insert(type_id, mir_type.clone());
  774|     61|        let idx = (type_id.get() - 1) as usize;
  775|     61|        if idx < self.module.types.len() {
  776|     61|            self.module.types[idx] = mir_type;
  777|     61|        }
                      ^0
  778|     61|    }
  779|       |
  780|  1.22k|    pub(crate) fn get_type(&self, type_id: TypeId) -> &MirType {
  781|  1.22k|        self.types.get(&type_id).expect("Type ID not found in MirBuilder")
  782|  1.22k|    }
  783|       |
  784|       |    /// Create a constant value
  785|  1.97k|    pub(crate) fn create_constant(&mut self, ty: TypeId, kind: ConstValueKind) -> ConstValueId {
  786|  1.97k|        let const_id = ConstValueId::new(self.next_const_id).unwrap();
  787|  1.97k|        self.next_const_id += 1;
  788|       |
  789|  1.97k|        let value = ConstValue { ty, kind };
  790|  1.97k|        self.constants.insert(const_id, value.clone());
  791|  1.97k|        self.module.constants.push(value);
  792|       |
  793|  1.97k|        const_id
  794|  1.97k|    }
  795|       |
  796|       |    /// Consumes the builder and returns all the generated MIR components.
  797|       |    /// This is the preferred way to get the final MIR, as it avoids cloning.
  798|    240|    pub(crate) fn consume(self) -> MirProgram {
  799|    240|        let pointer_width = self.module.pointer_width;
  800|    240|        MirProgram {
  801|    240|            module: self.module,
  802|    240|            functions: self.functions,
  803|    240|            blocks: self.blocks,
  804|    240|            locals: self.locals,
  805|    240|            globals: self.globals,
  806|    240|            types: self.types,
  807|    240|            constants: self.constants,
  808|    240|            statements: self.statements,
  809|    240|            pointer_width,
  810|    240|        }
  811|    240|    }
  812|       |
  813|       |    /// Get all functions for validation
  814|  1.10k|    pub(crate) fn get_functions(&self) -> &HashMap<MirFunctionId, MirFunction> {
  815|  1.10k|        &self.functions
  816|  1.10k|    }
  817|       |
  818|       |    /// Get all constants for validation
  819|    927|    pub(crate) fn get_constants(&self) -> &HashMap<ConstValueId, ConstValue> {
  820|    927|        &self.constants
  821|    927|    }
  822|       |
  823|     70|    pub(crate) fn get_globals(&self) -> &HashMap<GlobalId, Global> {
  824|     70|        &self.globals
  825|     70|    }
  826|       |
  827|    519|    pub(crate) fn get_locals(&self) -> &HashMap<LocalId, Local> {
  828|    519|        &self.locals
  829|    519|    }
  830|       |
  831|       |    /// Set the entry block for a function
  832|    246|    pub(crate) fn set_function_entry_block(&mut self, func_id: MirFunctionId, block_id: MirBlockId) {
  833|    246|        if let Some(func) = self.functions.get_mut(&func_id) {
  834|    246|            assert!(matches!(func.kind, MirFunctionKind::Defined));
                                  ^0
  835|    246|            func.entry_block = Some(block_id);
  836|      0|        }
  837|    246|    }
  838|       |
  839|     59|    pub(crate) fn get_next_anonymous_global_name(&mut self) -> NameId {
  840|     59|        let name = format!(".L.str{}", self.anonymous_global_counter);
  841|     59|        self.anonymous_global_counter += 1;
  842|     59|        NameId::new(name)
  843|     59|    }
  844|       |}
  845|       |
  846|       |/// Display implementations for debugging
  847|       |impl fmt::Display for MirModule {
  848|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  849|      0|        writeln!(f, "MirModule(id: {})", self.id.get())?;
  850|      0|        writeln!(f, "  Functions: {:?}", self.functions)?;
  851|      0|        writeln!(f, "  Globals: {:?}", self.globals)?;
  852|      0|        writeln!(f, "  Types: {:?}", self.types)?;
  853|      0|        writeln!(f, "  Constants: {:?}", self.constants)?;
  854|      0|        Ok(())
  855|      0|    }
  856|       |}
  857|       |
  858|       |impl fmt::Display for MirFunction {
  859|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  860|      0|        writeln!(
  861|      0|            f,
  862|      0|            "MirFunction(id: {}, name: {}, kind: {:?}, is_variadic: {})",
  863|      0|            self.id.get(),
  864|       |            self.name,
  865|       |            self.kind,
  866|       |            self.is_variadic
  867|      0|        )?;
  868|      0|        writeln!(f, "  Return type: {:?}", self.return_type)?;
  869|      0|        writeln!(f, "  Params: {:?}", self.params)?;
  870|      0|        writeln!(f, "  Locals: {:?}", self.locals)?;
  871|      0|        writeln!(f, "  Blocks: {:?}", self.blocks)?;
  872|      0|        if let Some(entry_block) = self.entry_block {
  873|      0|            writeln!(f, "  Entry block: {:?}", entry_block)?;
  874|       |        } else {
  875|      0|            writeln!(f, "  Entry block: None")?;
  876|       |        }
  877|      0|        Ok(())
  878|      0|    }
  879|       |}
  880|       |
  881|       |impl fmt::Display for MirBlock {
  882|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  883|      0|        writeln!(f, "MirBlock(id: {})", self.id.get())?;
  884|      0|        writeln!(f, "  Statements: {:?}", self.statements)?;
  885|      0|        writeln!(f, "  Terminator: {:?}", self.terminator)?;
  886|      0|        Ok(())
  887|      0|    }
  888|       |}
  889|       |
  890|       |impl fmt::Display for MirStmt {
  891|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  892|      0|        match self {
  893|      0|            MirStmt::Assign(place, operand) => write!(f, "Assign({:?}, {:?})", place, operand),
  894|      0|            MirStmt::Store(operand, place) => write!(f, "Store({:?}, {:?})", operand, place),
  895|      0|            MirStmt::Call { target, args, dest } => {
  896|      0|                write!(f, "Call {{ target: {:?}, args: {:?}, dest: {:?} }}", target, args, dest)
  897|       |            }
  898|      0|            MirStmt::Alloc(place, type_id) => write!(f, "Alloc({:?}, {})", place, type_id.get()),
  899|      0|            MirStmt::Dealloc(operand) => write!(f, "Dealloc({:?})", operand),
  900|      0|            MirStmt::BuiltinVaStart(ap, last) => write!(f, "BuiltinVaStart({:?}, {:?})", ap, last),
  901|      0|            MirStmt::BuiltinVaEnd(ap) => write!(f, "BuiltinVaEnd({:?})", ap),
  902|      0|            MirStmt::BuiltinVaCopy(dst, src) => write!(f, "BuiltinVaCopy({:?}, {:?})", dst, src),
  903|      0|            MirStmt::AtomicStore(ptr, val, order) => write!(f, "AtomicStore({:?}, {:?}, {:?})", ptr, val, order),
  904|       |        }
  905|      0|    }
  906|       |}
  907|       |
  908|       |impl fmt::Display for Terminator {
  909|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  910|      0|        match self {
  911|      0|            Terminator::Goto(block) => write!(f, "Goto({})", block.get()),
  912|      0|            Terminator::If(cond, then_block, else_block) => {
  913|      0|                write!(f, "If({:?}, {}, {})", cond, then_block.get(), else_block.get())
  914|       |            }
  915|      0|            Terminator::Return(operand) => write!(f, "Return({:?})", operand),
  916|      0|            Terminator::Unreachable => write!(f, "Unreachable"),
  917|       |        }
  918|      0|    }
  919|       |}
  920|       |
  921|       |impl fmt::Display for Place {
  922|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  923|      0|        match self {
  924|      0|            Place::Local(local) => write!(f, "Local({})", local.get()),
  925|      0|            Place::Deref(operand) => write!(f, "Deref({:?})", operand),
  926|      0|            Place::Global(global) => write!(f, "Global({})", global.get()),
  927|      0|            Place::StructField(place, field_idx) => write!(f, "StructField({:?}, {})", place, field_idx),
  928|      0|            Place::ArrayIndex(place, index) => write!(f, "ArrayIndex({:?}, {:?})", place, index),
  929|       |        }
  930|      0|    }
  931|       |}
  932|       |
  933|       |impl fmt::Display for Operand {
  934|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  935|      0|        match self {
  936|      0|            Operand::Copy(place) => write!(f, "Copy({:?})", place),
  937|      0|            Operand::Constant(const_id) => write!(f, "Constant({})", const_id.get()),
  938|      0|            Operand::AddressOf(place) => write!(f, "AddressOf({:?})", place),
  939|      0|            Operand::Cast(type_id, operand) => write!(f, "Cast({}, {:?})", type_id.get(), operand),
  940|       |        }
  941|      0|    }
  942|       |}
  943|       |
  944|       |impl fmt::Display for Rvalue {
  945|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  946|      0|        match self {
  947|      0|            Rvalue::Use(operand) => write!(f, "Use({:?})", operand),
  948|      0|            Rvalue::BinaryIntOp(op, left, right) => write!(f, "BinaryIntOp({}, {:?}, {:?})", op, left, right),
  949|      0|            Rvalue::BinaryFloatOp(op, left, right) => write!(f, "BinaryFloatOp({}, {:?}, {:?})", op, left, right),
  950|      0|            Rvalue::UnaryIntOp(op, operand) => write!(f, "UnaryIntOp({}, {:?})", op, operand),
  951|      0|            Rvalue::UnaryFloatOp(op, operand) => write!(f, "UnaryFloatOp({}, {:?})", op, operand),
  952|      0|            Rvalue::Cast(type_id, operand) => write!(f, "Cast({}, {:?})", type_id.get(), operand),
  953|      0|            Rvalue::PtrAdd(base, offset) => write!(f, "PtrAdd({:?}, {:?})", base, offset),
  954|      0|            Rvalue::PtrSub(base, offset) => write!(f, "PtrSub({:?}, {:?})", base, offset),
  955|      0|            Rvalue::PtrDiff(left, right) => write!(f, "PtrDiff({:?}, {:?})", left, right),
  956|      0|            Rvalue::StructLiteral(fields) => write!(f, "StructLiteral({:?})", fields),
  957|      0|            Rvalue::ArrayLiteral(elements) => write!(f, "ArrayLiteral({:?})", elements),
  958|      0|            Rvalue::Load(operand) => write!(f, "Load({:?})", operand),
  959|      0|            Rvalue::BuiltinVaArg(ap, ty) => write!(f, "BuiltinVaArg({:?}, {})", ap, ty.get()),
  960|      0|            Rvalue::AtomicLoad(ptr, order) => write!(f, "AtomicLoad({:?}, {:?})", ptr, order),
  961|      0|            Rvalue::AtomicExchange(ptr, val, order) => write!(f, "AtomicExchange({:?}, {:?}, {:?})", ptr, val, order),
  962|      0|            Rvalue::AtomicCompareExchange(ptr, expected, desired, weak, success, failure) => write!(
  963|      0|                f,
  964|      0|                "AtomicCompareExchange({:?}, {:?}, {:?}, {}, {:?}, {:?})",
  965|       |                ptr, expected, desired, weak, success, failure
  966|       |            ),
  967|      0|            Rvalue::AtomicFetchOp(op, ptr, val, order) => {
  968|      0|                write!(f, "AtomicFetchOp({:?}, {:?}, {:?}, {:?})", op, ptr, val, order)
  969|       |            }
  970|       |        }
  971|      0|    }
  972|       |}
  973|       |
  974|       |impl fmt::Display for BinaryIntOp {
  975|     30|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  976|     30|        match self {
  977|     15|            BinaryIntOp::Add => write!(f, "+"),
  978|      4|            BinaryIntOp::Sub => write!(f, "-"),
  979|      0|            BinaryIntOp::Mul => write!(f, "*"),
  980|      0|            BinaryIntOp::Div => write!(f, "/"),
  981|      0|            BinaryIntOp::Mod => write!(f, "%"),
  982|      1|            BinaryIntOp::BitAnd => write!(f, "&"),
  983|      1|            BinaryIntOp::BitOr => write!(f, "|"),
  984|      0|            BinaryIntOp::BitXor => write!(f, "^"),
  985|      0|            BinaryIntOp::LShift => write!(f, "<<"),
  986|      0|            BinaryIntOp::RShift => write!(f, ">>"),
  987|      1|            BinaryIntOp::Eq => write!(f, "=="),
  988|      6|            BinaryIntOp::Ne => write!(f, "!="),
  989|      1|            BinaryIntOp::Lt => write!(f, "<"),
  990|      0|            BinaryIntOp::Le => write!(f, "<="),
  991|      1|            BinaryIntOp::Gt => write!(f, ">"),
  992|      0|            BinaryIntOp::Ge => write!(f, ">="),
  993|       |        }
  994|     30|    }
  995|       |}
  996|       |
  997|       |impl fmt::Display for BinaryFloatOp {
  998|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
  999|      0|        match self {
 1000|      0|            BinaryFloatOp::Add => write!(f, "+"),
 1001|      0|            BinaryFloatOp::Sub => write!(f, "-"),
 1002|      0|            BinaryFloatOp::Mul => write!(f, "*"),
 1003|      0|            BinaryFloatOp::Div => write!(f, "/"),
 1004|      0|            BinaryFloatOp::Eq => write!(f, "=="),
 1005|      0|            BinaryFloatOp::Ne => write!(f, "!="),
 1006|      0|            BinaryFloatOp::Lt => write!(f, "<"),
 1007|      0|            BinaryFloatOp::Le => write!(f, "<="),
 1008|      0|            BinaryFloatOp::Gt => write!(f, ">"),
 1009|      0|            BinaryFloatOp::Ge => write!(f, ">="),
 1010|       |        }
 1011|      0|    }
 1012|       |}
 1013|       |
 1014|       |impl fmt::Display for UnaryIntOp {
 1015|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1016|      0|        match self {
 1017|      0|            UnaryIntOp::Neg => write!(f, "-"),
 1018|      0|            UnaryIntOp::BitwiseNot => write!(f, "~"),
 1019|      0|            UnaryIntOp::LogicalNot => write!(f, "!"),
 1020|       |        }
 1021|      0|    }
 1022|       |}
 1023|       |
 1024|       |impl fmt::Display for UnaryFloatOp {
 1025|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1026|      0|        match self {
 1027|      0|            UnaryFloatOp::Neg => write!(f, "-"),
 1028|       |        }
 1029|      0|    }
 1030|       |}
 1031|       |
 1032|       |impl fmt::Display for MirType {
 1033|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1034|      0|        match self {
 1035|      0|            MirType::Void => write!(f, "void"),
 1036|      0|            MirType::Bool => write!(f, "bool"),
 1037|       |
 1038|      0|            MirType::I8 => write!(f, "i8"),
 1039|      0|            MirType::I16 => write!(f, "i16"),
 1040|      0|            MirType::I32 => write!(f, "i32"),
 1041|      0|            MirType::I64 => write!(f, "i64"),
 1042|      0|            MirType::U8 => write!(f, "u8"),
 1043|      0|            MirType::U16 => write!(f, "u16"),
 1044|      0|            MirType::U32 => write!(f, "u32"),
 1045|      0|            MirType::U64 => write!(f, "u64"),
 1046|      0|            MirType::F32 => write!(f, "f32"),
 1047|      0|            MirType::F64 => write!(f, "f64"),
 1048|      0|            MirType::F80 => write!(f, "f80"),
 1049|      0|            MirType::F128 => write!(f, "f128"),
 1050|      0|            MirType::Pointer { pointee } => write!(f, "*{}", pointee.get()),
 1051|      0|            MirType::Array { element, size, .. } => write!(f, "[{}]{}", size, element.get()),
 1052|       |            MirType::Function {
 1053|      0|                return_type,
 1054|      0|                params,
 1055|      0|                is_variadic,
 1056|       |            } => {
 1057|      0|                if *is_variadic {
 1058|      0|                    write!(f, "fn({:?}, ...) -> {}", params, return_type.get())
 1059|       |                } else {
 1060|      0|                    write!(f, "fn({:?}) -> {}", params, return_type.get())
 1061|       |                }
 1062|       |            }
 1063|       |            MirType::Record {
 1064|      0|                name,
 1065|      0|                field_types,
 1066|      0|                field_names,
 1067|      0|                is_union,
 1068|       |                ..
 1069|       |            } => {
 1070|      0|                let kind = if *is_union { "union" } else { "struct" };
 1071|      0|                let fields_str = field_names
 1072|      0|                    .iter()
 1073|      0|                    .zip(field_types.iter())
 1074|      0|                    .map(|(name, ty)| format!("{}: {}", name, ty.get()))
 1075|      0|                    .collect::<Vec<_>>()
 1076|      0|                    .join(", ");
 1077|      0|                write!(f, "{} {} {{ {} }}", kind, name, fields_str)
 1078|       |            }
 1079|       |        }
 1080|      0|    }
 1081|       |}
 1082|       |
 1083|       |impl fmt::Display for ConstValueKind {
 1084|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1085|      0|        match self {
 1086|      0|            ConstValueKind::Int(val) => write!(f, "{}", val),
 1087|      0|            ConstValueKind::Float(val) => write!(f, "{}", val),
 1088|      0|            ConstValueKind::Bool(val) => write!(f, "{}", val),
 1089|      0|            ConstValueKind::Null => write!(f, "null"),
 1090|      0|            ConstValueKind::Zero => write!(f, "zeroinit"),
 1091|      0|            ConstValueKind::StructLiteral(fields) => write!(f, "StructLiteral({:?})", fields),
 1092|      0|            ConstValueKind::ArrayLiteral(elements) => write!(f, "ArrayLiteral({:?})", elements),
 1093|      0|            ConstValueKind::GlobalAddress(global_id) => write!(f, "GlobalAddress({})", global_id.get()),
 1094|      0|            ConstValueKind::FunctionAddress(func_id) => write!(f, "FunctionAddress({})", func_id.get()),
 1095|       |        }
 1096|      0|    }
 1097|       |}
 1098|       |
 1099|       |impl fmt::Display for ConstValue {
 1100|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1101|      0|        write!(f, "{} (ty: {})", self.kind, self.ty.get())
 1102|      0|    }
 1103|       |}
 1104|       |
 1105|       |impl fmt::Display for CallTarget {
 1106|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1107|      0|        match self {
 1108|      0|            CallTarget::Direct(func_id) => write!(f, "Direct({})", func_id.get()),
 1109|      0|            CallTarget::Indirect(operand) => write!(f, "Indirect({:?})", operand),
 1110|       |        }
 1111|      0|    }
 1112|       |}
 1113|       |
 1114|       |impl fmt::Display for Local {
 1115|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1116|      0|        write!(
 1117|      0|            f,
 1118|      0|            "Local(id: {}, name: {:?}, type: {}, is_param: {})",
 1119|      0|            self.id.get(),
 1120|       |            self.name,
 1121|      0|            self.type_id.get(),
 1122|       |            self.is_param
 1123|       |        )
 1124|      0|    }
 1125|       |}
 1126|       |
 1127|       |impl fmt::Display for Global {
 1128|      0|    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
 1129|      0|        write!(
 1130|      0|            f,
 1131|      0|            "Global(id: {}, name: {}, type: {}, is_constant: {})",
 1132|      0|            self.id.get(),
 1133|       |            self.name,
 1134|      0|            self.type_id.get(),
 1135|       |            self.is_constant
 1136|       |        )
 1137|      0|    }
 1138|       |}

/app/src/mir/dumper.rs:
    1|       |//! MIR (Mid-level Intermediate Representation) Dumper
    2|       |//!
    3|       |//! This module provides functionality to dump MIR in a human-readable format
    4|       |//! following the C11 compiler's specific conventions:
    5|       |//! - Local variables: %0, %1, %tmp3
    6|       |//! - Global variables: @g_var
    7|       |//! - Basic blocks: bb0, bb1
    8|       |//! - Constants: const 42, const null
    9|       |//! - Types: i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, ptr<T>
   10|       |
   11|       |use std::fmt::Write;
   12|       |
   13|       |use super::{
   14|       |    BinaryFloatOp, CallTarget, ConstValueId, ConstValueKind, Global, GlobalId, LocalId, MirBlock, MirBlockId,
   15|       |    MirFunction, MirFunctionId, MirFunctionKind, MirStmt, MirType, Operand, Place, Rvalue, Terminator, TypeId,
   16|       |    UnaryFloatOp,
   17|       |};
   18|       |use crate::mir::MirProgram;
   19|       |
   20|       |/// Configuration for MIR dump output
   21|       |#[derive(Debug, Clone)]
   22|       |pub struct MirDumpConfig {
   23|       |    pub include_header: bool,
   24|       |}
   25|       |
   26|       |impl Default for MirDumpConfig {
   27|      0|    fn default() -> Self {
   28|      0|        MirDumpConfig { include_header: true }
   29|      0|    }
   30|       |}
   31|       |
   32|       |/// Main MIR dumper that generates human-readable MIR output
   33|       |pub struct MirDumper<'a> {
   34|       |    mir: &'a MirProgram,
   35|       |    config: &'a MirDumpConfig,
   36|       |}
   37|       |
   38|       |impl<'a> MirDumper<'a> {
   39|       |    /// Create a new MIR dumper
   40|     82|    pub(crate) fn new(mir: &'a MirProgram, config: &'a MirDumpConfig) -> Self {
   41|     82|        Self { mir, config }
   42|     82|    }
   43|       |
   44|       |    /// Generate the complete MIR dump
   45|     82|    pub(crate) fn generate_mir_dump(&self) -> Result<String, std::fmt::Error> {
   46|     82|        let mut output = String::new();
   47|       |
   48|       |        // Dump module header
   49|     82|        if self.config.include_header {
   50|      1|            writeln!(output, "; MIR Dump for Module {}", self.mir.module.id.get())?;
                                                                                                ^0
   51|      1|            writeln!(output, "; Generated by Cendol C11 Compiler")?;
                                                                                ^0
   52|      1|            writeln!(output)?;
                                          ^0
   53|     81|        }
   54|       |
   55|       |        // Dump type definitions
   56|     82|        self.dump_types(&mut output)?;
                                                  ^0
   57|     82|        writeln!(output)?;
                                      ^0
   58|       |
   59|       |        // Dump global variables first
   60|     82|        if !self.mir.module.globals.is_empty() {
   61|     79|            for &global_id in &self.mir.module.globals {
                               ^45
   62|     45|                if let Some(global) = self.mir.globals.get(&global_id) {
   63|     45|                    self.dump_global(&mut output, global)?;
                                                                       ^0
   64|     45|                    writeln!(output)?;
                                                  ^0
   65|      0|                }
   66|       |            }
   67|     34|            writeln!(output)?;
                                          ^0
   68|     48|        }
   69|       |
   70|       |        // Dump all functions
   71|    170|        for &func_id in &self.mir.module.functions {
                           ^88
   72|     88|            if let Some(func) = self.mir.functions.get(&func_id) {
   73|     88|                self.dump_function(&mut output, func)?;
                                                                   ^0
   74|     88|                writeln!(output)?;
                                              ^0
   75|      0|            }
   76|       |        }
   77|       |
   78|     82|        Ok(output)
   79|     82|    }
   80|       |
   81|       |    /// Dump a single function
   82|     88|    fn dump_function(&self, output: &mut String, func: &MirFunction) -> Result<(), std::fmt::Error> {
   83|       |        // Function signature
   84|     88|        let return_type = self.type_to_string(func.return_type);
   85|     88|        let fn_keyword = match func.kind {
   86|      7|            MirFunctionKind::Extern => "extern fn",
   87|     81|            MirFunctionKind::Defined => "fn",
   88|       |        };
   89|     88|        write!(output, "{} {}(", fn_keyword, func.name)?;
                                                                     ^0
   90|       |
   91|       |        // Dump parameters
   92|     88|        for (i, &param_id) in func.params.iter().enumerate() {
                           ^22 ^22
   93|     22|            if i > 0 {
   94|      6|                write!(output, ", ")?;
                                                  ^0
   95|     16|            }
   96|     22|            if let Some(param) = self.mir.locals.get(&param_id) {
   97|     22|                let param_type = self.type_to_string(param.type_id);
   98|     22|                let param_name = param.name.as_ref().map_or("%unnamed".to_string(), |s| s.to_string());
   99|     22|                write!(output, "%{}: {}", param_name, param_type)?;
                                                                               ^0
  100|       |            } else {
  101|      0|                write!(output, "%param{}: ?", param_id.get())?;
  102|       |            }
  103|       |        }
  104|     88|        if func.is_variadic {
  105|      4|            if !func.params.is_empty() {
  106|      4|                write!(output, ", ")?;
                                                  ^0
  107|      0|            }
  108|      4|            write!(output, "...")?;
                                               ^0
  109|     84|        }
  110|       |
  111|     88|        write!(output, ") -> {}", return_type)?;
                                                            ^0
  112|       |
  113|       |        // For extern functions, don't output any body
  114|     88|        if matches!(func.kind, MirFunctionKind::Extern) {
                         ^81
  115|      7|            writeln!(output)?;
                                          ^0
  116|      7|            return Ok(());
  117|     81|        }
  118|       |
  119|     81|        writeln!(output)?;
                                      ^0
  120|       |
  121|       |        // Function body
  122|     81|        writeln!(output, "{{")?;
                                            ^0
  123|       |
  124|       |        // Dump locals section
  125|     81|        if func.locals.is_empty() == false {
  126|     56|            writeln!(output, "  locals {{")?;
                                                         ^0
  127|    268|            for &local_id in &func.locals {
                               ^212
  128|    212|                if let Some(local) = self.mir.locals.get(&local_id) {
  129|    212|                    let local_type = self.type_to_string(local.type_id);
  130|    212|                    let local_name = self.local_to_string(local_id);
  131|    212|                    writeln!(output, "    {}: {}", local_name, local_type)?;
                                                                                        ^0
  132|      0|                }
  133|       |            }
  134|     56|            writeln!(output, "  }}")?;
                                                  ^0
  135|     25|        }
  136|       |
  137|       |        // Dump basic blocks
  138|    236|        for &block_id in &func.blocks {
                           ^155
  139|    155|            if let Some(block) = self.mir.blocks.get(&block_id) {
  140|    155|                self.dump_block(output, block_id, block)?;
                                                                      ^0
  141|      0|            }
  142|       |        }
  143|       |
  144|     81|        writeln!(output, "}}")?;
                                            ^0
  145|     81|        Ok(())
  146|     88|    }
  147|       |
  148|       |    /// Dump all type definitions
  149|     82|    fn dump_types(&self, output: &mut String) -> Result<(), std::fmt::Error> {
  150|    268|        for (i, mir_type) in self.mir.module.types.iter().enumerate() {
                                           ^82                          ^82
  151|    268|            let type_id = TypeId::new((i + 1) as u32).unwrap();
  152|    268|            let type_str = self.type_to_string_with_id(type_id, mir_type);
  153|    268|            writeln!(output, "{}", type_str)?;
                                                          ^0
  154|       |        }
  155|     82|        Ok(())
  156|     82|    }
  157|       |
  158|       |    /// Convert MIR type to string representation with type ID
  159|    268|    fn type_to_string_with_id(&self, type_id: TypeId, mir_type: &MirType) -> String {
  160|    268|        let type_index = self.get_type_index_from_type_id(type_id);
  161|    268|        let type_name = format!("%t{}", type_index);
  162|       |
  163|    268|        match mir_type {
  164|     23|            MirType::Void => format!("type {} = void", type_name),
  165|      2|            MirType::Bool => format!("type {} = bool", type_name),
  166|       |
  167|     13|            MirType::I8 => format!("type {} = i8", type_name),
  168|      1|            MirType::I16 => format!("type {} = i16", type_name),
  169|     77|            MirType::I32 => format!("type {} = i32", type_name),
  170|      4|            MirType::I64 => format!("type {} = i64", type_name),
  171|      3|            MirType::U8 => format!("type {} = u8", type_name),
  172|      1|            MirType::U16 => format!("type {} = u16", type_name),
  173|      1|            MirType::U32 => format!("type {} = u32", type_name),
  174|      5|            MirType::U64 => format!("type {} = u64", type_name),
  175|      5|            MirType::F32 => format!("type {} = f32", type_name),
  176|      4|            MirType::F64 => format!("type {} = f64", type_name),
  177|      1|            MirType::F80 => format!("type {} = f80", type_name),
  178|      1|            MirType::F128 => format!("type {} = f128", type_name),
  179|     29|            MirType::Pointer { pointee } => {
  180|     29|                let pointee_index = self.get_type_index_from_type_id(*pointee);
  181|     29|                format!("type {} = ptr<%t{}>", type_name, pointee_index)
  182|       |            }
  183|     43|            MirType::Array { element, size, .. } => {
  184|     43|                let elem_index = self.get_type_index_from_type_id(*element);
  185|     43|                format!("type {} = [{}]%t{}", type_name, size, elem_index)
  186|       |            }
  187|       |            MirType::Function {
  188|     23|                return_type,
  189|     23|                params,
  190|     23|                is_variadic,
  191|       |            } => {
  192|     23|                let ret_index = self.get_type_index_from_type_id(*return_type);
  193|     23|                let mut param_types: Vec<String> = params
  194|     23|                    .iter()
  195|     23|                    .map(|&p| {
                                            ^9
  196|      9|                        let param_index = self.get_type_index_from_type_id(p);
  197|      9|                        format!("%t{}", param_index)
  198|      9|                    })
  199|     23|                    .collect();
  200|     23|                if *is_variadic {
  201|      4|                    param_types.push("...".to_string());
  202|     19|                }
  203|     23|                format!("type {} = fn({}) -> %t{}", type_name, param_types.join(", "), ret_index)
  204|       |            }
  205|       |            MirType::Record {
  206|     32|                name,
  207|     32|                field_types,
  208|     32|                field_names,
  209|     32|                is_union,
  210|       |                ..
  211|       |            } => {
  212|     32|                let field_strs: Vec<String> = field_names
  213|     32|                    .iter()
  214|     32|                    .zip(field_types.iter())
  215|     59|                    .map(|(fname, fid)| {
                                   ^32
  216|     59|                        let field_index = self.get_type_index_from_type_id(*fid);
  217|     59|                        format!("{}: %t{}", fname, field_index)
  218|     59|                    })
  219|     32|                    .collect();
  220|     32|                let kind = if *is_union { "union" } else { "struct" };
                                                        ^1               ^31
  221|     32|                format!("type {} = {} {} {{ {} }}", type_name, kind, name, field_strs.join(", "))
  222|       |            }
  223|       |        }
  224|    268|    }
  225|       |
  226|       |    /// Helper function to get type index from TypeId
  227|    946|    fn get_type_index_from_type_id(&self, type_id: TypeId) -> usize {
  228|       |        // Fallback: assume sequential mapping
  229|    946|        (type_id.get() - 1) as usize
  230|    946|    }
  231|       |
  232|       |    /// Dump a global variable
  233|     45|    fn dump_global(&self, output: &mut String, global: &Global) -> Result<(), std::fmt::Error> {
  234|     45|        let global_type = self.type_to_string(global.type_id);
  235|     45|        write!(output, "global @{}: {}", global.name, global_type)?;
                                                                                ^0
  236|       |
  237|     45|        if let Some(const_id) = global.initial_value {
                                  ^44
  238|       |            // Check if this global represents a string literal
  239|     44|            if let Some(string_repr) = self.try_format_as_string_literal(&global.name.to_string(), const_id) {
                                      ^10
  240|     10|                write!(output, " = {}", string_repr)?;
                                                                  ^0
  241|       |            } else {
  242|     34|                write!(output, " = {}", self.const_to_string(const_id))?;
                                                                                     ^0
  243|       |            }
  244|      1|        }
  245|       |
  246|     45|        Ok(())
  247|     45|    }
  248|       |
  249|       |    /// Dump a basic block
  250|    155|    fn dump_block(&self, output: &mut String, block_id: MirBlockId, block: &MirBlock) -> Result<(), std::fmt::Error> {
  251|    155|        writeln!(output)?;
                                      ^0
  252|    155|        writeln!(output, "  {}:", self.block_to_string(block_id))?;
                                                                               ^0
  253|       |
  254|       |        // Dump statements in the block
  255|    435|        for &stmt_id in &block.statements {
                           ^280
  256|    280|            if let Some(stmt) = self.mir.statements.get(&stmt_id) {
  257|    280|                write!(output, "    ")?;
                                                    ^0
  258|    280|                self.dump_statement(output, stmt)?;
                                                               ^0
  259|    280|                writeln!(output)?;
                                              ^0
  260|      0|            }
  261|       |        }
  262|       |
  263|       |        // Dump terminator (MUST be explicit)
  264|    155|        write!(output, "    ")?;
                                            ^0
  265|    155|        self.dump_terminator(output, &block.terminator)?;
                                                                     ^0
  266|    155|        writeln!(output)?;
                                      ^0
  267|       |
  268|    155|        Ok(())
  269|    155|    }
  270|       |
  271|       |    /// Dump a statement
  272|    280|    fn dump_statement(&self, output: &mut String, stmt: &MirStmt) -> Result<(), std::fmt::Error> {
  273|    280|        match stmt {
  274|    248|            MirStmt::Assign(place, rvalue) => {
  275|    248|                write!(output, "{} = ", self.place_to_string(place))?;
                                                                                  ^0
  276|    248|                self.dump_rvalue(output, rvalue)?;
                                                              ^0
  277|       |            }
  278|      1|            MirStmt::Store(operand, place) => {
  279|      1|                write!(output, "store ")?;
                                                      ^0
  280|      1|                self.dump_operand(output, operand)?;
                                                                ^0
  281|      1|                write!(output, ", {}", self.place_to_string(place))?;
                                                                                 ^0
  282|       |            }
  283|     25|            MirStmt::Call { target, args, dest } => {
  284|     25|                if let Some(place) = dest {
                                          ^6
  285|      6|                    write!(output, "{} = ", self.place_to_string(place))?;
                                                                                      ^0
  286|     19|                }
  287|     25|                write!(output, "call {}(", self.call_target_to_string(target))?;
                                                                                            ^0
  288|     25|                for (i, operand) in args.iter().enumerate() {
                                   ^16^16
  289|     16|                    if i > 0 {
  290|      6|                        write!(output, ", ")?;
                                                          ^0
  291|     10|                    }
  292|     16|                    self.dump_operand(output, operand)?;
                                                                    ^0
  293|       |                }
  294|     25|                write!(output, ")")?;
                                                 ^0
  295|       |            }
  296|      1|            MirStmt::Alloc(place, type_id) => {
  297|      1|                write!(
  298|      1|                    output,
  299|      1|                    "{} = alloc {}",
  300|      1|                    self.place_to_string(place),
  301|      1|                    self.type_to_string(*type_id)
  302|      0|                )?;
  303|       |            }
  304|      1|            MirStmt::Dealloc(operand) => {
  305|      1|                write!(output, "dealloc ")?;
                                                        ^0
  306|      1|                self.dump_operand(output, operand)?;
                                                                ^0
  307|       |            }
  308|      1|            MirStmt::BuiltinVaStart(ap, last) => {
  309|      1|                write!(
  310|      1|                    output,
  311|      1|                    "va_start({}, {})",
  312|      1|                    self.place_to_string(ap),
  313|      1|                    self.operand_to_string(last)
  314|      0|                )?;
  315|       |            }
  316|      1|            MirStmt::BuiltinVaEnd(ap) => {
  317|      1|                write!(output, "va_end({})", self.place_to_string(ap))?;
                                                                                    ^0
  318|       |            }
  319|      1|            MirStmt::BuiltinVaCopy(dst, src) => {
  320|      1|                write!(
  321|      1|                    output,
  322|      1|                    "va_copy({}, {})",
  323|      1|                    self.place_to_string(dst),
  324|      1|                    self.place_to_string(src)
  325|      0|                )?;
  326|       |            }
  327|      1|            MirStmt::AtomicStore(ptr, val, order) => {
  328|      1|                write!(
  329|      1|                    output,
  330|      1|                    "atomic_store({}, {}, {:?})",
  331|      1|                    self.operand_to_string(ptr),
  332|      1|                    self.operand_to_string(val),
  333|       |                    order
  334|      0|                )?;
  335|       |            }
  336|       |        }
  337|    280|        Ok(())
  338|    280|    }
  339|       |
  340|       |    /// Dump a terminator
  341|    155|    fn dump_terminator(&self, output: &mut String, terminator: &Terminator) -> Result<(), std::fmt::Error> {
  342|    155|        match terminator {
  343|     43|            Terminator::Goto(block_id) => {
  344|     43|                write!(output, "br {}", self.block_to_string(*block_id))?;
                                                                                      ^0
  345|       |            }
  346|     21|            Terminator::If(cond, then_block, else_block) => {
  347|     21|                write!(
  348|     21|                    output,
  349|     21|                    "cond_br {}, {}, {}",
  350|     21|                    self.operand_to_string(cond),
  351|     21|                    self.block_to_string(*then_block),
  352|     21|                    self.block_to_string(*else_block)
  353|      0|                )?;
  354|       |            }
  355|     90|            Terminator::Return(operand) => match operand {
  356|     73|                Some(op) => {
  357|     73|                    write!(output, "return ")?;
                                                           ^0
  358|     73|                    self.dump_operand(output, op)?;
                                                               ^0
  359|       |                }
  360|       |                None => {
  361|     17|                    write!(output, "return")?;
                                                          ^0
  362|       |                }
  363|       |            },
  364|       |            Terminator::Unreachable => {
  365|      1|                write!(output, "unreachable")?;
                                                           ^0
  366|       |            }
  367|       |        }
  368|    155|        Ok(())
  369|    155|    }
  370|       |
  371|       |    /// Convert MIR type to string representation
  372|    515|    fn type_to_string(&self, type_id: TypeId) -> String {
  373|    515|        if let Some(mir_type) = self.mir.types.get(&type_id) {
  374|    515|            let type_index = self.get_type_index_from_type_id(type_id);
  375|       |
  376|    515|            match mir_type {
  377|     31|                MirType::Void => "void".to_string(),
  378|      5|                MirType::Bool => "bool".to_string(),
  379|       |
  380|     48|                MirType::I8 => "i8".to_string(),
  381|      2|                MirType::I16 => "i16".to_string(),
  382|    187|                MirType::I32 => "i32".to_string(),
  383|     11|                MirType::I64 => "i64".to_string(),
  384|      2|                MirType::U8 => "u8".to_string(),
  385|      2|                MirType::U16 => "u16".to_string(),
  386|      2|                MirType::U32 => "u32".to_string(),
  387|     10|                MirType::U64 => "u64".to_string(),
  388|     28|                MirType::F32 => "f32".to_string(),
  389|     29|                MirType::F64 => "f64".to_string(),
  390|      0|                MirType::F80 => "f80".to_string(),
  391|      0|                MirType::F128 => "f128".to_string(),
  392|     61|                MirType::Pointer { pointee } => {
  393|     61|                    let pointee_type = self.type_to_string(*pointee);
  394|     61|                    format!("ptr<{}>", pointee_type)
  395|       |                }
  396|     32|                MirType::Array { element, size, .. } => {
  397|     32|                    let elem_type = self.type_to_string(*element);
  398|     32|                    format!("[{}]{}", size, elem_type)
  399|       |                }
  400|       |                MirType::Function {
  401|      1|                    return_type,
  402|      1|                    params,
  403|      1|                    is_variadic,
  404|       |                } => {
  405|      1|                    let ret_type = self.type_to_string(*return_type);
  406|      1|                    let mut param_types: Vec<String> = params.iter().map(|&p| self.type_to_string(p)).collect();
                                                                                            ^0   ^0             ^0
  407|      1|                    if *is_variadic {
  408|      0|                        param_types.push("...".to_string());
  409|      1|                    }
  410|      1|                    format!("fn({}) -> {}", param_types.join(", "), ret_type)
  411|       |                }
  412|       |                MirType::Record { .. } => {
  413|       |                    // For aggregate types, use the type ID to keep output concise
  414|     64|                    format!("%t{}", type_index)
  415|       |                }
  416|       |            }
  417|       |        } else {
  418|      0|            format!("unknown_type_{}", type_id.get())
  419|       |        }
  420|    515|    }
  421|       |
  422|       |    /// Convert local ID to string representation
  423|    770|    fn local_to_string(&self, local_id: LocalId) -> String {
  424|    770|        let local = self.mir.locals.get(&local_id);
  425|    770|        let name = match local {
  426|    770|            Some(local) => {
  427|    770|                if let Some(name) = &local.name {
                                          ^398
  428|    398|                    format!("{}", name)
  429|       |                } else {
  430|    372|                    format!("{}", local.id.get())
  431|       |                }
  432|       |            }
  433|      0|            None => format!("{}", local_id.get()),
  434|       |        };
  435|       |
  436|    770|        format!("%{}", name)
  437|    770|    }
  438|       |
  439|       |    /// Convert global ID to string representation
  440|     23|    fn global_to_string(&self, global_id: GlobalId) -> String {
  441|     23|        if let Some(global) = self.mir.globals.get(&global_id) {
  442|     23|            format!("@{}", global.name)
  443|       |        } else {
  444|      0|            format!("@global_{}", global_id.get())
  445|       |        }
  446|     23|    }
  447|       |
  448|       |    /// Convert block ID to string representation
  449|    240|    fn block_to_string(&self, block_id: MirBlockId) -> String {
  450|    240|        format!("bb{}", block_id.get())
  451|    240|    }
  452|       |
  453|       |    /// Convert function ID to string representation
  454|     30|    fn function_to_string(&self, func_id: MirFunctionId) -> String {
  455|     30|        if let Some(func) = self.mir.functions.get(&func_id) {
  456|     30|            format!("{}", func.name)
  457|       |        } else {
  458|      0|            format!("func_{}", func_id.get())
  459|       |        }
  460|     30|    }
  461|       |
  462|       |    /// Convert call target to string representation
  463|     25|    fn call_target_to_string(&self, call_target: &CallTarget) -> String {
  464|     25|        match call_target {
  465|     24|            CallTarget::Direct(func_id) => self.function_to_string(*func_id),
  466|      1|            CallTarget::Indirect(operand) => format!("*{}", self.operand_to_string(operand)),
  467|       |        }
  468|     25|    }
  469|       |
  470|       |    /// Try to format a constant as a string literal if applicable
  471|     44|    fn try_format_as_string_literal(&self, global_name: &str, const_id: ConstValueId) -> Option<String> {
  472|       |        // Only format as string if the global name starts with .L.str (our anonymous string literals)
  473|     44|        if !global_name.starts_with(".L.str") {
  474|     32|            return None;
  475|     12|        }
  476|       |
  477|     12|        if let Some(const_value) = self.mir.constants.get(&const_id)
  478|     12|            && let ConstValueKind::ArrayLiteral(elements) = &const_value.kind
                                                              ^10
  479|       |        {
  480|       |            // Try to convert the array elements to a string
  481|     10|            let mut string_content = String::new();
  482|       |
  483|     83|            for &element_id in elements {
  484|     83|                let element = self.mir.constants.get(&element_id).unwrap();
  485|     83|                if let ConstValueKind::Int(byte) = &element.kind {
  486|     83|                    let byte = *byte as u8;
  487|     83|                    if byte == 0 {
  488|       |                        // Null terminator - end of string
  489|     10|                        break;
  490|     73|                    }
  491|       |
  492|     67|                    match byte {
  493|      6|                        b'\n' => string_content.push_str("\\n"),
  494|      0|                        b'\r' => string_content.push_str("\\r"),
  495|      0|                        b'\t' => string_content.push_str("\\t"),
  496|      0|                        b'\\' => string_content.push_str("\\\\"),
  497|      0|                        b'"' => string_content.push_str("\\\""),
  498|     67|                        b if (32..=126).contains(&b) => string_content.push(b as char),
  499|       |                        _ => {
  500|       |                            // Use hex escape for other non-printable characters
  501|       |                            use std::fmt::Write;
  502|      0|                            write!(&mut string_content, "\\x{:02x}", byte).ok()?;
  503|       |                        }
  504|       |                    }
  505|       |                } else {
  506|       |                    // Non-integer element, not a string
  507|      0|                    return None;
  508|       |                }
  509|       |            }
  510|       |
  511|     10|            if !string_content.is_empty() {
  512|     10|                return Some(format!("const \"{}\"", string_content));
  513|      0|            }
  514|      2|        }
  515|       |
  516|      2|        None
  517|     44|    }
  518|       |
  519|       |    /// Convert constant ID to string representation
  520|    300|    fn const_to_string(&self, const_id: ConstValueId) -> String {
  521|    300|        if let Some(const_value) = self.mir.constants.get(&const_id) {
  522|    300|            match &const_value.kind {
  523|    208|                ConstValueKind::Int(val) => format!("const {}", val),
  524|      4|                ConstValueKind::Float(val) => format!("const {}", val),
  525|      0|                ConstValueKind::Bool(val) => format!("const {}", val),
  526|      1|                ConstValueKind::Null => "const null".to_string(),
  527|     38|                ConstValueKind::Zero => "const zero".to_string(),
  528|     21|                ConstValueKind::StructLiteral(fields) => {
  529|       |                    // Expand struct literal to show field contents
  530|     21|                    let field_strs: Vec<String> = fields
  531|     21|                        .iter()
  532|     32|                        .map(|(field_idx, field_const_id)| {
                                       ^21
  533|     32|                            let field_const_str = self.const_to_string(*field_const_id);
  534|     32|                            format!("{}: {}", field_idx, field_const_str)
  535|     32|                        })
  536|     21|                        .collect();
  537|     21|                    format!("const struct_literal {{ {} }}", field_strs.join(", "))
  538|       |                }
  539|     11|                ConstValueKind::ArrayLiteral(elements) => {
  540|       |                    // Expand array literal to show element contents
  541|     11|                    let element_strs: Vec<String> = elements
  542|     11|                        .iter()
  543|     50|                        .map(|element_const_id| self.const_to_string(*element_const_id))
                                       ^11
  544|     11|                        .collect();
  545|     11|                    format!("const array_literal [{}]", element_strs.join(", "))
  546|       |                }
  547|     11|                ConstValueKind::GlobalAddress(global_id) => {
  548|     11|                    format!("const {}", self.global_to_string(*global_id))
  549|       |                }
  550|      6|                ConstValueKind::FunctionAddress(func_id) => {
  551|      6|                    format!("const {}", self.function_to_string(*func_id))
  552|       |                }
  553|       |            }
  554|       |        } else {
  555|      0|            format!("const unknown_{}", const_id.get())
  556|       |        }
  557|    300|    }
  558|       |
  559|       |    /// Convert place to string representation
  560|    687|    fn place_to_string(&self, place: &Place) -> String {
  561|    687|        match place {
  562|    558|            Place::Local(local_id) => self.local_to_string(*local_id),
  563|     13|            Place::Deref(operand) => format!("deref({})", self.operand_to_string(operand)),
  564|     12|            Place::Global(global_id) => self.global_to_string(*global_id),
  565|    100|            Place::StructField(base_place, field_idx) => {
  566|    100|                format!("{}.field_{}", self.place_to_string(base_place), field_idx)
  567|       |            }
  568|      4|            Place::ArrayIndex(base_place, index) => {
  569|      4|                format!(
  570|      4|                    "{}[{}]",
  571|      4|                    self.place_to_string(base_place),
  572|      4|                    self.operand_to_string(index)
  573|       |                )
  574|       |            }
  575|       |        }
  576|    687|    }
  577|       |
  578|       |    /// Convert operand to string representation
  579|    558|    fn operand_to_string(&self, operand: &Operand) -> String {
  580|    558|        match operand {
  581|    316|            Operand::Copy(place) => self.place_to_string(place),
  582|    184|            Operand::Constant(const_id) => self.const_to_string(*const_id),
  583|      6|            Operand::AddressOf(place) => {
  584|      6|                format!("addr_of({})", self.place_to_string(place))
  585|       |            }
  586|     52|            Operand::Cast(type_id, operand) => {
  587|     52|                format!(
  588|     52|                    "cast<{}>({})",
  589|     52|                    self.type_to_string(*type_id),
  590|     52|                    self.operand_to_string(operand)
  591|       |                )
  592|       |            }
  593|       |        }
  594|    558|    }
  595|       |
  596|       |    /// Dump an operand (for use in statements)
  597|    211|    fn dump_operand(&self, output: &mut String, operand: &Operand) -> Result<(), std::fmt::Error> {
  598|    211|        write!(output, "{}", self.operand_to_string(operand))?;
                                                                           ^0
  599|    211|        Ok(())
  600|    211|    }
  601|       |
  602|       |    /// Dump an rvalue (for use in assignments)
  603|    248|    fn dump_rvalue(&self, output: &mut String, rvalue: &Rvalue) -> Result<(), std::fmt::Error> {
  604|    248|        match rvalue {
  605|    120|            Rvalue::Use(operand) => {
  606|    120|                self.dump_operand(output, operand)?;
                                                                ^0
  607|       |            }
  608|     29|            Rvalue::BinaryIntOp(op, left, right) => {
  609|     29|                write!(
  610|     29|                    output,
  611|     29|                    "{} {} {}",
  612|     29|                    self.operand_to_string(left),
  613|       |                    op,
  614|     29|                    self.operand_to_string(right)
  615|      0|                )?;
  616|       |            }
  617|     56|            Rvalue::BinaryFloatOp(op, left, right) => {
  618|     56|                write!(
  619|     56|                    output,
  620|     56|                    "{} {} {}",
  621|     56|                    self.operand_to_string(left),
  622|     56|                    self.binary_float_op_to_string(op),
  623|     56|                    self.operand_to_string(right)
  624|      0|                )?;
  625|       |            }
  626|      0|            Rvalue::UnaryIntOp(op, operand) => {
  627|      0|                write!(output, "{} {}", op, self.operand_to_string(operand))?;
  628|       |            }
  629|      7|            Rvalue::UnaryFloatOp(op, operand) => {
  630|      7|                write!(
  631|      7|                    output,
  632|      7|                    "{} {}",
  633|      7|                    self.unary_float_op_to_string(op),
  634|      7|                    self.operand_to_string(operand)
  635|      0|                )?;
  636|       |            }
  637|      0|            Rvalue::Cast(type_id, operand) => {
  638|      0|                write!(
  639|      0|                    output,
  640|      0|                    "cast<{}>({})",
  641|      0|                    self.type_to_string(*type_id),
  642|      0|                    self.operand_to_string(operand)
  643|      0|                )?;
  644|       |            }
  645|      5|            Rvalue::PtrAdd(base, offset) => {
  646|      5|                write!(
  647|      5|                    output,
  648|      5|                    "ptradd({}, {})",
  649|      5|                    self.operand_to_string(base),
  650|      5|                    self.operand_to_string(offset)
  651|      0|                )?;
  652|       |            }
  653|      1|            Rvalue::PtrSub(base, offset) => {
  654|      1|                write!(
  655|      1|                    output,
  656|      1|                    "ptrsub({}, {})",
  657|      1|                    self.operand_to_string(base),
  658|      1|                    self.operand_to_string(offset)
  659|      0|                )?;
  660|       |            }
  661|      1|            Rvalue::PtrDiff(left, right) => {
  662|      1|                write!(
  663|      1|                    output,
  664|      1|                    "ptrdiff({}, {})",
  665|      1|                    self.operand_to_string(left),
  666|      1|                    self.operand_to_string(right)
  667|      0|                )?;
  668|       |            }
  669|     15|            Rvalue::StructLiteral(fields) => {
  670|     15|                write!(output, "struct{{")?;
                                                        ^0
  671|     29|                for (i, (idx, op)) in fields.iter().enumerate() {
                                                    ^15           ^15
  672|     29|                    if i > 0 {
  673|     14|                        write!(output, ", ")?;
                                                          ^0
  674|     15|                    }
  675|     29|                    write!(output, "{}: {}", idx, self.operand_to_string(op))?;
                                                                                           ^0
  676|       |                }
  677|     15|                write!(output, "}}")?;
                                                  ^0
  678|       |            }
  679|      9|            Rvalue::ArrayLiteral(elements) => {
  680|      9|                write!(output, "[")?;
                                                 ^0
  681|     25|                for (i, op) in elements.iter().enumerate() {
                                             ^9              ^9
  682|     25|                    if i > 0 {
  683|     16|                        write!(output, ", ")?;
                                                          ^0
  684|      9|                    }
  685|     25|                    write!(output, "{}", self.operand_to_string(op))?;
                                                                                  ^0
  686|       |                }
  687|      9|                write!(output, "]")?;
                                                 ^0
  688|       |            }
  689|      0|            Rvalue::Load(operand) => {
  690|      0|                write!(output, "load {}", self.operand_to_string(operand))?;
  691|       |            }
  692|       |
  693|      1|            Rvalue::BuiltinVaArg(ap, ty) => {
  694|      1|                write!(
  695|      1|                    output,
  696|      1|                    "va_arg({}, {})",
  697|      1|                    self.place_to_string(ap),
  698|      1|                    self.type_to_string(*ty)
  699|      0|                )?;
  700|       |            }
  701|      1|            Rvalue::AtomicLoad(ptr, order) => {
  702|      1|                write!(output, "atomic_load({}, {:?})", self.operand_to_string(ptr), order)?;
                                                                                                         ^0
  703|       |            }
  704|      1|            Rvalue::AtomicExchange(ptr, val, order) => {
  705|      1|                write!(
  706|      1|                    output,
  707|      1|                    "atomic_xchg({}, {}, {:?})",
  708|      1|                    self.operand_to_string(ptr),
  709|      1|                    self.operand_to_string(val),
  710|       |                    order
  711|      0|                )?;
  712|       |            }
  713|      1|            Rvalue::AtomicCompareExchange(ptr, expected, desired, weak, success, failure) => {
  714|      1|                write!(
  715|      1|                    output,
  716|      1|                    "atomic_cmpxchg({}, {}, {}, {}, {:?}, {:?})",
  717|      1|                    self.operand_to_string(ptr),
  718|      1|                    self.operand_to_string(expected),
  719|      1|                    self.operand_to_string(desired),
  720|       |                    weak,
  721|       |                    success,
  722|       |                    failure
  723|      0|                )?;
  724|       |            }
  725|      1|            Rvalue::AtomicFetchOp(op, ptr, val, order) => {
  726|      1|                write!(
  727|      1|                    output,
  728|      1|                    "atomic_fetch_{}({}, {}, {:?})",
  729|       |                    op,
  730|      1|                    self.operand_to_string(ptr),
  731|      1|                    self.operand_to_string(val),
  732|       |                    order
  733|      0|                )?;
  734|       |            }
  735|       |        }
  736|    248|        Ok(())
  737|    248|    }
  738|       |
  739|       |    /// Convert floating-point binary operation to string representation
  740|     56|    fn binary_float_op_to_string(&self, op: &BinaryFloatOp) -> String {
  741|     56|        match op {
  742|     11|            BinaryFloatOp::Add => "fadd".to_string(),
  743|      9|            BinaryFloatOp::Sub => "fsub".to_string(),
  744|     21|            BinaryFloatOp::Mul => "fmul".to_string(),
  745|      5|            BinaryFloatOp::Div => "fdiv".to_string(),
  746|      3|            BinaryFloatOp::Eq => "feq".to_string(),
  747|      3|            BinaryFloatOp::Ne => "fne".to_string(),
  748|      1|            BinaryFloatOp::Lt => "flt".to_string(),
  749|      1|            BinaryFloatOp::Le => "fle".to_string(),
  750|      1|            BinaryFloatOp::Gt => "fgt".to_string(),
  751|      1|            BinaryFloatOp::Ge => "fge".to_string(),
  752|       |        }
  753|     56|    }
  754|       |
  755|       |    /// Convert floating-point unary operation to string representation
  756|      7|    fn unary_float_op_to_string(&self, op: &UnaryFloatOp) -> String {
  757|      7|        match op {
  758|      7|            UnaryFloatOp::Neg => "fneg".to_string(),
  759|       |        }
  760|      7|    }
  761|       |}

/app/src/mir/validation.rs:
    1|       |//! MIR Validation Pass
    2|       |//!
    3|       |//! This module implements a validation pass that ensures MIR is well-formed
    4|       |//! and ready for code generation. The validation pass checks:
    5|       |//! - All locals have types
    6|       |//! - All blocks end with a Terminator
    7|       |//! - No illegal operations remain
    8|       |//! - MIR is Cranelift-safe
    9|       |
   10|       |use crate::{
   11|       |    ast::NameId,
   12|       |    mir::{
   13|       |        BinaryFloatOp, BinaryIntOp, CallTarget, ConstValue, ConstValueId, ConstValueKind, GlobalId, LocalId,
   14|       |        MirBlockId, MirFunction, MirFunctionId, MirFunctionKind, MirProgram, MirStmt, MirStmtId, MirType, Operand,
   15|       |        Place, Rvalue, Terminator, TypeId, UnaryFloatOp, UnaryIntOp,
   16|       |    },
   17|       |};
   18|       |
   19|       |/// MIR Validation Error
   20|       |#[derive(Debug, PartialEq, Clone)]
   21|       |pub enum ValidationError {
   22|       |    /// Local variable is missing a type
   23|       |    LocalMissingType(LocalId),
   24|       |    /// Illegal operation found in MIR
   25|       |    IllegalOperation(String),
   26|       |    /// Type not found in type table
   27|       |    TypeNotFound(TypeId),
   28|       |    /// Local not found in local table
   29|       |    LocalNotFound(LocalId),
   30|       |    /// Global not found in global table
   31|       |    GlobalNotFound(GlobalId),
   32|       |    /// Function not found in function table
   33|       |    FunctionNotFound(MirFunctionId),
   34|       |    /// Block not found in block table
   35|       |    BlockNotFound(MirBlockId),
   36|       |    /// Statement not found in statement table
   37|       |    StatementNotFound(MirStmtId),
   38|       |    /// Invalid pointer arithmetic operation
   39|       |    InvalidPointerArithmetic,
   40|       |    /// Invalid cast operation
   41|       |    InvalidCast(TypeId, TypeId),
   42|       |    /// Function call argument type mismatch
   43|       |    FunctionCallArgTypeMismatch {
   44|       |        func_name: NameId,
   45|       |        arg_index: usize,
   46|       |        expected_type: TypeId,
   47|       |        actual_type: TypeId,
   48|       |    },
   49|       |    /// Constant value is out of range for its type
   50|       |    ConstantValueOutOfRange {
   51|       |        const_id: ConstValueId,
   52|       |        value: i64,
   53|       |        type_id: TypeId,
   54|       |    },
   55|       |}
   56|       |
   57|       |impl std::fmt::Display for ValidationError {
   58|     12|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   59|     12|        match self {
   60|      1|            ValidationError::LocalMissingType(local_id) => write!(f, "Local {} is missing a type", local_id.get()),
   61|      1|            ValidationError::IllegalOperation(op) => write!(f, "Illegal operation: {}", op),
   62|      1|            ValidationError::TypeNotFound(type_id) => write!(f, "Type {} not found", type_id.get()),
   63|      1|            ValidationError::LocalNotFound(local_id) => write!(f, "Local {} not found", local_id.get()),
   64|      1|            ValidationError::GlobalNotFound(global_id) => write!(f, "Global {} not found", global_id.get()),
   65|      1|            ValidationError::FunctionNotFound(func_id) => write!(f, "Function {} not found", func_id.get()),
   66|      1|            ValidationError::BlockNotFound(block_id) => write!(f, "Block {} not found", block_id.get()),
   67|      1|            ValidationError::StatementNotFound(stmt_id) => write!(f, "Statement {} not found", stmt_id.get()),
   68|      1|            ValidationError::InvalidPointerArithmetic => write!(f, "Invalid pointer arithmetic operation"),
   69|      1|            ValidationError::InvalidCast(from, to) => {
   70|      1|                write!(f, "Invalid cast from type {} to type {}", from.get(), to.get())
   71|       |            }
   72|       |            ValidationError::FunctionCallArgTypeMismatch {
   73|      1|                func_name,
   74|      1|                arg_index,
   75|      1|                expected_type,
   76|      1|                actual_type,
   77|       |            } => {
   78|      1|                write!(
   79|      1|                    f,
   80|      1|                    "Function '{}' argument {} type mismatch: expected type {}, got type {}",
   81|       |                    func_name,
   82|       |                    arg_index,
   83|      1|                    expected_type.get(),
   84|      1|                    actual_type.get()
   85|       |                )
   86|       |            }
   87|       |            ValidationError::ConstantValueOutOfRange {
   88|      1|                const_id,
   89|      1|                value,
   90|      1|                type_id,
   91|       |            } => {
   92|      1|                write!(
   93|      1|                    f,
   94|      1|                    "Constant {} value {} is out of range for type {}",
   95|      1|                    const_id.get(),
   96|       |                    value,
   97|      1|                    type_id.get()
   98|       |                )
   99|       |            }
  100|       |        }
  101|     12|    }
  102|       |}
  103|       |
  104|       |/// MIR Validation Pass
  105|       |///
  106|       |/// This pass validates that MIR is well-formed and ready for code generation.
  107|       |/// It performs comprehensive checks but does not modify the MIR.
  108|       |pub struct MirValidator<'a> {
  109|       |    mir: &'a MirProgram,
  110|       |    errors: Vec<ValidationError>,
  111|       |}
  112|       |
  113|       |impl<'a> MirValidator<'a> {
  114|       |    /// Create a new MIR validator
  115|     85|    pub(crate) fn new(mir_program: &'a MirProgram) -> Self {
  116|     85|        Self {
  117|     85|            mir: mir_program,
  118|     85|            errors: Vec::new(),
  119|     85|        }
  120|     85|    }
  121|       |
  122|       |    /// Validate a MIR module
  123|       |    ///
  124|       |    /// Returns Ok(()) if validation passes, or Err(Vec<ValidationError>) if errors are found
  125|     85|    pub(crate) fn validate(mut self) -> Result<(), Vec<ValidationError>> {
  126|       |        // eprintln!("VALIDATE: Starting validation");
  127|     85|        self.errors.clear();
  128|       |
  129|       |        // Validate each function
  130|    200|        for func_id in &self.mir.module.functions {
                          ^115
  131|    115|            if let Some(func) = self.mir.functions.get(func_id) {
                                      ^114
  132|    114|                self.validate_function(func);
  133|    114|            } else {
  134|      1|                self.errors.push(ValidationError::FunctionNotFound(*func_id));
  135|      1|            }
  136|       |        }
  137|       |
  138|       |        // Validate each global
  139|    149|        for global_id in &self.mir.module.globals {
                          ^64
  140|     64|            if self.mir.globals.get(global_id).is_none() {
  141|      1|                self.errors.push(ValidationError::GlobalNotFound(*global_id));
  142|     63|            }
  143|       |        }
  144|       |
  145|       |        // Validate each type - module.types is a Vec<MirType>, not HashMap<TypeId, MirType>
  146|       |        // So we validate that each type in the module is accessible via the types HashMap
  147|    371|        for (index, _) in self.mir.module.types.iter().enumerate() {
                                        ^85                          ^85
  148|    371|            let type_id = TypeId::new((index + 1) as u32).unwrap(); // Types are 1-indexed
  149|    371|            if !self.mir.types.contains_key(&type_id) {
  150|      1|                self.errors.push(ValidationError::TypeNotFound(type_id));
  151|    370|            }
  152|       |        }
  153|       |
  154|     85|        if self.errors.is_empty() {
  155|     64|            Ok(())
  156|       |        } else {
  157|     21|            Err(self.errors)
  158|       |        }
  159|     85|    }
  160|       |
  161|       |    /// Validate that a constant value can be cast to the target type
  162|    140|    fn validate_constant_cast(&mut self, const_id: ConstValueId, const_value: &ConstValue, target_type_id: TypeId) {
  163|    140|        let Some(target_ty) = self.mir.types.get(&target_type_id) else {
                               ^139
  164|      1|            return;
  165|       |        };
  166|    139|        let ConstValueKind::Int(value) = const_value.kind else {
                                              ^63
  167|     76|            return;
  168|       |        };
  169|       |
  170|     63|        let (min, max) = match target_ty {
                           ^59  ^59
  171|     16|            MirType::I8 | MirType::U8 => (-128, 255),
  172|      1|            MirType::I16 | MirType::U16 => (-32_768, 65_535),
  173|     42|            MirType::I32 | MirType::U32 => (-2_147_483_648, 4_294_967_295),
  174|      0|            MirType::Bool => (0, 1),
  175|      4|            _ => return, // No validation for other types
  176|       |        };
  177|       |
  178|     59|        if value < min || value > max {
  179|      1|            self.errors.push(ValidationError::ConstantValueOutOfRange {
  180|      1|                const_id,
  181|      1|                value,
  182|      1|                type_id: target_type_id,
  183|      1|            });
  184|     58|        }
  185|    140|    }
  186|       |
  187|       |    /// Validate a function
  188|    114|    fn validate_function(&mut self, func: &MirFunction) {
  189|    114|        if func.name.as_str().is_empty() {
  190|      1|            self.errors.push(ValidationError::IllegalOperation(
  191|      1|                "Function name cannot be empty".to_string(),
  192|      1|            ));
  193|    113|        }
  194|       |
  195|    114|        if !self.mir.types.contains_key(&func.return_type) {
  196|      1|            self.errors.push(ValidationError::TypeNotFound(func.return_type));
  197|    113|        }
  198|       |
  199|       |        // Validate presence of locals (params + locals)
  200|    195|        for local_id in func.params.iter().chain(&func.locals) {
                                      ^114               ^114  ^114
  201|    195|            if !self.mir.locals.contains_key(local_id) {
  202|      1|                self.errors.push(ValidationError::LocalNotFound(*local_id));
  203|    194|            }
  204|       |        }
  205|       |
  206|       |        // Validate presence of blocks (body + entry)
  207|    381|        for block_id in func.blocks.iter().chain(func.entry_block.as_ref()) {
                                      ^114               ^114  ^114             ^114
  208|    381|            if !self.mir.blocks.contains_key(block_id) {
  209|      1|                self.errors.push(ValidationError::BlockNotFound(*block_id));
  210|    380|            }
  211|       |        }
  212|       |
  213|       |        // Validate items within blocks for defined functions
  214|    114|        if func.kind == MirFunctionKind::Defined {
  215|    382|            for block_id in &func.blocks {
                              ^292
  216|    292|                let Some(block) = self.mir.blocks.get(block_id) else {
                                       ^291
  217|      1|                    continue;
  218|       |                };
  219|       |
  220|    526|                for stmt_id in &block.statements {
                                  ^235
  221|    235|                    let Some(stmt) = self.mir.statements.get(stmt_id) else {
                                           ^234
  222|      1|                        self.errors.push(ValidationError::StatementNotFound(*stmt_id));
  223|      1|                        continue;
  224|       |                    };
  225|       |
  226|    234|                    self.validate_statement(stmt);
  227|       |                }
  228|       |
  229|    291|                self.validate_terminator(&block.terminator);
  230|       |            }
  231|     24|        }
  232|    114|    }
  233|       |
  234|    234|    fn validate_statement(&mut self, stmt: &MirStmt) {
  235|    234|        match stmt {
  236|    183|            MirStmt::Assign(place, rvalue) => {
  237|    183|                let place_ty = self.validate_place(place);
  238|    183|                let rval_ty = self.validate_rvalue(rvalue);
  239|    183|                if let (Some(from), Some(to)) = (rval_ty, place_ty)
                                           ^115        ^115
  240|    115|                    && from != to
  241|      3|                    && !self.is_flexible_assignment(rvalue, from, to)
  242|      2|                    && !self.are_types_compatible(from, to)
  243|      1|                {
  244|      1|                    self.errors.push(ValidationError::InvalidCast(from, to));
  245|    182|                }
  246|       |            }
  247|      0|            MirStmt::Store(op, place) => {
  248|      0|                let op_ty = self.validate_operand(op);
  249|      0|                let place_ty = self.validate_place(place);
  250|      0|                if let (Some(from), Some(to)) = (op_ty, place_ty)
  251|      0|                    && from != to
  252|      0|                    && !self.are_types_compatible(from, to)
  253|      0|                {
  254|      0|                    self.errors.push(ValidationError::InvalidCast(from, to));
  255|      0|                }
  256|       |            }
  257|     44|            MirStmt::Call { target, args, dest } => {
  258|     44|                self.validate_call(target, args, dest);
  259|     44|            }
  260|      1|            MirStmt::Alloc(place, type_id) => {
  261|      1|                self.validate_place(place);
  262|      1|                if !self.mir.types.contains_key(type_id) {
  263|      1|                    self.errors.push(ValidationError::TypeNotFound(*type_id));
  264|      1|                }
                              ^0
  265|       |            }
  266|      0|            MirStmt::Dealloc(op) => {
  267|      0|                self.validate_operand(op);
  268|      0|            }
  269|      4|            MirStmt::BuiltinVaStart(ap, last) => {
  270|      4|                self.validate_place(ap);
  271|      4|                self.validate_operand(last);
  272|      4|            }
  273|      2|            MirStmt::BuiltinVaEnd(ap) => {
  274|      2|                self.validate_place(ap);
  275|      2|            }
  276|      0|            MirStmt::BuiltinVaCopy(dst, src) => {
  277|      0|                self.validate_place(dst);
  278|      0|                self.validate_place(src);
  279|      0|            }
  280|      0|            MirStmt::AtomicStore(ptr, val, _) => {
  281|      0|                self.validate_operand(ptr);
  282|      0|                self.validate_operand(val);
  283|      0|            }
  284|       |        }
  285|    234|    }
  286|       |
  287|      3|    fn is_flexible_assignment(&self, rvalue: &Rvalue, from: TypeId, to: TypeId) -> bool {
  288|      3|        let is_flexible_op = match rvalue {
                                                 ^0
  289|      0|            Rvalue::UnaryIntOp(UnaryIntOp::LogicalNot, _) => true,
  290|      1|            Rvalue::BinaryIntOp(bin, ..) => matches!(
                                                          ^0
  291|      1|                bin,
  292|       |                BinaryIntOp::Eq
  293|       |                    | BinaryIntOp::Ne
  294|       |                    | BinaryIntOp::Lt
  295|       |                    | BinaryIntOp::Le
  296|       |                    | BinaryIntOp::Gt
  297|       |                    | BinaryIntOp::Ge
  298|       |            ),
  299|      0|            Rvalue::BinaryFloatOp(bin, ..) => matches!(
  300|      0|                bin,
  301|       |                BinaryFloatOp::Eq
  302|       |                    | BinaryFloatOp::Ne
  303|       |                    | BinaryFloatOp::Lt
  304|       |                    | BinaryFloatOp::Le
  305|       |                    | BinaryFloatOp::Gt
  306|       |                    | BinaryFloatOp::Ge
  307|       |            ),
  308|      2|            _ => false,
  309|       |        };
  310|       |
  311|      3|        is_flexible_op && self.mir.get_type(from).is_int() && self.mir.get_type(to).is_int()
                                        ^1                      ^1          ^1                    ^1
  312|      3|    }
  313|       |
  314|     44|    fn validate_call(&mut self, target: &CallTarget, args: &[Operand], dest: &Option<Place>) {
  315|     44|        self.validate_call_target(target);
  316|    152|        for a in args {
                          ^108
  317|    108|            self.validate_operand(a);
  318|    108|        }
  319|     44|        if let Some(dest_place) = dest {
                                  ^1
  320|      1|            self.validate_place(dest_place);
  321|     43|        }
  322|       |
  323|     44|        match target {
  324|     43|            CallTarget::Direct(fid) => {
  325|     43|                if let Some(func) = self.mir.functions.get(fid) {
  326|     43|                    let param_types: Vec<TypeId> = func
  327|     43|                        .params
  328|     43|                        .iter()
  329|     44|                        .map(|p| self.mir.locals.get(p).unwrap().type_id)
                                       ^43
  330|     43|                        .collect();
  331|     43|                    self.check_call_signature(
  332|     43|                        Some(func.name),
  333|     43|                        &param_types,
  334|     43|                        func.is_variadic,
  335|     43|                        func.return_type,
  336|     43|                        args,
  337|     43|                        dest,
  338|       |                    );
  339|      0|                }
  340|       |            }
  341|      1|            CallTarget::Indirect(op) => {
  342|      1|                if let Some(op_ty) = self.operand_type(op)
  343|      1|                    && let Some(MirType::Pointer { pointee }) = self.mir.types.get(&op_ty)
  344|       |                    && let Some(MirType::Function {
  345|      1|                        params,
  346|      1|                        return_type,
  347|      1|                        is_variadic,
  348|      1|                    }) = self.mir.types.get(pointee)
  349|      1|                {
  350|      1|                    self.check_call_signature(None, params, *is_variadic, *return_type, args, dest);
  351|      1|                }
                              ^0
  352|       |            }
  353|       |        }
  354|     44|    }
  355|       |
  356|     44|    fn check_call_signature(
  357|     44|        &mut self,
  358|     44|        name: Option<NameId>,
  359|     44|        params: &[TypeId],
  360|     44|        is_variadic: bool,
  361|     44|        return_type: TypeId,
  362|     44|        args: &[Operand],
  363|     44|        dest: &Option<Place>,
  364|     44|    ) {
  365|     44|        let name = name.unwrap_or_else(|| "<indirect function>".into());
                                                        ^1                    ^1
  366|       |
  367|     44|        if (is_variadic && args.len() < params.len()) || (!is_variadic && args.len() != params.len()) {
                                         ^39  ^39                                       ^5   ^5
  368|      1|            self.errors.push(ValidationError::IllegalOperation(format!(
  369|      1|                "Call to function {} arg count mismatch",
  370|      1|                name
  371|      1|            )));
  372|      1|            return;
  373|     43|        }
  374|       |
  375|    107|        for (i, arg) in args.iter().enumerate() {
                                      ^43  ^43    ^43
  376|    107|            let actual = self.validate_operand(arg);
  377|    107|            if let Some(&expected) = params.get(i)
                                       ^45
  378|     45|                && let Some(actual) = actual
  379|     45|                && actual != expected
  380|      1|            {
  381|      1|                self.errors.push(ValidationError::FunctionCallArgTypeMismatch {
  382|      1|                    func_name: name,
  383|      1|                    arg_index: i,
  384|      1|                    expected_type: expected,
  385|      1|                    actual_type: actual,
  386|      1|                });
  387|    106|            }
  388|       |        }
  389|       |
  390|     43|        if let Some(dest_place) = dest {
                                  ^1
  391|      1|            self.validate_place(dest_place);
  392|      1|            if matches!(self.mir.types.get(&return_type), Some(MirType::Void)) {
                             ^0
  393|      1|                self.errors.push(ValidationError::IllegalOperation(format!(
  394|      1|                    "Call to void function {} with destination",
  395|      1|                    name
  396|      1|                )));
  397|      1|            }
                          ^0
  398|     42|        }
  399|     44|    }
  400|       |
  401|    612|    fn validate_place(&mut self, place: &Place) -> Option<TypeId> {
  402|    612|        match place {
  403|    424|            Place::Local(local_id) => {
  404|    424|                let local = self.mir.locals.get(local_id).or_else(|| {
                                                                                   ^0
  405|      0|                    self.errors.push(ValidationError::LocalNotFound(*local_id));
  406|      0|                    None
  407|      0|                })?;
  408|    424|                Some(local.type_id)
  409|       |            }
  410|      4|            Place::Deref(op) => {
  411|      4|                self.validate_operand(op);
  412|      4|                let op_ty = self.operand_type(op)?;
                                                               ^0
  413|      4|                let Some(ty) = self.mir.types.get(&op_ty) else {
  414|      0|                    self.errors.push(ValidationError::TypeNotFound(op_ty));
  415|      0|                    return None;
  416|       |                };
  417|       |
  418|      4|                let MirType::Pointer { pointee } = ty else {
                                                     ^3
  419|      1|                    self.errors.push(ValidationError::IllegalOperation(
  420|      1|                        "Deref of non-pointer operand".to_string(),
  421|      1|                    ));
  422|      1|                    return None;
  423|       |                };
  424|      3|                Some(*pointee)
  425|       |            }
  426|     38|            Place::Global(gid) => {
  427|     38|                let global = self.mir.globals.get(gid).or_else(|| {
                                                                                ^0
  428|      0|                    self.errors.push(ValidationError::GlobalNotFound(*gid));
  429|      0|                    None
  430|      0|                })?;
  431|     38|                Some(global.type_id)
  432|       |            }
  433|    105|            Place::StructField(base, idx) => {
  434|    105|                let base_ty = self.validate_place(base)?;
                                                                     ^0
  435|    105|                let Some(ty) = self.mir.types.get(&base_ty) else {
  436|      0|                    self.errors.push(ValidationError::TypeNotFound(base_ty));
  437|      0|                    return None;
  438|       |                };
  439|       |
  440|    105|                let MirType::Record { field_types, .. } = ty else {
                                                    ^104
  441|      1|                    self.errors.push(ValidationError::IllegalOperation(
  442|      1|                        "Struct field access on non-record type".to_string(),
  443|      1|                    ));
  444|      1|                    return None;
  445|       |                };
  446|       |
  447|    104|                field_types.get(*idx).copied().or_else(|| {
                                                                        ^1
  448|      1|                    self.errors.push(ValidationError::IllegalOperation(format!(
  449|      1|                        "Struct field index {} out of bounds",
  450|      1|                        idx
  451|      1|                    )));
  452|      1|                    None
  453|      1|                })
  454|       |            }
  455|     41|            Place::ArrayIndex(base, _idx_op) => {
  456|     41|                self.validate_place(base);
  457|     41|                None
  458|       |            }
  459|       |        }
  460|    612|    }
  461|       |
  462|    868|    fn validate_operand(&mut self, op: &Operand) -> Option<TypeId> {
  463|    868|        match op {
  464|    258|            Operand::Copy(place) => self.validate_place(place),
  465|    395|            Operand::Constant(cid) => {
  466|    395|                if let Some(cv) = self.mir.constants.get(cid) {
                                          ^394
  467|    394|                    Some(cv.ty)
  468|       |                } else {
  469|      1|                    self.errors.push(ValidationError::IllegalOperation(format!(
  470|      1|                        "Constant {} not found",
  471|      1|                        cid.get()
  472|      1|                    )));
  473|      1|                    None
  474|       |                }
  475|       |            }
  476|      9|            Operand::AddressOf(place) => {
  477|      9|                if let Some(base_ty) = self.validate_place(place) {
                                          ^2
  478|       |                    // create or lookup a pointer type for base_ty is non-trivial; try to find existing pointer type
  479|      4|                    for (tid, ty) in &self.mir.types {
  480|      4|                        if let MirType::Pointer { pointee } = ty
                                                                ^2
  481|      2|                            && *pointee == base_ty
  482|       |                        {
  483|      2|                            return Some(*tid);
  484|      2|                        }
  485|       |                    }
  486|      0|                    None
  487|       |                } else {
  488|      7|                    None
  489|       |                }
  490|       |            }
  491|    206|            Operand::Cast(type_id, inner) => {
  492|    206|                if !self.mir.types.contains_key(type_id) {
  493|      1|                    self.errors.push(ValidationError::TypeNotFound(*type_id));
  494|    205|                }
  495|       |                // Check if casting a constant value that doesn't fit in the target type
  496|    206|                if let Operand::Constant(const_id) = inner.as_ref()
                                                       ^140
  497|    140|                    && let Some(const_value) = self.mir.constants.get(const_id)
  498|    140|                {
  499|    140|                    self.validate_constant_cast(*const_id, const_value, *type_id);
  500|    140|                }
                              ^66
  501|    206|                self.validate_operand(inner);
  502|    206|                Some(*type_id)
  503|       |            }
  504|       |        }
  505|    868|    }
  506|       |
  507|    183|    fn validate_rvalue(&mut self, r: &Rvalue) -> Option<TypeId> {
  508|    183|        match r {
  509|    101|            Rvalue::Use(op) => self.validate_operand(op),
  510|     53|            Rvalue::BinaryIntOp(bin, a, b) => {
  511|     53|                let ta = self.validate_operand(a);
  512|     53|                let _tb = self.validate_operand(b);
  513|     53|                if bin.is_comparison() { self.find_bool_type() } else { ta }
                                                       ^42  ^42                       ^11
  514|       |            }
  515|      0|            Rvalue::BinaryFloatOp(bin, a, b) => {
  516|      0|                let ta = self.validate_operand(a);
  517|      0|                let _tb = self.validate_operand(b);
  518|      0|                if bin.is_comparison() { self.find_bool_type() } else { ta }
  519|       |            }
  520|      3|            Rvalue::UnaryIntOp(u, a) => {
  521|      3|                let ta = self.validate_operand(a);
  522|      3|                match u {
  523|      0|                    UnaryIntOp::Neg => ta,
  524|      0|                    UnaryIntOp::BitwiseNot => ta,
  525|      3|                    UnaryIntOp::LogicalNot => self.find_bool_type(),
  526|       |                }
  527|       |            }
  528|      0|            Rvalue::UnaryFloatOp(u, a) => {
  529|      0|                let ta = self.validate_operand(a);
  530|      0|                match u {
  531|      0|                    UnaryFloatOp::Neg => ta,
  532|       |                }
  533|       |            }
  534|      1|            Rvalue::Cast(type_id, op) => {
  535|      1|                let from_ty_id = self.validate_operand(op);
  536|      1|                let to_ty = self.mir.types.get(type_id);
  537|       |
  538|      1|                if to_ty.is_none() {
  539|      0|                    self.errors.push(ValidationError::TypeNotFound(*type_id));
  540|      1|                }
  541|       |
  542|      1|                if let (Some(from_id), Some(to_ty)) = (from_ty_id, to_ty)
  543|      1|                    && let Some(from_ty) = self.mir.types.get(&from_id)
  544|      1|                    && from_ty.is_aggregate()
  545|      1|                    && !to_ty.is_pointer()
  546|      1|                    && (to_ty.is_int() || to_ty.is_float())
                                                        ^0    ^0
  547|      1|                {
  548|      1|                    self.errors.push(ValidationError::InvalidCast(from_id, *type_id));
  549|      1|                }
                              ^0
  550|      1|                Some(*type_id)
  551|       |            }
  552|      2|            Rvalue::PtrAdd(a, b) | Rvalue::PtrSub(a, b) => {
  553|      4|                self.validate_operand(a);
  554|      4|                self.validate_operand(b);
  555|      4|                None
  556|       |            }
  557|      1|            Rvalue::PtrDiff(a, b) => {
  558|      1|                self.validate_operand(a);
  559|      1|                self.validate_operand(b);
  560|      1|                None
  561|       |            }
  562|      7|            Rvalue::StructLiteral(fields) => {
  563|     21|                for (_idx, op) in fields {
                                   ^14   ^14
  564|     14|                    self.validate_operand(op);
  565|     14|                }
  566|      7|                None
  567|       |            }
  568|      6|            Rvalue::ArrayLiteral(elems) => {
  569|     17|                for e in elems {
                                  ^11
  570|     11|                    self.validate_operand(e);
  571|     11|                }
  572|      6|                None
  573|       |            }
  574|      0|            Rvalue::Load(op) => {
  575|      0|                self.validate_operand(op);
  576|      0|                None
  577|       |            }
  578|       |
  579|      7|            Rvalue::BuiltinVaArg(ap, type_id) => {
  580|      7|                self.validate_place(ap);
  581|      7|                if !self.mir.types.contains_key(type_id) {
  582|      0|                    self.errors.push(ValidationError::TypeNotFound(*type_id));
  583|      7|                }
  584|      7|                Some(*type_id)
  585|       |            }
  586|      0|            Rvalue::AtomicLoad(ptr, _) => {
  587|      0|                self.validate_operand(ptr);
  588|      0|                None
  589|       |            }
  590|      0|            Rvalue::AtomicExchange(ptr, val, _) => {
  591|      0|                self.validate_operand(ptr);
  592|      0|                self.validate_operand(val);
  593|      0|                None
  594|       |            }
  595|      0|            Rvalue::AtomicCompareExchange(ptr, expected, desired, _, _, _) => {
  596|      0|                self.validate_operand(ptr);
  597|      0|                self.validate_operand(expected);
  598|      0|                self.validate_operand(desired);
  599|      0|                None
  600|       |            }
  601|      0|            Rvalue::AtomicFetchOp(_, ptr, val, _) => {
  602|      0|                self.validate_operand(ptr);
  603|      0|                self.validate_operand(val);
  604|      0|                None
  605|       |            }
  606|       |        }
  607|    183|    }
  608|       |
  609|     44|    fn validate_call_target(&mut self, target: &CallTarget) {
  610|     44|        match target {
  611|     43|            CallTarget::Direct(fid) => {
  612|     43|                if self.mir.functions.get(fid).is_none() {
  613|      0|                    self.errors.push(ValidationError::FunctionNotFound(*fid));
  614|     43|                }
  615|       |            }
  616|      1|            CallTarget::Indirect(op) => {
  617|      1|                self.validate_operand(op);
  618|      1|            }
  619|       |        }
  620|     44|    }
  621|       |
  622|      5|    fn operand_type(&mut self, op: &Operand) -> Option<TypeId> {
  623|      5|        self.validate_operand(op)
  624|      5|    }
  625|    291|    fn validate_terminator(&mut self, term: &Terminator) {
  626|    291|        match term {
  627|     92|            Terminator::Goto(bid) => {
  628|     92|                if !self.mir.blocks.contains_key(bid) {
  629|      1|                    self.errors.push(ValidationError::BlockNotFound(*bid));
  630|     91|                }
  631|       |            }
  632|     71|            Terminator::If(cond, then_bb, else_bb) => {
  633|     71|                self.validate_operand(cond);
  634|     71|                if !self.mir.blocks.contains_key(then_bb) {
  635|      0|                    self.errors.push(ValidationError::BlockNotFound(*then_bb));
  636|     71|                }
  637|     71|                if !self.mir.blocks.contains_key(else_bb) {
  638|      0|                    self.errors.push(ValidationError::BlockNotFound(*else_bb));
  639|     71|                }
  640|       |            }
  641|    127|            Terminator::Return(op) => {
  642|    127|                if let Some(op) = op {
                                          ^116
  643|    116|                    self.validate_operand(op);
  644|    116|                }
                              ^11
  645|       |            }
  646|      1|            Terminator::Unreachable => {}
  647|       |        }
  648|    291|    }
  649|       |
  650|     45|    fn find_bool_type(&self) -> Option<TypeId> {
  651|    333|        for (id, ty) in &self.mir.types {
                           ^291^291
  652|    291|            if matches!(ty, MirType::Bool) {
                             ^288
  653|      3|                return Some(*id);
  654|    288|            }
  655|       |        }
  656|     42|        None
  657|     45|    }
  658|       |
  659|      3|    fn are_types_compatible(&self, t1: TypeId, t2: TypeId) -> bool {
  660|      3|        if t1 == t2 {
  661|      1|            return true;
  662|      2|        }
  663|       |
  664|      2|        let (Some(ty1), Some(ty2)) = (self.mir.types.get(&t1), self.mir.types.get(&t2)) else {
  665|      0|            return false;
  666|       |        };
  667|       |
  668|      2|        match (ty1, ty2) {
  669|      0|            (MirType::Pointer { pointee: p1 }, MirType::Pointer { pointee: p2 }) => self.are_types_compatible(*p1, *p2),
  670|       |            (
  671|       |                MirType::Array {
  672|      1|                    element: e1, size: s1, ..
  673|       |                },
  674|       |                MirType::Array {
  675|      1|                    element: e2, size: s2, ..
  676|       |                },
  677|      1|            ) => s1 == s2 && self.are_types_compatible(*e1, *e2),
  678|       |            (
  679|       |                MirType::Function {
  680|      0|                    return_type: r1,
  681|      0|                    params: p1,
  682|      0|                    is_variadic: v1,
  683|       |                },
  684|       |                MirType::Function {
  685|      0|                    return_type: r2,
  686|      0|                    params: p2,
  687|      0|                    is_variadic: v2,
  688|       |                },
  689|       |            ) => {
  690|      0|                v1 == v2
  691|      0|                    && p1.len() == p2.len()
  692|      0|                    && self.are_types_compatible(*r1, *r2)
  693|      0|                    && p1.iter().zip(p2).all(|(&a, &b)| self.are_types_compatible(a, b))
  694|       |            }
  695|      1|            _ => ty1 == ty2,
  696|       |        }
  697|      3|    }
  698|       |}

/app/src/parser.rs:
    1|       |//! Parser module for C11 compiler
    2|       |//!
    3|       |//! This module provides the main parser coordination, public API, and state management.
    4|       |//! It orchestrates the parsing process by delegating to specialized sub-modules for
    5|       |//! different language constructs.
    6|       |
    7|       |use crate::ast::*;
    8|       |use crate::diagnostic::{DiagnosticEngine, ParseError};
    9|       |use crate::source_manager::{SourceLoc, SourceSpan};
   10|       |use log::debug;
   11|       |use std::collections::HashSet;
   12|       |
   13|       |pub mod declaration_core;
   14|       |pub mod declarations;
   15|       |pub mod declarator;
   16|       |pub mod enum_parsing;
   17|       |pub mod expressions;
   18|       |pub mod lexer;
   19|       |pub mod parsed_type_builder;
   20|       |pub mod statements;
   21|       |pub mod struct_parsing;
   22|       |pub mod type_specifiers;
   23|       |pub mod utils;
   24|       |
   25|       |// Re-export commonly used types
   26|       |pub(crate) use expressions::BindingPower;
   27|       |pub(crate) use lexer::{Lexer, Token, TokenKind};
   28|       |
   29|       |use expressions::parse_expression;
   30|       |
   31|       |/// Type context for tracking typedef names and other type-related state
   32|       |#[derive(Debug)]
   33|       |pub(crate) struct TypeDefContext {
   34|       |    /// Set of typedef names for disambiguation
   35|       |    typedef_names: HashSet<NameId>,
   36|       |}
   37|       |
   38|       |impl Default for TypeDefContext {
   39|      0|    fn default() -> Self {
   40|      0|        Self::new()
   41|      0|    }
   42|       |}
   43|       |
   44|       |impl TypeDefContext {
   45|       |    /// Create a new type context with builtin typedefs
   46|    670|    pub(crate) fn new() -> Self {
   47|    670|        let mut typedef_names = HashSet::new();
   48|       |        // Add builtin typedefs
   49|    670|        typedef_names.insert(NameId::new("int8_t"));
   50|    670|        typedef_names.insert(NameId::new("int16_t"));
   51|    670|        typedef_names.insert(NameId::new("int32_t"));
   52|    670|        typedef_names.insert(NameId::new("int64_t"));
   53|    670|        typedef_names.insert(NameId::new("uint8_t"));
   54|    670|        typedef_names.insert(NameId::new("uint16_t"));
   55|    670|        typedef_names.insert(NameId::new("uint32_t"));
   56|    670|        typedef_names.insert(NameId::new("uint64_t"));
   57|       |
   58|    670|        TypeDefContext { typedef_names }
   59|    670|    }
   60|       |
   61|       |    /// Check if a symbol is a typedef name
   62|  2.16k|    pub(crate) fn is_type_name(&self, symbol: NameId) -> bool {
   63|  2.16k|        let result = self.typedef_names.contains(&symbol);
   64|  2.16k|        debug!("is_type_name({:?}) = {}", symbol, result);
                             ^0
   65|  2.16k|        result
   66|  2.16k|    }
   67|       |
   68|       |    /// Add a typedef name
   69|     50|    pub(crate) fn add_typedef(&mut self, symbol: NameId) {
   70|     50|        self.typedef_names.insert(symbol);
   71|     50|    }
   72|       |}
   73|       |
   74|       |#[derive(Debug, Clone)]
   75|       |pub(crate) struct ParserState {
   76|       |    current_idx: usize,
   77|       |    diag_len: usize,
   78|       |}
   79|       |
   80|       |/// Main parser structure
   81|       |pub struct Parser<'arena, 'src> {
   82|       |    tokens: &'src [Token],
   83|       |    current_idx: usize,
   84|       |    ast: &'arena mut ParsedAst,
   85|       |    diag: &'src mut DiagnosticEngine,
   86|       |
   87|       |    // Type context for typedef tracking
   88|       |    type_context: TypeDefContext,
   89|       |}
   90|       |
   91|       |impl<'arena, 'src> Parser<'arena, 'src> {
   92|       |    /// Create a new parser
   93|    670|    pub(crate) fn new(tokens: &'src [Token], ast: &'arena mut ParsedAst, diag: &'src mut DiagnosticEngine) -> Self {
   94|    670|        Parser {
   95|    670|            tokens,
   96|    670|            current_idx: 0,
   97|    670|            ast,
   98|    670|            diag,
   99|    670|            type_context: TypeDefContext::new(),
  100|    670|        }
  101|    670|    }
  102|       |
  103|       |    /// Get the current token (returns None if at end of input)
  104|  67.8k|    fn try_current_token(&self) -> Option<Token> {
  105|  67.8k|        self.tokens.get(self.current_idx).cloned()
  106|  67.8k|    }
  107|       |
  108|       |    /// Get the current token (returns error if at end of input)
  109|  11.9k|    fn current_token(&self) -> Result<Token, ParseError> {
  110|  11.9k|        self.try_current_token().ok_or_else(|| {
                                                             ^0
  111|      0|            let prev = self.tokens.get(self.current_idx - 1);
  112|      0|            let span = match prev {
  113|      0|                Some(token) => token.span,
  114|      0|                None => SourceSpan::empty(),
  115|       |            };
  116|      0|            ParseError::UnexpectedEof { span }
  117|      0|        })
  118|  11.9k|    }
  119|       |
  120|       |    /// Get the current token kind
  121|  34.2k|    fn current_token_kind(&self) -> Option<TokenKind> {
  122|  34.2k|        self.try_current_token().map(|t| t.kind)
  123|  34.2k|    }
  124|       |
  125|       |    /// Get the current token location
  126|  2.02k|    pub(crate) fn current_token_span(&self) -> Result<SourceSpan, ParseError> {
  127|  2.02k|        Ok(self.current_token()?.span)
                                             ^0
  128|  2.02k|    }
  129|       |
  130|       |    /// Get the current token location (infallible, returns empty span on EOF)
  131|  1.41k|    pub(crate) fn current_token_span_or_empty(&self) -> SourceSpan {
  132|  1.41k|        self.try_current_token().map(|t| t.span).unwrap_or_default()
  133|  1.41k|    }
  134|       |
  135|       |    /// Get the location of the previous token, or an empty span if not available.
  136|     13|    pub(crate) fn previous_token_span(&self) -> SourceSpan {
  137|     13|        if self.current_idx > 0 {
  138|     13|            self.tokens
  139|     13|                .get(self.current_idx - 1)
  140|     13|                .map_or(SourceSpan::empty(), |token| token.span)
  141|       |        } else {
  142|      0|            SourceSpan::empty()
  143|       |        }
  144|     13|    }
  145|       |
  146|       |    /// Get the span of the last token (synonym for previous_token_span)
  147|  1.71k|    pub(crate) fn last_token_span(&self) -> Option<SourceSpan> {
  148|  1.71k|        if self.current_idx > 0 {
  149|  1.71k|            self.tokens.get(self.current_idx - 1).map(|token| token.span)
  150|       |        } else {
  151|      0|            None
  152|       |        }
  153|  1.71k|    }
  154|       |
  155|       |    /// Get the span of a token at a specific index
  156|    298|    pub(crate) fn get_token_span(&self, index: usize) -> Option<SourceSpan> {
  157|    298|        self.tokens.get(index).map(|token| token.span)
  158|    298|    }
  159|       |
  160|       |    /// Peek at the next token without consuming it
  161|    375|    fn peek_token(&self, next_index: u32) -> Option<&Token> {
  162|    375|        self.tokens.get(self.current_idx + 1 + next_index as usize)
  163|    375|    }
  164|       |
  165|       |    /// Advance to the next token and return previous token
  166|  17.2k|    fn advance(&mut self) -> Option<Token> {
  167|  17.2k|        if self.current_idx < self.tokens.len() {
  168|  17.2k|            let token = &self.tokens[self.current_idx];
  169|  17.2k|            self.current_idx += 1;
  170|  17.2k|            Some(*token)
  171|       |        } else {
  172|      0|            None
  173|       |        }
  174|  17.2k|    }
  175|       |
  176|       |    /// Accept a specific token kind if found, consume it and return it, otherwise nothing happens
  177|  19.8k|    fn accept(&mut self, accepted: TokenKind) -> Option<Token> {
  178|  19.8k|        if self.current_token_kind() == Some(accepted) {
  179|  3.37k|            self.advance()
  180|       |        } else {
  181|  16.5k|            None
  182|       |        }
  183|  19.8k|    }
  184|       |
  185|       |    /// Expect a specific token kind, consume it if found
  186|  5.04k|    fn expect(&mut self, expected: TokenKind) -> Result<Token, ParseError> {
  187|  5.04k|        let token = self.current_token()?;
                                                      ^0
  188|  5.04k|        if token.kind == expected {
  189|  5.04k|            self.advance();
  190|  5.04k|            Ok(token)
  191|       |        } else {
  192|      2|            Err(ParseError::UnexpectedToken {
  193|      2|                expected_tokens: format!("{:?}", expected),
  194|      2|                found: token.kind,
  195|      2|                span: token.span,
  196|      2|            })
  197|       |        }
  198|  5.04k|    }
  199|       |
  200|       |    /// Check if current token matches any of the given kinds
  201|    346|    fn matches(&self, kinds: &[TokenKind]) -> bool {
  202|    346|        self.current_token_kind().map(|k| kinds.contains(&k)).unwrap_or(false)
  203|    346|    }
  204|       |
  205|       |    /// Check if current token matches the given kind
  206|  12.8k|    fn is_token(&self, kind: TokenKind) -> bool {
  207|  12.8k|        self.current_token_kind() == Some(kind)
  208|  12.8k|    }
  209|       |
  210|       |    /// Skip tokens until we find a synchronization point
  211|      3|    fn synchronize(&mut self) {
  212|      3|        let mut brace_depth = 0;
  213|      3|        let mut paren_depth = 0;
  214|      3|        let mut any_advance = false;
  215|       |
  216|     11|        while let Some(token) = self.try_current_token() {
  217|     11|            match token.kind {
  218|      0|                TokenKind::LeftBrace => {
  219|      0|                    brace_depth += 1;
  220|      0|                    self.advance();
  221|      0|                    any_advance = true;
  222|      0|                }
  223|       |                TokenKind::RightBrace => {
  224|      0|                    brace_depth -= 1;
  225|      0|                    self.advance();
  226|      0|                    any_advance = true;
  227|      0|                    if brace_depth < 0 {
  228|      0|                        break; // Unmatched brace, stop here
  229|      0|                    }
  230|       |                }
  231|      0|                TokenKind::LeftParen => {
  232|      0|                    paren_depth += 1;
  233|      0|                    self.advance();
  234|      0|                    any_advance = true;
  235|      0|                }
  236|       |                TokenKind::RightParen => {
  237|      2|                    paren_depth -= 1;
  238|      2|                    self.advance();
  239|      2|                    any_advance = true;
  240|      2|                    if paren_depth < 0 {
  241|      2|                        break; // Unmatched paren, stop here
  242|      0|                    }
  243|       |                }
  244|       |                TokenKind::Semicolon => {
  245|      1|                    self.advance();
  246|      1|                    any_advance = true;
  247|      1|                    if brace_depth == 0 && paren_depth == 0 {
  248|      1|                        break;
  249|      0|                    }
  250|       |                }
  251|       |                TokenKind::EndOfFile => {
  252|      0|                    self.advance();
  253|      0|                    any_advance = true;
  254|      0|                    break;
  255|       |                }
  256|      8|                _ => {
  257|      8|                    self.advance();
  258|      8|                    any_advance = true;
  259|      8|                }
  260|       |            }
  261|       |        }
  262|       |
  263|       |        // If we didn't advance at all, force advance to avoid infinite loop
  264|      3|        if !any_advance {
  265|      0|            self.advance();
  266|      3|        }
  267|      3|    }
  268|       |
  269|       |    /// Main expression parsing using Pratt algorithm
  270|  2.46k|    pub(crate) fn parse_expression(
  271|  2.46k|        &mut self,
  272|  2.46k|        min_binding_power: expressions::BindingPower,
  273|  2.46k|    ) -> Result<ParsedNodeRef, ParseError> {
  274|  2.46k|        parse_expression(self, min_binding_power)
  275|  2.46k|    }
  276|       |
  277|       |    /// Private helper to parse an expression with a given binding power, ensuring it's not a declaration.
  278|  1.72k|    fn parse_expr_bp(&mut self, min_binding_power: BindingPower) -> Result<ParsedNodeRef, ParseError> {
  279|  1.72k|        self.parse_expression(min_binding_power)
  280|  1.72k|    }
  281|       |
  282|       |    /// Parse expression with minimum binding power
  283|    981|    pub(crate) fn parse_expr_min(&mut self) -> Result<ParsedNodeRef, ParseError> {
  284|    981|        self.parse_expr_bp(BindingPower::MIN)
  285|    981|    }
  286|       |
  287|       |    /// Parse expression up to assignment
  288|    536|    pub(crate) fn parse_expr_assignment(&mut self) -> Result<ParsedNodeRef, ParseError> {
  289|    536|        self.parse_expr_bp(BindingPower::ASSIGNMENT)
  290|    536|    }
  291|       |
  292|       |    /// Parse translation unit (top level)
  293|    562|    pub(crate) fn parse_translation_unit(&mut self) -> Result<ParsedNodeRef, ParseError> {
  294|    562|        declarations::parse_translation_unit(self)
  295|    562|    }
  296|       |
  297|       |    /// Check if current token starts an abstract declarator
  298|    240|    fn is_abstract_declarator_start(&self) -> bool {
  299|    240|        declarator::is_abstract_declarator_start(self)
  300|    240|    }
  301|       |
  302|       |    /// Extract the declared name from a declarator, if any
  303|     50|    fn get_declarator_name(&self, declarator: &ParsedDeclarator) -> Option<NameId> {
  304|     50|        declarator::get_declarator_name(declarator)
  305|     50|    }
  306|       |
  307|       |    /// Disambiguates between a type name and an identifier in ambiguous contexts.
  308|       |    /// This is crucial for parsing C's "declaration-specifier-list" vs "expression" ambiguity.
  309|  2.16k|    fn is_type_name(&self, symbol: NameId) -> bool {
  310|  2.16k|        self.type_context.is_type_name(symbol)
  311|  2.16k|    }
  312|       |
  313|       |    /// Check if a cast expression starts at the current position
  314|       |    /// This is called after consuming an opening parenthesis
  315|     94|    fn is_cast_expression_start(&self) -> bool {
  316|     94|        expressions::is_cast_expression_start(self)
  317|     94|    }
  318|       |
  319|       |    /// Check if the given token can start a type name.
  320|    171|    pub(crate) fn is_type_name_start_token(&self, token: &Token) -> bool {
  321|    171|        match token.kind {
  322|       |            // Basic type specifiers
  323|       |            TokenKind::Void
  324|       |            | TokenKind::Char
  325|       |            | TokenKind::Short
  326|       |            | TokenKind::Int
  327|       |            | TokenKind::Long
  328|       |            | TokenKind::Float
  329|       |            | TokenKind::Double
  330|       |            | TokenKind::Signed
  331|       |            | TokenKind::Unsigned
  332|       |            | TokenKind::Bool
  333|       |            | TokenKind::Complex
  334|       |            // Struct/union/enum specifiers
  335|       |            | TokenKind::Struct
  336|       |            | TokenKind::Union
  337|       |            | TokenKind::Enum
  338|       |            // Type qualifiers that can start a type name
  339|       |            | TokenKind::Const
  340|       |            | TokenKind::Volatile
  341|       |            | TokenKind::Restrict
  342|       |            | TokenKind::Atomic
  343|       |            // GCC attribute extension
  344|     64|            | TokenKind::Attribute => true,
  345|       |            // Check for typedef'd identifiers
  346|     41|            TokenKind::Identifier(symbol) => self.is_type_name(symbol),
  347|     66|            _ => false,
  348|       |        }
  349|    171|    }
  350|       |
  351|       |    /// Check if the current token can start a type name.
  352|       |    /// This is a lightweight check used for disambiguation.
  353|    149|    pub(crate) fn is_type_name_start(&self) -> bool {
  354|    149|        if let Some(token) = self.try_current_token() {
  355|    149|            self.is_type_name_start_token(&token)
  356|       |        } else {
  357|      0|            false
  358|       |        }
  359|    149|    }
  360|       |
  361|       |    /// Parse cast expression given the already parsed type and right paren token
  362|     26|    fn parse_cast_expression_from_type_and_paren(
  363|     26|        &mut self,
  364|     26|        parsed_type: ParsedType,
  365|     26|        right_paren_token: Token,
  366|     26|    ) -> Result<ParsedNodeRef, ParseError> {
  367|     26|        expressions::parse_cast_expression_from_type_and_paren(self, parsed_type, right_paren_token)
  368|     26|    }
  369|       |
  370|       |    /// Parse compound literal given the type and start location
  371|     12|    fn parse_compound_literal_from_type_and_start(
  372|     12|        &mut self,
  373|     12|        parsed_type: ParsedType,
  374|     12|        start_loc: SourceLoc,
  375|     12|    ) -> Result<ParsedNodeRef, ParseError> {
  376|     12|        expressions::parse_compound_literal_from_type_and_start(self, parsed_type, start_loc)
  377|     12|    }
  378|       |
  379|       |    /// parse and accept an identifier name
  380|    296|    fn accept_name(&mut self) -> Option<NameId> {
  381|    296|        if let Some(token) = self.try_current_token()
  382|    296|            && let TokenKind::Identifier(symbol) = token.kind
                                                       ^283
  383|       |        {
  384|    283|            self.advance();
  385|    283|            return Some(symbol);
  386|     13|        }
  387|     13|        None
  388|    296|    }
  389|       |
  390|       |    /// expect and accept an identifier name, returning the symbol or error
  391|    215|    fn expect_name(&mut self) -> Result<(NameId, SourceSpan), ParseError> {
  392|    215|        let token = self.current_token()?;
                                                      ^0
  393|    215|        if let TokenKind::Identifier(symbol) = token.kind {
  394|    215|            self.advance();
  395|    215|            Ok((symbol, token.span))
  396|       |        } else {
  397|      0|            Err(ParseError::UnexpectedToken {
  398|      0|                expected_tokens: "identifier".to_string(),
  399|      0|                found: token.kind,
  400|      0|                span: token.span,
  401|      0|            })
  402|       |        }
  403|    215|    }
  404|       |
  405|       |    /// Add a typedef name to the type context
  406|     50|    pub(crate) fn add_typedef(&mut self, symbol: NameId) {
  407|     50|        debug!("add_typedef: adding {:?} to typedef_names", symbol);
                             ^0
  408|     50|        self.type_context.add_typedef(symbol);
  409|     50|    }
  410|       |
  411|  1.72k|    fn save_state(&self) -> ParserState {
  412|  1.72k|        ParserState {
  413|  1.72k|            current_idx: self.current_idx,
  414|  1.72k|            diag_len: self.diag.diagnostics.len(),
  415|  1.72k|        }
  416|  1.72k|    }
  417|       |
  418|    398|    fn restore_state(&mut self, state: ParserState) {
  419|    398|        self.current_idx = state.current_idx;
  420|    398|        self.diag.diagnostics.truncate(state.diag_len);
  421|    398|    }
  422|       |
  423|  1.72k|    pub(crate) fn start_transaction(&mut self) -> utils::ParserTransaction<'_, 'arena, 'src> {
  424|  1.72k|        utils::ParserTransaction::new(self)
  425|  1.72k|    }
  426|       |
  427|       |    /// Check if the current token can start a declaration
  428|  1.27k|    pub(crate) fn starts_declaration(&self) -> bool {
  429|  1.27k|        if let Some(token) = self.try_current_token() {
  430|  1.27k|            let is_typedef = if let TokenKind::Identifier(symbol) = token.kind {
                                                                        ^231
  431|    231|                self.is_type_name(symbol)
  432|       |            } else {
  433|  1.04k|                false
  434|       |            };
  435|  1.27k|            token.kind.is_declaration_start(is_typedef)
  436|       |        } else {
  437|      0|            false
  438|       |        }
  439|  1.27k|    }
  440|       |}
  441|       |
  442|       |/// contain functions related to AST nodes
  443|       |impl<'arena, 'src> Parser<'arena, 'src> {
  444|       |    /// Push a node to the AST and return its reference
  445|  6.92k|    pub(crate) fn push_node(&mut self, kind: ParsedNodeKind, span: SourceSpan) -> ParsedNodeRef {
  446|  6.92k|        self.ast.push_node(ParsedNode::new(kind, span))
  447|  6.92k|    }
  448|       |
  449|  3.04k|    pub(crate) fn push_dummy(&mut self) -> ParsedNodeRef {
  450|  3.04k|        self.push_node(ParsedNodeKind::Dummy, SourceSpan::empty())
  451|  3.04k|    }
  452|       |
  453|       |    /// Push a node to the AST and return its reference
  454|  2.47k|    pub(crate) fn replace_node(
  455|  2.47k|        &mut self,
  456|  2.47k|        old_ref: ParsedNodeRef,
  457|  2.47k|        kind: ParsedNodeKind,
  458|  2.47k|        span: SourceSpan,
  459|  2.47k|    ) -> ParsedNodeRef {
  460|  2.47k|        self.ast.replace_node(old_ref, ParsedNode::new(kind, span))
  461|  2.47k|    }
  462|       |}

/app/src/parser/declaration_core.rs:
    1|       |//! Core declaration parsing module
    2|       |//!
    3|       |//! This module handles the main declaration parsing logic, including
    4|       |//! declaration specifiers, initializers, and coordination between
    5|       |//! different declaration components.
    6|       |
    7|       |use crate::ast::SourceSpan;
    8|       |use crate::ast::nodes::FunctionSpecifier;
    9|       |use crate::ast::nodes::StorageClass;
   10|       |use crate::ast::nodes::TypeQualifier;
   11|       |// Import all parsed types to be sure
   12|       |use crate::ast::parsed::{
   13|       |    ParsedAlignmentSpecifier, ParsedDeclSpecifier, ParsedDesignatedInitializer, ParsedDesignator, ParsedNodeKind,
   14|       |    ParsedNodeRef, ParsedTypeSpecifier,
   15|       |};
   16|       |use crate::diagnostic::ParseError;
   17|       |use crate::parser::TokenKind;
   18|       |use log::debug;
   19|       |use thin_vec::ThinVec;
   20|       |
   21|       |use super::Parser;
   22|       |
   23|       |/// Parse declaration specifiers
   24|  2.40k|pub(crate) fn parse_declaration_specifiers(parser: &mut Parser) -> Result<ThinVec<ParsedDeclSpecifier>, ParseError> {
   25|  2.40k|    let mut specifiers = ThinVec::new();
   26|  2.40k|    let mut has_type_specifier = false;
   27|  2.40k|    let start_idx = parser.current_idx;
   28|       |
   29|  2.40k|    debug!(
   30|      0|        "parse_declaration_specifiers: starting at position {}, token {:?}",
   31|       |        start_idx,
   32|      0|        parser.current_token_kind()
   33|       |    );
   34|       |
   35|  5.24k|    while let Some(token) = parser.try_current_token() {
   36|  5.24k|        debug!(
   37|      0|            "parse_declaration_specifiers: loop iteration at position {}, token {:?}",
   38|       |            parser.current_idx, token.kind
   39|       |        );
   40|  5.24k|        match token.kind {
   41|       |            // Storage class specifiers
   42|       |            TokenKind::Typedef
   43|       |            | TokenKind::Extern
   44|       |            | TokenKind::Static
   45|       |            | TokenKind::Auto
   46|       |            | TokenKind::Register
   47|       |            | TokenKind::ThreadLocal => {
   48|    113|                let storage_class = match token.kind {
   49|       |                    TokenKind::Typedef => {
   50|     52|                        debug!("Found Typedef token, setting storage_class Typedef");
                                             ^0
   51|     52|                        StorageClass::Typedef
   52|       |                    }
   53|     25|                    TokenKind::Extern => StorageClass::Extern,
   54|     26|                    TokenKind::Static => StorageClass::Static,
   55|      2|                    TokenKind::Auto => StorageClass::Auto,
   56|      6|                    TokenKind::Register => StorageClass::Register,
   57|      2|                    TokenKind::ThreadLocal => StorageClass::ThreadLocal,
   58|      0|                    _ => unreachable!(),
   59|       |                };
   60|    113|                parser.advance();
   61|    113|                specifiers.push(ParsedDeclSpecifier::StorageClass(storage_class));
   62|       |            }
   63|       |
   64|       |            // Type qualifiers
   65|       |            TokenKind::Const | TokenKind::Volatile | TokenKind::Restrict | TokenKind::Atomic => {
   66|    149|                let qualifier = match token.kind {
                                  ^87
   67|     77|                    TokenKind::Const => TypeQualifier::Const,
   68|      2|                    TokenKind::Volatile => TypeQualifier::Volatile,
   69|      2|                    TokenKind::Restrict => TypeQualifier::Restrict,
   70|       |                    TokenKind::Atomic => {
   71|     68|                        if parser.peek_token(0).is_some_and(|t| t.kind == TokenKind::LeftParen) {
   72|       |                            // This is the `_Atomic(type-name)` form.
   73|     62|                            parser.advance(); // consume `_Atomic`
   74|     62|                            parser.expect(TokenKind::LeftParen)?;
                                                                             ^0
   75|       |
   76|     62|                            let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                                                      ^0
   77|       |
   78|     62|                            parser.expect(TokenKind::RightParen)?;
                                                                              ^0
   79|     62|                            let type_specifier = ParsedTypeSpecifier::Atomic(parsed_type);
   80|     62|                            specifiers.push(ParsedDeclSpecifier::TypeSpecifier(type_specifier));
   81|     62|                            has_type_specifier = true;
   82|     62|                            continue;
   83|      6|                        }
   84|      6|                        TypeQualifier::Atomic
   85|       |                    }
   86|      0|                    _ => unreachable!(),
   87|       |                };
   88|     87|                parser.advance();
   89|     87|                specifiers.push(ParsedDeclSpecifier::TypeQualifier(qualifier));
   90|       |            }
   91|       |
   92|       |            // Function specifiers
   93|       |            TokenKind::Inline | TokenKind::Noreturn => {
   94|     12|                let func_spec = if token.kind == TokenKind::Inline {
   95|      2|                    FunctionSpecifier::Inline
   96|       |                } else {
   97|     10|                    FunctionSpecifier::Noreturn
   98|       |                };
   99|     12|                parser.advance();
  100|     12|                specifiers.push(ParsedDeclSpecifier::FunctionSpecifier(func_spec));
  101|       |            }
  102|       |
  103|       |            TokenKind::Attribute => {
  104|      2|                debug!("parse_declaration_specifiers: found __attribute__, parsing it");
                                     ^0
  105|      2|                if let Err(_e) = parse_attribute(parser) {
                                         ^0
  106|      0|                    // For now, ignore attribute parsing errors
  107|      2|                }
  108|      2|                specifiers.push(ParsedDeclSpecifier::Attribute);
  109|       |            }
  110|       |
  111|       |            // Type specifiers
  112|       |            TokenKind::Void
  113|       |            | TokenKind::Char
  114|       |            | TokenKind::Short
  115|       |            | TokenKind::Int
  116|       |            | TokenKind::Long
  117|       |            | TokenKind::Float
  118|       |            | TokenKind::Double
  119|       |            | TokenKind::Signed
  120|       |            | TokenKind::Unsigned
  121|       |            | TokenKind::Bool
  122|       |            | TokenKind::Complex
  123|       |            | TokenKind::Struct
  124|       |            | TokenKind::Union
  125|       |            | TokenKind::Enum
  126|       |            | TokenKind::BuiltinVaList => {
  127|  2.47k|                let type_specifier = super::type_specifiers::parse_type_specifier(parser)?;
                                                                                                       ^0
  128|  2.47k|                specifiers.push(ParsedDeclSpecifier::TypeSpecifier(type_specifier));
  129|  2.47k|                has_type_specifier = true;
  130|       |            }
  131|       |
  132|  1.88k|            TokenKind::Identifier(symbol) => {
  133|  1.88k|                debug!(
  134|      0|                    "parse_declaration_specifiers: found identifier {:?}, calling is_type_name, current position: {}",
  135|       |                    symbol, parser.current_idx
  136|       |                );
  137|  1.88k|                let is_type = parser.is_type_name(symbol);
  138|  1.88k|                debug!(
  139|      0|                    "parse_declaration_specifiers: is_type_name({:?}) = {}, has_type_specifier = {}",
  140|       |                    symbol, is_type, has_type_specifier
  141|       |                );
  142|  1.88k|                if is_type && !has_type_specifier {
                                            ^74
  143|     62|                    debug!(
  144|      0|                        "parse_declaration_specifiers: {:?} is a type name and no type specifier yet, parsing type specifier",
  145|       |                        symbol
  146|       |                    );
  147|     62|                    let type_specifier = super::type_specifiers::parse_type_specifier(parser)?;
                                                                                                           ^0
  148|     62|                    specifiers.push(ParsedDeclSpecifier::TypeSpecifier(type_specifier));
  149|     62|                    has_type_specifier = true;
  150|       |                } else {
  151|  1.82k|                    debug!(
  152|      0|                        "parse_declaration_specifiers: {:?} is not a type name or already have type specifier, breaking at position {}",
  153|       |                        symbol, parser.current_idx
  154|       |                    );
  155|  1.82k|                    break;
  156|       |                }
  157|       |            }
  158|       |
  159|       |            // Alignment specifier
  160|       |            TokenKind::Alignas => {
  161|     18|                parser.advance(); // consume _Alignas
  162|     18|                let alignment = if parser.accept(TokenKind::LeftParen).is_some() {
  163|     18|                    let next_token = parser.current_token()?;
                                                                         ^0
  164|       |
  165|     18|                    let is_type_start = if let TokenKind::Identifier(symbol) = next_token.kind {
                                                                                   ^1
  166|      1|                        parser.is_type_name(symbol)
  167|       |                    } else {
  168|     17|                        next_token.kind.is_declaration_specifier_start()
  169|       |                    };
  170|       |
  171|     18|                    if is_type_start {
  172|       |                        // _Alignas(type-name)
  173|      2|                        let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                                                  ^0
  174|      2|                        parser.expect(TokenKind::RightParen)?;
                                                                          ^0
  175|      2|                        ParsedAlignmentSpecifier::Type(parsed_type)
  176|       |                    } else {
  177|       |                        // _Alignas(constant-expression)
  178|     16|                        let expr = parser.parse_expr_min()?;
                                                                        ^0
  179|     16|                        parser.expect(TokenKind::RightParen)?;
                                                                          ^0
  180|     16|                        ParsedAlignmentSpecifier::Expr(expr)
  181|       |                    }
  182|       |                } else {
  183|      0|                    return Err(ParseError::UnexpectedToken {
  184|      0|                        expected_tokens: "'(' after _Alignas".to_string(),
  185|      0|                        found: token.kind,
  186|      0|                        span: token.span,
  187|      0|                    });
  188|       |                };
  189|       |
  190|     18|                specifiers.push(ParsedDeclSpecifier::AlignmentSpecifier(alignment));
  191|       |            }
  192|       |
  193|       |            _ => {
  194|    579|                debug!(
  195|      0|                    "parse_declaration_specifiers: token {:?} not recognized as declaration specifier, breaking at position {}",
  196|       |                    token.kind, parser.current_idx
  197|       |                );
  198|    579|                if let TokenKind::Identifier(symbol) = &token.kind {
                                                           ^0
  199|      0|                    debug!("parse_declaration_specifiers: unrecognized identifier: {:?}", symbol);
  200|    579|                }
  201|    579|                break;
  202|       |            }
  203|       |        }
  204|       |    }
  205|       |
  206|  2.40k|    debug!(
  207|      0|        "parse_declaration_specifiers: ending at position {}, specifiers len={}, found {} specifiers",
  208|       |        parser.current_idx,
  209|      0|        specifiers.len(),
  210|      0|        specifiers.len()
  211|       |    );
  212|       |
  213|  2.40k|    if specifiers.is_empty() {
  214|      1|        let current_token = parser.current_token()?;
                                                                ^0
  215|      1|        return Err(ParseError::UnexpectedToken {
  216|      1|            expected_tokens: "declaration specifiers".to_string(),
  217|      1|            found: current_token.kind,
  218|      1|            span: current_token.span,
  219|      1|        });
  220|  2.40k|    }
  221|       |
  222|  2.40k|    Ok(specifiers)
  223|  2.40k|}
  224|       |
  225|       |/// Parse initializer
  226|    422|pub(crate) fn parse_initializer(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  227|    422|    debug!(
  228|      0|        "parse_initializer: called at position {}, current token: {:?}",
  229|       |        parser.current_idx,
  230|      0|        parser.current_token_kind()
  231|       |    );
  232|    422|    let span = parser.current_token_span()?;
                                                        ^0
  233|       |
  234|    422|    if parser.accept(TokenKind::LeftBrace).is_some() {
  235|     90|        debug!("parse_initializer: found LeftBrace, parsing compound initializer");
                             ^0
  236|       |        // Compound initializer
  237|     90|        let mut initializers = Vec::new();
  238|       |
  239|    178|        while !parser.is_token(TokenKind::RightBrace) {
  240|       |            // Check if this is a designated initializer (starts with . or [)
  241|    174|            let is_designated = parser.matches(&[TokenKind::Dot, TokenKind::LeftBracket]);
  242|       |
  243|    174|            let initializer = if is_designated {
  244|       |                // Parse designated initializer
  245|     57|                parse_designated_initializer(parser)?
                                                                  ^0
  246|       |            } else {
  247|       |                // Parse regular initializer (expression or nested compound initializer)
  248|    117|                let expr_or_compound = if parser.is_token(TokenKind::LeftBrace) {
  249|       |                    // Nested compound initializer
  250|     11|                    parse_initializer(parser)?
                                                           ^0
  251|       |                } else {
  252|       |                    // Expression initializer - parse until comma or closing brace
  253|    106|                    parse_initializer_expression(parser)?
                                                                      ^0
  254|       |                };
  255|       |
  256|       |                // Wrap in ParsedDesignatedInitializer with empty designation
  257|    117|                ParsedDesignatedInitializer {
  258|    117|                    designation: Vec::new(),
  259|    117|                    initializer: expr_or_compound,
  260|    117|                }
  261|       |            };
  262|       |
  263|    174|            initializers.push(initializer);
  264|       |
  265|    174|            if parser.accept(TokenKind::Comma).is_none() {
  266|     86|                break;
  267|     88|            }
  268|       |        }
  269|       |
  270|     90|        let end_token = parser.expect(TokenKind::RightBrace)?;
                                                                          ^0
  271|     90|        let span = SourceSpan::new(span.start(), end_token.span.end());
  272|     90|        let initializer = parser.push_node(ParsedNodeKind::InitializerList(initializers), span);
  273|     90|        Ok(initializer)
  274|       |    } else {
  275|    332|        debug!(
  276|      0|            "parse_initializer: no LeftBrace found, current token: {:?}, trying expression initializer",
  277|      0|            parser.current_token_kind()
  278|       |        );
  279|       |        // Expression initializer - use simple parsing to avoid comma operators
  280|    332|        let node = parse_initializer_expression(parser)?;
                                                                     ^0
  281|    332|        Ok(node)
  282|       |    }
  283|    422|}
  284|       |
  285|       |/// Parse designated initializer
  286|     57|fn parse_designated_initializer(parser: &mut Parser) -> Result<ParsedDesignatedInitializer, ParseError> {
  287|     57|    let designation = if parser.matches(&[TokenKind::Dot, TokenKind::LeftBracket]) {
  288|     57|        parse_designation(parser)?
                                               ^0
  289|       |    } else {
  290|      0|        Vec::new()
  291|       |    };
  292|       |
  293|     57|    parser.expect(TokenKind::Assign)?;
                                                  ^0
  294|     57|    let initializer = parse_initializer(parser)?;
                                                             ^0
  295|       |
  296|     57|    Ok(ParsedDesignatedInitializer {
  297|     57|        designation,
  298|     57|        initializer,
  299|     57|    })
  300|     57|}
  301|       |
  302|       |/// Parse designation
  303|     57|fn parse_designation(parser: &mut Parser) -> Result<Vec<ParsedDesignator>, ParseError> {
  304|     57|    let mut designators = Vec::new();
  305|       |
  306|    115|    while parser.matches(&[TokenKind::Dot, TokenKind::LeftBracket]) {
  307|     58|        if parser.accept(TokenKind::Dot).is_some() {
  308|     25|            let (field_name, _) = parser.expect_name()?;
                                                                    ^0
  309|     25|            designators.push(ParsedDesignator::FieldName(field_name));
  310|     33|        } else if parser.accept(TokenKind::LeftBracket).is_some() {
  311|       |            // Check if this is a range designator (contains ellipsis)
  312|     33|            let start_expr = parser.parse_expr_min()?;
                                                                  ^0
  313|       |
  314|       |            // Check for ellipsis token indicating range syntax
  315|     33|            if parser.accept(TokenKind::Ellipsis).is_some() {
  316|      9|                let end_expr = parser.parse_expr_min()?;
                                                                    ^0
  317|      9|                parser.expect(TokenKind::RightBracket)?;
                                                                    ^0
  318|      9|                designators.push(ParsedDesignator::GnuArrayRange(start_expr, end_expr));
  319|       |            } else {
  320|       |                // Single index designator
  321|     24|                parser.expect(TokenKind::RightBracket)?;
                                                                    ^0
  322|     24|                designators.push(ParsedDesignator::ArrayIndex(start_expr));
  323|       |            }
  324|      0|        }
  325|       |    }
  326|       |
  327|     57|    Ok(designators)
  328|     57|}
  329|       |
  330|       |/// Parse expression for initializer (stops at commas that separate declarators)
  331|    438|fn parse_initializer_expression(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  332|       |    // Parse expressions in initializers, but stop at comma operators to avoid
  333|       |    // consuming declarator-separating commas. Use assignment precedence to allow
  334|       |    // most binary operators but prevent comma operators.
  335|    438|    parser.parse_expr_assignment()
  336|    438|}
  337|       |
  338|       |/// Parse GCC __attribute__ syntax: __attribute__ (( attribute-list ))
  339|       |/// For now, we parse and skip the attribute construct
  340|      6|pub(crate) fn parse_attribute(parser: &mut Parser) -> Result<(), ParseError> {
  341|      6|    debug!("parse_attribute: parsing __attribute__ construct");
                         ^0
  342|       |
  343|       |    // Expect __attribute__
  344|      6|    parser.expect(TokenKind::Attribute)?;
                                                     ^0
  345|       |
  346|       |    // Expect opening (
  347|      6|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  348|       |
  349|       |    // Expect opening (
  350|      6|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  351|       |
  352|       |    // Skip attribute list until we find ))
  353|      6|    let mut paren_depth = 2;
  354|     18|    while let Some(token) = parser.try_current_token() {
  355|     18|        match token.kind {
  356|      0|            TokenKind::LeftParen => {
  357|      0|                paren_depth += 1;
  358|      0|            }
  359|       |            TokenKind::RightParen => {
  360|     12|                paren_depth -= 1;
  361|     12|                if paren_depth == 0 {
  362|      6|                    parser.advance();
  363|      6|                    break;
  364|      6|                }
  365|       |            }
  366|      6|            _ => {}
  367|       |        }
  368|     12|        parser.advance();
  369|       |    }
  370|       |
  371|      6|    debug!("parse_attribute: successfully parsed __attribute__ construct");
                         ^0
  372|      6|    Ok(())
  373|      6|}
  374|       |
  375|       |/// Parse GCC __asm__ syntax: __asm__ ( string-literal )
  376|      2|pub(crate) fn parse_asm(parser: &mut Parser) -> Result<(), ParseError> {
  377|      2|    debug!("parse_asm: parsing __asm__ construct");
                         ^0
  378|       |
  379|       |    // Expect __asm__ (or asm)
  380|      2|    parser.expect(TokenKind::Asm)?;
                                               ^0
  381|       |
  382|       |    // Expect opening (
  383|      2|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  384|       |
  385|       |    // Parse string literal(s) - often a string literal, but can be concatenation
  386|       |    // We can reuse parse_expr_assignment or just parse string literals loop
  387|       |    // For simplicity, let's just consume tokens until ) matching the first (
  388|      2|    let mut paren_depth = 1;
  389|      4|    while let Some(token) = parser.try_current_token() {
  390|      4|        match token.kind {
  391|      0|            TokenKind::LeftParen => paren_depth += 1,
  392|       |            TokenKind::RightParen => {
  393|      2|                paren_depth -= 1;
  394|      2|                if paren_depth == 0 {
  395|      2|                    break;
  396|      0|                }
  397|       |            }
  398|      2|            _ => {}
  399|       |        }
  400|      2|        parser.advance();
  401|       |    }
  402|       |
  403|       |    // Expect closing )
  404|      2|    parser.expect(TokenKind::RightParen)?;
                                                      ^0
  405|       |
  406|      2|    debug!("parse_asm: successfully parsed __asm__ construct");
                         ^0
  407|      2|    Ok(())
  408|      2|}

/app/src/parser/declarations.rs:
    1|       |//! Declaration parsing module
    2|       |//!
    3|       |//! This module handles all declaration parsing logic, including type specifiers,
    4|       |//! declarators, initializers, and top-level constructs like function definitions
    5|       |//! and translation units.
    6|       |
    7|       |use crate::ast::{parsed::*, *};
    8|       |use crate::diagnostic::ParseError;
    9|       |use crate::parser::declaration_core::parse_declaration_specifiers;
   10|       |use crate::parser::{Token, TokenKind};
   11|       |use crate::source_manager::{SourceLoc, SourceSpan};
   12|       |use log::debug;
   13|       |use thin_vec::ThinVec;
   14|       |
   15|       |use super::Parser;
   16|       |
   17|       |/// Parse a declaration
   18|  1.34k|pub(crate) fn parse_declaration(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
   19|  1.34k|    let trx = parser.start_transaction();
   20|  1.34k|    let start_loc = trx.parser.current_token_span()?.start();
                                                                 ^0
   21|       |
   22|  1.34k|    let dummy = trx.parser.push_dummy();
   23|       |
   24|  1.34k|    debug!(
   25|      0|        "parse_declaration: starting at position {}, token {:?}",
   26|       |        trx.parser.current_idx,
   27|      0|        trx.parser.current_token_kind()
   28|       |    );
   29|       |
   30|       |    // Check for _Static_assert (C11)
   31|  1.34k|    if let Some(token) = trx.parser.accept(TokenKind::StaticAssert) {
                              ^41
   32|     41|        let result = parse_static_assert(trx.parser, token);
   33|     41|        if result.is_ok() {
   34|     41|            trx.commit();
   35|     41|        }
                      ^0
   36|       |        // The transaction will be rolled back on error automatically
   37|     41|        return result;
   38|  1.30k|    }
   39|       |
   40|       |    // Try to parse declaration specifiers
   41|  1.30k|    let specifiers = match parse_declaration_specifiers(trx.parser) {
   42|  1.30k|        Ok(specifiers) => {
   43|  1.30k|            debug!(
   44|      0|                "parse_declaration: parsed {} specifiers, current token {:?}",
   45|      0|                specifiers.len(),
   46|      0|                trx.parser.current_token_kind()
   47|       |            );
   48|  1.30k|            debug!(
   49|      0|                "parse_declaration: current token after specifiers: {:?}",
   50|      0|                trx.parser.current_token_kind()
   51|       |            );
   52|  1.30k|            if let Some(last_specifier) = specifiers.last() {
   53|  1.30k|                debug!(
   54|      0|                    "parse_declaration: last specifier type: {:?}",
   55|      0|                    match last_specifier {
   56|      0|                        ParsedDeclSpecifier::TypeSpecifier(ts) => std::mem::discriminant(ts),
   57|      0|                        _ => std::mem::discriminant(&ParsedTypeSpecifier::Void),
   58|       |                    }
   59|       |                );
   60|      0|            }
   61|  1.30k|            specifiers
   62|       |        }
   63|      0|        Err(e) => {
   64|      0|            return Err(e);
   65|       |        }
   66|       |    };
   67|       |
   68|       |    // Special handling for struct/union/enum declarations
   69|       |    // Check if any specifier is a struct/union/enum specifier (definition or forward declaration)
   70|  1.54k|    let has_record_enum_type = specifiers.iter().any(|s| {
                      ^1.30k                 ^1.30k            ^1.30k
   71|  1.30k|        matches!(
   72|  1.40k|            s,
   73|       |            ParsedDeclSpecifier::TypeSpecifier(ParsedTypeSpecifier::Record(_, _, _) | ParsedTypeSpecifier::Enum(_, _))
   74|       |        )
   75|  1.54k|    });
   76|  1.30k|    let has_storage_class = specifiers
   77|  1.30k|        .iter()
   78|  1.43k|        .any(|s| matches!(s, ParsedDeclSpecifier::StorageClass(_)));
                       ^1.30k
   79|  1.30k|    let is_record_enum_specifier = has_record_enum_type && !has_storage_class;
                                                                         ^234
   80|       |
   81|       |    // If we have a struct/union/enum specifier, we need to check if there are declarators following
   82|       |    // The logic should be:
   83|       |    // - If next token is semicolon: treat as record/enum declaration (definition or forward)
   84|       |    // - If next token is declarator-starting token: continue with normal declaration parsing
   85|  1.30k|    if is_record_enum_specifier {
   86|    224|        if let Some(semi) = trx.parser.accept(TokenKind::Semicolon) {
                                  ^129
   87|       |            // This is either:
   88|       |            // 1. A pure struct/union/enum definition like "struct foo { ... };" or "enum E { ... };"
   89|       |            // 2. A forward struct/union/enum declaration like "struct foo;" or "enum E;"
   90|       |            // In both cases, consume the semicolon and create declaration with no declarators
   91|    129|            let declaration_data = ParsedDeclarationData {
   92|    129|                specifiers,
   93|    129|                init_declarators: ThinVec::new(),
   94|    129|            };
   95|       |
   96|    129|            let end_loc = semi.span.end();
   97|    129|            let span = SourceSpan::new(start_loc, end_loc);
   98|       |
   99|    129|            let node = trx
  100|    129|                .parser
  101|    129|                .push_node(ParsedNodeKind::Declaration(declaration_data), span);
  102|    129|            debug!(
  103|      0|                "parse_declaration: successfully parsed record/enum declaration, node_id={}",
  104|      0|                node.get()
  105|       |            );
  106|    129|            trx.commit();
  107|    129|            return Ok(node);
  108|       |        } else {
  109|       |            // This is a record/enum specifier with declarators
  110|       |            // Continue with normal declaration parsing (e.g., "struct foo { ... } var;")
  111|     95|            debug!("parse_declaration: record/enum specifier with declarators, continuing with normal parsing");
                                 ^0
  112|       |        }
  113|  1.08k|    }
  114|       |
  115|       |    // For all other cases, check if we have declarators
  116|  1.17k|    let has_declarators = if trx.parser.is_token(TokenKind::Semicolon) {
  117|       |        // Definitely no declarators
  118|      0|        false
  119|       |    } else {
  120|       |        // Check if we have a declarator-starting token
  121|       |        // This includes: identifier, star, or left paren
  122|      2|        matches!(
  123|  1.17k|            trx.parser.current_token_kind(),
  124|       |            Some(TokenKind::Identifier(_)) | Some(TokenKind::Star) | Some(TokenKind::LeftParen)
  125|       |        )
  126|       |    };
  127|  1.17k|    debug!("parse_declaration: has_declarators = {}", has_declarators);
                         ^0
  128|       |
  129|       |    // If no declarators and this is not a record/enum definition, it's an error
  130|  1.17k|    if !has_declarators {
  131|       |        // Check if this looks like a record/enum definition
  132|       |        // by looking at the last parsed specifier
  133|      2|        let message = if let Some(ParsedDeclSpecifier::TypeSpecifier(ts)) = specifiers.last() {
  134|      2|            match ts {
  135|      0|                ParsedTypeSpecifier::Record(_, _, _) => "Expected ';' after struct/union definition",
  136|      0|                ParsedTypeSpecifier::Enum(_, _) => "Expected ';' after enum definition",
  137|      2|                _ => "Expected declarator or identifier after type specifier",
  138|       |            }
  139|       |        } else {
  140|       |            // No specifiers at all - this shouldn't happen
  141|      0|            "Expected type specifiers"
  142|       |        };
  143|       |
  144|      2|        let current_token = trx.parser.current_token()?;
                                                                    ^0
  145|      2|        return Err(ParseError::UnexpectedToken {
  146|      2|            expected_tokens: message.to_string(),
  147|      2|            found: current_token.kind,
  148|      2|            span: current_token.span,
  149|      2|        });
  150|  1.17k|    }
  151|       |
  152|       |    // Parse init declarators
  153|  1.17k|    let mut init_declarators = ThinVec::new();
  154|       |
  155|       |    loop {
  156|  1.20k|        let declarator_start_idx = trx.parser.current_idx;
  157|  1.20k|        let start_span = trx.parser.current_token_span_or_empty();
  158|       |
  159|  1.20k|        debug!(
  160|      0|            "parse_declaration: parsing declarator at position {}, token {:?}",
  161|       |            declarator_start_idx,
  162|      0|            trx.parser.current_token_kind()
  163|       |        );
  164|       |
  165|  1.20k|        let declarator = match super::declarator::parse_declarator(trx.parser, None) {
                          ^1.19k
  166|  1.19k|            Ok(declarator) => {
  167|  1.19k|                debug!(
  168|      0|                    "parse_declaration: parsed declarator, current token {:?}",
  169|      0|                    trx.parser.current_token_kind()
  170|       |                );
  171|  1.19k|                declarator
  172|       |            }
  173|      4|            Err(e) => {
  174|      4|                return Err(e);
  175|       |            }
  176|       |        };
  177|       |
  178|  1.19k|        let initializer = if trx.parser.accept(TokenKind::Assign).is_some() {
  179|    340|            debug!(
  180|      0|                "parse_declaration: found '=', parsing initializer at position {}",
  181|       |                trx.parser.current_idx
  182|       |            );
  183|    340|            match super::declaration_core::parse_initializer(trx.parser) {
  184|    340|                Ok(initializer) => {
  185|    340|                    debug!(
  186|      0|                        "parse_declaration: parsed initializer, now at position {} with token {:?}",
  187|       |                        trx.parser.current_idx,
  188|      0|                        trx.parser.current_token_kind()
  189|       |                    );
  190|    340|                    Some(initializer)
  191|       |                }
  192|      0|                Err(e) => {
  193|      0|                    return Err(e);
  194|       |                }
  195|       |            }
  196|       |        } else {
  197|    856|            None
  198|       |        };
  199|       |
  200|  1.19k|        let end_span = trx.parser.last_token_span().unwrap_or(start_span);
  201|  1.19k|        let span = start_span.merge(end_span);
  202|       |
  203|  1.19k|        init_declarators.push(ParsedInitDeclarator {
  204|  1.19k|            declarator,
  205|  1.19k|            initializer,
  206|  1.19k|            span,
  207|  1.19k|        });
  208|       |
  209|  1.19k|        if !trx.parser.is_token(TokenKind::Comma) {
  210|  1.16k|            break;
  211|     27|        }
  212|     27|        trx.parser.advance(); // consume comma
  213|       |    }
  214|       |
  215|       |    // Check for __attribute__ or __asm__ after declarator (GCC extension)
  216|       |    loop {
  217|  1.17k|        if trx.parser.is_token(TokenKind::Attribute) {
  218|      3|            debug!("parse_declaration: found __attribute__ after declarator, parsing it");
                                 ^0
  219|      3|            if let Err(_e) = super::declaration_core::parse_attribute(trx.parser) {
                                     ^0
  220|      0|                debug!("parse_declaration: failed to parse __attribute__: {:?}", _e);
  221|      3|            }
  222|  1.17k|        } else if trx.parser.is_token(TokenKind::Asm) {
  223|      2|            debug!("parse_declaration: found __asm__ after declarator, parsing it");
                                 ^0
  224|      2|            if let Err(_e) = super::declaration_core::parse_asm(trx.parser) {
                                     ^0
  225|      0|                debug!("parse_declaration: failed to parse __asm__: {:?}", _e);
  226|      2|            }
  227|       |        } else {
  228|  1.16k|            break;
  229|       |        }
  230|       |    }
  231|       |
  232|       |    // Check for semicolon at current position
  233|  1.16k|    debug!(
  234|      0|        "parse_declaration: expecting semicolon, current token {:?}",
  235|      0|        trx.parser.current_token_kind()
  236|       |    );
  237|  1.16k|    let semicolon_token = if let Some(token) = trx.parser.accept(TokenKind::Semicolon) {
                      ^779                          ^779
  238|    779|        token
  239|       |    } else {
  240|    390|        let current_token = trx.parser.current_token()?;
                                                                    ^0
  241|    390|        return Err(ParseError::UnexpectedToken {
  242|    390|            expected_tokens: "';' after declaration".to_string(),
  243|    390|            found: current_token.kind,
  244|    390|            span: current_token.span,
  245|    390|        });
  246|       |    };
  247|       |
  248|    779|    let end_loc = semicolon_token.span.end();
  249|       |
  250|    779|    let span = SourceSpan::new(start_loc, end_loc);
  251|       |
  252|       |    // Track typedef names for disambiguation
  253|  1.78k|    for specifier in &specifiers {
                      ^1.00k
  254|    957|        if matches!(specifier, ParsedDeclSpecifier::StorageClass(StorageClass::Typedef)) {
                                  ^89
  255|     50|            debug!("Found Typedef specifier, adding typedef names");
                                 ^0
  256|    100|            for init_declarator in &init_declarators {
                              ^50
  257|     50|                let name = trx.parser.get_declarator_name(&init_declarator.declarator);
  258|     50|                debug!("get_declarator_name returned: {:?}", name);
                                     ^0
  259|     50|                if let Some(name) = name {
  260|     50|                    debug!("Adding typedef name: {:?}", name);
                                         ^0
  261|     50|                    trx.parser.add_typedef(name);
  262|      0|                }
  263|       |            }
  264|    957|        }
  265|       |    }
  266|       |
  267|    779|    let declaration_data = ParsedDeclarationData {
  268|    779|        specifiers,
  269|    779|        init_declarators,
  270|    779|    };
  271|       |
  272|    779|    let node = trx
  273|    779|        .parser
  274|    779|        .replace_node(dummy, ParsedNodeKind::Declaration(declaration_data), span);
  275|    779|    debug!(
  276|      0|        "parse_declaration: successfully parsed declaration, node_id={}",
  277|      0|        node.get()
  278|       |    );
  279|    779|    trx.commit();
  280|    779|    Ok(node)
  281|  1.34k|}
  282|       |
  283|       |/// Parse function definition
  284|    390|fn parse_function_definition(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  285|    390|    let start_loc = parser.current_token()?.span.start();
                                                        ^0
  286|    390|    let dummy = parser.push_dummy();
  287|       |
  288|       |    // Parse declaration specifiers
  289|    390|    let specifiers = parse_declaration_specifiers(parser)?;
                                                                       ^0
  290|       |
  291|       |    // Parse declarator (should be a function declarator)
  292|    390|    let declarator = super::declarator::parse_declarator(parser, None)?;
                                                                                    ^0
  293|       |
  294|       |    // Parse function body
  295|    390|    let (body, body_end_loc) = super::statements::parse_compound_statement(parser)?;
                                                                                                ^0
  296|       |
  297|    390|    let span = SourceSpan::new(start_loc, body_end_loc);
  298|       |
  299|    390|    let function_def = ParsedFunctionDefData {
  300|    390|        specifiers,
  301|    390|        declarator: Box::new(declarator),
  302|    390|        body,
  303|    390|    };
  304|       |
  305|    390|    let node = parser.replace_node(dummy, ParsedNodeKind::FunctionDef(function_def), span);
  306|    390|    Ok(node)
  307|    390|}
  308|       |
  309|       |/// Parse translation unit (top level)
  310|    562|pub(crate) fn parse_translation_unit(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  311|    562|    let start_loc = parser.current_token()?.span.start();
                                                        ^0
  312|    562|    let mut end_loc = SourceLoc::builtin();
  313|       |
  314|    562|    let mut top_level_declarations = Vec::new();
  315|    562|    let mut iteration_count = 0;
  316|       |    const MAX_ITERATIONS: usize = 1000; // Prevent infinite loops
  317|       |
  318|       |    // TU must be placed as first node so reserve it place with dummy node before placing it last
  319|    562|    let dummy = parser.push_dummy();
  320|       |
  321|  1.47k|    while let Some(token) = parser.try_current_token() {
  322|  1.47k|        if token.kind == TokenKind::EndOfFile {
  323|    562|            end_loc = token.span.end();
  324|    562|            break;
  325|    908|        }
  326|       |
  327|       |        // Prevent infinite loops by limiting iterations
  328|    908|        iteration_count += 1;
  329|    908|        if iteration_count > MAX_ITERATIONS {
  330|       |            // infinite loop detected, we have bug in parser, so we don't return error but panic
  331|      0|            panic!(
  332|      0|                "Parser exceeded maximum iteration limit at token {:?}, position {}",
  333|       |                token.kind, parser.current_idx
  334|       |            );
  335|    908|        }
  336|       |
  337|    908|        let initial_idx = parser.current_idx;
  338|       |
  339|       |        // Try parsing as declaration first
  340|    908|        match parse_declaration(parser) {
  341|    518|            Ok(declaration) => {
  342|    518|                top_level_declarations.push(declaration);
  343|    518|            }
  344|       |            Err(_) => {
  345|       |                // If declaration parsing failed, try function definition
  346|       |                // Reset to initial position for backtracking
  347|    390|                parser.current_idx = initial_idx;
  348|    390|                match parse_function_definition(parser) {
  349|    390|                    Ok(func_def) => {
  350|    390|                        top_level_declarations.push(func_def);
  351|    390|                    }
  352|      0|                    Err(e) => {
  353|      0|                        parser.diag.report(e);
  354|      0|                        parser.synchronize();
  355|      0|                    }
  356|       |                }
  357|       |            }
  358|       |        }
  359|       |    }
  360|       |
  361|    562|    let span = SourceSpan::new(start_loc, end_loc);
  362|    562|    let node = parser.replace_node(dummy, ParsedNodeKind::TranslationUnit(top_level_declarations), span);
  363|       |
  364|    562|    Ok(node)
  365|    562|}
  366|       |
  367|       |/// Parse static assert (C11)
  368|     41|fn parse_static_assert(parser: &mut Parser, start_token: Token) -> Result<ParsedNodeRef, ParseError> {
  369|       |    // already consumed `_Static_assert`
  370|     41|    let start_loc = start_token.span.start();
  371|     41|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  372|       |
  373|     41|    let condition = parser.parse_expr_assignment()?;
                                                                ^0
  374|       |
  375|     41|    parser.expect(TokenKind::Comma)?;
                                                 ^0
  376|       |
  377|     41|    let token = parser.current_token()?;
                                                    ^0
  378|     41|    let message_node = match token.kind {
  379|     41|        TokenKind::StringLiteral(symbol) => {
  380|     41|            let literal = crate::ast::literal::Literal::String(symbol);
  381|     41|            let node = parser.push_node(ParsedNodeKind::Literal(literal), token.span);
  382|     41|            parser.advance();
  383|     41|            node
  384|       |        }
  385|       |        _ => {
  386|      0|            return Err(ParseError::UnexpectedToken {
  387|      0|                expected_tokens: "string literal".to_string(),
  388|      0|                found: token.kind,
  389|      0|                span: token.span,
  390|      0|            });
  391|       |        }
  392|       |    };
  393|       |
  394|     41|    parser.expect(TokenKind::RightParen)?;
                                                      ^0
  395|     41|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  396|     41|    let end_loc = semicolon_token.span.end();
  397|     41|    let span = SourceSpan::new(start_loc, end_loc);
  398|     41|    let node = parser.push_node(ParsedNodeKind::StaticAssert(condition, message_node), span);
  399|     41|    Ok(node)
  400|     41|}

/app/src/parser/declarator.rs:
    1|       |//! Declarator parsing module
    2|       |//!
    3|       |//! This module handles the parsing of C declarators, which are the most complex
    4|       |//! part of C's declaration syntax. Declarators can be nested and include pointers,
    5|       |//! arrays, and functions.
    6|       |
    7|       |use crate::diagnostic::ParseError;
    8|       |use crate::parser::declaration_core::parse_declaration_specifiers;
    9|       |use crate::parser::{Token, TokenKind};
   10|       |use crate::{ast::*, semantic::TypeQualifiers};
   11|       |use log::debug;
   12|       |use thin_vec::{ThinVec, thin_vec};
   13|       |
   14|       |use super::Parser;
   15|       |
   16|       |/// Helper enum for reconstructing complex declarators
   17|       |#[derive(Debug)]
   18|       |enum DeclaratorComponent {
   19|       |    Pointer(TypeQualifiers),
   20|       |}
   21|       |
   22|       |/// Look ahead past a GCC-style `__attribute__((...))` construct without consuming tokens.
   23|       |/// Returns the token immediately following the attribute if the structure is valid, or None.
   24|       |///
   25|       |/// Expects: Attribute (( ... ))
   26|      2|fn peek_past_attribute(parser: &Parser, mut start_offset: u32) -> Option<Token> {
   27|       |    // Check for multiple attributes
   28|       |    loop {
   29|       |        // start_offset points to Attribute
   30|       |        // Skip Attribute
   31|      2|        start_offset += 1;
   32|       |
   33|       |        // Expect ((
   34|       |        // If not ((, then it's not a GCC attribute (or it's ill-formed), stop
   35|      2|        if let Some(t) = parser.peek_token(start_offset) {
   36|      2|            if t.kind != TokenKind::LeftParen {
   37|      0|                return parser.peek_token(start_offset).cloned();
   38|      2|            }
   39|       |        } else {
   40|      0|            return None;
   41|       |        }
   42|      2|        start_offset += 1;
   43|       |
   44|      2|        if let Some(t) = parser.peek_token(start_offset) {
   45|      2|            if t.kind != TokenKind::LeftParen {
   46|      0|                return None;
   47|      2|            }
   48|       |        } else {
   49|      0|            return None;
   50|       |        }
   51|      2|        start_offset += 1;
   52|       |
   53|       |        // Skip balanced parens
   54|      2|        let mut depth = 2; // We saw two LeftParens
   55|       |
   56|      8|        while depth > 0 {
   57|      6|            let t = parser.peek_token(start_offset)?;
                                                                 ^0
   58|      6|            match t.kind {
   59|      0|                TokenKind::LeftParen => depth += 1,
   60|      4|                TokenKind::RightParen => depth -= 1,
   61|      2|                _ => {}
   62|       |            }
   63|      6|            start_offset += 1;
   64|       |        }
   65|       |
   66|       |        // Now we are past one attribute.
   67|       |        // Check if there is another one.
   68|      2|        if let Some(t) = parser.peek_token(start_offset) {
   69|      2|            if t.kind != TokenKind::Attribute {
   70|       |                // Not an attribute, so we are done
   71|      2|                return Some(*t);
   72|      0|            }
   73|       |            // It is an attribute, loop again (start_offset points to it)
   74|       |        } else {
   75|      0|            return None;
   76|       |        }
   77|       |    }
   78|      2|}
   79|       |
   80|       |/// Validate declarator combinations
   81|  1.05k|fn validate_declarator_combination(
   82|  1.05k|    base: &ParsedDeclarator,
   83|  1.05k|    new_kind: &str,
   84|  1.05k|    span: SourceSpan,
   85|  1.05k|) -> Result<(), ParseError> {
   86|  1.05k|    match base {
   87|       |        ParsedDeclarator::Function { .. } => {
   88|      2|            if new_kind == "array" {
   89|      1|                return Err(ParseError::DeclarationNotAllowed { span });
   90|      1|            }
   91|      1|            if new_kind == "function" {
   92|      1|                return Err(ParseError::DeclarationNotAllowed { span });
   93|      0|            }
   94|       |        }
   95|       |        ParsedDeclarator::Array(..) => {
   96|     11|            if new_kind == "function" {
   97|      1|                return Err(ParseError::DeclarationNotAllowed { span });
   98|     10|            }
   99|       |        }
  100|  1.04k|        _ => {}
  101|       |    }
  102|  1.05k|    Ok(())
  103|  1.05k|}
  104|       |
  105|       |/// Parse declarator
  106|  2.07k|pub(crate) fn parse_declarator(
  107|  2.07k|    parser: &mut Parser,
  108|  2.07k|    initial_declarator: Option<NameId>,
  109|  2.07k|) -> Result<ParsedDeclarator, ParseError> {
  110|  2.07k|    debug!(
  111|      0|        "parse_declarator: starting at position {}, token: {:?}, initial_declarator: {:?}",
  112|       |        parser.current_idx,
  113|      0|        parser.current_token_kind(),
  114|       |        initial_declarator
  115|       |    );
  116|       |
  117|       |    // Check for __attribute__ before declarator (GCC extension)
  118|  2.07k|    while parser.is_token(TokenKind::Attribute) {
  119|      0|        if let Err(_e) = super::declaration_core::parse_attribute(parser) {
  120|      0|            debug!("parse_declarator: failed to parse __attribute__: {:?}", _e);
  121|      0|        }
  122|       |    }
  123|       |
  124|       |    // Parse leading pointers and their qualifiers
  125|  2.07k|    let declarator_chain = parse_leading_pointers(parser)?;
                                                                       ^0
  126|       |
  127|       |    // Parse direct declarator (identifier or parenthesized declarator)
  128|  2.07k|    let base_declarator = if parser.accept(TokenKind::LeftParen).is_some() {
  129|     26|        debug!("parse_declarator: found LeftParen, parsing parenthesized declarator");
                             ^0
  130|     26|        let inner_declarator = parse_declarator(parser, None)?;
                                                                           ^0
  131|     26|        debug!(
  132|      0|            "parse_declarator: consumed RightParen, current token: {:?}",
  133|      0|            parser.current_token_kind()
  134|       |        );
  135|     26|        parser.expect(TokenKind::RightParen)?; // Consume ')'
                                                          ^0
  136|     26|        inner_declarator
  137|  2.04k|    } else if let Some(ident_symbol) = initial_declarator {
                                     ^0
  138|      0|        ParsedDeclarator::Identifier(ident_symbol, TypeQualifiers::empty())
  139|  2.04k|    } else if let Some(token) = parser.try_current_token() {
  140|  2.04k|        if let TokenKind::Identifier(symbol) = token.kind {
                                                   ^2.02k
  141|  2.02k|            parser.advance(); // Consume identifier
  142|  2.02k|            ParsedDeclarator::Identifier(symbol, TypeQualifiers::empty())
  143|     19|        } else if parser.is_abstract_declarator_start() {
  144|      0|            parse_abstract_declarator(parser)?
  145|       |        } else {
  146|       |            // For abstract declarator, if nothing matches, it's just abstract
  147|     19|            ParsedDeclarator::Abstract
  148|       |        }
  149|       |    } else {
  150|       |        // Consume invalid tokens until ) or end
  151|      0|        while let Some(token) = parser.try_current_token() {
  152|      0|            if token.kind == TokenKind::RightParen {
  153|      0|                break;
  154|      0|            }
  155|      0|            debug!("parse_declarator: unexpected token {:?}, consuming", token.kind);
  156|      0|            parser.advance();
  157|       |        }
  158|       |        // For abstract declarator, if no token, it's abstract
  159|      0|        ParsedDeclarator::Abstract
  160|       |    };
  161|       |
  162|       |    // Parse trailing array and function declarators
  163|  2.07k|    let current_base = parse_trailing_declarators(parser, base_declarator)?;
                      ^2.06k                                                            ^4
  164|       |
  165|       |    // Reconstruct the declarator chain in reverse order
  166|  2.06k|    let final_declarator = reconstruct_declarator_chain(declarator_chain, current_base);
  167|       |
  168|  2.06k|    Ok(final_declarator)
  169|  2.07k|}
  170|       |
  171|       |/// Helper to parse type qualifiers
  172|    362|fn parse_type_qualifiers(parser: &mut Parser) -> Result<TypeQualifiers, ParseError> {
  173|    362|    let mut qualifiers = TypeQualifiers::empty();
  174|    395|    while let Some(token) = parser.try_current_token() {
  175|    395|        match token.kind {
  176|     21|            TokenKind::Const => {
  177|     21|                qualifiers.insert(TypeQualifiers::CONST);
  178|     21|                parser.advance();
  179|     21|            }
  180|      6|            TokenKind::Volatile => {
  181|      6|                qualifiers.insert(TypeQualifiers::VOLATILE);
  182|      6|                parser.advance();
  183|      6|            }
  184|      6|            TokenKind::Restrict => {
  185|      6|                qualifiers.insert(TypeQualifiers::RESTRICT);
  186|      6|                parser.advance();
  187|      6|            }
  188|      0|            TokenKind::Atomic => {
  189|      0|                qualifiers.insert(TypeQualifiers::ATOMIC);
  190|      0|                parser.advance();
  191|      0|            }
  192|    362|            _ => break,
  193|       |        }
  194|       |    }
  195|    362|    Ok(qualifiers)
  196|    362|}
  197|       |
  198|       |/// Helper to parse array size
  199|    149|fn parse_array_size(parser: &mut Parser) -> Result<ParsedArraySize, ParseError> {
  200|    149|    let is_static = parser.accept(TokenKind::Static).is_some();
  201|    149|    let qualifiers = parse_type_qualifiers(parser)?;
                                                                ^0
  202|       |
  203|    149|    if parser.accept(TokenKind::Star).is_some() {
  204|      0|        Ok(ParsedArraySize::Star { qualifiers })
  205|    149|    } else if parser.is_token(TokenKind::RightBracket) {
  206|       |        // Empty []
  207|     39|        Ok(ParsedArraySize::Incomplete)
  208|       |    } else {
  209|       |        // Assume it's an expression for the size
  210|    110|        let expr_node = parser.parse_expr_min()?;
                                                             ^0
  211|    110|        if is_static || !qualifiers.is_empty() {
                                      ^101
  212|     21|            Ok(ParsedArraySize::VlaSpecifier {
  213|     21|                is_static,
  214|     21|                qualifiers,
  215|     21|                size: Some(expr_node),
  216|     21|            })
  217|       |        } else {
  218|     89|            Ok(ParsedArraySize::Expression {
  219|     89|                expr: expr_node,
  220|     89|                qualifiers,
  221|     89|            })
  222|       |        }
  223|       |    }
  224|    149|}
  225|       |
  226|       |/// Parse leading pointers and their qualifiers, building a declarator component chain
  227|  2.13k|fn parse_leading_pointers(parser: &mut Parser) -> Result<Vec<DeclaratorComponent>, ParseError> {
  228|  2.13k|    let mut declarator_chain: Vec<DeclaratorComponent> = Vec::new();
  229|       |
  230|  2.35k|    while parser.accept(TokenKind::Star).is_some() {
  231|    213|        let current_qualifiers = parse_type_qualifiers(parser)?;
                                                                            ^0
  232|    213|        declarator_chain.push(DeclaratorComponent::Pointer(current_qualifiers));
  233|       |    }
  234|       |
  235|  2.13k|    Ok(declarator_chain)
  236|  2.13k|}
  237|       |
  238|       |/// Parse trailing declarators (arrays, functions) that follow the base declarator
  239|       |/// This is used for abstract declarators in type names where bit-fields are not allowed
  240|     67|fn parse_trailing_declarators_for_type_names(
  241|     67|    parser: &mut Parser,
  242|     67|    mut current_base: ParsedDeclarator,
  243|     67|) -> Result<ParsedDeclarator, ParseError> {
  244|       |    loop {
  245|     89|        let current_token_span = parser.try_current_token().map_or(SourceSpan::empty(), |t| t.span);
  246|     89|        if parser.accept(TokenKind::LeftBracket).is_some() {
  247|       |            // Array declarator
  248|      4|            validate_declarator_combination(&current_base, "array", current_token_span)?;
                                                                                                     ^0
  249|      4|            let array_size = parse_array_size(parser)?;
                                                                   ^0
  250|      4|            parser.expect(TokenKind::RightBracket)?; // Consume ']'
                                                                ^0
  251|      4|            current_base = ParsedDeclarator::Array(Box::new(current_base), array_size);
  252|     85|        } else if parser.accept(TokenKind::LeftParen).is_some() {
  253|       |            // Function declarator
  254|     18|            validate_declarator_combination(&current_base, "function", current_token_span)?;
                                                                                                        ^0
  255|     18|            let (parameters, is_variadic) = parse_function_parameters(parser)?;
                                                                                           ^0
  256|     18|            parser.expect(TokenKind::RightParen)?; // Consume ')'
                                                              ^0
  257|     18|            current_base = ParsedDeclarator::Function {
  258|     18|                inner: Box::new(current_base),
  259|     18|                params: parameters,
  260|     18|                is_variadic,
  261|     18|            };
  262|       |        } else {
  263|     67|            break;
  264|       |        }
  265|       |    }
  266|       |
  267|     67|    Ok(current_base)
  268|     67|}
  269|       |
  270|       |/// Parse trailing declarators (arrays, functions, bit-fields) that follow the base declarator
  271|  2.07k|fn parse_trailing_declarators(
  272|  2.07k|    parser: &mut Parser,
  273|  2.07k|    mut current_base: ParsedDeclarator,
  274|  2.07k|) -> Result<ParsedDeclarator, ParseError> {
  275|       |    loop {
  276|  3.12k|        let current_token_span = parser.try_current_token().map_or(SourceSpan::empty(), |t| t.span);
  277|  3.12k|        if parser.accept(TokenKind::LeftBracket).is_some() {
  278|       |            // Array declarator
  279|    139|            validate_declarator_combination(&current_base, "array", current_token_span)?;
                                                                                                     ^1
  280|    138|            let array_size = parse_array_size(parser)?;
                                                                   ^0
  281|    138|            parser.expect(TokenKind::RightBracket)?; // Consume ']'
                                                                ^0
  282|    138|            current_base = ParsedDeclarator::Array(Box::new(current_base), array_size);
  283|  2.98k|        } else if parser.accept(TokenKind::LeftParen).is_some() {
  284|       |            // Function declarator
  285|    898|            validate_declarator_combination(&current_base, "function", current_token_span)?;
                                                                                                        ^2
  286|    896|            let (parameters, is_variadic) = parse_function_parameters(parser)?;
                                                                                           ^0
  287|    896|            parser.expect(TokenKind::RightParen)?; // Consume ')'
                                                              ^1
  288|    895|            current_base = ParsedDeclarator::Function {
  289|    895|                inner: Box::new(current_base),
  290|    895|                params: parameters,
  291|    895|                is_variadic,
  292|    895|            };
  293|  2.08k|        } else if parser.accept(TokenKind::Colon).is_some() {
  294|       |            // Bit-field declarator: name : width
  295|     20|            let bit_width_expr = parser.parse_expr_min()?;
                                                                      ^0
  296|     20|            current_base = ParsedDeclarator::BitField(Box::new(current_base), bit_width_expr);
  297|       |        } else {
  298|  2.06k|            break;
  299|       |        }
  300|       |    }
  301|       |
  302|  2.06k|    Ok(current_base)
  303|  2.07k|}
  304|       |
  305|       |/// Reconstruct the declarator chain by applying pointer qualifiers in reverse order
  306|  2.13k|fn reconstruct_declarator_chain(
  307|  2.13k|    declarator_chain: Vec<DeclaratorComponent>,
  308|  2.13k|    base_declarator: ParsedDeclarator,
  309|  2.13k|) -> ParsedDeclarator {
  310|  2.13k|    let mut final_declarator = base_declarator;
  311|  2.13k|    for component in declarator_chain.into_iter().rev() {
                      ^213
  312|    213|        final_declarator = match component {
  313|    213|            DeclaratorComponent::Pointer(qualifiers) => {
  314|    213|                ParsedDeclarator::Pointer(qualifiers, Some(Box::new(final_declarator)))
  315|    213|            }
  316|    213|        };
  317|    213|    }
  318|  2.13k|    final_declarator
  319|  2.13k|}
  320|       |
  321|       |/// Helper to parse function parameters
  322|    914|fn parse_function_parameters(parser: &mut Parser) -> Result<(ThinVec<ParsedParamData>, bool), ParseError> {
  323|    914|    let mut params = ThinVec::new();
  324|    914|    let mut is_variadic = false;
  325|       |
  326|    914|    if !parser.is_token(TokenKind::RightParen) {
  327|    260|        if parser.is_token(TokenKind::Void) && parser.peek_token(0).is_some_and(|t| t.kind == TokenKind::RightParen) {
                                                             ^35    ^35           ^35             ^35       ^35
  328|       |            // void parameter list (only if followed effectively by ')')
  329|     32|            parser.expect(TokenKind::Void)?;
                                                        ^0
  330|       |        } else {
  331|       |            loop {
  332|    347|                if parser.accept(TokenKind::Ellipsis).is_some() {
  333|     49|                    is_variadic = true;
  334|     49|                    break;
  335|    298|                }
  336|       |
  337|       |                // Check if we have a valid start for parameter declaration
  338|    298|                if !parser.starts_declaration() {
  339|      0|                    break;
  340|    298|                }
  341|       |
  342|    298|                let start_idx = parser.current_idx;
  343|       |
  344|       |                // Parse declaration specifiers for this parameter
  345|    298|                let specifiers_start_idx = parser.current_idx;
  346|    298|                let saved_diagnostic_count = parser.diag.diagnostics.len();
  347|       |
  348|    298|                debug!(
  349|      0|                    "parse_function_parameters: attempting to parse specifiers at position {}, token: {:?}, is_type_name: {}",
  350|       |                    start_idx,
  351|      0|                    parser.current_token_kind(),
  352|      0|                    if let Some(TokenKind::Identifier(sym)) = parser.current_token_kind() {
  353|      0|                        parser.is_type_name(sym)
  354|       |                    } else {
  355|      0|                        false
  356|       |                    }
  357|       |                );
  358|       |
  359|    298|                let specifiers = match parse_declaration_specifiers(parser) {
  360|    298|                    Ok(specifiers) => {
  361|    298|                        debug!(
  362|      0|                            "parse_function_parameters: successfully parsed specifiers, current token: {:?}",
  363|      0|                            parser.current_token_kind()
  364|       |                        );
  365|    298|                        specifiers
  366|       |                    }
  367|      0|                    Err(_e) => {
  368|       |                        // If specifier parsing fails, we might be at a position where we need
  369|       |                        // to fall back to parsing without a proper declarator
  370|      0|                        debug!(
  371|      0|                            "parse_function_parameters: specifier parsing failed at position {}, token: {:?}, error: {:?}, rolling back",
  372|       |                            parser.current_idx,
  373|      0|                            parser.current_token_kind(),
  374|       |                            _e
  375|       |                        );
  376|      0|                        parser.current_idx = specifiers_start_idx;
  377|      0|                        parser.diag.diagnostics.truncate(saved_diagnostic_count);
  378|       |
  379|       |                        // Create a simple default specifier
  380|      0|                        thin_vec![ParsedDeclSpecifier::TypeSpecifier(ParsedTypeSpecifier::Int)]
  381|       |                    }
  382|       |                };
  383|       |
  384|       |                // Try to parse declarator, but be more careful about failures
  385|    298|                let declarator = if !parser.is_token(TokenKind::Comma)
  386|    290|                    && !parser.is_token(TokenKind::RightParen)
  387|    255|                    && !parser.is_token(TokenKind::Ellipsis)
  388|       |                {
  389|       |                    // Special handling for abstract declarators in parameter context
  390|    254|                    if parser.is_token(TokenKind::LeftParen) {
  391|     17|                        debug!("parse_function_parameters: found LeftParen, trying abstract declarator parsing");
                                             ^0
  392|     17|                        let start_idx = parser.current_idx;
  393|     17|                        match parse_abstract_declarator(parser) {
  394|     17|                            Ok(abstract_decl) => {
  395|     17|                                debug!("parse_function_parameters: abstract declarator parsed successfully");
                                                     ^0
  396|     17|                                Some(abstract_decl)
  397|       |                            }
  398|      0|                            Err(e) => {
  399|      0|                                debug!(
  400|      0|                                    "parse_function_parameters: abstract declarator failed: {:?}, rolling back to {}",
  401|       |                                    e, start_idx
  402|       |                                );
  403|      0|                                parser.current_idx = start_idx;
  404|       |                                // Try regular declarator parsing as fallback
  405|      0|                                match parse_declarator(parser, None) {
  406|      0|                                    Ok(decl) => {
  407|      0|                                        debug!("parse_function_parameters: fallback declarator parsing succeeded");
  408|      0|                                        Some(decl)
  409|       |                                    }
  410|       |                                    Err(_) => {
  411|      0|                                        debug!(
  412|      0|                                            "parse_function_parameters: both abstract and regular declarator parsing failed"
  413|       |                                        );
  414|      0|                                        None
  415|       |                                    }
  416|       |                                }
  417|       |                            }
  418|       |                        }
  419|       |                    } else {
  420|       |                        // Regular declarator parsing for other cases
  421|    237|                        match parse_declarator(parser, None) {
  422|    237|                            Ok(declarator) => {
  423|    237|                                debug!(
  424|      0|                                    "parse_function_parameters: declarator parsed successfully, current token: {:?}",
  425|      0|                                    parser.current_token_kind()
  426|       |                                );
  427|    237|                                Some(declarator)
  428|       |                            }
  429|      0|                            Err(e) => {
  430|      0|                                debug!(
  431|      0|                                    "parse_function_parameters: declarator parsing failed: {:?}, current token: {:?}, position: {}",
  432|       |                                    e,
  433|      0|                                    parser.current_token_kind(),
  434|       |                                    parser.current_idx
  435|       |                                );
  436|      0|                                None
  437|       |                            }
  438|       |                        }
  439|       |                    }
  440|       |                } else {
  441|     44|                    debug!(
  442|      0|                        "parse_function_parameters: skipping declarator parsing due to comma/paren/ellipsis, token: {:?}",
  443|      0|                        parser.current_token_kind()
  444|       |                    );
  445|     44|                    None
  446|       |                };
  447|       |
  448|       |                // Calculate span for the parameter
  449|    298|                let end_span = parser
  450|    298|                    .last_token_span()
  451|    298|                    .unwrap_or_else(|| parser.current_token_span_or_empty());
                                                     ^0     ^0
  452|    298|                let start_token_span = parser.get_token_span(start_idx).unwrap_or_default();
  453|    298|                let span = start_token_span.merge(end_span);
  454|       |
  455|    298|                params.push(ParsedParamData {
  456|    298|                    specifiers,
  457|    298|                    declarator,
  458|    298|                    span,
  459|    298|                });
  460|       |
  461|    298|                debug!(
  462|      0|                    "parse_function_parameters: pushed parameter, current token: {:?}, position: {}",
  463|      0|                    parser.current_token_kind(),
  464|       |                    parser.current_idx
  465|       |                );
  466|       |
  467|    298|                if parser.accept(TokenKind::Comma).is_none() {
  468|    179|                    debug!(
  469|      0|                        "parse_function_parameters: no comma found, breaking from parameter loop. Current token: {:?}, position: {}",
  470|      0|                        parser.current_token_kind(),
  471|       |                        parser.current_idx
  472|       |                    );
  473|    179|                    break;
  474|    119|                }
  475|    119|                debug!("parse_function_parameters: found comma, continuing to next parameter");
                                     ^0
  476|       |
  477|       |                // After consuming comma, verify we're in a good state to continue
  478|    119|                if parser.is_token(TokenKind::RightParen) {
  479|      0|                    debug!("parse_function_parameters: found unexpected right paren after comma, breaking");
  480|      0|                    break;
  481|    119|                }
  482|       |            }
  483|       |        }
  484|    654|    }
  485|       |
  486|    914|    Ok((params, is_variadic))
  487|    914|}
  488|       |
  489|       |/// Check if current token starts an abstract declarator
  490|    240|pub(crate) fn is_abstract_declarator_start(parser: &Parser) -> bool {
  491|    240|    if let Some(token) = parser.try_current_token() {
  492|    240|        match token.kind {
  493|     24|            TokenKind::Star => true,        // pointer
  494|      7|            TokenKind::LeftParen => true,   // parenthesized abstract declarator
  495|      4|            TokenKind::LeftBracket => true, // array
  496|    205|            _ => false,
  497|       |        }
  498|       |    } else {
  499|      0|        false
  500|       |    }
  501|    240|}
  502|       |
  503|       |/// Extract the declared name from a declarator, if any
  504|     67|pub(crate) fn get_declarator_name(declarator: &ParsedDeclarator) -> Option<NameId> {
  505|      5|    match declarator {
  506|     54|        ParsedDeclarator::Identifier(name, _) => Some(*name),
  507|      5|        ParsedDeclarator::Pointer(_, Some(inner)) => get_declarator_name(inner),
  508|      2|        ParsedDeclarator::Array(inner, _) => get_declarator_name(inner),
  509|      6|        ParsedDeclarator::Function { inner, .. } => get_declarator_name(inner),
  510|      0|        ParsedDeclarator::BitField(inner, _) => get_declarator_name(inner),
  511|      0|        ParsedDeclarator::AnonymousRecord(_, _) => None,
  512|      0|        ParsedDeclarator::Abstract => None,
  513|      0|        ParsedDeclarator::Pointer(_, None) => None,
  514|       |    }
  515|     67|}
  516|       |
  517|       |/// Parse abstract declarator (for type names without identifiers)
  518|     67|pub(crate) fn parse_abstract_declarator(parser: &mut Parser) -> Result<ParsedDeclarator, ParseError> {
  519|     67|    debug!(
  520|      0|        "parse_abstract_declarator: starting at position {}, token {:?}",
  521|       |        parser.current_idx,
  522|      0|        parser.current_token_kind()
  523|       |    );
  524|       |
  525|       |    // Check for __attribute__ at the beginning (GCC extension)
  526|     68|    while parser.is_token(TokenKind::Attribute) {
  527|      1|        if let Err(_e) = super::declaration_core::parse_attribute(parser) {
                                 ^0
  528|      0|            debug!("parse_abstract_declarator: failed to parse __attribute__: {:?}", _e);
  529|      1|        }
  530|       |    }
  531|       |
  532|       |    // Parse leading pointers and their qualifiers
  533|     67|    let declarator_chain = parse_leading_pointers(parser)?;
                                                                       ^0
  534|       |
  535|       |    // Parse direct abstract declarator (parenthesized or array/function)
  536|     67|    let base_declarator = if let Some(token) = parser.try_current_token() {
  537|     67|        match token.kind {
  538|      7|            TokenKind::Identifier(symbol) => {
  539|      7|                if parser.is_type_name(symbol) {
  540|      0|                    parser.advance(); // consume type name
  541|       |                    // Check if next is identifier for named abstract declarator
  542|      0|                    if let Some(next_token) = parser.try_current_token() {
  543|      0|                        if let TokenKind::Identifier(name) = next_token.kind {
  544|      0|                            parser.advance(); // consume identifier
  545|      0|                            ParsedDeclarator::Identifier(name, TypeQualifiers::empty())
  546|       |                        } else {
  547|      0|                            ParsedDeclarator::Abstract
  548|       |                        }
  549|       |                    } else {
  550|      0|                        ParsedDeclarator::Abstract
  551|       |                    }
  552|       |                } else {
  553|      7|                    parser.advance(); // consume invalid identifier
  554|      7|                    ParsedDeclarator::Abstract
  555|       |                }
  556|       |            }
  557|       |            TokenKind::Int => {
  558|      0|                parser.advance(); // consume int
  559|       |                // Check if next is identifier
  560|      0|                if let Some(next_token) = parser.try_current_token() {
  561|      0|                    if let TokenKind::Identifier(name) = next_token.kind {
  562|      0|                        parser.advance(); // consume identifier
  563|      0|                        ParsedDeclarator::Identifier(name, TypeQualifiers::empty())
  564|       |                    } else {
  565|      0|                        ParsedDeclarator::Abstract
  566|       |                    }
  567|       |                } else {
  568|      0|                    ParsedDeclarator::Abstract
  569|       |                }
  570|       |            }
  571|       |            TokenKind::LeftParen => {
  572|     24|                debug!("parse_abstract_declarator: found LeftParen");
                                     ^0
  573|       |
  574|       |                // Check if this is likely a function parameter list start, e.g. `(int...)` or `(char...)`
  575|       |                // If so, we treat it as a function declarator applied to an empty abstract declarator,
  576|       |                // instead of consuming the paren as a parenthesized declarator.
  577|       |                // We also check for `()` which is an empty parameter list.
  578|     24|                let is_param_list_start = if let Some(next_token) = parser.peek_token(0) {
  579|     24|                    if next_token.kind == TokenKind::Attribute {
  580|       |                        // Disambiguate between `(ATTR *)` (parenthesized declarator) and `(ATTR int)` (param list).
  581|       |                        // If Attribute is followed by *, it's likely a parenthesized declarator.
  582|      2|                        if let Some(after_attr) = peek_past_attribute(parser, 0) {
  583|      2|                            after_attr.kind != TokenKind::Star
  584|       |                        } else {
  585|       |                            // Fallback if attribute syntax is weird
  586|      0|                            true
  587|       |                        }
  588|       |                    } else {
  589|     22|                        parser.is_type_name_start_token(next_token) || next_token.kind == TokenKind::RightParen
                                                                                     ^16
  590|       |                    }
  591|       |                } else {
  592|      0|                    false
  593|       |                };
  594|       |
  595|     24|                if is_param_list_start {
  596|       |                    // It's a suffix, e.g. `(int)` in `int (int)`.
  597|       |                    // We return Abstract so the trailing declarator parser picks it up as a function declarator.
  598|      9|                    ParsedDeclarator::Abstract
  599|       |                } else {
  600|     15|                    parser.advance(); // Consume '('
  601|     15|                    if parser.accept(TokenKind::RightParen).is_some() {
  602|       |                        // This case is actually covered by is_param_list_start above,
  603|       |                        // but if we somehow got here (maybe peek failed?), handle it.
  604|       |                        // Although if peek failed, we probably hit EOF soon.
  605|      0|                        ParsedDeclarator::Function {
  606|      0|                            inner: Box::new(ParsedDeclarator::Abstract),
  607|      0|                            params: ThinVec::new(),
  608|      0|                            is_variadic: false,
  609|      0|                        }
  610|       |                    } else {
  611|     15|                        let start_idx = parser.current_idx;
  612|     15|                        let inner_declarator = parse_abstract_declarator(parser)?;
                                                                                              ^0
  613|     15|                        debug!(
  614|      0|                            "parse_abstract_declarator: inner declarator parsed, current token: {:?}",
  615|      0|                            parser.current_token_kind()
  616|       |                        );
  617|     15|                        if parser.accept(TokenKind::RightParen).is_some() {
  618|     15|                            inner_declarator
  619|       |                        } else {
  620|       |                            // Check if we're dealing with a function parameter syntax like "int (int)"
  621|       |                            // In this case, the closing paren might be part of the parameter list context
  622|      0|                            debug!(
  623|      0|                                "parse_abstract_declarator: expected RightParen but found {:?}, position: {}",
  624|      0|                                parser.current_token_kind(),
  625|       |                                parser.current_idx
  626|       |                            );
  627|       |                            // Try to parse as function declarator if we see another LeftParen
  628|      0|                            if parser.accept(TokenKind::LeftParen).is_some() {
  629|      0|                                debug!(
  630|      0|                                    "parse_abstract_declarator: found another LeftParen, treating as function declarator"
  631|       |                                );
  632|      0|                                let (parameters, is_variadic) = parse_function_parameters(parser)?;
  633|      0|                                parser.expect(TokenKind::RightParen)?; // Consume ')'
  634|      0|                                ParsedDeclarator::Function {
  635|      0|                                    inner: Box::new(inner_declarator),
  636|      0|                                    params: parameters,
  637|      0|                                    is_variadic,
  638|      0|                                }
  639|       |                            } else {
  640|       |                                // Roll back and try a different approach
  641|      0|                                parser.current_idx = start_idx;
  642|      0|                                ParsedDeclarator::Abstract
  643|       |                            }
  644|       |                        }
  645|       |                    }
  646|       |                }
  647|       |            }
  648|       |            TokenKind::LeftBracket => {
  649|      7|                parser.advance(); // Consume '['
  650|      7|                let array_size = parse_array_size(parser)?;
                                                                       ^0
  651|      7|                parser.expect(TokenKind::RightBracket)?; // Consume ']'
                                                                    ^0
  652|      7|                ParsedDeclarator::Array(Box::new(ParsedDeclarator::Abstract), array_size)
  653|       |            }
  654|       |            TokenKind::Star => {
  655|      0|                parser.advance(); // Consume '*'
  656|      0|                let qualifiers = parse_type_qualifiers(parser)?;
  657|      0|                ParsedDeclarator::Pointer(qualifiers, Some(Box::new(ParsedDeclarator::Abstract)))
  658|       |            }
  659|       |            _ => {
  660|       |                // invalid token, don't consume
  661|     29|                ParsedDeclarator::Abstract
  662|       |            }
  663|       |        }
  664|       |    } else {
  665|      0|        ParsedDeclarator::Abstract
  666|       |    };
  667|       |
  668|     67|    debug!(
  669|      0|        "parse_abstract_declarator: base_declarator parsed, current token {:?}",
  670|      0|        parser.current_token_kind()
  671|       |    );
  672|       |
  673|       |    // Parse trailing array and function declarators
  674|     67|    let current_base = parse_trailing_declarators_for_type_names(parser, base_declarator)?;
                                                                                                       ^0
  675|       |
  676|       |    // Reconstruct the declarator chain in reverse order
  677|     67|    let final_declarator = reconstruct_declarator_chain(declarator_chain, current_base);
  678|       |
  679|     67|    Ok(final_declarator)
  680|     67|}

/app/src/parser/enum_parsing.rs:
    1|       |//! Enum parsing module
    2|       |//!
    3|       |//! This module handles parsing of enum declarations and enumerators.
    4|       |
    5|       |use crate::ast::*;
    6|       |use crate::diagnostic::ParseError;
    7|       |use crate::parser::TokenKind;
    8|       |
    9|       |use super::Parser;
   10|       |
   11|       |/// Parse enum specifier
   12|     26|pub(crate) fn parse_enum_specifier(parser: &mut Parser) -> Result<ParsedTypeSpecifier, ParseError> {
   13|     26|    let tag = parser.accept_name();
   14|     26|    let enumerators = if parser.accept(TokenKind::LeftBrace).is_some() {
   15|     18|        let enums = parse_enumerator_list(parser)?;
                                                               ^0
   16|     18|        parser.expect(TokenKind::RightBrace)?;
                                                          ^0
   17|     18|        Some(enums)
   18|       |    } else {
   19|      8|        None
   20|       |    };
   21|       |
   22|     26|    Ok(ParsedTypeSpecifier::Enum(tag, enumerators))
   23|     26|}
   24|       |
   25|       |/// Parse enumerator list
   26|     18|fn parse_enumerator_list(parser: &mut Parser) -> Result<Vec<ParsedNodeRef>, ParseError> {
   27|     18|    let mut enumerators = Vec::new();
   28|       |
   29|       |    loop {
   30|     38|        let enumerator = parse_enumerator(parser)?;
                                                               ^0
   31|     38|        enumerators.push(enumerator);
   32|       |
   33|     38|        if !parser.is_token(TokenKind::Comma) {
   34|     18|            break;
   35|     20|        }
   36|     20|        parser.advance(); // consume comma
   37|       |
   38|       |        // Allow trailing comma
   39|     20|        if parser.is_token(TokenKind::RightBrace) {
   40|      0|            break;
   41|     20|        }
   42|       |    }
   43|       |
   44|     18|    Ok(enumerators)
   45|     18|}
   46|       |
   47|       |/// Parse enumerator
   48|     38|fn parse_enumerator(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
   49|     38|    let (name, mut span) = parser.expect_name()?;
                                                             ^0
   50|     38|    let value = if parser.accept(TokenKind::Assign).is_some() {
   51|     16|        let expr = parser.parse_expr_assignment()?;
                                                               ^0
   52|     16|        span = SourceSpan::new(span.start(), parser.ast.get_node(expr).span.end());
   53|     16|        Some(expr)
   54|       |    } else {
   55|     22|        None
   56|       |    };
   57|       |
   58|     38|    let node = parser.push_node(ParsedNodeKind::EnumConstant(name, value), span);
   59|     38|    Ok(node)
   60|     38|}

/app/src/parser/expressions.rs:
    1|       |//! Expression parsing module
    2|       |//!
    3|       |//! This module handles all expression parsing logic, including the Pratt parser
    4|       |//! implementation for operator precedence and associativity.
    5|       |
    6|       |use crate::ast::{parsed::*, *};
    7|       |use crate::diagnostic::ParseError;
    8|       |use crate::parser::{Token, TokenKind};
    9|       |use crate::source_manager::{SourceLoc, SourceSpan};
   10|       |use log::{debug, trace};
   11|       |
   12|       |use super::Parser;
   13|       |
   14|       |/// Binding power for Pratt parser operator precedence
   15|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
   16|       |pub(crate) struct BindingPower(u8);
   17|       |
   18|       |impl BindingPower {
   19|       |    pub(crate) const MIN: Self = Self(0);
   20|       |    pub const COMMA: Self = Self(2);
   21|       |    pub const ASSIGNMENT: Self = Self(4);
   22|       |    pub const CONDITIONAL: Self = Self(6);
   23|       |    pub const LOGICAL_OR: Self = Self(8);
   24|       |    pub const LOGICAL_AND: Self = Self(10);
   25|       |    pub const BITWISE_OR: Self = Self(12);
   26|       |    pub const BITWISE_XOR: Self = Self(14);
   27|       |    pub const BITWISE_AND: Self = Self(16);
   28|       |    pub const EQUALITY: Self = Self(18);
   29|       |    pub const RELATIONAL: Self = Self(20);
   30|       |    pub const SHIFT: Self = Self(22);
   31|       |    pub const ADDITIVE: Self = Self(24);
   32|       |    pub const MULTIPLICATIVE: Self = Self(26);
   33|       |    pub const CAST: Self = Self(28);
   34|       |    pub const UNARY: Self = Self(30);
   35|       |    pub const POSTFIX: Self = Self(32);
   36|       |    // pub const PRIMARY: Self = Self(34);
   37|       |}
   38|       |
   39|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   40|       |pub(crate) enum Associativity {
   41|       |    Left,
   42|       |    Right,
   43|       |}
   44|       |
   45|       |/// Pratt parser implementation
   46|       |pub(crate) struct PrattParser;
   47|       |
   48|       |impl PrattParser {
   49|  3.15k|    fn get_binding_power(token_kind: TokenKind) -> Option<(BindingPower, Associativity)> {
   50|  3.15k|        match token_kind {
   51|       |            // Assignment operators (right-associative)
   52|       |            TokenKind::Assign
   53|       |            | TokenKind::PlusAssign
   54|       |            | TokenKind::MinusAssign
   55|       |            | TokenKind::StarAssign
   56|       |            | TokenKind::DivAssign
   57|       |            | TokenKind::ModAssign
   58|       |            | TokenKind::AndAssign
   59|       |            | TokenKind::OrAssign
   60|       |            | TokenKind::XorAssign
   61|       |            | TokenKind::LeftShiftAssign
   62|    134|            | TokenKind::RightShiftAssign => Some((BindingPower::ASSIGNMENT, Associativity::Right)),
   63|       |
   64|       |            // Comma operator (left-associative, lowest precedence)
   65|    431|            TokenKind::Comma => Some((BindingPower::COMMA, Associativity::Left)),
   66|       |
   67|       |            // Conditional operator (right-associative)
   68|     13|            TokenKind::Question => Some((BindingPower::CONDITIONAL, Associativity::Right)),
   69|       |
   70|       |            // Logical operators (left-associative)
   71|     22|            TokenKind::LogicOr => Some((BindingPower::LOGICAL_OR, Associativity::Left)),
   72|     24|            TokenKind::LogicAnd => Some((BindingPower::LOGICAL_AND, Associativity::Left)),
   73|       |
   74|       |            // Bitwise operators (left-associative)
   75|      1|            TokenKind::Or => Some((BindingPower::BITWISE_OR, Associativity::Left)),
   76|      1|            TokenKind::Xor => Some((BindingPower::BITWISE_XOR, Associativity::Left)),
   77|      2|            TokenKind::And => Some((BindingPower::BITWISE_AND, Associativity::Left)),
   78|       |
   79|       |            // Comparison operators (left-associative)
   80|     91|            TokenKind::Equal | TokenKind::NotEqual => Some((BindingPower::EQUALITY, Associativity::Left)),
   81|       |            TokenKind::Less | TokenKind::Greater | TokenKind::LessEqual | TokenKind::GreaterEqual => {
   82|     28|                Some((BindingPower::RELATIONAL, Associativity::Left))
   83|       |            }
   84|       |
   85|       |            // Shift operators (left-associative)
   86|      2|            TokenKind::LeftShift | TokenKind::RightShift => Some((BindingPower::SHIFT, Associativity::Left)),
   87|       |
   88|       |            // Additive operators (left-associative)
   89|     92|            TokenKind::Plus | TokenKind::Minus => Some((BindingPower::ADDITIVE, Associativity::Left)),
   90|       |
   91|       |            // Multiplicative operators (left-associative)
   92|       |            TokenKind::Star | TokenKind::Slash | TokenKind::Percent => {
   93|     30|                Some((BindingPower::MULTIPLICATIVE, Associativity::Left))
   94|       |            }
   95|       |
   96|       |            // Postfix operators
   97|       |            TokenKind::Increment
   98|       |            | TokenKind::Decrement
   99|       |            | TokenKind::LeftParen
  100|       |            | TokenKind::LeftBracket
  101|       |            | TokenKind::Dot
  102|    308|            | TokenKind::Arrow => Some((BindingPower::POSTFIX, Associativity::Left)),
  103|       |
  104|  1.98k|            _ => None,
  105|       |        }
  106|  3.15k|    }
  107|       |}
  108|       |
  109|       |/// Main expression parsing using Pratt algorithm
  110|  2.46k|pub(crate) fn parse_expression(
  111|  2.46k|    parser: &mut Parser,
  112|  2.46k|    min_binding_power: BindingPower,
  113|  2.46k|) -> Result<ParsedNodeRef, ParseError> {
  114|  2.46k|    trace!("parse_expression: min_binding_power={}", min_binding_power.0);
                         ^0
  115|  2.46k|    let mut left = parse_prefix(parser)?;
                      ^2.45k                         ^2
  116|       |
  117|  3.15k|    while let Some(current_token) = parser.try_current_token() {
  118|  3.15k|        debug!(
  119|      0|            "parse_expression: loop iteration, current token {:?}, min_binding_power={}",
  120|       |            current_token.kind, min_binding_power.0
  121|       |        );
  122|       |
  123|  3.15k|        let Some((binding_power, associativity)) = PrattParser::get_binding_power(current_token.kind) else {
                                ^1.17k         ^1.17k
  124|  1.98k|            debug!(
  125|      0|                "parse_expression: no binding power for {:?}, breaking",
  126|       |                current_token.kind
  127|       |            );
  128|  1.98k|            break;
  129|       |        };
  130|       |
  131|  1.17k|        let should_break = match associativity {
  132|  1.03k|            Associativity::Left => binding_power <= min_binding_power,
  133|    147|            Associativity::Right => binding_power < min_binding_power,
  134|       |        };
  135|       |
  136|  1.17k|        if should_break {
  137|    479|            debug!(
  138|      0|                "parse_expression: binding power {:?} should break at min {:?} (assoc {:?}), breaking",
  139|       |                binding_power.0, min_binding_power.0, associativity
  140|       |            );
  141|    479|            break;
  142|    700|        }
  143|       |
  144|    700|        let op_token = current_token;
  145|    700|        parser.advance(); // Consume the operator token
  146|       |
  147|       |        // Dispatch to the correct parsing function based on the operator kind
  148|    700|        left = match op_token.kind {
  149|       |            // Postfix operators are handled here directly
  150|     16|            TokenKind::Increment => parse_postfix_increment(parser, left, op_token)?,
                                                                                                 ^0
  151|      7|            TokenKind::Decrement => parse_postfix_decrement(parser, left, op_token)?,
                                                                                                 ^0
  152|    107|            TokenKind::LeftParen => parse_function_call(parser, left)?,
                                                                                   ^0
  153|     51|            TokenKind::LeftBracket => parse_index_access(parser, left)?,
                                                                                    ^0
  154|    110|            TokenKind::Dot => parse_member_access(parser, left, false)?,
                                                                                    ^0
  155|     17|            TokenKind::Arrow => parse_member_access(parser, left, true)?,
                                                                                     ^0
  156|       |
  157|       |            // Ternary operator is a special case
  158|       |            TokenKind::Question => {
  159|       |                // The middle operand is an `expression`, which allows assignment.
  160|       |                // C11: logical-OR-expression ? expression : conditional-expression
  161|     12|                let true_expr = parser.parse_expr_assignment()?;
                                                                            ^0
  162|     12|                parser.expect(TokenKind::Colon)?;
                                                             ^0
  163|       |                // The third operand is a `conditional-expression`, which has higher precedence.
  164|     12|                let false_expr = parser.parse_expr_bp(BindingPower::CONDITIONAL)?;
                                                                                              ^0
  165|       |
  166|     12|                let span = SourceSpan::new(
  167|     12|                    parser.ast.get_node(left).span.start(),
  168|     12|                    parser.ast.get_node(false_expr).span.end(),
  169|       |                );
  170|     12|                parser.push_node(ParsedNodeKind::TernaryOp(left, true_expr, false_expr), span)
  171|       |            }
  172|       |
  173|       |            // All other operators are binary/infix
  174|       |            _ => {
  175|    380|                let next_min_bp = if associativity == Associativity::Left {
  176|    252|                    BindingPower(binding_power.0 + 1)
  177|       |                } else {
  178|    128|                    binding_power
  179|       |                };
  180|    380|                parse_infix(parser, left, op_token, next_min_bp)?
                                                                              ^0
  181|       |            }
  182|       |        };
  183|       |    }
  184|       |
  185|  2.45k|    Ok(left)
  186|  2.46k|}
  187|       |
  188|       |/// Parse prefix expression
  189|  2.46k|fn parse_prefix(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  190|  2.46k|    let token = parser.current_token()?;
                                                    ^0
  191|       |
  192|  2.46k|    debug!("parse_prefix: token={:?} at {}", token.kind, token.span);
                         ^0
  193|  2.46k|    match token.kind {
  194|    767|        TokenKind::Identifier(symbol) => {
  195|    767|            parser.advance();
  196|    767|            debug!("parse_prefix: parsed identifier {:?}", symbol);
                                 ^0
  197|    767|            let node = parser.push_node(ParsedNodeKind::Ident(symbol), token.span);
  198|    767|            Ok(node)
  199|       |        }
  200|  1.18k|        TokenKind::IntegerConstant(val, suffix) => {
  201|  1.18k|            parser.advance();
  202|  1.18k|            let node = parser.push_node(
  203|  1.18k|                ParsedNodeKind::Literal(literal::Literal::Int { val, suffix }),
  204|  1.18k|                token.span,
  205|       |            );
  206|  1.18k|            Ok(node)
  207|       |        }
  208|     35|        TokenKind::FloatConstant(val, suffix) => {
  209|     35|            parser.advance();
  210|     35|            let node = parser.push_node(
  211|     35|                ParsedNodeKind::Literal(literal::Literal::Float { val, suffix }),
  212|     35|                token.span,
  213|       |            );
  214|     35|            Ok(node)
  215|       |        }
  216|     85|        TokenKind::StringLiteral(s) => {
  217|     85|            parser.advance();
  218|     85|            let node = parser.push_node(ParsedNodeKind::Literal(literal::Literal::String(s)), token.span);
  219|     85|            Ok(node)
  220|       |        }
  221|     14|        TokenKind::CharacterConstant(c) => {
  222|     14|            parser.advance();
  223|     14|            let node = parser.push_node(ParsedNodeKind::Literal(literal::Literal::Char(c)), token.span);
  224|     14|            Ok(node)
  225|       |        }
  226|       |        TokenKind::LeftParen => {
  227|     94|            let left_paren_token = token; // Save the opening paren token for span calculation
  228|     94|            parser.advance();
  229|       |            // Check if this is a cast expression or compound literal by looking ahead for a type name
  230|     94|            if parser.is_cast_expression_start() {
  231|       |                // Parse the type name
  232|     39|                let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                  ^38                                                                     ^1
  233|       |                // Expect closing parenthesis
  234|     38|                parser.expect(TokenKind::RightParen)?;
                                                                  ^0
  235|       |
  236|       |                // Check if this is a compound literal (next token is '{')
  237|     38|                if parser.is_token(TokenKind::LeftBrace) {
  238|       |                    // This is a compound literal: (type-name){initializer}
  239|     12|                    parser.parse_compound_literal_from_type_and_start(parsed_type, left_paren_token.span.start())
  240|       |                } else {
  241|       |                    // This is a cast expression: (type-name)expression
  242|     26|                    let dummy_right_paren = Token {
  243|     26|                        kind: TokenKind::RightParen,
  244|     26|                        span: SourceSpan::new(left_paren_token.span.end(), left_paren_token.span.end()),
  245|     26|                    };
  246|     26|                    parser.parse_cast_expression_from_type_and_paren(parsed_type, dummy_right_paren)
  247|       |                }
  248|     55|            } else if parser.is_token(TokenKind::LeftBrace) {
  249|       |                // This is a GNU statement expression: ({ ... })
  250|      5|                parse_gnu_statement_expression(parser, left_paren_token.span.start())
  251|       |            } else {
  252|       |                // Regular parenthesized expression
  253|     50|                let expr = parser.parse_expr_min()?;
                                                                ^0
  254|     50|                parser.expect(TokenKind::RightParen)?;
                                                                  ^0
  255|     50|                Ok(expr)
  256|       |            }
  257|       |        }
  258|       |        TokenKind::Plus
  259|       |        | TokenKind::Minus
  260|       |        | TokenKind::Not
  261|       |        | TokenKind::Tilde
  262|       |        | TokenKind::Increment
  263|       |        | TokenKind::Decrement
  264|       |        | TokenKind::Star
  265|       |        | TokenKind::And
  266|       |        | TokenKind::Real
  267|    113|        | TokenKind::Imag => parse_unary_operator(parser, token),
  268|     58|        TokenKind::Generic => parse_generic_selection(parser),
  269|      7|        TokenKind::Alignof => parse_alignof(parser),
  270|       |        TokenKind::Sizeof => {
  271|     57|            debug!(
  272|      0|                "parse_prefix: parsing sizeof expression at position {}",
  273|       |                parser.current_idx
  274|       |            );
  275|     57|            parse_sizeof(parser)
  276|       |        }
  277|      8|        TokenKind::BuiltinVaArg => parse_builtin_va_arg(parser),
  278|      5|        TokenKind::BuiltinVaStart => parse_builtin_va_start(parser),
  279|      3|        TokenKind::BuiltinVaEnd => parse_builtin_va_end(parser),
  280|      1|        TokenKind::BuiltinVaCopy => parse_builtin_va_copy(parser),
  281|      3|        TokenKind::BuiltinExpect => parse_builtin_expect(parser),
  282|     13|        TokenKind::BuiltinOffsetof => parse_builtin_offsetof(parser),
  283|      4|        TokenKind::BuiltinAtomicLoadN => parse_atomic_op(parser, AtomicOp::LoadN),
  284|      1|        TokenKind::BuiltinAtomicStoreN => parse_atomic_op(parser, AtomicOp::StoreN),
  285|      1|        TokenKind::BuiltinAtomicExchangeN => parse_atomic_op(parser, AtomicOp::ExchangeN),
  286|      2|        TokenKind::BuiltinAtomicCompareExchangeN => parse_atomic_op(parser, AtomicOp::CompareExchangeN),
  287|      1|        TokenKind::BuiltinAtomicFetchAdd => parse_atomic_op(parser, AtomicOp::FetchAdd),
  288|      1|        TokenKind::BuiltinAtomicFetchSub => parse_atomic_op(parser, AtomicOp::FetchSub),
  289|      2|        TokenKind::BuiltinAtomicFetchAnd => parse_atomic_op(parser, AtomicOp::FetchAnd),
  290|      1|        TokenKind::BuiltinAtomicFetchOr => parse_atomic_op(parser, AtomicOp::FetchOr),
  291|      1|        TokenKind::BuiltinAtomicFetchXor => parse_atomic_op(parser, AtomicOp::FetchXor),
  292|       |        _ => {
  293|      0|            let expected = "identifier, integer, float, string, char, or '('";
  294|      0|            Err(ParseError::UnexpectedToken {
  295|      0|                expected_tokens: expected.to_string(),
  296|      0|                found: token.kind,
  297|      0|                span: token.span,
  298|      0|            })
  299|       |        }
  300|       |    }
  301|  2.46k|}
  302|       |
  303|       |/// Parse unary operator
  304|    113|fn parse_unary_operator(parser: &mut Parser, token: Token) -> Result<ParsedNodeRef, ParseError> {
  305|    113|    let op = match token.kind {
  306|      9|        TokenKind::Plus => UnaryOp::Plus,
  307|     20|        TokenKind::Minus => UnaryOp::Minus,
  308|     20|        TokenKind::Not => UnaryOp::LogicNot,
  309|      7|        TokenKind::Tilde => UnaryOp::BitNot,
  310|      4|        TokenKind::Increment => UnaryOp::PreIncrement,
  311|      2|        TokenKind::Decrement => UnaryOp::PreDecrement,
  312|     11|        TokenKind::Star => UnaryOp::Deref,
  313|     36|        TokenKind::And => UnaryOp::AddrOf,
  314|      2|        TokenKind::Real => UnaryOp::Real,
  315|      2|        TokenKind::Imag => UnaryOp::Imag,
  316|       |        _ => {
  317|      0|            return Err(ParseError::InvalidUnaryOperator { span: token.span });
  318|       |        }
  319|       |    };
  320|       |
  321|    113|    parser.advance();
  322|    113|    let operand_node = parser.parse_expr_bp(BindingPower::UNARY)?;
                                                                              ^0
  323|    113|    let span = SourceSpan::new(token.span.start(), parser.ast.get_node(operand_node).span.end());
  324|    113|    let node = parser.push_node(ParsedNodeKind::UnaryOp(op, operand_node), span);
  325|    113|    Ok(node)
  326|    113|}
  327|       |
  328|       |/// Parse infix operator
  329|    380|fn parse_infix(
  330|    380|    parser: &mut Parser,
  331|    380|    left: ParsedNodeRef,
  332|    380|    operator_token: Token,
  333|    380|    min_bp: BindingPower,
  334|    380|) -> Result<ParsedNodeRef, ParseError> {
  335|    380|    debug!(
  336|      0|        "parse_infix: processing operator {:?} at {}",
  337|       |        operator_token.kind, operator_token.span
  338|       |    );
  339|       |
  340|       |    // For all binary operators, parse the right operand
  341|    380|    let right_node = parser.parse_expression(min_bp)?;
                                                                  ^0
  342|       |
  343|    380|    let op = match operator_token.kind {
  344|     56|        TokenKind::Plus => BinaryOp::Add,
  345|     22|        TokenKind::Minus => BinaryOp::Sub,
  346|     17|        TokenKind::Star => BinaryOp::Mul,
  347|      9|        TokenKind::Slash => BinaryOp::Div,
  348|      3|        TokenKind::Percent => BinaryOp::Mod,
  349|     26|        TokenKind::Equal => BinaryOp::Equal,
  350|     57|        TokenKind::NotEqual => BinaryOp::NotEqual,
  351|     14|        TokenKind::Less => BinaryOp::Less,
  352|      7|        TokenKind::Greater => BinaryOp::Greater,
  353|      2|        TokenKind::LessEqual => BinaryOp::LessEqual,
  354|      2|        TokenKind::GreaterEqual => BinaryOp::GreaterEqual,
  355|      2|        TokenKind::And => BinaryOp::BitAnd,
  356|      1|        TokenKind::Or => BinaryOp::BitOr,
  357|      1|        TokenKind::Xor => BinaryOp::BitXor,
  358|      1|        TokenKind::LeftShift => BinaryOp::LShift,
  359|      1|        TokenKind::RightShift => BinaryOp::RShift,
  360|     12|        TokenKind::LogicAnd => BinaryOp::LogicAnd,
  361|     13|        TokenKind::LogicOr => BinaryOp::LogicOr,
  362|    116|        TokenKind::Assign => BinaryOp::Assign,
  363|      5|        TokenKind::PlusAssign => BinaryOp::AssignAdd,
  364|      4|        TokenKind::MinusAssign => BinaryOp::AssignSub,
  365|      1|        TokenKind::StarAssign => BinaryOp::AssignMul,
  366|      1|        TokenKind::DivAssign => BinaryOp::AssignDiv,
  367|      1|        TokenKind::ModAssign => BinaryOp::AssignMod,
  368|      0|        TokenKind::AndAssign => BinaryOp::AssignBitAnd,
  369|      0|        TokenKind::OrAssign => BinaryOp::AssignBitOr,
  370|      0|        TokenKind::XorAssign => BinaryOp::AssignBitXor,
  371|      0|        TokenKind::LeftShiftAssign => BinaryOp::AssignLShift,
  372|      0|        TokenKind::RightShiftAssign => BinaryOp::AssignRShift,
  373|      6|        TokenKind::Comma => BinaryOp::Comma,
  374|       |        // Postfix operators are handled in `parse_expression` and should not reach here.
  375|       |        _ => {
  376|      0|            return Err(ParseError::UnexpectedToken {
  377|      0|                expected_tokens: "binary operator".to_string(),
  378|      0|                found: operator_token.kind,
  379|      0|                span: operator_token.span,
  380|      0|            });
  381|       |        }
  382|       |    };
  383|       |
  384|    380|    let span = SourceSpan::new(
  385|    380|        parser.ast.get_node(left).span.start(),
  386|    380|        parser.ast.get_node(right_node).span.end(),
  387|       |    );
  388|       |
  389|    380|    let node = if op.is_assignment() {
  390|    128|        parser.push_node(ParsedNodeKind::Assignment(op, left, right_node), span)
  391|       |    } else {
  392|    252|        parser.push_node(ParsedNodeKind::BinaryOp(op, left, right_node), span)
  393|       |    };
  394|    380|    Ok(node)
  395|    380|}
  396|       |
  397|       |/// Parse GNU statement expression: ({ compound-statement })
  398|      5|fn parse_gnu_statement_expression(parser: &mut Parser, start_loc: SourceLoc) -> Result<ParsedNodeRef, ParseError> {
  399|      5|    debug!("parse_gnu_statement_expression: parsing GNU statement expression");
                         ^0
  400|       |
  401|       |    // Parse the compound statement (parse_compound_statement expects LeftBrace)
  402|      5|    let (compound_stmt, _) = super::statements::parse_compound_statement(parser)?;
                                                                                              ^0
  403|       |
  404|       |    // Expect the closing parenthesis
  405|      5|    let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                              ^0
  406|       |
  407|       |    // For GNU statement expressions, the result is the last expression in the compound statement
  408|       |    // We need to extract it from the compound statement
  409|      5|    let result_expr = extract_last_expression_from_compound_statement(parser, compound_stmt);
  410|       |
  411|      5|    let end_loc = right_paren_token.span.end();
  412|      5|    let span = SourceSpan::new(start_loc, end_loc);
  413|       |
  414|      5|    let node = parser.push_node(ParsedNodeKind::GnuStatementExpression(compound_stmt, result_expr), span);
  415|      5|    debug!("parse_gnu_statement_expression: successfully parsed GNU statement expression");
                         ^0
  416|      5|    Ok(node)
  417|      5|}
  418|       |
  419|       |/// Extract the last expression from a compound statement for GNU statement expressions
  420|      5|fn extract_last_expression_from_compound_statement(
  421|      5|    parser: &mut Parser,
  422|      5|    compound_stmt_node_ref: ParsedNodeRef,
  423|      5|) -> ParsedNodeRef {
  424|       |    // Get the compound statement node
  425|      5|    let compound_stmt_node = parser.ast.get_node(compound_stmt_node_ref);
  426|       |
  427|      5|    if let ParsedNodeKind::CompoundStatement(statements) = &compound_stmt_node.kind {
  428|       |        // Find the last expression statement in the compound statement
  429|      7|        for &stmt_ref in statements.iter().rev() {
                                       ^5                ^5
  430|      7|            let stmt_node = parser.ast.get_node(stmt_ref);
  431|      4|            if let ParsedNodeKind::ExpressionStatement(Some(expr)) = &stmt_node.kind {
  432|      4|                return *expr;
  433|      3|            }
  434|       |        }
  435|       |
  436|       |        // If no expression statement found, create a dummy expression
  437|       |        // This shouldn't happen in valid GNU statement expressions
  438|      1|        let dummy_expr = parser.push_node(ParsedNodeKind::Dummy, compound_stmt_node.span);
  439|      1|        return dummy_expr;
  440|      0|    }
  441|       |
  442|       |    // Fallback: create a dummy expression
  443|      0|    parser.push_node(ParsedNodeKind::Dummy, compound_stmt_node.span)
  444|      5|}
  445|       |
  446|       |/// Parse function call
  447|    107|fn parse_function_call(parser: &mut Parser, function: ParsedNodeRef) -> Result<ParsedNodeRef, ParseError> {
  448|    107|    debug!("parse_function_call: parsing function call with LeftParen");
                         ^0
  449|       |
  450|       |    // Parse the argument list using the utility function
  451|    107|    let args = super::utils::expr_patterns::parse_expr_list(parser, BindingPower::ASSIGNMENT)?;
                                                                                                           ^0
  452|       |
  453|    107|    let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                              ^0
  454|    107|    debug!(
  455|      0|        "parse_function_call: successfully parsed function call with {} arguments",
  456|      0|        args.len()
  457|       |    );
  458|       |
  459|    107|    let span = SourceSpan::new(parser.ast.get_node(function).span.start(), right_paren_token.span.end());
  460|    107|    let node = parser.push_node(ParsedNodeKind::FunctionCall(function, args), span);
  461|    107|    Ok(node)
  462|    107|}
  463|       |
  464|       |/// Parse array index access
  465|     51|fn parse_index_access(parser: &mut Parser, array: ParsedNodeRef) -> Result<ParsedNodeRef, ParseError> {
  466|     51|    debug!("parse_index_access: parsing array index");
                         ^0
  467|       |
  468|       |    // The `[` token has already been consumed by the caller (`parse_infix`).
  469|       |    // We are now at the start of the index expression.
  470|     51|    let index_node = parser.parse_expr_min()?;
                                                          ^0
  471|       |
  472|     51|    let right_bracket_token = parser.expect(TokenKind::RightBracket)?;
                                                                                  ^0
  473|     51|    debug!(
  474|      0|        "parse_index_access: parsed closing bracket, current token now {:?}",
  475|      0|        parser.current_token_kind()
  476|       |    );
  477|       |
  478|     51|    let span = SourceSpan::new(parser.ast.get_node(array).span.start(), right_bracket_token.span.end());
  479|     51|    let node = parser.push_node(ParsedNodeKind::IndexAccess(array, index_node), span);
  480|     51|    Ok(node)
  481|     51|}
  482|       |
  483|       |/// Parse member access
  484|    127|fn parse_member_access(
  485|    127|    parser: &mut Parser,
  486|    127|    object: ParsedNodeRef,
  487|    127|    is_arrow: bool,
  488|    127|) -> Result<ParsedNodeRef, ParseError> {
  489|    127|    let (symbol, span) = parser.expect_name()?;
                                                           ^0
  490|    127|    let span = SourceSpan::new(parser.ast.get_node(object).span.start(), span.end());
  491|    127|    let node = parser.push_node(ParsedNodeKind::MemberAccess(object, symbol, is_arrow), span);
  492|    127|    Ok(node)
  493|    127|}
  494|       |
  495|       |/// Parse postfix increment
  496|     16|fn parse_postfix_increment(
  497|     16|    parser: &mut Parser,
  498|     16|    operand: ParsedNodeRef,
  499|     16|    operator_token: Token,
  500|     16|) -> Result<ParsedNodeRef, ParseError> {
  501|     16|    let span = SourceSpan::new(parser.ast.get_node(operand).span.start(), operator_token.span.end());
  502|     16|    let node = parser.push_node(ParsedNodeKind::PostIncrement(operand), span);
  503|     16|    Ok(node)
  504|     16|}
  505|       |
  506|       |/// Parse postfix decrement
  507|      7|fn parse_postfix_decrement(
  508|      7|    parser: &mut Parser,
  509|      7|    operand: ParsedNodeRef,
  510|      7|    operator_token: Token,
  511|      7|) -> Result<ParsedNodeRef, ParseError> {
  512|      7|    let span = SourceSpan::new(parser.ast.get_node(operand).span.start(), operator_token.span.end());
  513|      7|    let node = parser.push_node(ParsedNodeKind::PostDecrement(operand), span);
  514|      7|    Ok(node)
  515|      7|}
  516|       |
  517|       |/// Parse _Generic selection (C11)
  518|     58|fn parse_generic_selection(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  519|     58|    let token = parser.expect(TokenKind::Generic)?;
                                                               ^0
  520|     58|    let start_loc = token.span.start();
  521|       |
  522|     58|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  523|       |
  524|       |    // The controlling expression is an assignment-expression, so we parse with ASSIGNMENT binding power.
  525|     58|    let controlling_expr = parser.parse_expr_bp(BindingPower::ASSIGNMENT)?;
                                                                                       ^0
  526|       |
  527|     58|    parser.expect(TokenKind::Comma)?;
                                                 ^0
  528|       |
  529|       |    // Reserve slot for the generic selection node so that any nested parsing
  530|       |    // that might push nodes won't accidentally observe an unstable index.
  531|     58|    let dummy = parser.push_dummy();
  532|       |
  533|     58|    let mut associations: Vec<ParsedGenericAssociation> = Vec::new();
  534|       |
  535|       |    loop {
  536|    116|        let type_name = if parser.accept(TokenKind::Default).is_some() {
                          ^115
  537|     46|            None
  538|       |        } else {
  539|     70|            let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                              ^69                                                                     ^1
  540|     69|            Some(parsed_type)
  541|       |        };
  542|       |
  543|    115|        parser.expect(TokenKind::Colon)?;
                                                     ^0
  544|       |
  545|    115|        let result_expr = parser.parse_expression(BindingPower::COMMA)?;
                                                                                    ^0
  546|       |
  547|    115|        associations.push(ParsedGenericAssociation { type_name, result_expr });
  548|       |
  549|    115|        if !parser.is_token(TokenKind::Comma) {
  550|     57|            break;
  551|     58|        }
  552|     58|        parser.advance(); // consume comma
  553|       |    }
  554|       |
  555|     57|    let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                              ^0
  556|     57|    let end_loc = right_paren_token.span.end();
  557|     57|    let span = SourceSpan::new(start_loc, end_loc);
  558|       |
  559|     57|    let node = parser.replace_node(
  560|     57|        dummy,
  561|     57|        ParsedNodeKind::GenericSelection(controlling_expr, associations),
  562|     57|        span,
  563|       |    );
  564|     57|    Ok(node)
  565|     58|}
  566|       |
  567|       |/// Parse compound literal given the type and start location
  568|     12|pub(crate) fn parse_compound_literal_from_type_and_start(
  569|     12|    parser: &mut Parser,
  570|     12|    parsed_type: ParsedType,
  571|     12|    start_loc: SourceLoc,
  572|     12|) -> Result<ParsedNodeRef, ParseError> {
  573|     12|    let initializer_ref = super::declaration_core::parse_initializer(parser)?;
                                                                                          ^0
  574|       |
  575|     12|    let end_loc = parser.current_token_span()?.end();
                                                           ^0
  576|     12|    let span = SourceSpan::new(start_loc, end_loc);
  577|     12|    let node = parser.push_node(ParsedNodeKind::CompoundLiteral(parsed_type, initializer_ref), span);
  578|     12|    Ok(node)
  579|     12|}
  580|       |
  581|       |/// Parse sizeof expression or type
  582|     57|fn parse_sizeof(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  583|     57|    let token = parser.expect(TokenKind::Sizeof)?;
                                                              ^0
  584|     57|    let start_loc = token.span.start();
  585|       |
  586|     57|    let node = if parser.accept(TokenKind::LeftParen).is_some() {
  587|     55|        debug!(
  588|      0|            "parse_sizeof: found '(', now at position {}, token {:?}",
  589|       |            parser.current_idx,
  590|      0|            parser.current_token_kind()
  591|       |        );
  592|       |
  593|       |        // Check if it's a type name or expression
  594|     55|        if parser.is_type_name_start() {
  595|     21|            debug!("parse_sizeof: detected type name start, parsing type name");
                                 ^0
  596|     21|            let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                                      ^0
  597|     21|            debug!(
  598|      0|                "parse_sizeof: parsed type name, now at position {}, token {:?}",
  599|       |                parser.current_idx,
  600|      0|                parser.current_token_kind()
  601|       |            );
  602|       |
  603|     21|            let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                                      ^0
  604|       |
  605|     21|            let end_loc = right_paren_token.span.end();
  606|     21|            let span = SourceSpan::new(start_loc, end_loc);
  607|       |
  608|     21|            debug!("parse_sizeof: successfully parsed sizeof(type)");
                                 ^0
  609|     21|            parser.push_node(ParsedNodeKind::SizeOfType(parsed_type), span)
  610|       |        } else {
  611|     34|            debug!("parse_sizeof: detected expression, parsing expression");
                                 ^0
  612|     34|            let expr = parser.parse_expr_min()?;
                                                            ^0
  613|     34|            let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                                      ^0
  614|       |
  615|     34|            let end_loc = right_paren_token.span.end();
  616|     34|            let span = SourceSpan::new(start_loc, end_loc);
  617|       |
  618|     34|            debug!("parse_sizeof: successfully parsed sizeof(expression)");
                                 ^0
  619|     34|            parser.push_node(ParsedNodeKind::SizeOfExpr(expr), span)
  620|       |        }
  621|       |    } else {
  622|      2|        debug!("parse_sizeof: no '(', parsing unary expression");
                             ^0
  623|      2|        let expr = parser.parse_expr_bp(BindingPower::UNARY)?;
                                                                          ^0
  624|       |
  625|      2|        let end_loc = parser.ast.get_node(expr).span.end();
  626|      2|        let span = SourceSpan::new(start_loc, end_loc);
  627|       |
  628|      2|        debug!("parse_sizeof: successfully parsed sizeof unary expression");
                             ^0
  629|      2|        parser.push_node(ParsedNodeKind::SizeOfExpr(expr), span)
  630|       |    };
  631|       |
  632|     57|    Ok(node)
  633|     57|}
  634|       |
  635|       |/// Parse _Alignof (C11)
  636|      7|fn parse_alignof(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  637|      7|    let token = parser.expect(TokenKind::Alignof)?;
                                                               ^0
  638|      7|    let start_loc = token.span.start();
  639|       |
  640|      7|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  641|       |
  642|      7|    let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                              ^0
  643|      7|    let right_paren_token = parser.expect(TokenKind::RightParen)?;
                                                                              ^0
  644|       |
  645|      7|    let end_loc = right_paren_token.span.end();
  646|       |
  647|      7|    let span = SourceSpan::new(start_loc, end_loc);
  648|       |
  649|       |    // Use ParsedAlignOf for the parser phase
  650|      7|    let node = parser.push_node(ParsedNodeKind::AlignOf(parsed_type), span);
  651|      7|    Ok(node)
  652|      7|}
  653|       |
  654|       |/// Check if a cast expression starts at the current position
  655|       |/// This is called after consuming an opening parenthesis
  656|     94|pub(crate) fn is_cast_expression_start(parser: &Parser) -> bool {
  657|       |    //  Bolt: This is much more efficient than the old lookahead implementation.
  658|       |    // It avoids a manual loop over the token stream by using the centralized
  659|       |    // `is_type_name_start` helper, which performs a simple and fast check
  660|       |    // on the current token.
  661|     94|    parser.is_type_name_start()
  662|     94|}
  663|       |
  664|       |/// Parse cast expression given the already parsed type and right paren token
  665|     26|pub(crate) fn parse_cast_expression_from_type_and_paren(
  666|     26|    parser: &mut Parser,
  667|     26|    parsed_type: ParsedType,
  668|     26|    right_paren_token: Token,
  669|     26|) -> Result<ParsedNodeRef, ParseError> {
  670|       |    // Parse the expression being cast
  671|     26|    let expr_node = parser.parse_expr_bp(BindingPower::CAST)?;
                                                                          ^0
  672|       |
  673|     26|    let span = SourceSpan::new(
  674|     26|        right_paren_token.span.start(), // Start from the opening paren
  675|     26|        parser.ast.get_node(expr_node).span.end(),
  676|       |    );
  677|       |
  678|     26|    let node = parser.push_node(ParsedNodeKind::Cast(parsed_type, expr_node), span);
  679|       |
  680|     26|    debug!("parse_cast_expression: successfully parsed cast expression");
                         ^0
  681|     26|    Ok(node)
  682|     26|}
  683|       |
  684|       |/// Parse __builtin_va_arg(expr, type)
  685|      8|fn parse_builtin_va_arg(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  686|      8|    let token = parser.expect(TokenKind::BuiltinVaArg)?;
                                                                    ^0
  687|      8|    let start_loc = token.span.start();
  688|       |
  689|      8|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  690|       |
  691|       |    // Parse expression (ap)
  692|      8|    let expr = parser.parse_expr_assignment()?;
                                                           ^0
  693|       |
  694|      8|    parser.expect(TokenKind::Comma)?;
                                                 ^0
  695|       |
  696|       |    // Parse type
  697|      8|    let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                              ^0
  698|       |
  699|      8|    let right_paren = parser.expect(TokenKind::RightParen)?;
                                                                        ^0
  700|      8|    let end_loc = right_paren.span.end();
  701|      8|    let span = SourceSpan::new(start_loc, end_loc);
  702|       |
  703|      8|    let node = parser.push_node(ParsedNodeKind::BuiltinVaArg(parsed_type, expr), span);
  704|      8|    Ok(node)
  705|      8|}
  706|       |
  707|       |/// Parse __builtin_va_start(ap, last_param)
  708|      5|fn parse_builtin_va_start(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  709|      5|    let token = parser.expect(TokenKind::BuiltinVaStart)?;
                                                                      ^0
  710|      5|    let start_loc = token.span.start();
  711|       |
  712|      5|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  713|       |
  714|      5|    let ap = parser.parse_expr_assignment()?;
                                                         ^0
  715|      5|    parser.expect(TokenKind::Comma)?;
                                                 ^0
  716|      5|    let last = parser.parse_expr_assignment()?;
                                                           ^0
  717|       |
  718|      5|    let right_paren = parser.expect(TokenKind::RightParen)?;
                                                                        ^0
  719|      5|    let end_loc = right_paren.span.end();
  720|      5|    let span = SourceSpan::new(start_loc, end_loc);
  721|       |
  722|      5|    let node = parser.push_node(ParsedNodeKind::BuiltinVaStart(ap, last), span);
  723|      5|    Ok(node)
  724|      5|}
  725|       |
  726|       |/// Parse __builtin_va_end(ap)
  727|      3|fn parse_builtin_va_end(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  728|      3|    let token = parser.expect(TokenKind::BuiltinVaEnd)?;
                                                                    ^0
  729|      3|    let start_loc = token.span.start();
  730|       |
  731|      3|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  732|       |
  733|      3|    let ap = parser.parse_expr_assignment()?;
                                                         ^0
  734|       |
  735|      3|    let right_paren = parser.expect(TokenKind::RightParen)?;
                                                                        ^0
  736|      3|    let end_loc = right_paren.span.end();
  737|      3|    let span = SourceSpan::new(start_loc, end_loc);
  738|       |
  739|      3|    let node = parser.push_node(ParsedNodeKind::BuiltinVaEnd(ap), span);
  740|      3|    Ok(node)
  741|      3|}
  742|       |
  743|       |/// Parse __builtin_va_copy(dst, src)
  744|      1|fn parse_builtin_va_copy(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  745|      1|    let token = parser.expect(TokenKind::BuiltinVaCopy)?;
                                                                     ^0
  746|      1|    let start_loc = token.span.start();
  747|       |
  748|      1|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  749|       |
  750|      1|    let dst = parser.parse_expr_assignment()?;
                                                          ^0
  751|      1|    parser.expect(TokenKind::Comma)?;
                                                 ^0
  752|      1|    let src = parser.parse_expr_assignment()?;
                                                          ^0
  753|       |
  754|      1|    let right_paren = parser.expect(TokenKind::RightParen)?;
                                                                        ^0
  755|      1|    let end_loc = right_paren.span.end();
  756|      1|    let span = SourceSpan::new(start_loc, end_loc);
  757|       |
  758|      1|    let node = parser.push_node(ParsedNodeKind::BuiltinVaCopy(dst, src), span);
  759|      1|    Ok(node)
  760|      1|}
  761|       |
  762|       |/// Parse __builtin_expect(exp, c)
  763|      3|fn parse_builtin_expect(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  764|      3|    let token = parser.expect(TokenKind::BuiltinExpect)?;
                                                                     ^0
  765|      3|    let start_loc = token.span.start();
  766|       |
  767|      3|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  768|       |
  769|      3|    let exp = parser.parse_expr_assignment()?;
                                                          ^0
  770|      3|    parser.expect(TokenKind::Comma)?;
                                                 ^0
  771|      3|    let c = parser.parse_expr_assignment()?;
                                                        ^0
  772|       |
  773|      3|    let right_paren = parser.expect(TokenKind::RightParen)?;
                                                                        ^0
  774|      3|    let end_loc = right_paren.span.end();
  775|      3|    let span = SourceSpan::new(start_loc, end_loc);
  776|       |
  777|      3|    let node = parser.push_node(ParsedNodeKind::BuiltinExpect(exp, c), span);
  778|      3|    Ok(node)
  779|      3|}
  780|       |
  781|     13|fn parse_builtin_offsetof(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  782|     13|    let token = parser.expect(TokenKind::BuiltinOffsetof)?;
                                                                       ^0
  783|     13|    let start_loc = token.span.start();
  784|       |
  785|     13|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  786|       |
  787|       |    // Parse type
  788|     13|    let parsed_type = super::parsed_type_builder::parse_parsed_type_name(parser)?;
                                                                                              ^0
  789|       |
  790|     13|    parser.expect(TokenKind::Comma)?;
                                                 ^0
  791|       |
  792|       |    // Parse member-designator.
  793|       |    // C11 7.19p3: "The member-designator shall be such that given static type t* p;
  794|       |    // the expression &(p->member-designator) is an integer constant expression."
  795|       |    // We'll parse this into a tree of MemberAccess and IndexAccess nodes.
  796|       |    // We start with a dummy base representing 'p'.
  797|     13|    let mut current_node = parser.push_node(ParsedNodeKind::Dummy, parser.previous_token_span());
  798|       |
  799|       |    // First element MUST be a member name.
  800|     13|    let (first_member_name, first_member_span) = parser.expect_name()?;
                                                                                   ^0
  801|       |
  802|     13|    current_node = parser.push_node(
  803|     13|        ParsedNodeKind::MemberAccess(current_node, first_member_name, false /* is_arrow */),
  804|     13|        first_member_span,
  805|     13|    );
  806|       |
  807|       |    // Subsequent elements can be .member or [index]
  808|       |    loop {
  809|     17|        let tok = parser.current_token()?;
                                                      ^0
  810|     17|        match tok.kind {
  811|       |            TokenKind::Dot => {
  812|      2|                parser.advance();
  813|      2|                let (member_name, member_span) = parser.expect_name()?;
                                                                                   ^0
  814|      2|                current_node = parser.push_node(
  815|      2|                    ParsedNodeKind::MemberAccess(current_node, member_name, false /* is_arrow */),
  816|      2|                    tok.span.merge(member_span),
  817|      2|                );
  818|       |            }
  819|       |            TokenKind::LeftBracket => {
  820|      2|                parser.advance();
  821|      2|                let index_expr = parser.parse_expr_min()?; // Use parse_expr_min for full expression
                                                                      ^0
  822|      2|                let right_bracket = parser.expect(TokenKind::RightBracket)?;
                                                                                        ^0
  823|      2|                current_node = parser.push_node(
  824|      2|                    ParsedNodeKind::IndexAccess(current_node, index_expr),
  825|      2|                    tok.span.merge(right_bracket.span),
  826|      2|                );
  827|       |            }
  828|     13|            _ => break,
  829|       |        }
  830|       |    }
  831|       |
  832|     13|    let right_paren = parser.expect(TokenKind::RightParen)?;
                                                                        ^0
  833|     13|    let end_loc = right_paren.span.end();
  834|     13|    let span = SourceSpan::new(start_loc, end_loc);
  835|       |
  836|     13|    let node = parser.push_node(ParsedNodeKind::BuiltinOffsetof(parsed_type, current_node), span);
  837|     13|    Ok(node)
  838|     13|}
  839|       |
  840|       |/// Parse atomic builtins
  841|     14|fn parse_atomic_op(parser: &mut Parser, op: AtomicOp) -> Result<ParsedNodeRef, ParseError> {
  842|     14|    let token = parser.advance(); // Consume the builtin token
  843|     14|    let start_loc = token.expect("atomic op token").span.start();
  844|       |
  845|     14|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  846|       |
  847|     14|    let args = super::utils::expr_patterns::parse_expr_list(parser, BindingPower::ASSIGNMENT)?;
                                                                                                           ^0
  848|       |
  849|     14|    let right_paren = parser.expect(TokenKind::RightParen)?;
                                                                        ^0
  850|     14|    let end_loc = right_paren.span.end();
  851|     14|    let span = SourceSpan::new(start_loc, end_loc);
  852|       |
  853|     14|    let node = parser.push_node(ParsedNodeKind::AtomicOp(op, args), span);
  854|     14|    Ok(node)
  855|     14|}

/app/src/parser/lexer.rs:
    1|       |use crate::ast::StringId;
    2|       |use crate::ast::literal::{FloatSuffix, IntegerSuffix};
    3|       |use crate::ast::literal_parsing;
    4|       |use crate::pp::{PPToken, PPTokenKind};
    5|       |use crate::source_manager::SourceSpan;
    6|       |
    7|       |use serde::Serialize;
    8|       |/// C11 token kinds for the lexical analyzer
    9|       |#[derive(Debug, Clone, Copy, PartialEq, Serialize)]
   10|       |pub enum TokenKind {
   11|       |    // === LITERALS ===
   12|       |    IntegerConstant(i64, Option<IntegerSuffix>), // Parsed integer literal value
   13|       |    FloatConstant(f64, Option<FloatSuffix>),     // Parsed float literal value
   14|       |    CharacterConstant(u64),                      // Value of character constant
   15|       |    StringLiteral(StringId),                     // Interned string literal
   16|       |
   17|       |    // === IDENTIFIERS ===
   18|       |    Identifier(StringId), // Interned identifier
   19|       |
   20|       |    // === KEYWORDS ===
   21|       |    // Storage class specifiers
   22|       |    Auto,
   23|       |    Extern,
   24|       |    Register,
   25|       |    Static,
   26|       |    ThreadLocal,
   27|       |
   28|       |    // Type qualifiers
   29|       |    Const,
   30|       |    Restrict,
   31|       |    Volatile,
   32|       |    Atomic,
   33|       |
   34|       |    // Type specifiers
   35|       |    Bool,
   36|       |    Char,
   37|       |    Double,
   38|       |    Float,
   39|       |    Int,
   40|       |    Long,
   41|       |    Short,
   42|       |    Signed,
   43|       |    Unsigned,
   44|       |    Void,
   45|       |    Complex,
   46|       |
   47|       |    // Complex type specifiers
   48|       |    Struct,
   49|       |    Union,
   50|       |    Enum,
   51|       |
   52|       |    // Control flow
   53|       |    Break,
   54|       |    Case,
   55|       |    Continue,
   56|       |    Default,
   57|       |    Do,
   58|       |    Else,
   59|       |    For,
   60|       |    Goto,
   61|       |    If,
   62|       |    Return,
   63|       |    Switch,
   64|       |    While,
   65|       |
   66|       |    // Other keywords
   67|       |    Alignas,
   68|       |    Alignof,
   69|       |    Generic,
   70|       |    Inline,
   71|       |    Noreturn,
   72|       |    Pragma,
   73|       |    Sizeof,
   74|       |    StaticAssert,
   75|       |    Typedef,
   76|       |    Real,
   77|       |    Imag,
   78|       |    Attribute,
   79|       |    BuiltinVaArg,
   80|       |    BuiltinVaList,
   81|       |    BuiltinVaStart,
   82|       |    BuiltinVaEnd,
   83|       |    BuiltinVaCopy,
   84|       |    BuiltinExpect,
   85|       |    BuiltinOffsetof,
   86|       |    Asm,
   87|       |
   88|       |    // Atomic builtins
   89|       |    BuiltinAtomicLoadN,
   90|       |    BuiltinAtomicStoreN,
   91|       |    BuiltinAtomicExchangeN,
   92|       |    BuiltinAtomicCompareExchangeN,
   93|       |    BuiltinAtomicFetchAdd,
   94|       |    BuiltinAtomicFetchSub,
   95|       |    BuiltinAtomicFetchAnd,
   96|       |    BuiltinAtomicFetchOr,
   97|       |    BuiltinAtomicFetchXor,
   98|       |
   99|       |    // === OPERATORS ===
  100|       |    // Arithmetic operators
  101|       |    Plus,
  102|       |    Minus,
  103|       |    Star,
  104|       |    Slash,
  105|       |    Percent,
  106|       |    Increment,
  107|       |    Decrement,
  108|       |
  109|       |    // Bitwise operators
  110|       |    And,
  111|       |    Or,
  112|       |    Xor,
  113|       |    Not,
  114|       |    Tilde,
  115|       |    LeftShift,
  116|       |    RightShift,
  117|       |
  118|       |    // Comparison operators
  119|       |    Less,
  120|       |    Greater,
  121|       |    LessEqual,
  122|       |    GreaterEqual,
  123|       |    Equal,
  124|       |    NotEqual,
  125|       |
  126|       |    // Assignment operators
  127|       |    Assign,
  128|       |    PlusAssign,
  129|       |    MinusAssign,
  130|       |    StarAssign,
  131|       |    DivAssign,
  132|       |    ModAssign,
  133|       |    AndAssign,
  134|       |    OrAssign,
  135|       |    XorAssign,
  136|       |    LeftShiftAssign,
  137|       |    RightShiftAssign,
  138|       |
  139|       |    // Logical operators
  140|       |    LogicAnd,
  141|       |    LogicOr,
  142|       |
  143|       |    // Member access
  144|       |    Arrow,
  145|       |    Dot,
  146|       |
  147|       |    // Ternary operator
  148|       |    Question,
  149|       |    Colon,
  150|       |
  151|       |    // === PUNCTUATION ===
  152|       |    Comma,
  153|       |    Semicolon,
  154|       |    Ellipsis,
  155|       |
  156|       |    // Brackets and parentheses
  157|       |    LeftParen,
  158|       |    RightParen,
  159|       |    LeftBracket,
  160|       |    RightBracket,
  161|       |    LeftBrace,
  162|       |    RightBrace,
  163|       |
  164|       |    // === SPECIAL TOKENS ===
  165|       |    EndOfFile,
  166|       |    Unknown,
  167|       |}
  168|       |
  169|       |impl TokenKind {
  170|       |    /// Check if the token is a storage class specifier
  171|  1.29k|    pub(crate) fn is_storage_class_specifier(&self) -> bool {
  172|  1.27k|        matches!(
  173|  1.29k|            self,
  174|       |            TokenKind::Typedef
  175|       |                | TokenKind::Extern
  176|       |                | TokenKind::Static
  177|       |                | TokenKind::ThreadLocal
  178|       |                | TokenKind::Auto
  179|       |                | TokenKind::Register
  180|       |        )
  181|  1.29k|    }
  182|       |
  183|       |    /// Check if the token is a type specifier
  184|  1.27k|    pub(crate) fn is_type_specifier(&self) -> bool {
  185|    731|        matches!(
  186|  1.27k|            self,
  187|       |            TokenKind::Void
  188|       |                | TokenKind::Char
  189|       |                | TokenKind::Short
  190|       |                | TokenKind::Int
  191|       |                | TokenKind::Long
  192|       |                | TokenKind::Float
  193|       |                | TokenKind::Double
  194|       |                | TokenKind::Signed
  195|       |                | TokenKind::Unsigned
  196|       |                | TokenKind::Bool
  197|       |                | TokenKind::Complex
  198|       |                | TokenKind::Atomic
  199|       |                | TokenKind::Struct
  200|       |                | TokenKind::Union
  201|       |                | TokenKind::Enum
  202|       |                | TokenKind::BuiltinVaList
  203|       |        )
  204|  1.27k|    }
  205|       |
  206|       |    /// Check if the token is a type qualifier
  207|    731|    pub(crate) fn is_type_qualifier(&self) -> bool {
  208|    678|        matches!(
  209|    731|            self,
  210|       |            TokenKind::Const | TokenKind::Restrict | TokenKind::Volatile | TokenKind::Atomic
  211|       |        )
  212|    731|    }
  213|       |
  214|       |    /// Check if the token is a function specifier
  215|    678|    pub(crate) fn is_function_specifier(&self) -> bool {
  216|    678|        matches!(self, TokenKind::Inline | TokenKind::Noreturn)
                      ^674
  217|    678|    }
  218|       |
  219|       |    /// Check if the token is an alignment specifier
  220|    674|    pub(crate) fn is_alignment_specifier(&self) -> bool {
  221|    674|        matches!(self, TokenKind::Alignas)
                      ^671
  222|    674|    }
  223|       |
  224|       |    /// Check if the token can start a declaration specifier
  225|  1.29k|    pub(crate) fn is_declaration_specifier_start(&self) -> bool {
  226|  1.29k|        self.is_storage_class_specifier()
  227|  1.27k|            || self.is_type_specifier()
  228|    731|            || self.is_type_qualifier()
  229|    678|            || self.is_function_specifier()
  230|    674|            || self.is_alignment_specifier()
  231|    671|            || matches!(self, TokenKind::Attribute)
                             ^670
  232|  1.29k|    }
  233|       |
  234|       |    /// Check if the token can start a declaration (including typedefs)
  235|  1.27k|    pub(crate) fn is_declaration_start(&self, is_typedef: bool) -> bool {
  236|  1.27k|        if self.is_declaration_specifier_start() || *self == TokenKind::StaticAssert {
                                                                  ^655
  237|    640|            return true;
  238|    635|        }
  239|       |
  240|    635|        if let TokenKind::Identifier(_) = self {
  241|    231|            return is_typedef;
  242|    404|        }
  243|       |
  244|    404|        false
  245|  1.27k|    }
  246|       |}
  247|       |
  248|       |/// Token with source span for the parser
  249|       |#[derive(Debug, Clone, Copy, PartialEq)]
  250|       |pub struct Token {
  251|       |    pub kind: TokenKind,
  252|       |    pub span: SourceSpan,
  253|       |}
  254|       |
  255|       |/// Classify a preprocessor punctuation token into a lexical token.
  256|       |///
  257|       |///  Bolt: Optimized with a `match` statement.
  258|       |/// This is significantly faster than the previous `HashMap` implementation because
  259|       |/// the Rust compiler can optimize it into a perfect hash table or a more direct
  260|       |/// jump table, avoiding the overhead of runtime hashing and lookups.
  261|  8.01k|fn classify_punctuation(pp_token_kind: PPTokenKind) -> TokenKind {
  262|  8.01k|    match pp_token_kind {
  263|       |        // Arithmetic operators
  264|     66|        PPTokenKind::Plus => TokenKind::Plus,
  265|     43|        PPTokenKind::Minus => TokenKind::Minus,
  266|    228|        PPTokenKind::Star => TokenKind::Star,
  267|     10|        PPTokenKind::Slash => TokenKind::Slash,
  268|      4|        PPTokenKind::Percent => TokenKind::Percent,
  269|     21|        PPTokenKind::Increment => TokenKind::Increment,
  270|     10|        PPTokenKind::Decrement => TokenKind::Decrement,
  271|       |
  272|       |        // Bitwise operators
  273|     39|        PPTokenKind::And => TokenKind::And,
  274|      2|        PPTokenKind::Or => TokenKind::Or,
  275|      2|        PPTokenKind::Xor => TokenKind::Xor,
  276|     21|        PPTokenKind::Not => TokenKind::Not,
  277|      8|        PPTokenKind::Tilde => TokenKind::Tilde,
  278|      2|        PPTokenKind::LeftShift => TokenKind::LeftShift,
  279|      2|        PPTokenKind::RightShift => TokenKind::RightShift,
  280|       |
  281|       |        // Comparison operators
  282|     15|        PPTokenKind::Less => TokenKind::Less,
  283|      8|        PPTokenKind::Greater => TokenKind::Greater,
  284|      3|        PPTokenKind::LessEqual => TokenKind::LessEqual,
  285|      3|        PPTokenKind::GreaterEqual => TokenKind::GreaterEqual,
  286|     27|        PPTokenKind::Equal => TokenKind::Equal,
  287|     58|        PPTokenKind::NotEqual => TokenKind::NotEqual,
  288|       |
  289|       |        // Assignment operators
  290|    532|        PPTokenKind::Assign => TokenKind::Assign,
  291|      6|        PPTokenKind::PlusAssign => TokenKind::PlusAssign,
  292|      5|        PPTokenKind::MinusAssign => TokenKind::MinusAssign,
  293|      2|        PPTokenKind::StarAssign => TokenKind::StarAssign,
  294|      2|        PPTokenKind::DivAssign => TokenKind::DivAssign,
  295|      2|        PPTokenKind::ModAssign => TokenKind::ModAssign,
  296|      1|        PPTokenKind::AndAssign => TokenKind::AndAssign,
  297|      1|        PPTokenKind::OrAssign => TokenKind::OrAssign,
  298|      1|        PPTokenKind::XorAssign => TokenKind::XorAssign,
  299|      1|        PPTokenKind::LeftShiftAssign => TokenKind::LeftShiftAssign,
  300|      1|        PPTokenKind::RightShiftAssign => TokenKind::RightShiftAssign,
  301|       |
  302|       |        // Logical operators
  303|     13|        PPTokenKind::LogicAnd => TokenKind::LogicAnd,
  304|     14|        PPTokenKind::LogicOr => TokenKind::LogicOr,
  305|       |
  306|       |        // Member access
  307|     18|        PPTokenKind::Arrow => TokenKind::Arrow,
  308|    138|        PPTokenKind::Dot => TokenKind::Dot,
  309|       |
  310|       |        // Ternary operator
  311|     13|        PPTokenKind::Question => TokenKind::Question,
  312|    190|        PPTokenKind::Colon => TokenKind::Colon,
  313|       |
  314|       |        // Punctuation
  315|    545|        PPTokenKind::Comma => TokenKind::Comma,
  316|  1.76k|        PPTokenKind::Semicolon => TokenKind::Semicolon,
  317|     57|        PPTokenKind::Ellipsis => TokenKind::Ellipsis,
  318|       |
  319|       |        // Brackets and parentheses
  320|  1.15k|        PPTokenKind::LeftParen => TokenKind::LeftParen,
  321|  1.15k|        PPTokenKind::RightParen => TokenKind::RightParen,
  322|    226|        PPTokenKind::LeftBracket => TokenKind::LeftBracket,
  323|    226|        PPTokenKind::RightBracket => TokenKind::RightBracket,
  324|    683|        PPTokenKind::LeftBrace => TokenKind::LeftBrace,
  325|    683|        PPTokenKind::RightBrace => TokenKind::RightBrace,
  326|       |
  327|       |        // Tokens that don't map directly to a parser token
  328|      0|        PPTokenKind::Hash | PPTokenKind::HashHash => TokenKind::Unknown,
  329|       |
  330|       |        // Non-punctuation tokens are not handled by this function
  331|      1|        _ => TokenKind::Unknown,
  332|       |    }
  333|  8.01k|}
  334|       |
  335|       |/// Check if a symbol represents a C11 keyword.
  336|       |///
  337|       |///  Bolt: Optimized with a pre-initialized `HashMap`.
  338|       |/// This is significantly faster than the previous match-based implementation, which
  339|       |/// required converting the `StringId` to a `&str` for every lookup. This version
  340|       |// pre-interns all keywords and stores them in a lazily-initialized `HashMap`.
  341|       |/// Subsequent lookups use the `StringId` directly, resulting in a much faster
  342|       |/// integer comparison instead of a string comparison.
  343|  6.14k|pub(crate) fn is_keyword(symbol: StringId) -> Option<TokenKind> {
  344|  6.14k|    keyword_map().get(&symbol).copied()
  345|  6.14k|}
  346|       |
  347|  6.14k|fn keyword_map() -> &'static hashbrown::HashMap<StringId, TokenKind> {
  348|       |    static KEYWORDS: std::sync::OnceLock<hashbrown::HashMap<StringId, TokenKind>> = std::sync::OnceLock::new();
  349|  6.14k|    KEYWORDS.get_or_init(|| {
                                          ^1
  350|      1|        let mut m = hashbrown::HashMap::new();
  351|      1|        m.insert(StringId::new("auto"), TokenKind::Auto);
  352|      1|        m.insert(StringId::new("break"), TokenKind::Break);
  353|      1|        m.insert(StringId::new("case"), TokenKind::Case);
  354|      1|        m.insert(StringId::new("char"), TokenKind::Char);
  355|      1|        m.insert(StringId::new("const"), TokenKind::Const);
  356|      1|        m.insert(StringId::new("continue"), TokenKind::Continue);
  357|      1|        m.insert(StringId::new("default"), TokenKind::Default);
  358|      1|        m.insert(StringId::new("do"), TokenKind::Do);
  359|      1|        m.insert(StringId::new("double"), TokenKind::Double);
  360|      1|        m.insert(StringId::new("else"), TokenKind::Else);
  361|      1|        m.insert(StringId::new("enum"), TokenKind::Enum);
  362|      1|        m.insert(StringId::new("extern"), TokenKind::Extern);
  363|      1|        m.insert(StringId::new("float"), TokenKind::Float);
  364|      1|        m.insert(StringId::new("for"), TokenKind::For);
  365|      1|        m.insert(StringId::new("goto"), TokenKind::Goto);
  366|      1|        m.insert(StringId::new("if"), TokenKind::If);
  367|      1|        m.insert(StringId::new("inline"), TokenKind::Inline);
  368|      1|        m.insert(StringId::new("int"), TokenKind::Int);
  369|      1|        m.insert(StringId::new("long"), TokenKind::Long);
  370|      1|        m.insert(StringId::new("register"), TokenKind::Register);
  371|      1|        m.insert(StringId::new("restrict"), TokenKind::Restrict);
  372|      1|        m.insert(StringId::new("return"), TokenKind::Return);
  373|      1|        m.insert(StringId::new("short"), TokenKind::Short);
  374|      1|        m.insert(StringId::new("signed"), TokenKind::Signed);
  375|      1|        m.insert(StringId::new("sizeof"), TokenKind::Sizeof);
  376|      1|        m.insert(StringId::new("static"), TokenKind::Static);
  377|      1|        m.insert(StringId::new("struct"), TokenKind::Struct);
  378|      1|        m.insert(StringId::new("switch"), TokenKind::Switch);
  379|      1|        m.insert(StringId::new("typedef"), TokenKind::Typedef);
  380|      1|        m.insert(StringId::new("union"), TokenKind::Union);
  381|      1|        m.insert(StringId::new("unsigned"), TokenKind::Unsigned);
  382|      1|        m.insert(StringId::new("void"), TokenKind::Void);
  383|      1|        m.insert(StringId::new("volatile"), TokenKind::Volatile);
  384|      1|        m.insert(StringId::new("while"), TokenKind::While);
  385|      1|        m.insert(StringId::new("__real__"), TokenKind::Real);
  386|      1|        m.insert(StringId::new("__imag__"), TokenKind::Imag);
  387|      1|        m.insert(StringId::new("_Alignas"), TokenKind::Alignas);
  388|      1|        m.insert(StringId::new("_Alignof"), TokenKind::Alignof);
  389|      1|        m.insert(StringId::new("_Atomic"), TokenKind::Atomic);
  390|      1|        m.insert(StringId::new("_Bool"), TokenKind::Bool);
  391|      1|        m.insert(StringId::new("_Complex"), TokenKind::Complex);
  392|      1|        m.insert(StringId::new("_Generic"), TokenKind::Generic);
  393|      1|        m.insert(StringId::new("_Noreturn"), TokenKind::Noreturn);
  394|      1|        m.insert(StringId::new("_Pragma"), TokenKind::Pragma);
  395|      1|        m.insert(StringId::new("_Static_assert"), TokenKind::StaticAssert);
  396|      1|        m.insert(StringId::new("_Thread_local"), TokenKind::ThreadLocal);
  397|      1|        m.insert(StringId::new("__attribute__"), TokenKind::Attribute);
  398|      1|        m.insert(StringId::new("__attribute"), TokenKind::Attribute);
  399|      1|        m.insert(StringId::new("__builtin_va_arg"), TokenKind::BuiltinVaArg);
  400|      1|        m.insert(StringId::new("__builtin_va_list"), TokenKind::BuiltinVaList);
  401|      1|        m.insert(StringId::new("__gnuc_va_list"), TokenKind::BuiltinVaList); // GCC alias for __builtin_va_list
  402|      1|        m.insert(StringId::new("__builtin_va_start"), TokenKind::BuiltinVaStart);
  403|      1|        m.insert(StringId::new("__builtin_va_end"), TokenKind::BuiltinVaEnd);
  404|      1|        m.insert(StringId::new("__builtin_va_copy"), TokenKind::BuiltinVaCopy);
  405|      1|        m.insert(StringId::new("__builtin_expect"), TokenKind::BuiltinExpect);
  406|      1|        m.insert(StringId::new("__builtin_offsetof"), TokenKind::BuiltinOffsetof);
  407|      1|        m.insert(StringId::new("__atomic_load_n"), TokenKind::BuiltinAtomicLoadN);
  408|      1|        m.insert(StringId::new("__atomic_store_n"), TokenKind::BuiltinAtomicStoreN);
  409|      1|        m.insert(StringId::new("__atomic_exchange_n"), TokenKind::BuiltinAtomicExchangeN);
  410|      1|        m.insert(
  411|      1|            StringId::new("__atomic_compare_exchange_n"),
  412|      1|            TokenKind::BuiltinAtomicCompareExchangeN,
  413|       |        );
  414|      1|        m.insert(StringId::new("__atomic_fetch_add"), TokenKind::BuiltinAtomicFetchAdd);
  415|      1|        m.insert(StringId::new("__atomic_fetch_sub"), TokenKind::BuiltinAtomicFetchSub);
  416|      1|        m.insert(StringId::new("__atomic_fetch_and"), TokenKind::BuiltinAtomicFetchAnd);
  417|      1|        m.insert(StringId::new("__atomic_fetch_or"), TokenKind::BuiltinAtomicFetchOr);
  418|      1|        m.insert(StringId::new("__atomic_fetch_xor"), TokenKind::BuiltinAtomicFetchXor);
  419|       |
  420|       |        // GCC/Clang extensions
  421|      1|        m.insert(StringId::new("__restrict"), TokenKind::Restrict);
  422|      1|        m.insert(StringId::new("__restrict__"), TokenKind::Restrict);
  423|      1|        m.insert(StringId::new("__const"), TokenKind::Const);
  424|      1|        m.insert(StringId::new("__const__"), TokenKind::Const);
  425|      1|        m.insert(StringId::new("__volatile"), TokenKind::Volatile);
  426|      1|        m.insert(StringId::new("__volatile__"), TokenKind::Volatile);
  427|      1|        m.insert(StringId::new("__inline"), TokenKind::Inline);
  428|      1|        m.insert(StringId::new("__inline__"), TokenKind::Inline);
  429|      1|        m.insert(StringId::new("__signed"), TokenKind::Signed);
  430|      1|        m.insert(StringId::new("__signed__"), TokenKind::Signed);
  431|      1|        m.insert(StringId::new("__unsigned"), TokenKind::Unsigned);
  432|      1|        m.insert(StringId::new("__unsigned__"), TokenKind::Unsigned);
  433|      1|        m.insert(StringId::new("__asm"), TokenKind::Asm);
  434|      1|        m.insert(StringId::new("__asm__"), TokenKind::Asm);
  435|      1|        m.insert(StringId::new("asm"), TokenKind::Asm);
  436|      1|        m
  437|      1|    })
  438|  6.14k|}
  439|       |
  440|       |/// Lexer state machine
  441|       |pub struct Lexer<'src> {
  442|       |    // Current position in token stream
  443|       |    tokens: &'src [PPToken],
  444|       |}
  445|       |
  446|       |impl<'src> Lexer<'src> {
  447|       |    /// Create a new lexer with the given preprocessor token stream
  448|    813|    pub(crate) fn new(tokens: &'src [PPToken]) -> Self {
  449|    813|        Lexer { tokens }
  450|    813|    }
  451|       |
  452|       |    /// Classify a preprocessor token into a lexical token
  453|  16.3k|    fn classify_token(&self, pptoken: &PPToken) -> TokenKind {
  454|  16.3k|        match pptoken.kind {
  455|  6.09k|            PPTokenKind::Identifier(symbol) => {
  456|       |                // Check if it's a keyword
  457|  6.09k|                is_keyword(symbol).unwrap_or(TokenKind::Identifier(symbol))
  458|       |            }
  459|    135|            PPTokenKind::StringLiteral(symbol) => TokenKind::StringLiteral(symbol),
  460|     16|            PPTokenKind::CharLiteral(codepoint, _) => TokenKind::CharacterConstant(codepoint),
  461|  1.24k|            PPTokenKind::Number(value) => {
  462|       |                // Try to parse as integer first, then float, then unknown
  463|  1.24k|                if let Some((int_val, suffix)) = literal_parsing::parse_c11_integer_literal(value.as_str()) {
                                           ^1.20k   ^1.20k
  464|  1.20k|                    TokenKind::IntegerConstant(int_val as i64, suffix)
  465|     38|                } else if let Some((float_val, suffix)) = literal_parsing::parse_c11_float_literal(value.as_str()) {
  466|     38|                    TokenKind::FloatConstant(float_val, suffix)
  467|       |                } else {
  468|      0|                    TokenKind::Unknown // Could not parse as integer or float
  469|       |                }
  470|       |            }
  471|    813|            PPTokenKind::Eof => TokenKind::EndOfFile,
  472|      0|            PPTokenKind::Eod => TokenKind::Unknown,
  473|       |            // Handle punctuation tokens using the optimized match-based function
  474|  8.01k|            pptoken_kind => classify_punctuation(pptoken_kind),
  475|       |        }
  476|  16.3k|    }
  477|       |
  478|       |    /// Get all tokens from the stream
  479|    813|    pub(crate) fn tokenize_all(&mut self) -> Vec<Token> {
  480|       |        // Bolt : Pre-allocate the tokens vector with the capacity of the preprocessor tokens.
  481|       |        // This is a reasonable estimate that reduces the number of reallocations,
  482|       |        // as the number of lexical tokens is usually similar to the number of preprocessor tokens.
  483|    813|        let mut tokens = Vec::with_capacity(self.tokens.len());
  484|    813|        let mut current_token_iter = self.tokens.iter().peekable();
  485|       |
  486|  16.3k|        while let Some(pptoken) = current_token_iter.next() {
  487|  16.3k|            if let PPTokenKind::StringLiteral(symbol) = pptoken.kind {
                                                            ^141
  488|       |                //  Bolt: Optimized string literal handling.
  489|       |                // This introduces a fast path for single string literals, which are the
  490|       |                // most common case. By peeking ahead, we avoid the overhead of the
  491|       |                // two-pass concatenation logic unless it's actually needed. This
  492|       |                // reduces overhead and improves lexer performance.
  493|       |
  494|       |                // --- Fast path for single string literals ---
  495|    135|                if !matches!(
  496|    141|                    current_token_iter.peek(),
  497|       |                    Some(PPToken {
  498|       |                        kind: PPTokenKind::StringLiteral(_),
  499|       |                        ..
  500|       |                    })
  501|       |                ) {
  502|    135|                    tokens.push(Token {
  503|    135|                        kind: self.classify_token(pptoken),
  504|    135|                        span: SourceSpan::new_with_length(
  505|    135|                            pptoken.location.source_id(),
  506|    135|                            pptoken.location.offset(),
  507|    135|                            pptoken.length as u32,
  508|    135|                        ),
  509|    135|                    });
  510|    135|                    continue;
  511|      6|                }
  512|       |
  513|       |                // --- Slow path: Concatenate adjacent string literals ---
  514|      6|                let start_span = SourceSpan::new_with_length(
  515|      6|                    pptoken.location.source_id(),
  516|      6|                    pptoken.location.offset(),
  517|      6|                    pptoken.length as u32,
  518|       |                );
  519|      6|                let mut final_span = start_span;
  520|       |
  521|       |                // --- Phase 1: Determine final prefix and total size ---
  522|      6|                let (mut prefix, first_content) = Self::extract_literal_parts(symbol.as_str()).unwrap_or(("", ""));
  523|       |
  524|       |                // Concatenate raw content (inside quotes)
  525|      6|                let mut concatenated_content = String::with_capacity(first_content.len() * 2);
  526|      6|                concatenated_content.push_str(first_content);
  527|       |
  528|      6|                let mut adjacent_literals = 0;
  529|      6|                let next_token_idx = self.tokens.len() - current_token_iter.len();
  530|       |
  531|     15|                while let Some(next_pptoken) = self.tokens.get(next_token_idx + adjacent_literals) {
  532|     15|                    if let PPTokenKind::StringLiteral(next_symbol) = next_pptoken.kind {
                                                                    ^9
  533|      9|                        let (next_prefix, next_content) =
  534|      9|                            Self::extract_literal_parts(next_symbol.as_str()).unwrap_or(("", ""));
  535|       |
  536|      9|                        if prefix.is_empty() && !next_prefix.is_empty() {
  537|      0|                            prefix = next_prefix;
  538|      9|                        }
  539|       |
  540|      9|                        concatenated_content.push_str(next_content);
  541|       |
  542|      9|                        final_span = SourceSpan::new_with_length(
  543|      9|                            next_pptoken.location.source_id(),
  544|      9|                            next_pptoken.location.offset(),
  545|      9|                            next_pptoken.length as u32,
  546|      9|                        );
  547|      9|                        adjacent_literals += 1;
  548|       |                    } else {
  549|      6|                        break;
  550|       |                    }
  551|       |                }
  552|       |
  553|       |                // --- Phase 2: Consume tokens ---
  554|      9|                for _ in 0..adjacent_literals {
                                          ^6
  555|      9|                    current_token_iter.next();
  556|      9|                }
  557|       |
  558|       |                // Construct final literal: prefix + " + content + "
  559|      6|                let mut final_literal = String::with_capacity(concatenated_content.len() + prefix.len() + 2);
  560|      6|                final_literal.push_str(prefix);
  561|      6|                final_literal.push('"');
  562|      6|                final_literal.push_str(&concatenated_content);
  563|      6|                final_literal.push('"');
  564|       |
  565|      6|                tokens.push(Token {
  566|      6|                    kind: TokenKind::StringLiteral(StringId::new(final_literal)),
  567|      6|                    span: start_span.merge(final_span),
  568|      6|                });
  569|      6|                continue;
  570|  16.1k|            }
  571|       |
  572|       |            // For all other tokens, process normally
  573|  16.1k|            let token = Token {
  574|  16.1k|                kind: self.classify_token(pptoken),
  575|  16.1k|                span: SourceSpan::new_with_length(
  576|  16.1k|                    pptoken.location.source_id(),
  577|  16.1k|                    pptoken.location.offset(),
  578|  16.1k|                    pptoken.length as u32,
  579|  16.1k|                ),
  580|  16.1k|            };
  581|       |
  582|  16.1k|            let is_eof = matches!(token.kind, TokenKind::EndOfFile);
                                       ^15.3k
  583|  16.1k|            tokens.push(token);
  584|  16.1k|            if is_eof {
  585|    813|                break;
  586|  15.3k|            }
  587|       |        }
  588|       |
  589|    813|        tokens
  590|    813|    }
  591|       |
  592|       |    /// Extract parts from a string literal symbol: (prefix, content_without_quotes)
  593|     15|    fn extract_literal_parts(s: &str) -> Option<(&str, &str)> {
  594|     15|        if let Some(rest) = s.strip_prefix("L\"") {
                                  ^0
  595|      0|            if let Some(inner) = rest.strip_suffix('"') {
  596|      0|                return Some(("L", inner));
  597|      0|            }
  598|     15|        } else if let Some(rest) = s.strip_prefix("u\"") {
                                         ^0
  599|      0|            if let Some(inner) = rest.strip_suffix('"') {
  600|      0|                return Some(("u", inner));
  601|      0|            }
  602|     15|        } else if let Some(rest) = s.strip_prefix("U\"") {
                                         ^0
  603|      0|            if let Some(inner) = rest.strip_suffix('"') {
  604|      0|                return Some(("U", inner));
  605|      0|            }
  606|     15|        } else if let Some(rest) = s.strip_prefix("u8\"") {
                                         ^0
  607|      0|            if let Some(inner) = rest.strip_suffix('"') {
  608|      0|                return Some(("u8", inner));
  609|      0|            }
  610|     15|        } else if let Some(rest) = s.strip_prefix("\"")
  611|     15|            && let Some(inner) = rest.strip_suffix('"')
  612|       |        {
  613|     15|            return Some(("", inner));
  614|      0|        }
  615|      0|        None
  616|     15|    }
  617|       |}

/app/src/parser/parsed_type_builder.rs:
    1|       |//! ParsedType builder functions for the parser phase.
    2|       |//!
    3|       |//! This module provides helper functions to build ParsedType objects
    4|       |//! from declaration specifiers and declarators during the parsing phase.
    5|       |//! These functions ensure that no semantic types (TypeRef) are created
    6|       |//! during parsing, only syntactic types (ParsedType).
    7|       |
    8|       |use crate::ast::*;
    9|       |use crate::diagnostic::ParseError;
   10|       |use crate::semantic::TypeQualifiers;
   11|       |use thin_vec::ThinVec;
   12|       |
   13|       |use super::Parser;
   14|       |
   15|       |/// Build a ParsedType from declaration specifiers and an optional declarator
   16|    228|pub(crate) fn build_parsed_type_from_specifiers(
   17|    228|    parser: &mut Parser,
   18|    228|    specifiers: &ThinVec<ParsedDeclSpecifier>,
   19|    228|    declarator: Option<&ParsedDeclarator>,
   20|    228|) -> Result<ParsedType, ParseError> {
   21|    228|    let (base_type_ref, qualifiers) = parse_base_type_and_qualifiers(parser, specifiers)?;
                       ^227           ^227                                                            ^1
   22|       |
   23|    227|    let declarator_ref = if let Some(d) = declarator {
                                                   ^39
   24|     39|        build_parsed_declarator(parser, d)?
                                                        ^0
   25|       |    } else {
   26|    188|        parser
   27|    188|            .ast
   28|    188|            .parsed_types
   29|    188|            .alloc_decl(ParsedDeclaratorNode::Identifier { name: None })
   30|       |    };
   31|       |
   32|    227|    Ok(ParsedType {
   33|    227|        base: base_type_ref,
   34|    227|        declarator: declarator_ref,
   35|    227|        qualifiers,
   36|    227|    })
   37|    228|}
   38|       |
   39|     71|fn merge_parsed_type_specifiers(
   40|     71|    current: ParsedTypeSpecifier,
   41|     71|    new: ParsedTypeSpecifier,
   42|     71|    span: crate::ast::SourceSpan,
   43|     71|) -> Result<ParsedTypeSpecifier, ParseError> {
   44|       |    use ParsedTypeSpecifier::*;
   45|     71|    match (current, new) {
   46|       |        // Redundant same types
   47|      1|        (Long, Long) => Ok(LongLong),
   48|      1|        (Long, Int) => Ok(Long),
   49|      2|        (Int, Long) => Ok(Long),
   50|      1|        (Short, Int) => Ok(Short),
   51|      2|        (Int, Short) => Ok(Short),
   52|       |
   53|       |        // Signed
   54|      2|        (Signed, Int) => Ok(Int),
   55|      4|        (Int, Signed) => Ok(Int),
   56|      1|        (Signed, Char) => Ok(SignedChar),
   57|      1|        (Char, Signed) => Ok(SignedChar),
   58|      2|        (Signed, Short) => Ok(SignedShort),
   59|      1|        (Short, Signed) => Ok(SignedShort),
   60|      2|        (Signed, Long) => Ok(SignedLong),
   61|      1|        (Long, Signed) => Ok(SignedLong),
   62|      2|        (Signed, LongLong) => Ok(SignedLongLong),
   63|      1|        (LongLong, Signed) => Ok(SignedLongLong),
   64|       |
   65|       |        // Unsigned
   66|      2|        (Unsigned, Int) => Ok(Unsigned),
   67|      4|        (Int, Unsigned) => Ok(Unsigned),
   68|      1|        (Unsigned, Char) => Ok(UnsignedChar),
   69|      1|        (Char, Unsigned) => Ok(UnsignedChar),
   70|      3|        (Unsigned, Short) => Ok(UnsignedShort),
   71|      1|        (Short, Unsigned) => Ok(UnsignedShort),
   72|      5|        (Unsigned, Long) => Ok(UnsignedLong),
   73|      1|        (Long, Unsigned) => Ok(UnsignedLong),
   74|      3|        (Unsigned, LongLong) => Ok(UnsignedLongLong),
   75|      1|        (LongLong, Unsigned) => Ok(UnsignedLongLong),
   76|       |
   77|       |        // Complex combinations
   78|      0|        (Long, LongLong) => Ok(LongLong),
   79|      1|        (LongLong, Long) => Ok(LongLong),
   80|      2|        (LongLong, Int) => Ok(LongLong),
   81|      2|        (Int, LongLong) => Ok(LongLong),
   82|       |
   83|      1|        (Signed, Signed) => Ok(Signed),
   84|      1|        (Unsigned, Unsigned) => Ok(Unsigned),
   85|       |
   86|       |        // Composite + Int (e.g. unsigned long int)
   87|      1|        (UnsignedLong, Int) => Ok(UnsignedLong),
   88|      0|        (Int, UnsignedLong) => Ok(UnsignedLong),
   89|      1|        (SignedLong, Int) => Ok(SignedLong),
   90|      0|        (Int, SignedLong) => Ok(SignedLong),
   91|      1|        (UnsignedLongLong, Int) => Ok(UnsignedLongLong),
   92|      0|        (Int, UnsignedLongLong) => Ok(UnsignedLongLong),
   93|      1|        (SignedLongLong, Int) => Ok(SignedLongLong),
   94|      0|        (Int, SignedLongLong) => Ok(SignedLongLong),
   95|      1|        (UnsignedShort, Int) => Ok(UnsignedShort),
   96|      0|        (Int, UnsignedShort) => Ok(UnsignedShort),
   97|      1|        (SignedShort, Int) => Ok(SignedShort),
   98|      0|        (Int, SignedShort) => Ok(SignedShort),
   99|       |
  100|       |        // Complex combinations
  101|      4|        (Float, Complex) => Ok(ComplexFloat),
  102|      1|        (Complex, Float) => Ok(ComplexFloat),
  103|      2|        (Double, Complex) => Ok(ComplexDouble),
  104|      2|        (Complex, Double) => Ok(ComplexDouble),
  105|      2|        (LongDouble, Complex) => Ok(ComplexLongDouble),
  106|      1|        (Complex, LongDouble) => Ok(ComplexLongDouble),
  107|       |
  108|       |        // Mismatch
  109|      0|        (a, _) => Err(ParseError::UnexpectedToken {
  110|      0|            expected_tokens: format!("compatible type specifier for {:?}", a),
  111|      0|            found: crate::parser::TokenKind::Unknown,
  112|      0|            span,
  113|      0|        }),
  114|       |    }
  115|     71|}
  116|       |
  117|       |/// Parse base type and qualifiers from declaration specifiers
  118|    228|fn parse_base_type_and_qualifiers(
  119|    228|    parser: &mut Parser,
  120|    228|    specifiers: &ThinVec<ParsedDeclSpecifier>,
  121|    228|) -> Result<(ParsedBaseTypeRef, TypeQualifiers), ParseError> {
  122|    228|    let mut qualifiers = TypeQualifiers::empty();
  123|    228|    let mut base_type_specifier: Option<ParsedTypeSpecifier> = None;
  124|    228|    let mut other_base_type_node = None;
  125|       |
  126|    539|    for spec in specifiers {
                      ^312
  127|    312|        match spec {
  128|    300|            ParsedDeclSpecifier::TypeSpecifier(ts) => {
  129|    300|                match ts {
  130|       |                    // Collect mergeable basic types
  131|       |                    ParsedTypeSpecifier::Void
  132|       |                    | ParsedTypeSpecifier::Char
  133|       |                    | ParsedTypeSpecifier::Short
  134|       |                    | ParsedTypeSpecifier::Int
  135|       |                    | ParsedTypeSpecifier::Long
  136|       |                    | ParsedTypeSpecifier::LongLong
  137|       |                    | ParsedTypeSpecifier::Float
  138|       |                    | ParsedTypeSpecifier::Double
  139|       |                    | ParsedTypeSpecifier::LongDouble
  140|       |                    | ParsedTypeSpecifier::Signed
  141|       |                    | ParsedTypeSpecifier::Unsigned
  142|       |                    | ParsedTypeSpecifier::Bool
  143|       |                    | ParsedTypeSpecifier::Complex => {
  144|    260|                        if other_base_type_node.is_some() {
  145|      0|                            return Err(ParseError::UnexpectedToken {
  146|      0|                                expected_tokens: "single type specifier".to_string(),
  147|      0|                                found: crate::parser::TokenKind::Unknown,
  148|      0|                                span: crate::ast::SourceSpan::default(),
  149|      0|                            });
  150|    260|                        }
  151|    260|                        if let Some(current) = base_type_specifier {
                                                  ^71
  152|       |                            // Merge
  153|       |                            // We don't have span for specifiers in ThinVec directly?
  154|       |                            // We can use parser.current_span() but that's wrong.
  155|       |                            // ParsedDeclSpecifier doesn't store span.
  156|       |                            // We will assume dummy span for now or fix this later.
  157|     71|                            base_type_specifier = Some(merge_parsed_type_specifiers(
  158|     71|                                current,
  159|     71|                                ts.clone(),
  160|     71|                                crate::ast::SourceSpan::default(),
  161|      0|                            )?);
  162|    189|                        } else {
  163|    189|                            base_type_specifier = Some(ts.clone());
  164|    189|                        }
  165|       |                    }
  166|       |                    _ => {
  167|       |                        // Non-mergeable types (struct, enum, typedef, atomic)
  168|       |                        // Should error if we already have a type
  169|     40|                        if base_type_specifier.is_some() || other_base_type_node.is_some() {
                                                                          ^39                  ^39
  170|       |                            // Error: multiple types
  171|       |                            // Since we don't have easy error here, we might just overwrite or error?
  172|       |                            // Let's error.
  173|      1|                            return Err(ParseError::UnexpectedToken {
  174|      1|                                expected_tokens: "single type specifier".to_string(),
  175|      1|                                found: crate::parser::TokenKind::Unknown,
  176|      1|                                span: crate::ast::SourceSpan::default(),
  177|      1|                            });
  178|     39|                        }
  179|     39|                        let parsed_base = parse_type_specifier_to_parsed_base(parser, ts)?;
                                                                                                       ^0
  180|     39|                        other_base_type_node = Some(parsed_base);
  181|       |                    }
  182|       |                }
  183|       |            }
  184|     11|            ParsedDeclSpecifier::TypeQualifier(q) => {
  185|     11|                let qualifier = match q {
  186|      9|                    crate::ast::nodes::TypeQualifier::Const => TypeQualifiers::CONST,
  187|      1|                    crate::ast::nodes::TypeQualifier::Volatile => TypeQualifiers::VOLATILE,
  188|      0|                    crate::ast::nodes::TypeQualifier::Restrict => TypeQualifiers::RESTRICT,
  189|      1|                    crate::ast::nodes::TypeQualifier::Atomic => TypeQualifiers::ATOMIC,
  190|       |                };
  191|     11|                qualifiers |= qualifier;
  192|       |            }
  193|      1|            _ => {
  194|      1|                // Other specifiers (storage class, function specifiers, etc.)
  195|      1|                // are handled elsewhere and don't affect the base type
  196|      1|            }
  197|       |        }
  198|       |    }
  199|       |
  200|    227|    let base_type_ref = if let Some(ts) = base_type_specifier {
                                                  ^188
  201|    188|        parse_type_specifier_to_parsed_base(parser, &ts)?
                                                                      ^0
  202|     39|    } else if let Some(node) = other_base_type_node {
  203|     39|        node
  204|       |    } else {
  205|       |        // Default to int if no type specifier found
  206|      0|        parser
  207|      0|            .ast
  208|      0|            .parsed_types
  209|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Int))
  210|       |    };
  211|       |
  212|    227|    Ok((base_type_ref, qualifiers))
  213|    228|}
  214|       |
  215|       |/// Convert a TypeSpecifier to a ParsedBaseTypeNode
  216|    227|fn parse_type_specifier_to_parsed_base(
  217|    227|    parser: &mut Parser,
  218|    227|    ts: &ParsedTypeSpecifier,
  219|    227|) -> Result<ParsedBaseTypeRef, ParseError> {
  220|    227|    match ts {
  221|     10|        ParsedTypeSpecifier::Void => Ok(parser
  222|     10|            .ast
  223|     10|            .parsed_types
  224|     10|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Void))),
  225|      8|        ParsedTypeSpecifier::Char => Ok(parser
  226|      8|            .ast
  227|      8|            .parsed_types
  228|      8|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Char))),
  229|      3|        ParsedTypeSpecifier::Short => Ok(parser
  230|      3|            .ast
  231|      3|            .parsed_types
  232|      3|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Short))),
  233|    104|        ParsedTypeSpecifier::Int => Ok(parser
  234|    104|            .ast
  235|    104|            .parsed_types
  236|    104|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Int))),
  237|      7|        ParsedTypeSpecifier::Long => Ok(parser
  238|      7|            .ast
  239|      7|            .parsed_types
  240|      7|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Long))),
  241|      8|        ParsedTypeSpecifier::LongLong => Ok(parser
  242|      8|            .ast
  243|      8|            .parsed_types
  244|      8|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::LongLong))),
  245|       |
  246|       |        // New variants
  247|      6|        ParsedTypeSpecifier::UnsignedLong => Ok(parser
  248|      6|            .ast
  249|      6|            .parsed_types
  250|      6|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::UnsignedLong))),
  251|      4|        ParsedTypeSpecifier::UnsignedLongLong => Ok(parser
  252|      4|            .ast
  253|      4|            .parsed_types
  254|      4|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::UnsignedLongLong))),
  255|      4|        ParsedTypeSpecifier::UnsignedShort => Ok(parser
  256|      4|            .ast
  257|      4|            .parsed_types
  258|      4|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::UnsignedShort))),
  259|      2|        ParsedTypeSpecifier::UnsignedChar => Ok(parser
  260|      2|            .ast
  261|      2|            .parsed_types
  262|      2|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::UnsignedChar))),
  263|      2|        ParsedTypeSpecifier::SignedChar => Ok(parser
  264|      2|            .ast
  265|      2|            .parsed_types
  266|      2|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::SignedChar))),
  267|      3|        ParsedTypeSpecifier::SignedShort => Ok(parser
  268|      3|            .ast
  269|      3|            .parsed_types
  270|      3|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::SignedShort))),
  271|      3|        ParsedTypeSpecifier::SignedLong => Ok(parser
  272|      3|            .ast
  273|      3|            .parsed_types
  274|      3|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::SignedLong))),
  275|      3|        ParsedTypeSpecifier::SignedLongLong => Ok(parser
  276|      3|            .ast
  277|      3|            .parsed_types
  278|      3|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::SignedLongLong))),
  279|       |
  280|      0|        ParsedTypeSpecifier::Float => Ok(parser
  281|      0|            .ast
  282|      0|            .parsed_types
  283|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Float))),
  284|      3|        ParsedTypeSpecifier::Double => Ok(parser
  285|      3|            .ast
  286|      3|            .parsed_types
  287|      3|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Double))),
  288|      3|        ParsedTypeSpecifier::LongDouble => Ok(parser
  289|      3|            .ast
  290|      3|            .parsed_types
  291|      3|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::LongDouble))),
  292|      5|        ParsedTypeSpecifier::ComplexFloat => Ok(parser
  293|      5|            .ast
  294|      5|            .parsed_types
  295|      5|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::ComplexFloat))),
  296|      4|        ParsedTypeSpecifier::ComplexDouble => Ok(parser
  297|      4|            .ast
  298|      4|            .parsed_types
  299|      4|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::ComplexDouble))),
  300|      3|        ParsedTypeSpecifier::ComplexLongDouble => Ok(parser
  301|      3|            .ast
  302|      3|            .parsed_types
  303|      3|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::ComplexLongDouble))),
  304|      0|        ParsedTypeSpecifier::Signed => Ok(parser
  305|      0|            .ast
  306|      0|            .parsed_types
  307|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Signed))),
  308|      3|        ParsedTypeSpecifier::Unsigned => Ok(parser
  309|      3|            .ast
  310|      3|            .parsed_types
  311|      3|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Unsigned))),
  312|      0|        ParsedTypeSpecifier::Bool => Ok(parser
  313|      0|            .ast
  314|      0|            .parsed_types
  315|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Bool))),
  316|      0|        ParsedTypeSpecifier::Complex => Ok(parser
  317|      0|            .ast
  318|      0|            .parsed_types
  319|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Complex))),
  320|      1|        ParsedTypeSpecifier::Atomic(parsed_type) => {
  321|       |            // _Atomic(type-name) - the parsed_type already contains the parsed inner type
  322|      1|            Ok(parser
  323|      1|                .ast
  324|      1|                .parsed_types
  325|      1|                .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::Atomic(*parsed_type))))
  326|       |        }
  327|     34|        ParsedTypeSpecifier::Record(is_union, tag, definition) => {
  328|     34|            let members = if let Some(def_data) = definition {
                                                    ^3
  329|      3|                if let Some(member_decls) = &def_data.members {
  330|      3|                    let mut parsed_members = Vec::new();
  331|      7|                    for decl in member_decls {
                                      ^4
  332|       |                        // Parse each member declaration
  333|      8|                        for init_decl in &decl.init_declarators {
                                          ^4
  334|      4|                            if let Some(member_name) = super::declarator::get_declarator_name(&init_decl.declarator) {
  335|      4|                                let member_parsed_type = build_parsed_type_from_specifiers(
  336|      4|                                    parser,
  337|      4|                                    &decl.specifiers,
  338|      4|                                    Some(&init_decl.declarator),
  339|      0|                                )?;
  340|       |
  341|       |                                // Extract alignment from specifiers
  342|      4|                                let mut alignment = None;
  343|      8|                                for spec in &decl.specifiers {
                                                  ^4
  344|      4|                                    if let ParsedDeclSpecifier::AlignmentSpecifier(align_spec) = spec {
                                                                                                 ^0
  345|      0|                                        match align_spec {
  346|      0|                                            ParsedAlignmentSpecifier::Expr(expr_ref) => {
  347|      0|                                                if let ParsedNodeKind::Literal(literal::Literal::Int { val, .. }) =
  348|      0|                                                    parser.ast.get_node(*expr_ref).kind
  349|      0|                                                {
  350|      0|                                                    alignment = Some(val as u32);
  351|      0|                                                }
  352|       |                                            }
  353|      0|                                            ParsedAlignmentSpecifier::Type(_) => {
  354|      0|                                                // Handling type alignment in parser is hard, skip for now or resolve during lowering
  355|      0|                                            }
  356|       |                                        }
  357|      4|                                    }
  358|       |                                }
  359|       |
  360|      4|                                parsed_members.push(ParsedStructMember {
  361|      4|                                    name: Some(member_name),
  362|      4|                                    ty: member_parsed_type,
  363|      4|                                    bit_field_size: None,
  364|      4|                                    alignment,
  365|      4|                                    span: init_decl.span,
  366|      4|                                });
  367|      0|                            }
  368|       |                        }
  369|       |                    }
  370|      3|                    Some(parser.ast.parsed_types.alloc_struct_members(parsed_members))
  371|       |                } else {
  372|      0|                    None
  373|       |                }
  374|       |            } else {
  375|     31|                None
  376|       |            };
  377|       |
  378|     34|            Ok(parser.ast.parsed_types.alloc_base_type(ParsedBaseTypeNode::Record {
  379|     34|                tag: *tag,
  380|     34|                members,
  381|     34|                is_union: *is_union,
  382|     34|            }))
  383|       |        }
  384|      1|        ParsedTypeSpecifier::Enum(tag, enumerators) => {
  385|      1|            let parsed_enumerators = if let Some(enum_node_refs) = enumerators {
  386|      1|                let mut parsed_enums = Vec::new();
  387|      2|                for &enum_ref in enum_node_refs {
                                   ^1
  388|      1|                    let enum_node = parser.ast.get_node(enum_ref);
  389|      1|                    if let ParsedNodeKind::EnumConstant(name, value_expr_ref) = &enum_node.kind {
  390|      1|                        parsed_enums.push(ParsedEnumConstant {
  391|      1|                            name: *name,
  392|      1|                            value: value_expr_ref.as_ref().and_then(|expr_ref| {
  393|       |                                // Try to evaluate constant expression
  394|      0|                                if let ParsedNodeKind::Literal(literal::Literal::Int { val, .. }) =
  395|      1|                                    parser.ast.get_node(*expr_ref).kind
  396|       |                                {
  397|      0|                                    Some(val)
  398|       |                                } else {
  399|      1|                                    None
  400|       |                                }
  401|      1|                            }),
  402|      1|                            span: enum_node.span,
  403|       |                        });
  404|      0|                    }
  405|       |                }
  406|      1|                Some(parser.ast.parsed_types.alloc_enum_constants(parsed_enums))
  407|       |            } else {
  408|      0|                None
  409|       |            };
  410|       |
  411|      1|            Ok(parser.ast.parsed_types.alloc_base_type(ParsedBaseTypeNode::Enum {
  412|      1|                tag: *tag,
  413|      1|                enumerators: parsed_enumerators,
  414|      1|            }))
  415|       |        }
  416|      3|        ParsedTypeSpecifier::TypedefName(name) => Ok(parser
  417|      3|            .ast
  418|      3|            .parsed_types
  419|      3|            .alloc_base_type(ParsedBaseTypeNode::Typedef(*name))),
  420|      0|        ParsedTypeSpecifier::VaList => Ok(parser
  421|      0|            .ast
  422|      0|            .parsed_types
  423|      0|            .alloc_base_type(ParsedBaseTypeNode::Builtin(ParsedTypeSpecifier::VaList))),
  424|       |    }
  425|    227|}
  426|       |
  427|       |/// Build a ParsedDeclaratorNode from a ParsedDeclarator
  428|     78|fn build_parsed_declarator(parser: &mut Parser, declarator: &ParsedDeclarator) -> Result<ParsedDeclRef, ParseError> {
  429|     78|    match declarator {
  430|      4|        ParsedDeclarator::Identifier(name, qualifiers) => {
  431|       |            // Simple identifier with optional qualifiers
  432|      4|            if qualifiers.is_empty() {
  433|      4|                Ok(parser
  434|      4|                    .ast
  435|      4|                    .parsed_types
  436|      4|                    .alloc_decl(ParsedDeclaratorNode::Identifier { name: Some(*name) }))
  437|       |            } else {
  438|       |                // Create a pointer declarator with the qualifiers
  439|      0|                let inner = parser
  440|      0|                    .ast
  441|      0|                    .parsed_types
  442|      0|                    .alloc_decl(ParsedDeclaratorNode::Identifier { name: Some(*name) });
  443|      0|                Ok(parser.ast.parsed_types.alloc_decl(ParsedDeclaratorNode::Pointer {
  444|      0|                    qualifiers: *qualifiers,
  445|      0|                    inner,
  446|      0|                }))
  447|       |            }
  448|       |        }
  449|     28|        ParsedDeclarator::Pointer(ptr_qualifiers, inner_decl) => {
  450|     28|            let inner_ref = if let Some(inner) = inner_decl {
  451|     28|                build_parsed_declarator(parser, inner)?
                                                                    ^0
  452|       |            } else {
  453|      0|                parser
  454|      0|                    .ast
  455|      0|                    .parsed_types
  456|      0|                    .alloc_decl(ParsedDeclaratorNode::Identifier { name: None })
  457|       |            };
  458|       |
  459|     28|            Ok(parser.ast.parsed_types.alloc_decl(ParsedDeclaratorNode::Pointer {
  460|     28|                qualifiers: *ptr_qualifiers,
  461|     28|                inner: inner_ref,
  462|     28|            }))
  463|       |        }
  464|      4|        ParsedDeclarator::Array(inner, size) => {
  465|      4|            let inner_ref = build_parsed_declarator(parser, inner)?;
                                                                                ^0
  466|       |
  467|      4|            Ok(parser.ast.parsed_types.alloc_decl(ParsedDeclaratorNode::Array {
  468|      4|                size: size.clone(),
  469|      4|                inner: inner_ref,
  470|      4|            }))
  471|       |        }
  472|       |        ParsedDeclarator::Function {
  473|      7|            inner,
  474|      7|            params,
  475|      7|            is_variadic,
  476|       |        } => {
  477|      7|            let inner_ref = build_parsed_declarator(parser, inner)?;
                                                                                ^0
  478|       |
  479|       |            // Parse parameters
  480|      7|            let mut parsed_params = Vec::new();
  481|     10|            for param in params {
                              ^3
  482|      3|                let param_parsed_type =
  483|      3|                    build_parsed_type_from_specifiers(parser, &param.specifiers, param.declarator.as_ref())?;
                                                                                                                         ^0
  484|       |
  485|      3|                parsed_params.push(ParsedFunctionParam {
  486|      3|                    name: param
  487|      3|                        .declarator
  488|      3|                        .as_ref()
  489|      3|                        .and_then(super::declarator::get_declarator_name),
  490|      3|                    ty: param_parsed_type,
  491|      3|                    span: param.span,
  492|      3|                });
  493|       |            }
  494|       |
  495|      7|            let param_range = parser.ast.parsed_types.alloc_params(parsed_params);
  496|       |
  497|      7|            Ok(parser.ast.parsed_types.alloc_decl(ParsedDeclaratorNode::Function {
  498|      7|                params: param_range,
  499|      7|                flags: FunctionFlags {
  500|      7|                    is_variadic: *is_variadic,
  501|      7|                },
  502|      7|                inner: inner_ref,
  503|      7|            }))
  504|       |        }
  505|     35|        ParsedDeclarator::Abstract => Ok(parser
  506|     35|            .ast
  507|     35|            .parsed_types
  508|     35|            .alloc_decl(ParsedDeclaratorNode::Identifier { name: None })),
  509|       |
  510|      0|        ParsedDeclarator::BitField(inner, _width_expr) => {
  511|       |            // BitFields inside structs are usually handled by struct parsing,
  512|       |            // creating ParsedStructMember directly.
  513|       |            // But if we encounter one here (rare in types?), we probably treat as identifier
  514|       |            // or maybe we need to represent it.
  515|       |            // For types, a bitfield declarator resolves to the underlying type declarator.
  516|      0|            build_parsed_declarator(parser, inner)
  517|       |        }
  518|       |
  519|      0|        ParsedDeclarator::AnonymousRecord(_is_union, _members) => {
  520|       |            // Anonymous records are handled elsewhere or ignored in type building
  521|       |            // as they declare types themselves, not just a declarator.
  522|      0|            Ok(parser
  523|      0|                .ast
  524|      0|                .parsed_types
  525|      0|                .alloc_decl(ParsedDeclaratorNode::Identifier { name: None }))
  526|       |        }
  527|       |    }
  528|     78|}
  529|       |
  530|       |/// Parse a type name and return ParsedType (for casts, sizeof, etc.)
  531|    222|pub(crate) fn parse_parsed_type_name(parser: &mut Parser) -> Result<ParsedType, ParseError> {
  532|       |    // Parse declaration specifiers
  533|    222|    let specifiers = super::declaration_core::parse_declaration_specifiers(parser)?;
                      ^221                                                                      ^1
  534|       |
  535|       |    // Parse abstract declarator (optional)
  536|    221|    let declarator = if parser.is_abstract_declarator_start() {
  537|     35|        Some(super::declarator::parse_abstract_declarator(parser)?)
                                                                               ^0
  538|       |    } else {
  539|    186|        None
  540|       |    };
  541|       |
  542|       |    // Build the ParsedType from specifiers and declarator
  543|    221|    build_parsed_type_from_specifiers(parser, &specifiers, declarator.as_ref())
  544|    222|}

/app/src/parser/statements.rs:
    1|       |//! Statement parsing module
    2|       |//!
    3|       |//! This module handles all statement parsing logic, including control flow
    4|       |//! statements, compound statements, and expression statements.
    5|       |
    6|       |use super::Parser;
    7|       |use crate::ast::*;
    8|       |use crate::diagnostic::ParseError;
    9|       |use crate::parser::TokenKind;
   10|       |use crate::parser::declaration_core::parse_declaration_specifiers;
   11|       |use crate::parser::declarator::parse_declarator;
   12|       |use crate::parser::utils::expr_patterns::parse_parenthesized_expr;
   13|       |use crate::source_manager::{SourceLoc, SourceSpan};
   14|       |use log::debug;
   15|       |use thin_vec::thin_vec;
   16|       |
   17|       |/// Parse a statement
   18|    751|pub(crate) fn parse_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
   19|    751|    let token = parser.current_token()?;
                                                    ^0
   20|       |
   21|       |    // Check for label: identifier :
   22|    751|    debug!("parse_statement: token is {:?}, looking for label pattern", token.kind);
                         ^0
   23|       |
   24|       |    // Try to check if current token is identifier followed by colon
   25|    751|    if let TokenKind::Identifier(label_symbol) = token.kind
                                               ^236
   26|    236|        && let Some(next_token) = parser.peek_token(0)
   27|       |    {
   28|    236|        debug!(
   29|      0|            "parse_statement: identifier '{}' followed by {:?}",
   30|       |            label_symbol, next_token.kind
   31|       |        );
   32|    236|        if next_token.kind == TokenKind::Colon {
   33|     26|            debug!("parse_statement: found label pattern, calling parse_label_statement");
                                 ^0
   34|     26|            return parse_label_statement(parser, label_symbol);
   35|    210|        }
   36|    515|    }
   37|       |
   38|    725|    match token.kind {
   39|       |        TokenKind::LeftBrace => {
   40|     40|            let (node, _) = parse_compound_statement(parser)?;
                                                                          ^0
   41|     40|            Ok(node)
   42|       |        }
   43|     67|        TokenKind::If => parse_if_statement(parser),
   44|      6|        TokenKind::Switch => parse_switch_statement(parser),
   45|      6|        TokenKind::While => parse_while_statement(parser),
   46|      5|        TokenKind::Do => parse_do_while_statement(parser),
   47|      6|        TokenKind::For => parse_for_statement(parser),
   48|     10|        TokenKind::Goto => parse_goto_statement(parser),
   49|      3|        TokenKind::Continue => parse_continue_statement(parser),
   50|     13|        TokenKind::Break => parse_break_statement(parser),
   51|    303|        TokenKind::Return => parse_return_statement(parser),
   52|      4|        TokenKind::Semicolon => parse_empty_statement(parser),
   53|     11|        TokenKind::Case => parse_case_statement(parser),
   54|      3|        TokenKind::Default => parse_default_statement(parser),
   55|    248|        _ => parse_expression_statement(parser),
   56|       |    }
   57|    751|}
   58|       |
   59|       |/// Parse compound statement (block)
   60|    438|pub(crate) fn parse_compound_statement(parser: &mut Parser) -> Result<(ParsedNodeRef, SourceLoc), ParseError> {
   61|    438|    let token = parser.expect(TokenKind::LeftBrace)?;
                                                                 ^0
   62|    438|    let start_loc = token.span.start();
   63|    438|    let dummy = parser.push_dummy();
   64|       |
   65|    438|    let mut block_items = Vec::new();
   66|       |
   67|  1.41k|    while !parser.is_token(TokenKind::RightBrace) {
   68|    974|        let initial_idx = parser.current_idx;
   69|       |
   70|    974|        debug!(
   71|      0|            "parse_compound_statement: parsing block item, current token {:?}, position {}",
   72|      0|            parser.current_token_kind(),
   73|       |            initial_idx
   74|       |        );
   75|       |
   76|       |        // Try parsing as declaration first, but only if it looks like a declaration start
   77|    974|        let should_try_declaration = parser.starts_declaration();
   78|    974|        let mut declaration_attempt: Option<Result<ParsedNodeRef, ParseError>> = None;
   79|       |
   80|    974|        if should_try_declaration {
   81|    375|            let trx = parser.start_transaction();
   82|    375|            debug!(
   83|      0|                "parse_compound_statement: trying declaration parsing at position {}",
   84|       |                trx.parser.current_idx
   85|       |            );
   86|    375|            match super::declarations::parse_declaration(trx.parser) {
   87|    373|                Ok(declaration) => {
   88|    373|                    debug!("parse_compound_statement: successfully parsed declaration");
                                         ^0
   89|    373|                    block_items.push(declaration);
   90|    373|                    trx.commit();
   91|       |                }
   92|      2|                Err(decl_error) => {
   93|      2|                    debug!("parse_compound_statement: declaration parsing failed: {:?}", decl_error);
                                         ^0
   94|      2|                    declaration_attempt = Some(Err(decl_error));
   95|       |                }
   96|       |            }
   97|    599|        }
   98|       |
   99|       |        // If declaration failed or wasn't attempted, try as statement
  100|    974|        if declaration_attempt.is_some() || !should_try_declaration {
                                                          ^972
  101|    601|            if declaration_attempt.is_some() {
  102|      2|                debug!(
  103|      0|                    "parse_compound_statement: reset to position {}, trying statement",
  104|       |                    initial_idx
  105|       |                );
  106|       |            } else {
  107|    599|                debug!("parse_compound_statement: not a declaration start, trying statement");
                                     ^0
  108|       |            }
  109|       |
  110|    601|            match parse_statement(parser) {
  111|    598|                Ok(statement) => {
  112|    598|                    debug!("parse_compound_statement: successfully parsed statement");
                                         ^0
  113|    598|                    block_items.push(statement);
  114|       |                }
  115|      3|                Err(stmt_error) => {
  116|      3|                    debug!(
  117|      0|                        "parse_compound_statement: statement parsing also failed: {:?}",
  118|       |                        stmt_error
  119|       |                    );
  120|       |                    // Both declaration and statement parsing failed
  121|       |                    // Report the declaration error and try to synchronize
  122|      0|                    if let Some(Err(decl_error)) = declaration_attempt {
  123|      0|                        parser.diag.report(decl_error);
  124|      3|                    } else {
  125|      3|                        parser.diag.report(stmt_error);
  126|      3|                    }
  127|      3|                    parser.synchronize();
  128|       |                }
  129|       |            }
  130|    373|        }
  131|       |    }
  132|       |
  133|    438|    let right_brace_token = parser.expect(TokenKind::RightBrace)?;
                                                                              ^0
  134|    438|    let end_loc = right_brace_token.span.end();
  135|       |
  136|    438|    let span = SourceSpan::new(start_loc, end_loc);
  137|       |
  138|    438|    let node = parser.replace_node(dummy, ParsedNodeKind::CompoundStatement(block_items), span);
  139|    438|    Ok((node, end_loc))
  140|    438|}
  141|       |
  142|       |/// Parse if statement
  143|     67|fn parse_if_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  144|     67|    let token = parser.expect(TokenKind::If)?;
                                                          ^0
  145|     67|    let start_loc = token.span.start();
  146|       |
  147|     67|    let condition = parse_parenthesized_expr(parser)?;
                                                                  ^0
  148|     67|    let then_branch = parse_statement(parser)?;
                                                           ^0
  149|       |
  150|     67|    let else_branch = if parser.accept(TokenKind::Else).is_some() {
  151|      6|        Some(parse_statement(parser)?)
                                                  ^0
  152|       |    } else {
  153|     61|        None
  154|       |    };
  155|       |
  156|     67|    let end_loc = match &else_branch {
  157|      6|        Some(else_stmt) => parser.ast.get_node(*else_stmt).span.end(),
  158|     61|        None => parser.ast.get_node(then_branch).span.end(),
  159|       |    };
  160|       |
  161|     67|    let span = SourceSpan::new(start_loc, end_loc);
  162|       |
  163|     67|    let if_stmt = ParsedIfStmt {
  164|     67|        condition,
  165|     67|        then_branch,
  166|     67|        else_branch,
  167|     67|    };
  168|       |
  169|     67|    let node = parser.push_node(ParsedNodeKind::If(if_stmt), span);
  170|     67|    Ok(node)
  171|     67|}
  172|       |
  173|       |/// Parse switch statement
  174|      6|fn parse_switch_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  175|      6|    let token = parser.expect(TokenKind::Switch)?;
                                                              ^0
  176|      6|    let start_loc = token.span.start();
  177|       |
  178|      6|    let condition = parse_parenthesized_expr(parser)?;
                                                                  ^0
  179|       |
  180|      6|    debug!("parse_for_statement: parsing body");
                         ^0
  181|       |
  182|      6|    let body = parse_statement(parser)?;
                                                    ^0
  183|       |
  184|      6|    let end_loc = parser.ast.get_node(body).span.end();
  185|       |
  186|      6|    let span = SourceSpan::new(start_loc, end_loc);
  187|       |
  188|      6|    let node = parser.push_node(ParsedNodeKind::Switch(condition, body), span);
  189|      6|    Ok(node)
  190|      6|}
  191|       |
  192|       |/// Parse while statement
  193|      6|fn parse_while_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  194|      6|    let token = parser.expect(TokenKind::While)?;
                                                             ^0
  195|      6|    let start_loc = token.span.start();
  196|       |
  197|      6|    let condition = parse_parenthesized_expr(parser)?;
                                                                  ^0
  198|      6|    let body = parse_statement(parser)?;
                                                    ^0
  199|       |
  200|      6|    let end_loc = parser.ast.get_node(body).span.end();
  201|       |
  202|      6|    let span = SourceSpan::new(start_loc, end_loc);
  203|       |
  204|      6|    let while_stmt = ParsedWhileStmt { condition, body };
  205|       |
  206|      6|    let node = parser.push_node(ParsedNodeKind::While(while_stmt), span);
  207|      6|    Ok(node)
  208|      6|}
  209|       |
  210|       |/// Parse do-while statement
  211|      5|fn parse_do_while_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  212|      5|    let token = parser.expect(TokenKind::Do)?;
                                                          ^0
  213|      5|    let start_loc = token.span.start();
  214|       |
  215|      5|    let body = parse_statement(parser)?;
                                                    ^0
  216|       |
  217|      5|    parser.expect(TokenKind::While)?;
                                                 ^0
  218|      5|    let condition = parse_parenthesized_expr(parser)?;
                                                                  ^0
  219|      5|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  220|      5|    let end_loc = semicolon_token.span.end();
  221|       |
  222|      5|    let span = SourceSpan::new(start_loc, end_loc);
  223|       |
  224|      5|    let node = parser.push_node(ParsedNodeKind::DoWhile(body, condition), span);
  225|      5|    Ok(node)
  226|      5|}
  227|       |
  228|       |/// Parse for statement
  229|      6|fn parse_for_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  230|      6|    let token = parser.expect(TokenKind::For)?;
                                                           ^0
  231|      6|    let start_loc = token.span.start();
  232|      6|    let dummy = parser.push_dummy();
  233|       |
  234|      6|    parser.expect(TokenKind::LeftParen)?;
                                                     ^0
  235|       |
  236|      6|    debug!("parse_for_statement: parsing initialization");
                         ^0
  237|       |
  238|       |    // Parse initialization
  239|      6|    let init = if parser.is_token(TokenKind::Semicolon) {
  240|      3|        None
  241|      3|    } else if parser.starts_declaration() {
  242|      2|        debug!("parse_for_statement: parsing declaration in init");
                             ^0
  243|       |        // Parse declaration specifiers
  244|      2|        let specifiers = parse_declaration_specifiers(parser)?;
                                                                           ^0
  245|      2|        let declarator_start_span = parser.current_token_span_or_empty();
  246|       |        // Parse declarator
  247|      2|        let declarator = parse_declarator(parser, None)?;
                                                                     ^0
  248|       |        // Parse initializer if present
  249|      2|        let initializer = if parser.accept(TokenKind::Assign).is_some() {
  250|      2|            Some(super::declaration_core::parse_initializer(parser)?)
                                                                                 ^0
  251|       |        } else {
  252|      0|            None
  253|       |        };
  254|       |
  255|      2|        let end_span = parser.last_token_span().unwrap_or(declarator_start_span);
  256|      2|        let span = declarator_start_span.merge(end_span);
  257|       |
  258|      2|        let init_declarator = ParsedInitDeclarator {
  259|      2|            declarator,
  260|      2|            initializer,
  261|      2|            span,
  262|      2|        };
  263|       |
  264|      2|        let declaration_data = ParsedDeclarationData {
  265|      2|            specifiers,
  266|      2|            init_declarators: thin_vec![init_declarator],
  267|      2|        };
  268|       |
  269|       |        // Don't consume semicolon here - it will be consumed by the normal for loop flow
  270|      2|        let span = SourceSpan::new(start_loc, parser.current_token_span()?.end());
                                                                                       ^0
  271|       |
  272|      2|        Some(parser.push_node(ParsedNodeKind::Declaration(declaration_data), span))
  273|       |    } else {
  274|      1|        debug!("parse_for_statement: parsing expression in init");
                             ^0
  275|      1|        Some(parser.parse_expr_min()?)
                                                  ^0
  276|       |    };
  277|       |
  278|      6|    parser.expect(TokenKind::Semicolon)?;
                                                     ^0
  279|       |
  280|      6|    debug!("parse_for_statement: parsing condition");
                         ^0
  281|       |
  282|       |    // Parse condition
  283|      6|    let condition = if parser.is_token(TokenKind::Semicolon) {
  284|      1|        None
  285|       |    } else {
  286|      5|        Some(parser.parse_expr_min()?)
                                                  ^0
  287|       |    };
  288|       |
  289|      6|    parser.expect(TokenKind::Semicolon)?;
                                                     ^0
  290|       |
  291|      6|    debug!("parse_for_statement: parsing increment");
                         ^0
  292|       |
  293|       |    // Parse increment
  294|      6|    let increment = if parser.is_token(TokenKind::RightParen) {
  295|      2|        None
  296|       |    } else {
  297|      4|        Some(parser.parse_expr_min()?)
                                                  ^0
  298|       |    };
  299|       |
  300|      6|    parser.expect(TokenKind::RightParen)?;
                                                      ^0
  301|       |
  302|      6|    let body = parse_statement(parser)?;
                                                    ^0
  303|       |
  304|      6|    let end_loc = parser.ast.get_node(body).span.end();
  305|       |
  306|      6|    let span = SourceSpan::new(start_loc, end_loc);
  307|       |
  308|      6|    let for_stmt = ParsedForStmt {
  309|      6|        init,
  310|      6|        condition,
  311|      6|        increment,
  312|      6|        body,
  313|      6|    };
  314|       |
  315|      6|    let node = parser.replace_node(dummy, ParsedNodeKind::For(for_stmt), span);
  316|      6|    Ok(node)
  317|      6|}
  318|       |
  319|       |/// Parse goto statement
  320|     10|fn parse_goto_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  321|     10|    let token = parser.expect(TokenKind::Goto)?;
                                                            ^0
  322|     10|    let start_loc = token.span.start();
  323|       |
  324|     10|    let (label, _) = parser.expect_name()?;
                                                       ^0
  325|       |
  326|     10|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  327|     10|    let end_loc = semicolon_token.span.end();
  328|       |
  329|     10|    let span = SourceSpan::new(start_loc, end_loc);
  330|     10|    let node = parser.push_node(ParsedNodeKind::Goto(label), span);
  331|     10|    Ok(node)
  332|     10|}
  333|       |
  334|       |/// Parse continue statement
  335|      3|fn parse_continue_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  336|      3|    let token = parser.expect(TokenKind::Continue)?;
                                                                ^0
  337|      3|    let start_loc = token.span.start();
  338|       |
  339|      3|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  340|      3|    let end_loc = semicolon_token.span.end();
  341|       |
  342|      3|    let span = SourceSpan::new(start_loc, end_loc);
  343|       |
  344|      3|    let node = parser.push_node(ParsedNodeKind::Continue, span);
  345|      3|    Ok(node)
  346|      3|}
  347|       |
  348|       |/// Parse break statement
  349|     13|fn parse_break_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  350|     13|    let token = parser.expect(TokenKind::Break)?;
                                                             ^0
  351|     13|    let start_loc = token.span.start();
  352|       |
  353|     13|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  354|     13|    let end_loc = semicolon_token.span.end();
  355|       |
  356|     13|    let span = SourceSpan::new(start_loc, end_loc);
  357|       |
  358|     13|    let node = parser.push_node(ParsedNodeKind::Break, span);
  359|     13|    Ok(node)
  360|     13|}
  361|       |
  362|       |/// Parse return statement
  363|    303|fn parse_return_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  364|    303|    let token = parser.expect(TokenKind::Return)?;
                                                              ^0
  365|    303|    let start_loc = token.span.start();
  366|       |
  367|    303|    let value = if parser.is_token(TokenKind::Semicolon) {
  368|      3|        None
  369|       |    } else {
  370|    300|        let expr = parser.parse_expr_min()?;
                                                        ^0
  371|    300|        Some(expr)
  372|       |    };
  373|       |
  374|    303|    let semicolon_token = parser.expect(TokenKind::Semicolon)?;
                                                                           ^0
  375|    303|    let end_loc = semicolon_token.span.end();
  376|       |
  377|    303|    let span = SourceSpan::new(start_loc, end_loc);
  378|       |
  379|    303|    let node = parser.push_node(ParsedNodeKind::Return(value), span);
  380|    303|    Ok(node)
  381|    303|}
  382|       |
  383|       |/// Parse empty statement
  384|      4|fn parse_empty_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  385|      4|    let token = parser.expect(TokenKind::Semicolon)?;
                                                                 ^0
  386|      4|    let span = token.span;
  387|      4|    let node = parser.push_node(ParsedNodeKind::EmptyStatement, span);
  388|      4|    Ok(node)
  389|      4|}
  390|       |
  391|       |/// Parse case statement (including GNU case ranges)
  392|     11|fn parse_case_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  393|     11|    let token = parser.expect(TokenKind::Case)?;
                                                            ^0
  394|     11|    let start_loc = token.span.start();
  395|       |
  396|     11|    let start_expr = parser.parse_expr_min()?;
                                                          ^0
  397|       |
  398|       |    // Check for GNU case range extension: case 1 ... 10:
  399|     11|    let (end_expr, is_range) = if parser.accept(TokenKind::Ellipsis).is_some() {
  400|      3|        let end_expr = parser.parse_expr_min()?;
                                                            ^0
  401|      3|        (Some(end_expr), true)
  402|       |    } else {
  403|      8|        (None, false)
  404|       |    };
  405|       |
  406|     11|    parser.expect(TokenKind::Colon)?;
                                                 ^0
  407|       |
  408|     11|    let statement = parse_statement(parser)?;
                                                         ^0
  409|       |
  410|     11|    let end_loc = parser.ast.get_node(statement).span.end();
  411|       |
  412|     11|    let span = SourceSpan::new(start_loc, end_loc);
  413|       |
  414|     11|    let node = if is_range {
  415|      3|        parser.push_node(
  416|      3|            ParsedNodeKind::CaseRange(start_expr, end_expr.unwrap(), statement),
  417|      3|            span,
  418|       |        )
  419|       |    } else {
  420|      8|        parser.push_node(ParsedNodeKind::Case(start_expr, statement), span)
  421|       |    };
  422|     11|    Ok(node)
  423|     11|}
  424|       |
  425|       |/// Parse default statement
  426|      3|fn parse_default_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  427|      3|    let token = parser.expect(TokenKind::Default)?;
                                                               ^0
  428|      3|    let start_loc = token.span.start();
  429|       |
  430|      3|    parser.expect(TokenKind::Colon)?;
                                                 ^0
  431|       |
  432|      3|    let statement = parse_statement(parser)?;
                                                         ^0
  433|      3|    let end_loc = parser.ast.get_node(statement).span.end();
  434|       |
  435|      3|    let span = SourceSpan::new(start_loc, end_loc);
  436|       |
  437|      3|    let node = parser.push_node(ParsedNodeKind::Default(statement), span);
  438|      3|    Ok(node)
  439|      3|}
  440|       |
  441|       |/// Parse label statement
  442|     26|fn parse_label_statement(parser: &mut Parser, label_symbol: NameId) -> Result<ParsedNodeRef, ParseError> {
  443|     26|    let token = parser.advance().unwrap(); // consume the identifier
  444|     26|    let start_loc = token.span.start();
  445|       |
  446|     26|    parser.expect(TokenKind::Colon)?; // consume the colon
                                                 ^0
  447|       |
  448|     26|    let statement = parse_statement(parser)?;
                                                         ^0
  449|     26|    let end_loc = parser.ast.get_node(statement).span.end();
  450|       |
  451|     26|    let span = SourceSpan::new(start_loc, end_loc);
  452|       |
  453|       |    // ParsedNodeKind::Label(NameId, ParsedNodeRef)
  454|     26|    let node = parser.push_node(ParsedNodeKind::Label(label_symbol, statement), span);
  455|     26|    Ok(node)
  456|     26|}
  457|       |
  458|       |/// Parse expression statement
  459|    248|fn parse_expression_statement(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
  460|    248|    let start_loc = parser.current_token_span()?.start();
                                                             ^0
  461|    248|    let dummy = parser.push_dummy();
  462|       |
  463|    248|    let (semi, expr) = if let Some(token) = parser.accept(TokenKind::Semicolon) {
                       ^245  ^245                ^0
  464|      0|        (token, None)
  465|       |    } else {
  466|    248|        let expr = parser.parse_expr_min()?;
                          ^246                          ^2
  467|    246|        (parser.expect(TokenKind::Semicolon)?, Some(expr))
                                                          ^1 ^245
  468|       |    };
  469|       |
  470|    245|    let end_loc = semi.span.end();
  471|    245|    let span = SourceSpan::new(start_loc, end_loc);
  472|       |
  473|    245|    let node = parser.replace_node(dummy, ParsedNodeKind::ExpressionStatement(expr), span);
  474|    245|    Ok(node)
  475|    248|}

/app/src/parser/struct_parsing.rs:
    1|       |//! Struct and union parsing module
    2|       |//!
    3|       |//! This module handles parsing of struct and union declarations,
    4|       |//! including member declarations and anonymous structs/unions.
    5|       |
    6|       |use thin_vec::{ThinVec, thin_vec};
    7|       |
    8|       |use crate::ast::*;
    9|       |use crate::diagnostic::ParseError;
   10|       |use crate::parser::TokenKind;
   11|       |
   12|       |use super::Parser;
   13|       |
   14|       |/// Parse struct or union specifier with context
   15|    258|pub(crate) fn parse_record_specifier_with_context(
   16|    258|    parser: &mut Parser,
   17|    258|    is_union: bool,
   18|    258|    in_struct_member: bool,
   19|    258|) -> Result<ParsedTypeSpecifier, ParseError> {
   20|       |    // Check for __attribute__ after struct/union keyword (GCC extension)
   21|    258|    if parser.is_token(TokenKind::Attribute)
   22|      0|        && let Err(_e) = super::declaration_core::parse_attribute(parser)
   23|      0|    {
   24|      0|        // For now, ignore attribute parsing errors
   25|    258|    }
   26|       |
   27|    258|    let tag = parser.accept_name();
   28|       |
   29|       |    // In struct member context, only parse members if we have a specific tag
   30|       |    // to avoid confusion with anonymous nested structs
   31|    258|    let definition = if parser.accept(TokenKind::LeftBrace).is_some() && (!in_struct_member || tag.is_some()) {
                                                                                        ^123                 ^0  ^0
   32|    123|        let members = parse_struct_declaration_list(parser)?;
                                                                         ^0
   33|    123|        parser.expect(TokenKind::RightBrace)?;
                                                          ^0
   34|       |
   35|       |        // Check for __attribute__ after struct definition (GCC extension)
   36|    123|        if parser.is_token(TokenKind::Attribute)
   37|      0|            && let Err(_e) = super::declaration_core::parse_attribute(parser)
   38|      0|        {
   39|      0|            // For now, ignore attribute parsing errors
   40|    123|        }
   41|       |
   42|    123|        Some(ParsedRecordDefData {
   43|    123|            tag,
   44|    123|            members: Some(members),
   45|    123|            is_union,
   46|    123|        })
   47|       |    } else {
   48|    135|        None
   49|       |    };
   50|       |
   51|    258|    Ok(ParsedTypeSpecifier::Record(is_union, tag, definition))
   52|    258|}
   53|       |
   54|       |/// Parse struct declaration list
   55|    136|fn parse_struct_declaration_list(parser: &mut Parser) -> Result<Vec<ParsedDeclarationData>, ParseError> {
   56|    136|    let mut declarations = Vec::new();
   57|       |
   58|    351|    while !parser.is_token(TokenKind::RightBrace) {
   59|    215|        let declaration = parse_struct_declaration(parser)?;
                                                                        ^0
   60|    215|        declarations.push(declaration);
   61|       |    }
   62|       |
   63|    136|    Ok(declarations)
   64|    136|}
   65|       |
   66|       |/// Parse struct declaration
   67|    215|fn parse_struct_declaration(parser: &mut Parser) -> Result<ParsedDeclarationData, ParseError> {
   68|       |    // Check if we have an anonymous struct/union
   69|    215|    let is_struct = parser.accept(TokenKind::Struct).is_some();
   70|    215|    let is_union = if !is_struct {
   71|    195|        parser.accept(TokenKind::Union).is_some()
   72|       |    } else {
   73|     20|        false
   74|       |    };
   75|    215|    if is_struct || is_union {
                                  ^195
   76|       |        // Check if this is an anonymous struct
   77|     25|        if parser.is_token(TokenKind::LeftBrace) {
   78|       |            // Anonymous struct definition
   79|     13|            parser.expect(TokenKind::LeftBrace)?;
                                                             ^0
   80|     13|            let members = parse_struct_declaration_list(parser)?;
                                                                             ^0
   81|     13|            parser.expect(TokenKind::RightBrace)?;
                                                              ^0
   82|       |
   83|       |            // After parsing { members }, check the next token
   84|       |            // If the next token is ';', treat it as an anonymous struct member (no declarator needed)
   85|       |            // If the next token is an identifier or declarator start, continue with variable declaration parsing
   86|     13|            let init_declarators = if parser.is_token(TokenKind::Semicolon) {
   87|       |                // Anonymous struct member: struct { members };
   88|     12|                parser.expect(TokenKind::Semicolon)?;
                                                                 ^0
   89|     12|                ThinVec::new()
   90|       |            } else {
   91|       |                // Variable declaration with anonymous struct type: struct { members } variable;
   92|      1|                let mut init_declarators = ThinVec::new();
   93|       |                loop {
   94|      1|                    let start_span = parser.current_token_span_or_empty();
   95|      1|                    let declarator = super::declarator::parse_declarator(parser, None)?;
                                                                                                    ^0
   96|      1|                    let end_span = parser.last_token_span().unwrap_or(start_span);
   97|      1|                    let span = start_span.merge(end_span);
   98|       |
   99|      1|                    init_declarators.push(ParsedInitDeclarator {
  100|      1|                        declarator,
  101|      1|                        initializer: None,
  102|      1|                        span,
  103|      1|                    });
  104|       |
  105|      1|                    if parser.accept(TokenKind::Comma).is_none() {
  106|      1|                        break;
  107|      0|                    }
  108|       |                }
  109|      1|                init_declarators
  110|       |            };
  111|       |
  112|     13|            let type_specifier = ParsedTypeSpecifier::Record(
  113|     13|                is_union,
  114|     13|                None,
  115|     13|                Some(ParsedRecordDefData {
  116|     13|                    tag: None,
  117|     13|                    members: Some(members),
  118|     13|                    is_union,
  119|     13|                }),
  120|     13|            );
  121|       |
  122|     13|            let specifiers = thin_vec![ParsedDeclSpecifier::TypeSpecifier(type_specifier)];
  123|       |
  124|       |            // Only expect semicolon if we haven't already consumed it in the anonymous case
  125|     13|            if !init_declarators.is_empty() {
  126|      1|                parser.expect(TokenKind::Semicolon)?;
                                                                 ^0
  127|     12|            }
  128|       |
  129|     13|            Ok(ParsedDeclarationData {
  130|     13|                specifiers,
  131|     13|                init_declarators,
  132|     13|            })
  133|       |        } else {
  134|       |            // Named struct - read the tag first
  135|     12|            let tag = parser.accept_name();
  136|       |
  137|       |            // Check if it's defined inline
  138|     12|            if parser.is_token(TokenKind::LeftBrace) {
  139|       |                // Named struct with definition
  140|      0|                parser.expect(TokenKind::LeftBrace)?;
  141|      0|                let members = parse_struct_declaration_list(parser)?;
  142|      0|                parser.expect(TokenKind::RightBrace)?;
  143|       |
  144|       |                // After parsing { members }, check the next token
  145|      0|                let init_declarators = if parser.is_token(TokenKind::Semicolon) {
  146|       |                    // Named struct definition: struct tag { members };
  147|      0|                    parser.expect(TokenKind::Semicolon)?;
  148|      0|                    ThinVec::new()
  149|       |                } else {
  150|       |                    // Variable declaration with named struct type: struct tag { members } variable;
  151|      0|                    let mut init_declarators = ThinVec::new();
  152|       |                    loop {
  153|      0|                        let start_span = parser.current_token_span_or_empty();
  154|      0|                        let declarator = super::declarator::parse_declarator(parser, None)?;
  155|      0|                        let end_span = parser.last_token_span().unwrap_or(start_span);
  156|      0|                        let span = start_span.merge(end_span);
  157|       |
  158|      0|                        init_declarators.push(ParsedInitDeclarator {
  159|      0|                            declarator,
  160|      0|                            initializer: None,
  161|      0|                            span,
  162|      0|                        });
  163|       |
  164|      0|                        if parser.accept(TokenKind::Comma).is_none() {
  165|      0|                            break;
  166|      0|                        }
  167|       |                    }
  168|      0|                    init_declarators
  169|       |                };
  170|       |
  171|      0|                let type_specifier = ParsedTypeSpecifier::Record(
  172|      0|                    is_union,
  173|      0|                    tag,
  174|      0|                    Some(ParsedRecordDefData {
  175|      0|                        tag,
  176|      0|                        members: Some(members),
  177|      0|                        is_union,
  178|      0|                    }),
  179|      0|                );
  180|       |
  181|      0|                let specifiers = thin_vec![ParsedDeclSpecifier::TypeSpecifier(type_specifier)];
  182|       |
  183|       |                // Only expect semicolon if we haven't already consumed it
  184|      0|                if !init_declarators.is_empty() {
  185|      0|                    parser.expect(TokenKind::Semicolon)?;
  186|      0|                }
  187|       |
  188|      0|                Ok(ParsedDeclarationData {
  189|      0|                    specifiers,
  190|      0|                    init_declarators,
  191|      0|                })
  192|       |            } else {
  193|       |                // Named struct type with declarators: struct tag declarator1, declarator2;
  194|       |                // OR forward declaration: struct tag;
  195|     12|                let type_specifier = ParsedTypeSpecifier::Record(is_union, tag, None);
  196|       |
  197|     12|                let specifiers = thin_vec![ParsedDeclSpecifier::TypeSpecifier(type_specifier)];
  198|       |
  199|       |                // Check if there are declarators following
  200|     12|                if parser.is_token(TokenKind::Semicolon) {
  201|       |                    // Just a forward declaration: struct tag;
  202|      0|                    parser.expect(TokenKind::Semicolon)?;
  203|       |
  204|      0|                    Ok(ParsedDeclarationData {
  205|      0|                        specifiers,
  206|      0|                        init_declarators: ThinVec::new(),
  207|      0|                    })
  208|       |                } else {
  209|       |                    // Named struct type with declarators: struct tag declarator1, declarator2;
  210|     12|                    let mut init_declarators = ThinVec::new();
  211|       |                    loop {
  212|     13|                        let start_span = parser.current_token_span_or_empty();
  213|     13|                        let declarator = super::declarator::parse_declarator(parser, None)?;
                                                                                                        ^0
  214|     13|                        let end_span = parser.last_token_span().unwrap_or(start_span);
  215|     13|                        let span = start_span.merge(end_span);
  216|       |
  217|     13|                        init_declarators.push(ParsedInitDeclarator {
  218|     13|                            declarator,
  219|     13|                            initializer: None,
  220|     13|                            span,
  221|     13|                        });
  222|       |
  223|     13|                        if parser.accept(TokenKind::Comma).is_none() {
  224|     12|                            break;
  225|      1|                        }
  226|       |                    }
  227|       |
  228|     12|                    parser.expect(TokenKind::Semicolon)?;
                                                                     ^0
  229|       |
  230|     12|                    Ok(ParsedDeclarationData {
  231|     12|                        specifiers,
  232|     12|                        init_declarators,
  233|     12|                    })
  234|       |                }
  235|       |            }
  236|       |        }
  237|       |    } else {
  238|       |        // Regular member: declaration specifiers + multiple declarators
  239|    190|        let specifiers = super::declaration_core::parse_declaration_specifiers(parser)?;
                                                                                                    ^0
  240|       |
  241|    190|        let mut init_declarators = ThinVec::new();
  242|       |        loop {
  243|    203|            let start_span = parser.current_token_span_or_empty();
  244|    203|            let declarator = super::declarator::parse_declarator(parser, None)?; // This needs to enable ParsedDeclarator
                                                                                            ^0
  245|    203|            let end_span = parser.last_token_span().unwrap_or(start_span);
  246|    203|            let span = start_span.merge(end_span);
  247|       |
  248|    203|            init_declarators.push(ParsedInitDeclarator {
  249|    203|                declarator,
  250|    203|                initializer: None,
  251|    203|                span,
  252|    203|            });
  253|       |
  254|    203|            if parser.accept(TokenKind::Comma).is_none() {
  255|    190|                break;
  256|     13|            }
  257|       |        }
  258|       |
  259|    190|        parser.expect(TokenKind::Semicolon)?;
                                                         ^0
  260|       |
  261|    190|        Ok(ParsedDeclarationData {
  262|    190|            specifiers,
  263|    190|            init_declarators,
  264|    190|        })
  265|       |    }
  266|    215|}

/app/src/parser/type_specifiers.rs:
    1|       |//! Type specifier parsing module
    2|       |//!
    3|       |//! This module handles parsing of C type specifiers including basic types,
    4|       |//! typedef names, struct/union/enum specifiers, and atomic types.
    5|       |
    6|       |use crate::ast::*;
    7|       |use crate::diagnostic::ParseError;
    8|       |use crate::parser::TokenKind;
    9|       |
   10|       |use super::Parser;
   11|       |
   12|       |/// Parse type specifier
   13|  2.54k|pub(crate) fn parse_type_specifier(parser: &mut Parser) -> Result<ParsedTypeSpecifier, ParseError> {
   14|  2.54k|    parse_type_specifier_with_context(parser, false)
   15|  2.54k|}
   16|       |
   17|       |/// Parse type specifier with context
   18|  2.54k|fn parse_type_specifier_with_context(
   19|  2.54k|    parser: &mut Parser,
   20|  2.54k|    in_struct_member: bool,
   21|  2.54k|) -> Result<ParsedTypeSpecifier, ParseError> {
   22|  2.54k|    let token = parser.try_current_token().ok_or_else(|| ParseError::UnexpectedEof {
   23|      0|        span: parser.previous_token_span(),
   24|      0|    })?;
   25|       |
   26|  2.54k|    match token.kind {
   27|       |        TokenKind::Void => {
   28|    284|            parser.advance();
   29|    284|            Ok(ParsedTypeSpecifier::Void)
   30|       |        }
   31|       |        TokenKind::Char => {
   32|    117|            parser.advance();
   33|    117|            Ok(ParsedTypeSpecifier::Char)
   34|       |        }
   35|       |        TokenKind::Short => {
   36|     24|            parser.advance();
   37|     24|            Ok(ParsedTypeSpecifier::Short)
   38|       |        }
   39|       |        TokenKind::Int => {
   40|  1.36k|            parser.advance();
   41|  1.36k|            Ok(ParsedTypeSpecifier::Int)
   42|       |        }
   43|       |        TokenKind::Long => {
   44|    141|            parser.advance();
   45|       |            // Check for long long or long double
   46|    141|            if let Some(next_token) = parser.try_current_token() {
   47|    141|                match next_token.kind {
   48|       |                    TokenKind::Long => {
   49|     67|                        parser.advance();
   50|     67|                        Ok(ParsedTypeSpecifier::LongLong)
   51|       |                    }
   52|       |                    TokenKind::Double => {
   53|     14|                        parser.advance();
   54|     14|                        Ok(ParsedTypeSpecifier::LongDouble)
   55|       |                    }
   56|     60|                    _ => Ok(ParsedTypeSpecifier::Long),
   57|       |                }
   58|       |            } else {
   59|      0|                Ok(ParsedTypeSpecifier::Long)
   60|       |            }
   61|       |        }
   62|       |        TokenKind::Float => {
   63|     53|            parser.advance();
   64|     53|            Ok(ParsedTypeSpecifier::Float)
   65|       |        }
   66|       |        TokenKind::Double => {
   67|     40|            parser.advance();
   68|     40|            Ok(ParsedTypeSpecifier::Double)
   69|       |        }
   70|       |        TokenKind::Signed => {
   71|     25|            parser.advance();
   72|     25|            Ok(ParsedTypeSpecifier::Signed)
   73|       |        }
   74|       |        TokenKind::Unsigned => {
   75|     77|            parser.advance();
   76|     77|            Ok(ParsedTypeSpecifier::Unsigned)
   77|       |        }
   78|       |        TokenKind::Bool => {
   79|      7|            parser.advance();
   80|      7|            Ok(ParsedTypeSpecifier::Bool)
   81|       |        }
   82|       |        TokenKind::Complex => {
   83|     57|            parser.advance();
   84|     57|            Ok(ParsedTypeSpecifier::Complex)
   85|       |        }
   86|       |        TokenKind::Struct => {
   87|    250|            parser.advance();
   88|    250|            super::struct_parsing::parse_record_specifier_with_context(parser, false, in_struct_member)
   89|       |        }
   90|       |        TokenKind::Union => {
   91|      8|            parser.advance();
   92|      8|            super::struct_parsing::parse_record_specifier_with_context(parser, true, in_struct_member)
   93|       |        }
   94|       |        TokenKind::Enum => {
   95|     26|            parser.advance();
   96|     26|            super::enum_parsing::parse_enum_specifier(parser)
   97|       |        }
   98|     62|        TokenKind::Identifier(symbol) => {
   99|     62|            parser.advance();
  100|     62|            Ok(ParsedTypeSpecifier::TypedefName(symbol))
  101|       |        }
  102|       |        TokenKind::BuiltinVaList => {
  103|      8|            parser.advance();
  104|      8|            Ok(ParsedTypeSpecifier::VaList)
  105|       |        }
  106|       |        _ => {
  107|      0|            let expected = "void, char, short, int, long, float, double, signed, unsigned, bool, complex, atomic, struct, union, enum, or identifier";
  108|      0|            Err(ParseError::UnexpectedToken {
  109|      0|                expected_tokens: expected.to_string(),
  110|      0|                found: token.kind,
  111|      0|                span: token.span,
  112|      0|            })
  113|       |        }
  114|       |    }
  115|  2.54k|}

/app/src/parser/utils.rs:
    1|       |//! Common parsing utilities and helper functions
    2|       |//!
    3|       |//! This module provides utility functions that abstract repetitive patterns
    4|       |//! found throughout the parser, including expression result handling,
    5|       |//! binding power utilities, and common parsing operations.
    6|       |
    7|       |use crate::ast::*;
    8|       |use crate::diagnostic::ParseError;
    9|       |use log::debug;
   10|       |
   11|       |use super::expressions::BindingPower;
   12|       |use super::{Parser, ParserState, TokenKind};
   13|       |
   14|       |/// Common expression parsing patterns
   15|       |pub(crate) mod expr_patterns {
   16|       |    use super::*;
   17|       |
   18|       |    /// Parse a parenthesized expression: (expression)
   19|     84|    pub(crate) fn parse_parenthesized_expr(parser: &mut Parser) -> Result<ParsedNodeRef, ParseError> {
   20|     84|        debug!("parse_parenthesized_expr: parsing parenthesized expression");
                             ^0
   21|     84|        parser.expect(TokenKind::LeftParen)?;
                                                         ^0
   22|     84|        let expr = parser.parse_expr_min()?;
                                                        ^0
   23|     84|        parser.expect(TokenKind::RightParen)?;
                                                          ^0
   24|     84|        Ok(expr)
   25|     84|    }
   26|       |
   27|       |    /// Parse a comma-separated list of expressions with specified binding power
   28|    121|    pub(crate) fn parse_expr_list(
   29|    121|        parser: &mut Parser,
   30|    121|        binding_power: BindingPower,
   31|    121|    ) -> Result<Vec<ParsedNodeRef>, ParseError> {
   32|    121|        debug!("parse_expr_list: parsing expression list");
                             ^0
   33|    121|        let mut args = Vec::new();
   34|       |
   35|    121|        if parser.is_token(TokenKind::RightParen) {
   36|     26|            return Ok(args);
   37|     95|        }
   38|       |
   39|       |        loop {
   40|    208|            let arg = parser.parse_expression(binding_power)?;
                                                                          ^0
   41|    208|            args.push(arg);
   42|       |
   43|    208|            if !parser.is_token(TokenKind::Comma) {
   44|     95|                break;
   45|    113|            }
   46|    113|            parser.advance(); // consume comma
   47|       |        }
   48|       |
   49|     95|        Ok(args)
   50|    121|    }
   51|       |}
   52|       |
   53|       |pub(crate) struct ParserTransaction<'a, 'arena, 'src> {
   54|       |    pub(crate) parser: &'a mut Parser<'arena, 'src>,
   55|       |    state: ParserState,
   56|       |    committed: bool,
   57|       |}
   58|       |
   59|       |impl<'a, 'arena, 'src> ParserTransaction<'a, 'arena, 'src> {
   60|  1.72k|    pub(crate) fn new(parser: &'a mut Parser<'arena, 'src>) -> Self {
   61|  1.72k|        let state = parser.save_state();
   62|  1.72k|        Self {
   63|  1.72k|            parser,
   64|  1.72k|            state,
   65|  1.72k|            committed: false,
   66|  1.72k|        }
   67|  1.72k|    }
   68|       |
   69|  1.32k|    pub(crate) fn commit(mut self) {
   70|  1.32k|        self.committed = true;
   71|  1.32k|    }
   72|       |}
   73|       |
   74|       |impl<'a, 'arena, 'src> Drop for ParserTransaction<'a, 'arena, 'src> {
   75|  1.72k|    fn drop(&mut self) {
   76|  1.72k|        if !self.committed {
   77|    398|            self.parser.restore_state(self.state.clone());
   78|  1.32k|        }
   79|  1.72k|    }
   80|       |}

/app/src/pp/dumper.rs:
    1|       |//! Preprocessor Dumper module
    2|       |//!
    3|       |//! This module handles dumping preprocessed tokens back to source text,
    4|       |//! with support for line markers and whitespace reconstruction.
    5|       |
    6|       |use crate::pp::{PPToken, PPTokenFlags, PPTokenKind};
    7|       |use crate::source_manager::SourceManager;
    8|       |use std::io::Write;
    9|       |
   10|       |/// Dumper for preprocessed output
   11|       |pub struct PPDumper<'a> {
   12|       |    tokens: &'a [PPToken],
   13|       |    source_manager: &'a SourceManager,
   14|       |    suppress_line_markers: bool,
   15|       |}
   16|       |
   17|       |impl<'a> PPDumper<'a> {
   18|       |    /// Create a new preprocessor dumper
   19|      3|    pub(crate) fn new(tokens: &'a [PPToken], source_manager: &'a SourceManager, suppress_line_markers: bool) -> Self {
   20|      3|        Self {
   21|      3|            tokens,
   22|      3|            source_manager,
   23|      3|            suppress_line_markers,
   24|      3|        }
   25|      3|    }
   26|       |
   27|       |    /// Dump preprocessed output to the given writer
   28|      3|    pub(crate) fn dump(&self, writer: &mut impl Write) -> std::io::Result<()> {
   29|      3|        if self.tokens.is_empty() {
   30|      0|            return Ok(());
   31|      3|        }
   32|       |
   33|       |        // Get the source buffer for the first token
   34|      3|        let first_token = &self.tokens[0];
   35|       |
   36|       |        // Initial heuristic: try to find the first non-macro-expanded token
   37|       |        // to establish the "current file" context. This prevents line markers
   38|       |        // generally being emitted for the file itself if it starts with a macro.
   39|      3|        let mut current_file_id = first_token.location.source_id();
   40|      3|        for token in self.tokens {
   41|      3|            if !token.flags.contains(PPTokenFlags::MACRO_EXPANDED) {
   42|      3|                current_file_id = token.location.source_id();
   43|      3|                break;
   44|      0|            }
   45|       |        }
   46|      3|        let mut current_buffer = self.source_manager.get_buffer(current_file_id);
   47|      3|        let mut last_pos = 0u32;
   48|      3|        let mut last_was_macro_expanded = false;
   49|       |
   50|     22|        for token in self.tokens {
                          ^19
   51|     19|            if token.kind == PPTokenKind::Eof {
   52|      0|                break;
   53|     19|            }
   54|       |
   55|       |            // Handle macro-expanded tokens (Level A: use canonical spelling)
   56|     19|            if token.flags.contains(PPTokenFlags::MACRO_EXPANDED) {
   57|       |                // Heuristic: if we are entering a macro expansion (previous was not macro),
   58|       |                // and there was whitespace at the current position in the source, print a space.
   59|       |                // This preserves separation like "return FOO" -> "return 123".
   60|      2|                if !last_was_macro_expanded {
   61|       |                    // Check if char at last_pos is whitespace
   62|      2|                    if let Some(&byte) = current_buffer.get(last_pos as usize)
   63|      2|                        && (byte as char).is_whitespace()
   64|       |                    {
   65|      2|                        write!(writer, " ")?;
                                                         ^0
   66|      0|                    }
   67|       |                } else {
   68|       |                    // Add space between consecutive macro-expanded tokens (linearization)
   69|      0|                    write!(writer, " ")?;
   70|       |                }
   71|       |
   72|       |                // For macro-expanded tokens, just print the canonical spelling
   73|       |                // No whitespace reconstruction for Level A - these tokens don't have
   74|       |                // meaningful source locations for whitespace calculation
   75|      2|                write!(writer, "{}", token.get_text())?;
                                                                    ^0
   76|      2|                last_was_macro_expanded = true;
   77|       |                // Don't update last_pos for macro-expanded tokens
   78|      2|                continue;
   79|     17|            }
   80|       |
   81|       |            // Check for file transitions and emit line markers
   82|     17|            if token.location.source_id() != current_file_id {
   83|       |                // Emit line marker for file transition (unless suppressed)
   84|      0|                if !self.suppress_line_markers
   85|      0|                    && let Some(file_info) = self.source_manager.get_file_info(token.location.source_id())
   86|       |                {
   87|      0|                    let line = self
   88|      0|                        .source_manager
   89|      0|                        .get_line_column(token.location)
   90|      0|                        .map(|(l, _)| l)
   91|      0|                        .unwrap_or(1);
   92|      0|                    let filename = file_info
   93|      0|                        .path
   94|      0|                        .file_name()
   95|      0|                        .and_then(|n| n.to_str())
   96|      0|                        .unwrap_or("<unknown>");
   97|       |
   98|       |                    // Ensure we start on a new line
   99|      0|                    writeln!(writer)?;
  100|      0|                    writeln!(writer, "# {} \"{}\" 1", line, filename)?;
  101|      0|                }
  102|       |
  103|      0|                current_file_id = token.location.source_id();
  104|      0|                current_buffer = self.source_manager.get_buffer(current_file_id);
  105|      0|                last_pos = token.location.offset();
  106|     17|            }
  107|       |
  108|     17|            let token_start = token.location.offset();
  109|     17|            let token_end = token_start + token.length as u32;
  110|       |
  111|       |            // Print all bytes between last_pos and token_start (whitespace, comments)
  112|     17|            if token_start > last_pos {
  113|     14|                let slice = &current_buffer[last_pos as usize..token_start as usize];
  114|       |                // Convert to string, assuming UTF-8 (preprocessor should ensure this)
  115|     14|                if let Ok(text) = std::str::from_utf8(slice) {
  116|       |                    // Only print slices that are all whitespace to avoid printing directive text
  117|     22|                    if text.chars().all(|c| c.is_whitespace()) {
                                     ^14          ^14
  118|     10|                        write!(writer, "{}", text)?;
                                                                ^0
  119|      4|                    }
  120|      0|                }
  121|      3|            }
  122|       |
  123|       |            // Print the token's raw bytes from source
  124|     17|            let token_slice = token.get_raw_slice(current_buffer);
  125|     17|            if let Ok(text) = std::str::from_utf8(token_slice) {
  126|     17|                write!(writer, "{}", text)?;
                                                        ^0
  127|      0|            }
  128|       |
  129|     17|            last_pos = token_end;
  130|     17|            last_was_macro_expanded = false;
  131|       |        }
  132|       |
  133|      3|        writeln!(writer)?;
                                      ^0
  134|      3|        Ok(())
  135|      3|    }
  136|       |}

/app/src/pp/header_search.rs:
    1|       |use std::path::{Path, PathBuf};
    2|       |
    3|       |/// Manages header search paths and include resolution
    4|       |#[derive(Clone)]
    5|       |pub(crate) struct HeaderSearch {
    6|       |    pub(crate) system_path: Vec<PathBuf>,
    7|       |    pub(crate) framework_path: Vec<PathBuf>,
    8|       |    pub(crate) quoted_includes: Vec<String>,
    9|       |    pub(crate) angled_includes: Vec<String>,
   10|       |}
   11|       |
   12|       |impl HeaderSearch {
   13|       |    /// Add a system include path
   14|     31|    pub(crate) fn add_system_path(&mut self, path: PathBuf) {
   15|     31|        self.system_path.push(path);
   16|     31|    }
   17|       |
   18|       |    /// Add a quoted include path (-iquote)
   19|      3|    pub(crate) fn add_quoted_path(&mut self, path: PathBuf) {
   20|      3|        self.quoted_includes.push(path.to_string_lossy().to_string());
   21|      3|    }
   22|       |
   23|       |    /// Add an angled include path (-I)
   24|      8|    pub(crate) fn add_angled_path(&mut self, path: PathBuf) {
   25|      8|        self.angled_includes.push(path.to_string_lossy().to_string());
   26|      8|    }
   27|       |
   28|       |    /// Add a framework path
   29|      1|    pub(crate) fn add_framework_path(&mut self, path: PathBuf) {
   30|      1|        self.framework_path.push(path);
   31|      1|    }
   32|       |
   33|       |    /// Resolve an include path to an absolute path
   34|     34|    pub(crate) fn resolve_path(&self, include_path: &str, is_angled: bool, current_dir: &Path) -> Option<PathBuf> {
   35|     34|        if is_angled {
   36|       |            // Angled includes: search angled_includes, then system_path, then framework_path
   37|     13|            self.check_paths(&self.angled_includes, include_path)
   38|     13|                .or_else(|| self.check_paths(&self.system_path, include_path))
                                          ^10  ^10         ^10                ^10
   39|     13|                .or_else(|| self.check_paths(&self.framework_path, include_path))
                                          ^7   ^7          ^7                    ^7
   40|       |        } else {
   41|       |            // Quoted includes: search current_dir, then quoted_includes, then angled_includes, then system_path, then framework_path
   42|     21|            let candidate = current_dir.join(include_path);
   43|     21|            if candidate.exists() {
   44|      2|                return Some(candidate);
   45|     19|            }
   46|     19|            self.check_paths(&self.quoted_includes, include_path)
   47|     19|                .or_else(|| self.check_paths(&self.angled_includes, include_path))
   48|     19|                .or_else(|| self.check_paths(&self.system_path, include_path))
   49|     19|                .or_else(|| self.check_paths(&self.framework_path, include_path))
                                          ^18  ^18         ^18                   ^18
   50|       |        }
   51|     34|    }
   52|       |
   53|       |    /// Helper to check a list of paths for an include file
   54|    105|    fn check_paths<P: AsRef<Path>>(&self, paths: &[P], include_path: &str) -> Option<PathBuf> {
   55|    112|        for path in paths {
                          ^15
   56|     15|            let candidate = path.as_ref().join(include_path);
   57|     15|            if candidate.exists() {
   58|      8|                return Some(candidate);
   59|      7|            }
   60|       |        }
   61|     97|        None
   62|    105|    }
   63|       |
   64|       |    /// Resolve an include path for #include_next, skipping the search path valid for current_dir
   65|      8|    pub(crate) fn resolve_next_path(&self, include_path: &str, is_angled: bool, current_dir: &Path) -> Option<PathBuf> {
   66|      8|        let mut found_current = false;
   67|       |
   68|      8|        if !is_angled {
   69|      6|            for path_str in &self.quoted_includes {
                              ^4
   70|      4|                let path: &Path = Path::new(path_str);
   71|      4|                if !found_current && current_dir.starts_with(path) {
                                                   ^3          ^3          ^3
   72|      2|                    found_current = true;
   73|      2|                    continue;
   74|      2|                }
   75|       |
   76|      2|                if found_current {
   77|      1|                    let candidate = path.join(include_path);
   78|      1|                    if candidate.exists() {
   79|      1|                        return Some(candidate);
   80|      0|                    }
   81|      1|                }
   82|       |            }
   83|      5|        }
   84|       |
   85|     16|        for path_str in &self.angled_includes {
                          ^13
   86|     13|            let path: &Path = Path::new(path_str);
   87|     13|            if !found_current && current_dir.starts_with(path) {
                                               ^9          ^9          ^9
   88|      6|                found_current = true;
   89|      6|                continue;
   90|      7|            }
   91|       |
   92|      7|            if found_current {
   93|      4|                let candidate = path.join(include_path);
   94|      4|                if candidate.exists() {
   95|      4|                    return Some(candidate);
   96|      0|                }
   97|      3|            }
   98|       |        }
   99|       |
  100|      3|        for path in &self.system_path {
                          ^1
  101|      1|            if !found_current && current_dir.starts_with(path) {
                                               ^0          ^0          ^0
  102|      0|                found_current = true;
  103|      0|                continue;
  104|      1|            }
  105|       |
  106|      1|            if found_current {
  107|      1|                let candidate = path.join(include_path);
  108|      1|                if candidate.exists() {
  109|      1|                    return Some(candidate);
  110|      0|                }
  111|      0|            }
  112|       |        }
  113|       |
  114|      2|        for path in &self.framework_path {
                          ^0
  115|      0|            if !found_current && current_dir.starts_with(path) {
  116|      0|                found_current = true;
  117|      0|                continue;
  118|      0|            }
  119|       |
  120|      0|            if found_current {
  121|      0|                let candidate = path.join(include_path);
  122|      0|                if candidate.exists() {
  123|      0|                    return Some(candidate);
  124|      0|                }
  125|      0|            }
  126|       |        }
  127|       |
  128|      2|        None
  129|      8|    }
  130|       |}

/app/src/pp/interpreter.rs:
    1|       |use crate::ast::StringId;
    2|       |use crate::ast::literal::IntegerSuffix;
    3|       |use crate::ast::literal_parsing;
    4|       |use crate::ast::{BinaryOp, UnaryOp};
    5|       |use crate::pp::{PPError, PPErrorKind, PPToken, PPTokenKind, Preprocessor};
    6|       |use crate::source_manager::{SourceLoc, SourceSpan};
    7|       |
    8|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
    9|       |pub(crate) struct ExprValue {
   10|       |    pub value: u64,
   11|       |    pub is_unsigned: bool,
   12|       |}
   13|       |
   14|       |impl ExprValue {
   15|    186|    pub(crate) fn new(value: u64, is_unsigned: bool) -> Self {
   16|    186|        ExprValue { value, is_unsigned }
   17|    186|    }
   18|       |
   19|     50|    fn from_bool(b: bool) -> Self {
   20|     50|        ExprValue {
   21|     50|            value: u64::from(b),
   22|     50|            is_unsigned: false,
   23|     50|        }
   24|     50|    }
   25|       |
   26|     88|    pub(crate) fn is_truthy(&self) -> bool {
   27|     88|        self.value != 0
   28|     88|    }
   29|       |}
   30|       |
   31|       |#[derive(Debug)]
   32|       |pub(crate) enum PPExpr {
   33|       |    Number(ExprValue),
   34|       |    Identifier(String),
   35|       |    Defined(Box<PPExpr>),
   36|       |    HasInclude(String, bool),
   37|       |    Binary(BinaryOp, Box<PPExpr>, Box<PPExpr>),
   38|       |    Unary(UnaryOp, Box<PPExpr>),
   39|       |    Conditional(Box<PPExpr>, Box<PPExpr>, Box<PPExpr>),
   40|       |}
   41|       |
   42|       |impl PPExpr {
   43|    239|    pub(crate) fn evaluate(&self, pp: &Preprocessor, span: SourceSpan) -> Result<ExprValue, PPError> {
   44|    239|        match self {
   45|    141|            PPExpr::Number(n) => Ok(*n),
   46|      0|            PPExpr::Identifier(_) => Ok(ExprValue::new(0, false)), // C11 6.10.1p4: All remaining identifiers are replaced with 0
   47|      1|            PPExpr::Defined(ident) => {
   48|      1|                if let PPExpr::Identifier(s) = &**ident {
   49|      1|                    Ok(ExprValue::from_bool(pp.is_macro_defined(&StringId::new(s))))
   50|       |                } else {
   51|      0|                    Err(Self::expr_error(span))
   52|       |                }
   53|       |            }
   54|      6|            PPExpr::HasInclude(path, is_angled) => Ok(ExprValue::from_bool(pp.check_header_exists(path, *is_angled))),
   55|     65|            PPExpr::Binary(op, left, right) => Self::eval_binary(*op, left, right, pp, span),
   56|     21|            PPExpr::Unary(op, operand) => Self::eval_unary(*op, operand, pp, span),
   57|      5|            PPExpr::Conditional(cond, true_e, false_e) => Self::eval_conditional(cond, true_e, false_e, pp, span),
   58|       |        }
   59|    239|    }
   60|       |
   61|      2|    fn expr_error(span: SourceSpan) -> PPError {
   62|      2|        PPError {
   63|      2|            kind: PPErrorKind::InvalidConditionalExpression,
   64|      2|            span,
   65|      2|        }
   66|      2|    }
   67|       |
   68|     21|    fn eval_unary(op: UnaryOp, operand: &PPExpr, pp: &Preprocessor, span: SourceSpan) -> Result<ExprValue, PPError> {
   69|     21|        let o = operand.evaluate(pp, span)?;
                                                        ^0
   70|     21|        Ok(match op {
   71|      1|            UnaryOp::Plus => o,
   72|     16|            UnaryOp::Minus => ExprValue::new(o.value.wrapping_neg(), o.is_unsigned),
   73|      2|            UnaryOp::BitNot => ExprValue::new(!o.value, o.is_unsigned),
   74|      2|            UnaryOp::LogicNot => ExprValue::from_bool(!o.is_truthy()),
   75|      0|            _ => unreachable!("Unsupported unary operator in preprocessor"),
   76|       |        })
   77|     21|    }
   78|       |
   79|      5|    fn eval_conditional(
   80|      5|        cond: &PPExpr,
   81|      5|        true_e: &PPExpr,
   82|      5|        false_e: &PPExpr,
   83|      5|        pp: &Preprocessor,
   84|      5|        span: SourceSpan,
   85|      5|    ) -> Result<ExprValue, PPError> {
   86|      5|        let c = cond.evaluate(pp, span)?;
                                                     ^0
   87|      5|        let t = true_e.evaluate(pp, span)?;
                                                       ^0
   88|      5|        let f = false_e.evaluate(pp, span)?;
                                                        ^0
   89|      5|        let is_unsigned = t.is_unsigned || f.is_unsigned;
   90|      5|        let chosen = if c.is_truthy() { t } else { f };
                                                      ^4         ^1
   91|      5|        Ok(if is_unsigned {
   92|      1|            ExprValue::new(chosen.value, true)
   93|       |        } else {
   94|      4|            chosen
   95|       |        })
   96|      5|    }
   97|       |
   98|     65|    fn eval_binary(
   99|     65|        op: BinaryOp,
  100|     65|        left: &PPExpr,
  101|     65|        right: &PPExpr,
  102|     65|        pp: &Preprocessor,
  103|     65|        span: SourceSpan,
  104|     65|    ) -> Result<ExprValue, PPError> {
  105|     65|        let l = left.evaluate(pp, span)?;
                                                     ^0
  106|       |
  107|       |        // Short-circuit evaluation for logical operators
  108|     65|        if op == BinaryOp::LogicAnd {
  109|      3|            return Ok(ExprValue::from_bool(
  110|      3|                l.is_truthy() && right.evaluate(pp, span)?.is_truthy(),
                                               ^2    ^2       ^2  ^2   ^0^2
  111|       |            ));
  112|     62|        }
  113|     62|        if op == BinaryOp::LogicOr {
  114|      2|            return Ok(ExprValue::from_bool(
  115|      2|                l.is_truthy() || right.evaluate(pp, span)?.is_truthy(),
                                               ^1    ^1       ^1  ^1   ^0^1
  116|       |            ));
  117|     60|        }
  118|       |
  119|     60|        let r = right.evaluate(pp, span)?;
                                                      ^0
  120|     60|        let is_unsigned = l.is_unsigned || r.is_unsigned;
                                                         ^51
  121|     60|        let (lv, rv) = (l.value, r.value);
  122|       |
  123|     60|        Ok(match op {
  124|      1|            BinaryOp::BitOr => ExprValue::new(lv | rv, is_unsigned),
  125|      1|            BinaryOp::BitXor => ExprValue::new(lv ^ rv, is_unsigned),
  126|      1|            BinaryOp::BitAnd => ExprValue::new(lv & rv, is_unsigned),
  127|     26|            BinaryOp::Equal => ExprValue::from_bool(lv == rv),
  128|      1|            BinaryOp::NotEqual => ExprValue::from_bool(lv != rv),
  129|      2|            BinaryOp::Less => Self::cmp(lv, rv, is_unsigned, i64::lt, u64::lt),
  130|      2|            BinaryOp::LessEqual => Self::cmp(lv, rv, is_unsigned, i64::le, u64::le),
  131|      3|            BinaryOp::Greater => Self::cmp(lv, rv, is_unsigned, i64::gt, u64::gt),
  132|      2|            BinaryOp::GreaterEqual => Self::cmp(lv, rv, is_unsigned, i64::ge, u64::ge),
  133|      1|            BinaryOp::LShift => ExprValue::new(lv.wrapping_shl(rv as u32), l.is_unsigned),
  134|       |            BinaryOp::RShift => {
  135|      2|                let shift = rv as u32;
  136|      2|                if l.is_unsigned {
  137|      1|                    ExprValue::new(lv.wrapping_shr(shift), true)
  138|       |                } else {
  139|      1|                    ExprValue::new(((lv as i64).wrapping_shr(shift)) as u64, false)
  140|       |                }
  141|       |            }
  142|      2|            BinaryOp::Add => ExprValue::new(lv.wrapping_add(rv), is_unsigned),
  143|      4|            BinaryOp::Sub => ExprValue::new(lv.wrapping_sub(rv), is_unsigned),
  144|      2|            BinaryOp::Mul => ExprValue::new(lv.wrapping_mul(rv), is_unsigned),
  145|      5|            BinaryOp::Div => Self::eval_div(lv, rv, is_unsigned, span)?,
                                                                                    ^1
  146|      5|            BinaryOp::Mod => Self::eval_mod(lv, rv, is_unsigned, span)?,
                                                                                    ^1
  147|      0|            _ => unreachable!(),
  148|       |        })
  149|     65|    }
  150|       |
  151|      9|    fn cmp(
  152|      9|        lv: u64,
  153|      9|        rv: u64,
  154|      9|        is_unsigned: bool,
  155|      9|        signed_f: fn(&i64, &i64) -> bool,
  156|      9|        unsigned_f: fn(&u64, &u64) -> bool,
  157|      9|    ) -> ExprValue {
  158|      9|        ExprValue::from_bool(if is_unsigned {
  159|      3|            unsigned_f(&lv, &rv)
  160|       |        } else {
  161|      6|            signed_f(&(lv as i64), &(rv as i64))
  162|       |        })
  163|      9|    }
  164|       |
  165|      5|    fn eval_div(lv: u64, rv: u64, is_unsigned: bool, span: SourceSpan) -> Result<ExprValue, PPError> {
  166|      5|        if rv == 0 {
  167|      1|            return Err(Self::expr_error(span));
  168|      4|        }
  169|      4|        Ok(if is_unsigned {
  170|      1|            ExprValue::new(lv / rv, true)
  171|       |        } else {
  172|      3|            let (ls, rs) = (lv as i64, rv as i64);
  173|      3|            ExprValue::new(
  174|      3|                if ls == i64::MIN && rs == -1 {
                                                   ^1
  175|      1|                    ls as u64
  176|       |                } else {
  177|      2|                    (ls / rs) as u64
  178|       |                },
  179|       |                false,
  180|       |            )
  181|       |        })
  182|      5|    }
  183|       |
  184|      5|    fn eval_mod(lv: u64, rv: u64, is_unsigned: bool, span: SourceSpan) -> Result<ExprValue, PPError> {
  185|      5|        if rv == 0 {
  186|      1|            return Err(Self::expr_error(span));
  187|      4|        }
  188|      4|        Ok(if is_unsigned {
  189|      1|            ExprValue::new(lv % rv, true)
  190|       |        } else {
  191|      3|            let (ls, rs) = (lv as i64, rv as i64);
  192|      3|            ExprValue::new(
  193|      3|                if ls == i64::MIN && rs == -1 {
                                                   ^1
  194|      1|                    0
  195|       |                } else {
  196|      2|                    (ls % rs) as u64
  197|       |                },
  198|       |                false,
  199|       |            )
  200|       |        })
  201|      5|    }
  202|       |}
  203|       |
  204|       |/// Expression interpreter for preprocessor arithmetic
  205|       |pub(crate) struct Interpreter<'a> {
  206|       |    tokens: &'a [PPToken],
  207|       |    pos: usize,
  208|       |    preprocessor: &'a Preprocessor<'a>,
  209|       |}
  210|       |
  211|       |impl<'a> Interpreter<'a> {
  212|     75|    pub(crate) fn new(tokens: &'a [PPToken], preprocessor: &'a Preprocessor<'a>) -> Self {
  213|     75|        Interpreter {
  214|     75|            tokens,
  215|     75|            pos: 0,
  216|     75|            preprocessor,
  217|     75|        }
  218|     75|    }
  219|       |
  220|     75|    fn current_span(&self) -> SourceSpan {
  221|     75|        let loc = self
  222|     75|            .tokens
  223|     75|            .get(self.pos)
  224|     75|            .or_else(|| self.tokens.last())
  225|     75|            .map_or(SourceLoc::builtin(), |t| t.location);
  226|     75|        SourceSpan::new(loc, loc)
  227|     75|    }
  228|       |
  229|      0|    fn error(&self) -> PPError {
  230|      0|        PPError {
  231|      0|            kind: PPErrorKind::InvalidConditionalExpression,
  232|      0|            span: self.current_span(),
  233|      0|        }
  234|      0|    }
  235|       |
  236|  1.48k|    fn peek(&self) -> Option<&PPTokenKind> {
  237|  1.48k|        self.tokens.get(self.pos).map(|t| &t.kind)
  238|  1.48k|    }
  239|       |
  240|    379|    fn at_end(&self) -> bool {
  241|    379|        self.pos >= self.tokens.len()
  242|    379|    }
  243|       |
  244|    325|    fn advance(&mut self) {
  245|    325|        self.pos += 1;
  246|    325|    }
  247|       |
  248|     39|    fn expect(&mut self, kind: PPTokenKind) -> Result<(), PPError> {
  249|     39|        if self.peek() == Some(&kind) {
  250|     39|            self.advance();
  251|     39|            Ok(())
  252|       |        } else {
  253|      0|            Err(self.error())
  254|       |        }
  255|     39|    }
  256|       |
  257|       |    /// Returns the current token or an error if at the end of the stream.
  258|    367|    fn current(&self) -> Result<&'a PPToken, PPError> {
  259|    367|        if self.at_end() {
  260|      0|            Err(self.error())
  261|       |        } else {
  262|    367|            Ok(&self.tokens[self.pos])
  263|       |        }
  264|    367|    }
  265|       |
  266|       |    /// Returns the current token and advances the position, or returns an error if at the end.
  267|    167|    fn next(&mut self) -> Result<&'a PPToken, PPError> {
  268|    167|        let token = self.current()?;
                                                ^0
  269|    167|        self.advance();
  270|    167|        Ok(token)
  271|    167|    }
  272|       |
  273|     75|    pub(crate) fn evaluate(&mut self) -> Result<ExprValue, PPError> {
  274|     75|        let expr = self.parse_conditional()?;
                                                         ^0
  275|     75|        expr.evaluate(self.preprocessor, self.current_span())
  276|     75|    }
  277|       |
  278|    106|    fn parse_conditional(&mut self) -> Result<PPExpr, PPError> {
  279|    106|        let cond = self.parse_or()?;
                                                ^0
  280|    106|        if self.peek() == Some(&PPTokenKind::Question) {
  281|      5|            self.advance();
  282|      5|            let true_e = self.parse_conditional()?;
                                                               ^0
  283|      5|            self.expect(PPTokenKind::Colon)?;
                                                         ^0
  284|      5|            let false_e = self.parse_conditional()?;
                                                                ^0
  285|      5|            Ok(PPExpr::Conditional(Box::new(cond), Box::new(true_e), Box::new(false_e)))
  286|       |        } else {
  287|    101|            Ok(cond)
  288|       |        }
  289|    106|    }
  290|       |
  291|    106|    fn parse_or(&mut self) -> Result<PPExpr, PPError> {
  292|    106|        self.parse_left_assoc(Self::parse_and, &[(PPTokenKind::LogicOr, BinaryOp::LogicOr)])
  293|    106|    }
  294|       |
  295|    108|    fn parse_and(&mut self) -> Result<PPExpr, PPError> {
  296|    108|        self.parse_left_assoc(Self::parse_bitwise_or, &[(PPTokenKind::LogicAnd, BinaryOp::LogicAnd)])
  297|    108|    }
  298|       |
  299|    111|    fn parse_bitwise_or(&mut self) -> Result<PPExpr, PPError> {
  300|    111|        self.parse_left_assoc(Self::parse_bitwise_xor, &[(PPTokenKind::Or, BinaryOp::BitOr)])
  301|    111|    }
  302|       |
  303|    112|    fn parse_bitwise_xor(&mut self) -> Result<PPExpr, PPError> {
  304|    112|        self.parse_left_assoc(Self::parse_bitwise_and, &[(PPTokenKind::Xor, BinaryOp::BitXor)])
  305|    112|    }
  306|       |
  307|    113|    fn parse_bitwise_and(&mut self) -> Result<PPExpr, PPError> {
  308|    113|        self.parse_left_assoc(Self::parse_equality, &[(PPTokenKind::And, BinaryOp::BitAnd)])
  309|    113|    }
  310|       |
  311|    114|    fn parse_equality(&mut self) -> Result<PPExpr, PPError> {
  312|    114|        self.parse_left_assoc(
  313|    114|            Self::parse_relational,
  314|    114|            &[
  315|    114|                (PPTokenKind::Equal, BinaryOp::Equal),
  316|    114|                (PPTokenKind::NotEqual, BinaryOp::NotEqual),
  317|    114|            ],
  318|       |        )
  319|    114|    }
  320|       |
  321|    141|    fn parse_relational(&mut self) -> Result<PPExpr, PPError> {
  322|    141|        self.parse_left_assoc(
  323|    141|            Self::parse_shift,
  324|    141|            &[
  325|    141|                (PPTokenKind::Less, BinaryOp::Less),
  326|    141|                (PPTokenKind::LessEqual, BinaryOp::LessEqual),
  327|    141|                (PPTokenKind::Greater, BinaryOp::Greater),
  328|    141|                (PPTokenKind::GreaterEqual, BinaryOp::GreaterEqual),
  329|    141|            ],
  330|       |        )
  331|    141|    }
  332|       |
  333|    150|    fn parse_shift(&mut self) -> Result<PPExpr, PPError> {
  334|    150|        self.parse_left_assoc(
  335|    150|            Self::parse_additive,
  336|    150|            &[
  337|    150|                (PPTokenKind::LeftShift, BinaryOp::LShift),
  338|    150|                (PPTokenKind::RightShift, BinaryOp::RShift),
  339|    150|            ],
  340|       |        )
  341|    150|    }
  342|       |
  343|    153|    fn parse_additive(&mut self) -> Result<PPExpr, PPError> {
  344|    153|        self.parse_left_assoc(
  345|    153|            Self::parse_multiplicative,
  346|    153|            &[(PPTokenKind::Plus, BinaryOp::Add), (PPTokenKind::Minus, BinaryOp::Sub)],
  347|       |        )
  348|    153|    }
  349|       |
  350|    159|    fn parse_multiplicative(&mut self) -> Result<PPExpr, PPError> {
  351|    159|        self.parse_left_assoc(
  352|    159|            Self::parse_unary,
  353|    159|            &[
  354|    159|                (PPTokenKind::Star, BinaryOp::Mul),
  355|    159|                (PPTokenKind::Slash, BinaryOp::Div),
  356|    159|                (PPTokenKind::Percent, BinaryOp::Mod),
  357|    159|            ],
  358|       |        )
  359|    159|    }
  360|       |
  361|       |    /// Generic left-associative binary operator parser.
  362|  1.26k|    fn parse_left_assoc(
  363|  1.26k|        &mut self,
  364|  1.26k|        next: fn(&mut Self) -> Result<PPExpr, PPError>,
  365|  1.26k|        ops: &[(PPTokenKind, BinaryOp)],
  366|  1.26k|    ) -> Result<PPExpr, PPError> {
  367|  1.26k|        let mut left = next(self)?;
                                               ^0
  368|  1.33k|        while let Some(kind) = self.peek() {
                                     ^584
  369|  1.18k|            if let Some((_, bin_op)) = ops.iter().find(|(tk, _)| tk == kind) {
                                          ^67        ^584       ^584
  370|     67|                self.advance();
  371|     67|                let right = next(self)?;
                                                    ^0
  372|     67|                left = PPExpr::Binary(*bin_op, Box::new(left), Box::new(right));
  373|       |            } else {
  374|    517|                break;
  375|       |            }
  376|       |        }
  377|  1.26k|        Ok(left)
  378|  1.26k|    }
  379|       |
  380|    194|    fn parse_unary(&mut self) -> Result<PPExpr, PPError> {
  381|    194|        let token = self.current()?;
                                                ^0
  382|       |
  383|       |        // Handle `defined`
  384|      7|        if matches!(token.kind, PPTokenKind::Identifier(sym) if sym == self.preprocessor.defined_symbol()) {
                         ^1                                           ^1                                              ^1
  385|      1|            self.advance();
  386|      1|            let ident = if self.peek() == Some(&PPTokenKind::LeftParen) {
  387|      1|                self.advance();
  388|      1|                let ident = self.parse_primary()?;
                                                              ^0
  389|      1|                self.expect(PPTokenKind::RightParen)?;
                                                                  ^0
  390|      1|                ident
  391|       |            } else {
  392|      0|                self.parse_primary()?
  393|       |            };
  394|      1|            return Ok(PPExpr::Defined(Box::new(ident)));
  395|    193|        }
  396|       |
  397|       |        // Handle `__has_include`
  398|      6|        if matches!(token.kind, PPTokenKind::Identifier(sym) if sym == self.preprocessor.has_include_symbol()) {
  399|      6|            self.advance();
  400|      6|            return self.parse_has_include();
  401|    187|        }
  402|       |
  403|       |        // Handle unary operators
  404|    187|        let unary_op = match token.kind {
  405|      1|            PPTokenKind::Plus => Some(UnaryOp::Plus),
  406|     16|            PPTokenKind::Minus => Some(UnaryOp::Minus),
  407|      2|            PPTokenKind::Tilde => Some(UnaryOp::BitNot),
  408|      2|            PPTokenKind::Not => Some(UnaryOp::LogicNot),
  409|    166|            _ => None,
  410|       |        };
  411|    187|        if let Some(op) = unary_op {
                                  ^21
  412|     21|            self.advance();
  413|     21|            return Ok(PPExpr::Unary(op, Box::new(self.parse_unary()?)));
                                                                                 ^0
  414|    166|        }
  415|       |
  416|    166|        self.parse_primary()
  417|    194|    }
  418|       |
  419|      6|    fn parse_has_include(&mut self) -> Result<PPExpr, PPError> {
  420|      6|        self.expect(PPTokenKind::LeftParen)?;
                                                         ^0
  421|      6|        let token = self.current()?;
                                                ^0
  422|       |
  423|      6|        let (path, is_angled) = match &token.kind {
  424|      3|            PPTokenKind::StringLiteral(sym) => {
  425|      3|                let s = sym.as_str();
  426|      3|                if s.starts_with('"') && s.ends_with('"') {
  427|      3|                    self.advance();
  428|      3|                    (s[1..s.len() - 1].to_string(), false)
  429|       |                } else {
  430|      0|                    return Err(self.error());
  431|       |                }
  432|       |            }
  433|       |            PPTokenKind::Less => {
  434|      3|                self.advance();
  435|      3|                let mut path_str = String::new();
  436|       |                loop {
  437|     12|                    if self.at_end() {
  438|      0|                        return Err(self.error());
  439|     12|                    }
  440|     12|                    let t = &self.tokens[self.pos];
  441|     12|                    if t.kind == PPTokenKind::Greater {
  442|      3|                        self.advance();
  443|      3|                        break;
  444|      9|                    }
  445|      9|                    path_str.push_str(self.preprocessor.get_token_text(t));
  446|      9|                    self.advance();
  447|       |                }
  448|      3|                (path_str, true)
  449|       |            }
  450|      0|            _ => return Err(self.error()),
  451|       |        };
  452|       |
  453|      6|        self.expect(PPTokenKind::RightParen)?;
                                                          ^0
  454|      6|        Ok(PPExpr::HasInclude(path, is_angled))
  455|      6|    }
  456|       |
  457|    167|    fn parse_primary(&mut self) -> Result<PPExpr, PPError> {
  458|    167|        let token = self.next()?;
                                             ^0
  459|       |
  460|    167|        match &token.kind {
  461|    143|            PPTokenKind::Number(sym) => {
  462|    143|                let text = sym.as_str();
  463|    143|                let (val, suffix) = literal_parsing::parse_c11_integer_literal(text).ok_or_else(|| self.error())?;
                                                                                                                 ^0   ^0      ^0
  464|    143|                let mut is_unsigned = matches!(suffix, Some(IntegerSuffix::U | IntegerSuffix::UL | IntegerSuffix::ULL));
                                                    ^131     ^12
  465|    143|                if !is_unsigned && val > i64::MAX as u64 {
                                                 ^131
  466|      0|                    is_unsigned = true;
  467|    143|                }
  468|    143|                Ok(PPExpr::Number(ExprValue::new(val, is_unsigned)))
  469|       |            }
  470|      2|            PPTokenKind::CharLiteral(codepoint, _) => Ok(PPExpr::Number(ExprValue::new(*codepoint, false))),
  471|      1|            PPTokenKind::Identifier(sym) => Ok(PPExpr::Identifier(sym.as_str().to_string())),
  472|       |            PPTokenKind::LeftParen => {
  473|     21|                let result = self.parse_conditional()?;
                                                                   ^0
  474|     21|                self.expect(PPTokenKind::RightParen)?;
                                                                  ^0
  475|     21|                Ok(result)
  476|       |            }
  477|      0|            _ => Err(self.error()),
  478|       |        }
  479|    167|    }
  480|       |}

/app/src/pp/pp_lexer.rs:
    1|       |use crate::ast::StringId;
    2|       |use crate::ast::literal_parsing;
    3|       |use crate::source_manager::{SourceId, SourceLoc};
    4|       |use std::sync::Arc;
    5|       |
    6|       |// Packed token flags for preprocessor tokens
    7|       |bitflags::bitflags! {
    8|       |    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    9|       |    pub struct PPTokenFlags: u8 {
   10|       |        const LEADING_SPACE = 1 << 0;  // Token has leading whitespace
   11|       |        const STARTS_PP_LINE = 1 << 1; // Token starts a preprocessing line
   12|       |        const NEEDS_CLEANUP = 1 << 2;  // Token needs cleanup after expansion
   13|       |        const MACRO_EXPANDED = 1 << 3; // Token was generated by macro expansion
   14|       |        const HAS_INVALID_UCN = 1 << 4; // Token contains an invalid UCN
   15|       |    }
   16|       |}
   17|       |
   18|       |/// Token kinds for preprocessor tokens
   19|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
   20|       |pub enum PPTokenKind {
   21|       |    // Punctuation and operators
   22|       |    Plus,
   23|       |    Minus,
   24|       |    Star,
   25|       |    Slash,
   26|       |    Percent, // + - * / %
   27|       |    And,
   28|       |    Or,
   29|       |    Xor,
   30|       |    Not,
   31|       |    Tilde, // & | ^ ! ~
   32|       |    Less,
   33|       |    Greater,
   34|       |    LessEqual,
   35|       |    GreaterEqual,
   36|       |    Equal,
   37|       |    NotEqual, // < > <= >= == !=
   38|       |    LeftShift,
   39|       |    RightShift, // << >>
   40|       |    Assign,
   41|       |    PlusAssign,
   42|       |    MinusAssign, // = += -=
   43|       |    StarAssign,
   44|       |    DivAssign,
   45|       |    ModAssign, // *= /= %=
   46|       |    AndAssign,
   47|       |    OrAssign,
   48|       |    XorAssign, // &= |= ^=
   49|       |    LeftShiftAssign,
   50|       |    RightShiftAssign, // <<= >>=
   51|       |    Increment,
   52|       |    Decrement, // ++ --
   53|       |    Arrow,
   54|       |    Dot, // -> .
   55|       |    Question,
   56|       |    Colon, // ? :
   57|       |    Comma,
   58|       |    Semicolon, // , ;
   59|       |    LeftParen,
   60|       |    RightParen, // ( )
   61|       |    LeftBracket,
   62|       |    RightBracket, // [ ]
   63|       |    LeftBrace,
   64|       |    RightBrace, // { }
   65|       |    Ellipsis,   // ...
   66|       |    LogicAnd,
   67|       |    LogicOr, // && ||
   68|       |    Hash,
   69|       |    HashHash, // # ##
   70|       |    // Literals and identifiers
   71|       |    Identifier(StringId),       // Interned identifier
   72|       |    StringLiteral(StringId),    // Interned string literal
   73|       |    CharLiteral(u64, StringId), // char value and raw text
   74|       |    Number(StringId),           // Raw numeric literal text for parser
   75|       |    // Special
   76|       |    Eof,
   77|       |    Eod,
   78|       |    Unknown,
   79|       |}
   80|       |
   81|       |/// Token structure for preprocessor tokens
   82|       |#[derive(Clone, Copy, Debug)]
   83|       |pub struct PPToken {
   84|       |    pub kind: PPTokenKind,
   85|       |    pub flags: PPTokenFlags,
   86|       |    pub location: SourceLoc, // Contains file ID and byte offset
   87|       |    pub length: u16,         // Maximum token length (64KB should be sufficient for any token)
   88|       |}
   89|       |
   90|       |impl PPToken {
   91|       |    /// Create a PPToken with full control over all fields
   92|  35.9k|    pub(crate) fn new(kind: PPTokenKind, flags: PPTokenFlags, location: SourceLoc, length: u16) -> Self {
   93|  35.9k|        PPToken {
   94|  35.9k|            kind,
   95|  35.9k|            flags,
   96|  35.9k|            location,
   97|  35.9k|            length,
   98|  35.9k|        }
   99|  35.9k|    }
  100|       |
  101|       |    /// Create a PPToken with text-based length
  102|  1.65k|    pub(crate) fn text(kind: PPTokenKind, flags: PPTokenFlags, location: SourceLoc, text: &str) -> Self {
  103|  1.65k|        PPToken::new(kind, flags, location, text.len() as u16)
  104|  1.65k|    }
  105|       |
  106|       |    /// Get the raw byte slice from the source buffer for this token
  107|     17|    pub(crate) fn get_raw_slice<'a>(&self, buffer: &'a [u8]) -> &'a [u8] {
  108|     17|        let start = self.location.offset() as usize;
  109|     17|        let end = start + self.length as usize;
  110|     17|        &buffer[start..end]
  111|     17|    }
  112|       |
  113|       |    /// Get the text representation of the token
  114|    316|    pub(crate) fn get_text(&self) -> &str {
  115|    316|        match &self.kind {
  116|    123|            PPTokenKind::Identifier(sym) => sym.as_str(),
  117|     50|            PPTokenKind::Number(sym) => sym.as_str(),
  118|     24|            PPTokenKind::StringLiteral(sym) => sym.as_str(),
  119|     13|            PPTokenKind::CharLiteral(_, sym) => sym.as_str(),
  120|     10|            PPTokenKind::LeftParen => "(",
  121|     10|            PPTokenKind::RightParen => ")",
  122|      3|            PPTokenKind::LeftBracket => "[",
  123|      3|            PPTokenKind::RightBracket => "]",
  124|      3|            PPTokenKind::LeftBrace => "{",
  125|      3|            PPTokenKind::RightBrace => "}",
  126|      4|            PPTokenKind::Plus => "+",
  127|      1|            PPTokenKind::Minus => "-",
  128|      2|            PPTokenKind::Star => "*",
  129|      1|            PPTokenKind::Slash => "/",
  130|      1|            PPTokenKind::Percent => "%",
  131|      1|            PPTokenKind::And => "&",
  132|      2|            PPTokenKind::Or => "|",
  133|      2|            PPTokenKind::Xor => "^",
  134|      1|            PPTokenKind::Not => "!",
  135|      2|            PPTokenKind::Tilde => "~",
  136|      1|            PPTokenKind::Less => "<",
  137|      1|            PPTokenKind::Greater => ">",
  138|      1|            PPTokenKind::LessEqual => "<=",
  139|      1|            PPTokenKind::GreaterEqual => ">=",
  140|      1|            PPTokenKind::Equal => "==",
  141|      1|            PPTokenKind::NotEqual => "!=",
  142|      1|            PPTokenKind::LeftShift => "<<",
  143|      1|            PPTokenKind::RightShift => ">>",
  144|      7|            PPTokenKind::Assign => "=",
  145|      1|            PPTokenKind::PlusAssign => "+=",
  146|      1|            PPTokenKind::MinusAssign => "-=",
  147|      1|            PPTokenKind::StarAssign => "*=",
  148|      1|            PPTokenKind::DivAssign => "/=",
  149|      1|            PPTokenKind::ModAssign => "%=",
  150|      1|            PPTokenKind::AndAssign => "&=",
  151|      1|            PPTokenKind::OrAssign => "|=",
  152|      1|            PPTokenKind::XorAssign => "^=",
  153|      1|            PPTokenKind::LeftShiftAssign => "<<=",
  154|      1|            PPTokenKind::RightShiftAssign => ">>=",
  155|      1|            PPTokenKind::Increment => "++",
  156|      1|            PPTokenKind::Decrement => "--",
  157|      1|            PPTokenKind::Arrow => "->",
  158|      1|            PPTokenKind::Dot => ".",
  159|      1|            PPTokenKind::Question => "?",
  160|      1|            PPTokenKind::Colon => ":",
  161|      6|            PPTokenKind::Comma => ",",
  162|      6|            PPTokenKind::Semicolon => ";",
  163|      1|            PPTokenKind::Ellipsis => "...",
  164|      1|            PPTokenKind::LogicAnd => "&&",
  165|      1|            PPTokenKind::LogicOr => "||",
  166|      5|            PPTokenKind::Hash => "#",
  167|      2|            PPTokenKind::HashHash => "##",
  168|      2|            PPTokenKind::Unknown => "?",
  169|      2|            _ => "",
  170|       |        }
  171|    316|    }
  172|       |}
  173|       |
  174|       |/// Manages lexing from different source buffers
  175|       |pub(crate) struct PPLexer {
  176|       |    pub(crate) source_id: SourceId,
  177|       |    buffer: Arc<[u8]>,
  178|       |    pub(crate) position: u32, // its okay to use u32 here since source files are limited to 4 MB
  179|       |    line_starts: Vec<u32>,
  180|       |    put_back_token: Option<PPToken>,
  181|       |    pub(crate) line_offset: u32,
  182|       |    pub(crate) in_directive_line: bool, // Whether we are currently processing tokens on a directive line
  183|       |    pub(crate) at_start_of_line: bool,  // Whether we are at the beginning of a line (only whitespace/comments seen)
  184|       |}
  185|       |
  186|       |impl PPLexer {
  187|    995|    pub(crate) fn new(source_id: SourceId, buffer: Arc<[u8]>) -> Self {
  188|    995|        let line_starts = vec![0]; // First line starts at offset 0
  189|       |
  190|    995|        PPLexer {
  191|    995|            source_id,
  192|    995|            buffer,
  193|    995|            position: 0,
  194|    995|            line_starts,
  195|    995|            put_back_token: None,
  196|    995|            line_offset: 0,
  197|    995|            in_directive_line: false,
  198|    995|            at_start_of_line: true,
  199|    995|        }
  200|    995|    }
  201|       |
  202|       |    /// Get the next character, handling line splicing transparently
  203|       |    /// Line splicing: backslash followed by newline removes both characters
  204|  62.3k|    pub(crate) fn next_char(&mut self) -> Option<u8> {
  205|       |        loop {
  206|  62.3k|            let pos = self.position as usize;
  207|  62.3k|            if pos >= self.buffer.len() {
  208|  1.55k|                return None;
  209|  60.8k|            }
  210|       |
  211|  60.8k|            let mut ch = self.buffer[pos];
  212|       |
  213|       |            //  Bolt: Fast path for common characters.
  214|       |            // If the character is not the start of a trigraph ('?') or a line splice ('\'),
  215|       |            // we can consume it immediately and skip the complex logic below.
  216|       |            // This significantly improves performance as most characters fall into this case.
  217|  60.8k|            if ch != b'?' && ch != b'\\' {
                                           ^60.7k
  218|  60.6k|                self.position += 1;
  219|  60.6k|                if ch == b'\n' {
  220|  3.04k|                    self.line_starts.push(self.position);
  221|  57.5k|                }
  222|  60.6k|                return Some(ch);
  223|    190|            }
  224|       |
  225|    190|            let mut consumed_len = 1;
  226|       |
  227|       |            // Phase 1: Trigraphs
  228|    190|            if ch == b'?' && pos + 2 < self.buffer.len() && self.buffer[pos + 1] == b'?' {
                                           ^94                            ^89
  229|     34|                let replacement = match self.buffer[pos + 2] {
  230|      5|                    b'=' => Some(b'#'),
  231|      3|                    b'(' => Some(b'['),
  232|      8|                    b'/' => Some(b'\\'),
  233|      3|                    b')' => Some(b']'),
  234|      3|                    b'\'' => Some(b'^'),
  235|      3|                    b'<' => Some(b'{'),
  236|      3|                    b'!' => Some(b'|'),
  237|      3|                    b'>' => Some(b'}'),
  238|      3|                    b'-' => Some(b'~'),
  239|      0|                    _ => None,
  240|       |                };
  241|       |
  242|     34|                if let Some(r) = replacement {
  243|     34|                    ch = r;
  244|     34|                    consumed_len = 3;
  245|     34|                }
                              ^0
  246|    156|            }
  247|       |
  248|       |            // Phase 2: Line Splicing
  249|    190|            if ch == b'\\' {
  250|    104|                let mut check_pos = pos + consumed_len;
  251|    104|                let mut found_splice = false;
  252|    104|                let mut new_pos = check_pos;
  253|       |
  254|       |                // Look ahead for whitespace followed by newline
  255|    112|                while check_pos < self.buffer.len() {
  256|    112|                    let c = self.buffer[check_pos];
  257|    112|                    if c == b' ' || c == b'\t' {
                                                  ^104
  258|      8|                        check_pos += 1;
  259|    104|                    } else if c == b'\n' {
  260|       |                        // Splicing: \ [ws] \n
  261|     23|                        new_pos = check_pos + 1;
  262|     23|                        found_splice = true;
  263|     23|                        break;
  264|     81|                    } else if c == b'\r' {
  265|       |                        // Splicing: \ [ws] \r or \ [ws] \r \n
  266|      0|                        let after_cr = check_pos + 1;
  267|      0|                        if after_cr < self.buffer.len() && self.buffer[after_cr] == b'\n' {
  268|      0|                            new_pos = after_cr + 1;
  269|      0|                        } else {
  270|      0|                            new_pos = check_pos + 1;
  271|      0|                        }
  272|      0|                        found_splice = true;
  273|      0|                        break;
  274|       |                    } else {
  275|       |                        // Not a splice
  276|     81|                        break;
  277|       |                    }
  278|       |                }
  279|       |
  280|    104|                if found_splice {
  281|     23|                    self.position = new_pos as u32;
  282|     23|                    self.line_starts.push(self.position);
  283|     23|                    continue;
  284|     81|                } else {
  285|     81|                    // Not a splice
  286|     81|                }
  287|     86|            }
  288|       |
  289|    167|            self.position += consumed_len as u32;
  290|       |
  291|       |            // Update line starts for regular newlines
  292|    167|            if ch == b'\n' {
  293|      0|                self.line_starts.push(self.position);
  294|    167|            }
  295|       |
  296|    167|            return Some(ch);
  297|       |        }
  298|  62.3k|    }
  299|       |
  300|       |    /// Peek at the next character without consuming it, handling line splicing
  301|  22.5k|    pub(crate) fn peek_char(&mut self) -> Option<u8> {
  302|  22.5k|        let pos = self.position as usize;
  303|       |
  304|       |        //  Bolt: Fast path for peeking common characters.
  305|       |        // If the next character is not the start of a trigraph or line splice,
  306|       |        // we can return it directly without the overhead of saving/restoring state.
  307|  22.5k|        if pos < self.buffer.len() {
  308|  21.4k|            let ch = self.buffer[pos];
  309|  21.4k|            if ch != b'?' && ch != b'\\' {
                                           ^21.4k
  310|  21.4k|                return Some(ch);
  311|     41|            }
  312|  1.12k|        }
  313|       |
  314|  1.16k|        let saved_position = self.position;
  315|       |        //  Bolt: Avoid cloning `line_starts` by saving its length.
  316|       |        // `next_char` only ever appends to this vector, so we can restore its
  317|       |        // state by truncating it to its original length. This is a significant
  318|       |        // performance win as `peek_char` is called frequently.
  319|  1.16k|        let saved_line_starts_len = self.line_starts.len();
  320|       |
  321|  1.16k|        let result = self.next_char();
  322|       |
  323|       |        // Restore state
  324|  1.16k|        self.position = saved_position;
  325|  1.16k|        self.line_starts.truncate(saved_line_starts_len);
  326|       |
  327|  1.16k|        result
  328|  22.5k|    }
  329|       |
  330|       |    ///  Bolt: Consolidated operator lexing.
  331|       |    /// This helper function centralizes the logic for lexing single and multi-character operators,
  332|       |    /// significantly reducing code duplication and branching in the main `next_token` function.
  333|       |    /// This improves performance by making the tokenization logic more direct and predictable
  334|       |    /// for the compiler to optimize. It also fixes a bug in the original `...` lexing logic.
  335|  8.92k|    fn lex_operator(&mut self, start_pos: u32, ch: u8, flags: PPTokenFlags) -> PPToken {
  336|  8.92k|        let loc = SourceLoc::new(self.source_id, start_pos);
  337|       |        //  Bolt: Check if we're at the beginning of a line (ignoring whitespace).
  338|       |        // This is crucial for identifying the '#' or '%:' that starts a preprocessor directive.
  339|  8.92k|        let is_at_start_of_line = self.at_start_of_line;
  340|       |
  341|       |        // Helper macro to reduce boilerplate when creating a token.
  342|       |        macro_rules! token {
  343|       |            ($kind:expr, $len:expr) => {
  344|       |                PPToken::new($kind, flags, loc, $len)
  345|       |            };
  346|       |            ($kind:expr, $len:expr, $custom_flags:expr) => {
  347|       |                PPToken::new($kind, $custom_flags, loc, $len)
  348|       |            };
  349|       |        }
  350|       |
  351|       |        // Helper macro to check the next character and consume it if it matches.
  352|       |        macro_rules! consume_if {
  353|       |            ($c:expr) => {{
  354|       |                if self.peek_char() == Some($c) {
  355|       |                    self.next_char();
  356|       |                    true
  357|       |                } else {
  358|       |                    false
  359|       |                }
  360|       |            }};
  361|       |        }
  362|       |
  363|  8.92k|        match ch {
  364|       |            b'#' => {
  365|    412|                if consume_if!(b'#') {
  366|     12|                    token!(PPTokenKind::HashHash, 2)
  367|       |                } else {
  368|    400|                    let mut token_flags = flags;
  369|    400|                    if is_at_start_of_line {
  370|    397|                        token_flags |= PPTokenFlags::STARTS_PP_LINE;
  371|    397|                        self.in_directive_line = true;
  372|    397|                    }
                                  ^3
  373|    400|                    token!(PPTokenKind::Hash, 1, token_flags)
  374|       |                }
  375|       |            }
  376|       |            b'+' => {
  377|    103|                if consume_if!(b'+') {
  378|     22|                    token!(PPTokenKind::Increment, 2)
  379|     81|                } else if consume_if!(b'=') {
  380|      7|                    token!(PPTokenKind::PlusAssign, 2)
  381|       |                } else {
  382|     74|                    token!(PPTokenKind::Plus, 1)
  383|       |                }
  384|       |            }
  385|       |            b'-' => {
  386|    100|                if consume_if!(b'-') {
  387|     11|                    token!(PPTokenKind::Decrement, 2)
  388|     89|                } else if consume_if!(b'=') {
  389|      6|                    token!(PPTokenKind::MinusAssign, 2)
  390|     83|                } else if consume_if!(b'>') {
  391|     19|                    token!(PPTokenKind::Arrow, 2)
  392|       |                } else {
  393|     64|                    token!(PPTokenKind::Minus, 1)
  394|       |                }
  395|       |            }
  396|       |            b'*' => {
  397|    237|                if consume_if!(b'=') {
  398|      3|                    token!(PPTokenKind::StarAssign, 2)
  399|       |                } else {
  400|    234|                    token!(PPTokenKind::Star, 1)
  401|       |                }
  402|       |            }
  403|       |            b'/' => {
  404|     22|                if consume_if!(b'=') {
  405|      3|                    token!(PPTokenKind::DivAssign, 2)
  406|       |                } else {
  407|     19|                    token!(PPTokenKind::Slash, 1)
  408|       |                }
  409|       |            }
  410|       |            b'%' => {
  411|     18|                if consume_if!(b'=') {
  412|      3|                    token!(PPTokenKind::ModAssign, 2)
  413|     15|                } else if consume_if!(b'>') {
  414|      1|                    token!(PPTokenKind::RightBrace, 2)
  415|     14|                } else if consume_if!(b':') {
  416|       |                    // Check for %:%: (##)
  417|      4|                    let saved_pos = self.position;
  418|      4|                    let saved_lines_len = self.line_starts.len();
  419|       |
  420|      4|                    if consume_if!(b'%') {
  421|      2|                        if consume_if!(b':') {
  422|      2|                            token!(PPTokenKind::HashHash, 4)
  423|       |                        } else {
  424|       |                            // Backtrack to after %:
  425|      0|                            self.position = saved_pos;
  426|      0|                            self.line_starts.truncate(saved_lines_len);
  427|      0|                            let mut token_flags = flags;
  428|      0|                            if is_at_start_of_line {
  429|      0|                                token_flags |= PPTokenFlags::STARTS_PP_LINE;
  430|      0|                                self.in_directive_line = true;
  431|      0|                            }
  432|      0|                            token!(PPTokenKind::Hash, 2, token_flags)
  433|       |                        }
  434|       |                    } else {
  435|       |                        // %: -> Hash
  436|      2|                        let mut token_flags = flags;
  437|      2|                        if is_at_start_of_line {
  438|      1|                            token_flags |= PPTokenFlags::STARTS_PP_LINE;
  439|      1|                            self.in_directive_line = true;
  440|      1|                        }
  441|      2|                        token!(PPTokenKind::Hash, 2, token_flags)
  442|       |                    }
  443|       |                } else {
  444|     10|                    token!(PPTokenKind::Percent, 1)
  445|       |                }
  446|       |            }
  447|       |            b'=' => {
  448|    596|                if consume_if!(b'=') {
  449|     54|                    token!(PPTokenKind::Equal, 2)
  450|       |                } else {
  451|    542|                    token!(PPTokenKind::Assign, 1)
  452|       |                }
  453|       |            }
  454|       |            b'!' => {
  455|     84|                if consume_if!(b'=') {
  456|     60|                    token!(PPTokenKind::NotEqual, 2)
  457|       |                } else {
  458|     24|                    token!(PPTokenKind::Not, 1)
  459|       |                }
  460|       |            }
  461|       |            b'<' => {
  462|     47|                if consume_if!(b'<') {
  463|      6|                    if consume_if!(b'=') {
  464|      2|                        token!(PPTokenKind::LeftShiftAssign, 3)
  465|       |                    } else {
  466|      4|                        token!(PPTokenKind::LeftShift, 2)
  467|       |                    }
  468|     41|                } else if consume_if!(b'=') {
  469|      6|                    token!(PPTokenKind::LessEqual, 2)
  470|     35|                } else if consume_if!(b':') {
  471|      1|                    token!(PPTokenKind::LeftBracket, 2)
  472|     34|                } else if consume_if!(b'%') {
  473|      1|                    token!(PPTokenKind::LeftBrace, 2)
  474|       |                } else {
  475|     33|                    token!(PPTokenKind::Less, 1)
  476|       |                }
  477|       |            }
  478|       |            b'>' => {
  479|     39|                if consume_if!(b'>') {
  480|      7|                    if consume_if!(b'=') {
  481|      2|                        token!(PPTokenKind::RightShiftAssign, 3)
  482|       |                    } else {
  483|      5|                        token!(PPTokenKind::RightShift, 2)
  484|       |                    }
  485|     32|                } else if consume_if!(b'=') {
  486|      6|                    token!(PPTokenKind::GreaterEqual, 2)
  487|       |                } else {
  488|     26|                    token!(PPTokenKind::Greater, 1)
  489|       |                }
  490|       |            }
  491|       |            b'&' => {
  492|     60|                if consume_if!(b'&') {
  493|     17|                    token!(PPTokenKind::LogicAnd, 2)
  494|     43|                } else if consume_if!(b'=') {
  495|      2|                    token!(PPTokenKind::AndAssign, 2)
  496|       |                } else {
  497|     41|                    token!(PPTokenKind::And, 1)
  498|       |                }
  499|       |            }
  500|       |            b'|' => {
  501|     24|                if consume_if!(b'|') {
  502|     17|                    token!(PPTokenKind::LogicOr, 2)
  503|      7|                } else if consume_if!(b'=') {
  504|      2|                    token!(PPTokenKind::OrAssign, 2)
  505|       |                } else {
  506|      5|                    token!(PPTokenKind::Or, 1)
  507|       |                }
  508|       |            }
  509|       |            b'^' => {
  510|      7|                if consume_if!(b'=') {
  511|      2|                    token!(PPTokenKind::XorAssign, 2)
  512|       |                } else {
  513|      5|                    token!(PPTokenKind::Xor, 1)
  514|       |                }
  515|       |            }
  516|     12|            b'~' => token!(PPTokenKind::Tilde, 1),
  517|       |            b'.' => 'ellipsis: {
  518|    217|                let pos_after_first = self.position;
  519|    217|                let lines_after_first = self.line_starts.len();
  520|    217|                if self.peek_char() == Some(b'.') {
  521|     63|                    self.next_char(); // Consume second '.'
  522|     63|                    if self.peek_char() == Some(b'.') {
  523|     63|                        self.next_char(); // Consume third '.'
  524|     63|                        break 'ellipsis token!(PPTokenKind::Ellipsis, 3);
  525|      0|                    }
  526|       |                    // It was '..', which is not a valid C token. Backtrack to handle it as a single '.'
  527|      0|                    self.position = pos_after_first;
  528|      0|                    self.line_starts.truncate(lines_after_first);
  529|    154|                }
  530|    154|                token!(PPTokenKind::Dot, 1)
  531|       |            }
  532|     19|            b'?' => token!(PPTokenKind::Question, 1),
  533|       |            b':' => {
  534|    175|                if consume_if!(b'>') {
  535|      1|                    token!(PPTokenKind::RightBracket, 2)
  536|       |                } else {
  537|    174|                    token!(PPTokenKind::Colon, 1)
  538|       |                }
  539|       |            }
  540|    580|            b',' => token!(PPTokenKind::Comma, 1),
  541|  1.78k|            b';' => token!(PPTokenKind::Semicolon, 1),
  542|  1.28k|            b'(' => token!(PPTokenKind::LeftParen, 1),
  543|  1.28k|            b')' => token!(PPTokenKind::RightParen, 1),
  544|    228|            b'[' => token!(PPTokenKind::LeftBracket, 1),
  545|    228|            b']' => token!(PPTokenKind::RightBracket, 1),
  546|    687|            b'{' => token!(PPTokenKind::LeftBrace, 1),
  547|    687|            b'}' => token!(PPTokenKind::RightBrace, 1),
  548|      0|            _ => token!(PPTokenKind::Unknown, 1),
  549|       |        }
  550|  8.92k|    }
  551|       |
  552|  18.9k|    pub(crate) fn next_token(&mut self) -> Option<PPToken> {
  553|  18.9k|        if let Some(token) = self.put_back_token.take() {
                                  ^0
  554|      0|            return Some(token);
  555|  18.9k|        }
  556|       |
  557|  18.9k|        let saved_position = self.position;
  558|  18.9k|        self.skip_whitespace_and_comments();
  559|  18.9k|        let had_leading_space = self.position > saved_position;
  560|       |
  561|  18.9k|        if self.position as usize >= self.buffer.len() {
  562|    965|            if self.in_directive_line {
  563|     29|                self.in_directive_line = false;
  564|     29|                return Some(PPToken::new(
  565|     29|                    PPTokenKind::Eod,
  566|     29|                    PPTokenFlags::empty(),
  567|     29|                    SourceLoc::new(self.source_id, self.position),
  568|     29|                    0,
  569|     29|                ));
  570|       |            } else {
  571|    936|                return None;
  572|       |            }
  573|  18.0k|        }
  574|       |
  575|  18.0k|        let flags = if had_leading_space {
  576|  9.34k|            PPTokenFlags::LEADING_SPACE
  577|       |        } else {
  578|  8.69k|            PPTokenFlags::empty()
  579|       |        };
  580|       |
  581|  18.0k|        let start_pos = self.position;
  582|  18.0k|        let ch = self.next_char().unwrap_or(b' ');
  583|       |
  584|       |        // Check if this is a newline that ends a directive line
  585|       |        // Only \n triggers Eod, \r is treated as whitespace (Windows \r\n support)
  586|  18.0k|        if ch == b'\n' && self.in_directive_line {
                                        ^361
  587|    361|            self.in_directive_line = false;
  588|    361|            self.at_start_of_line = true;
  589|    361|            return Some(PPToken::new(
  590|    361|                PPTokenKind::Eod,
  591|    361|                flags,
  592|    361|                SourceLoc::new(self.source_id, start_pos),
  593|    361|                1,
  594|    361|            ));
  595|  17.6k|        }
  596|       |
  597|  17.6k|        let token = match ch {
  598|  7.47k|            b'a'..=b'z' | b'A'..=b'Z' | b'_' => {
                                        ^2.90k
  599|  7.08k|                if ch == b'L' || ch == b'u' || ch == b'U' {
                                               ^7.05k        ^6.90k
  600|    196|                    let next_ch = self.peek_char();
  601|       |
  602|       |                    // Check for u8" (UTF-8 string literal)
  603|    196|                    if ch == b'u' && next_ch == Some(b'8') {
                                                   ^146
  604|     18|                        let saved_pos = self.position;
  605|     18|                        let saved_line_starts_len = self.line_starts.len();
  606|     18|                        self.next_char(); // consume '8'
  607|       |
  608|     18|                        if self.peek_char() == Some(b'"') {
  609|      2|                            Some(self.lex_string_literal(start_pos, b"u8", flags))
  610|       |                        } else {
  611|       |                            // Backtrack if it's not u8"
  612|     16|                            self.position = saved_pos;
  613|     16|                            self.line_starts.truncate(saved_line_starts_len);
  614|     16|                            Some(self.lex_identifier(start_pos, ch, flags))
  615|       |                        }
  616|    178|                    } else if next_ch == Some(b'"') {
  617|     15|                        Some(self.lex_string_literal(start_pos, &[ch], flags))
  618|    163|                    } else if next_ch == Some(b'\'') {
  619|      4|                        Some(self.lex_char_literal(start_pos, &[ch], flags))
  620|       |                    } else {
  621|    159|                        Some(self.lex_identifier(start_pos, ch, flags))
  622|       |                    }
  623|       |                } else {
  624|  6.88k|                    Some(self.lex_identifier(start_pos, ch, flags))
  625|       |                }
  626|       |            }
  627|       |            b'\\' => {
  628|      4|                let saved_pos = self.position;
  629|      4|                let saved_lines_len = self.line_starts.len();
  630|       |
  631|      4|                match self.lex_ucn(false) {
  632|       |                    Some(Ok(_)) => {
  633|       |                        // Valid UCN start. Backtrack to just after `\` so lex_identifier can re-parse it.
  634|      2|                        self.position = saved_pos;
  635|      2|                        self.line_starts.truncate(saved_lines_len);
  636|      2|                        Some(self.lex_identifier(start_pos, ch, flags))
  637|       |                    }
  638|       |                    _ => {
  639|       |                        // Not a UCN or invalid.
  640|       |                        // Backtrack to just after `\` (saved_pos).
  641|      2|                        self.position = saved_pos;
  642|      2|                        self.line_starts.truncate(saved_lines_len);
  643|      2|                        Some(PPToken::new(
  644|      2|                            PPTokenKind::Unknown,
  645|      2|                            flags,
  646|      2|                            SourceLoc::new(self.source_id, start_pos),
  647|      2|                            1,
  648|      2|                        ))
  649|       |                    }
  650|       |                }
  651|       |            }
  652|      2|            0x80..=0xFF => {
  653|      2|                if self.is_valid_utf8_start(ch) {
  654|      2|                    Some(self.lex_identifier(start_pos, ch, flags))
  655|       |                } else {
  656|      0|                    Some(PPToken::new(
  657|      0|                        PPTokenKind::Unknown,
  658|      0|                        flags,
  659|      0|                        SourceLoc::new(self.source_id, start_pos),
  660|      0|                        1,
  661|      0|                    ))
  662|       |                }
  663|       |            }
  664|  1.43k|            b'0'..=b'9' => Some(self.lex_number(start_pos, ch, flags)),
                                         ^1.42k^1.42k^1.42k     ^1.42k
  665|    198|            b'"' => Some(self.lex_string_literal(start_pos, &[ch], flags)),
  666|     27|            b'\'' => Some(self.lex_char_literal(start_pos, &[ch], flags)),
  667|    430|            b'#' | b'%' => Some(self.lex_operator(start_pos, ch, flags)),
  668|       |            b'.' => {
  669|    217|                if let Some(next_ch) = self.peek_char()
                                          ^216
  670|    216|                    && next_ch.is_ascii_digit()
  671|       |                {
  672|      0|                    Some(self.lex_number(start_pos, ch, flags))
  673|       |                } else {
  674|    217|                    Some(self.lex_operator(start_pos, ch, flags))
  675|       |                }
  676|       |            }
  677|       |            // All operators and punctuation are handled by the optimized helper function.
  678|       |            b'+' | b'-' | b'*' | b'/' | b'=' | b'!' | b'<' | b'>' | b'&' | b'|' | b'^' | b'~' | b'?' | b':' | b','
  679|  8.28k|            | b';' | b'(' | b')' | b'[' | b']' | b'{' | b'}' => Some(self.lex_operator(start_pos, ch, flags)),
  680|      1|            _ => Some(PPToken::new(
  681|      1|                PPTokenKind::Unknown,
  682|      1|                flags,
  683|      1|                SourceLoc::new(self.source_id, start_pos),
  684|      1|                1,
  685|      1|            )),
  686|       |        };
  687|       |
  688|  17.6k|        if let Some(t) = &token
  689|  17.6k|            && t.kind != PPTokenKind::Eod
  690|  17.6k|        {
  691|  17.6k|            self.at_start_of_line = false;
  692|  17.6k|        }
                      ^0
  693|       |
  694|  17.6k|        token
  695|  18.9k|    }
  696|       |
  697|  18.9k|    fn skip_whitespace_and_comments(&mut self) {
  698|       |        loop {
  699|       |            // Skip whitespace, handling line splicing
  700|       |            // But don't skip newlines if we're in a directive line (let them be processed as tokens)
  701|       |
  702|       |            //  Bolt: Fast path for skipping common whitespace characters.
  703|       |            // This avoids the overhead of `peek_char` and `next_char` for the majority of whitespace.
  704|  50.6k|            while (self.position as usize) < self.buffer.len() {
  705|  49.7k|                let ch = self.buffer[self.position as usize];
  706|  49.7k|                if ch == b' ' || ch == b'\t' || ch == b'\r' || ch == b'\x0c' || ch == b'\x0b' {
                                               ^20.9k         ^20.9k         ^20.9k           ^20.9k
  707|  28.7k|                    self.position += 1;
  708|  28.7k|                } else if ch == b'\n' && !self.in_directive_line {
                                        ^20.9k         ^3.17k
  709|  2.81k|                    self.position += 1;
  710|  2.81k|                    self.line_starts.push(self.position);
  711|  2.81k|                    self.at_start_of_line = true;
  712|  2.81k|                } else {
  713|       |                    // Trigraphs, line splices, or non-whitespace.
  714|  18.1k|                    break;
  715|       |                }
  716|       |            }
  717|       |
  718|  19.1k|            while let Some(ch) = self.peek_char() {
                                         ^18.1k
  719|  18.1k|                if ch.is_ascii_whitespace() && !(ch == b'\n' && self.in_directive_line) {
                                                               ^368           ^361
  720|      7|                    if ch == b'\n' {
  721|      0|                        self.at_start_of_line = true;
  722|      7|                    }
  723|      7|                    self.next_char();
  724|       |                } else {
  725|  18.1k|                    break;
  726|       |                }
  727|       |            }
  728|       |
  729|  19.1k|            if self.position as usize >= self.buffer.len() {
  730|    965|                break;
  731|  18.1k|            }
  732|       |
  733|       |            // Check for comments by temporarily consuming
  734|  18.1k|            let saved_position = self.position;
  735|  18.1k|            let saved_line_starts_len = self.line_starts.len();
  736|       |
  737|  18.1k|            let ch1 = self.next_char();
  738|  18.1k|            let ch2 = self.next_char();
  739|       |
  740|  18.1k|            if ch1 == Some(b'/') && ch2 == Some(b'/') {
                                                  ^133
  741|       |                // Line comment, skip to end of line
  742|  2.91k|                while let Some(ch) = self.next_char() {
  743|  2.91k|                    if ch == b'\n' {
  744|     80|                        break;
  745|  2.83k|                    }
  746|       |                }
  747|       |                // Continue loop
  748|  18.0k|            } else if ch1 == Some(b'/') && ch2 == Some(b'*') {
                                                         ^53
  749|       |                // Block comment, skip to */
  750|    695|                while let Some(ch) = self.next_char() {
  751|    695|                    if ch == b'*' && self.peek_char() == Some(b'/') {
                                                   ^31
  752|     31|                        self.next_char(); // consume '/'
  753|     31|                        break;
  754|    664|                    }
  755|       |                }
  756|       |                // Continue loop
  757|       |            } else {
  758|       |                // Not a comment, restore position
  759|  18.0k|                self.position = saved_position;
  760|  18.0k|                self.line_starts.truncate(saved_line_starts_len);
  761|  18.0k|                break;
  762|       |            }
  763|       |        }
  764|  18.9k|    }
  765|       |
  766|       |    /// Consumes characters based on a predicate, building a string.
  767|       |    ///
  768|       |    /// The predicate receives the current state and the character.
  769|       |    /// It should return `true` to consume the character, or `false` to stop.
  770|       |    /// The closure can modify state (e.g., tracking scientific notation 'e').
  771|  1.42k|    fn consume_while<F, S>(&mut self, mut state: S, first_ch: u8, mut pred: F) -> String
  772|  1.42k|    where
  773|  1.42k|        F: FnMut(&mut S, u8) -> bool,
  774|       |    {
  775|       |        //  Bolt: Pre-allocate the vector with a reasonable capacity to avoid
  776|       |        // multiple reallocations during identifier/number lexing.
  777|  1.42k|        let mut chars = Vec::with_capacity(32);
  778|  1.42k|        chars.push(first_ch);
  779|       |        loop {
  780|       |            //  Bolt: Fast path for direct buffer access when no line splicing or trigraphs are present.
  781|  2.14k|            let pos = self.position as usize;
  782|  2.14k|            if pos < self.buffer.len() {
  783|  2.09k|                let ch = self.buffer[pos];
  784|  2.09k|                if ch != b'?' && ch != b'\\' {
  785|  2.09k|                    if pred(&mut state, ch) {
  786|    711|                        self.position += 1;
  787|    711|                        chars.push(ch);
  788|    711|                        continue;
  789|       |                    } else {
  790|  1.38k|                        break;
  791|       |                    }
  792|      1|                }
  793|     45|            }
  794|       |
  795|     46|            if let Some(ch) = self.peek_char()
                                      ^1
  796|      1|                && pred(&mut state, ch)
  797|       |            {
  798|      1|                chars.push(self.next_char().unwrap());
  799|      1|                continue;
  800|     45|            }
  801|     45|            break;
  802|       |        }
  803|       |        // Safety: We assume the caller only consumes valid UTF-8 characters (identifiers/numbers).
  804|  1.42k|        String::from_utf8(chars).unwrap()
  805|  1.42k|    }
  806|       |
  807|       |    /// Generic helper for lexing textual tokens (identifiers, numbers)
  808|  1.42k|    fn lex_textual_token<S, F, K>(
  809|  1.42k|        &mut self,
  810|  1.42k|        start_pos: u32,
  811|  1.42k|        first_ch: u8,
  812|  1.42k|        flags: PPTokenFlags,
  813|  1.42k|        state: S,
  814|  1.42k|        pred: F,
  815|  1.42k|        kind_ctor: K,
  816|  1.42k|    ) -> PPToken
  817|  1.42k|    where
  818|  1.42k|        F: FnMut(&mut S, u8) -> bool,
  819|  1.42k|        K: FnOnce(StringId) -> PPTokenKind,
  820|       |    {
  821|  1.42k|        let text = self.consume_while(state, first_ch, pred);
  822|  1.42k|        let symbol = StringId::new(&text);
  823|  1.42k|        PPToken::text(
  824|  1.42k|            kind_ctor(symbol),
  825|  1.42k|            flags,
  826|  1.42k|            SourceLoc::new(self.source_id, start_pos),
  827|  1.42k|            &text,
  828|       |        )
  829|  1.42k|    }
  830|       |
  831|       |    /// Try to parse a UCN.
  832|       |    /// Assumes the leading backslash has already been consumed.
  833|       |    /// Returns:
  834|       |    /// - None: Not a UCN (didn't consume anything).
  835|       |    /// - Some(Ok((char, raw_string))): Valid UCN.
  836|       |    /// - Some(Err(raw_string)): Invalid UCN (consumed raw_string).
  837|     58|    fn lex_ucn(&mut self, allow_basic_charset: bool) -> Option<Result<(char, String), String>> {
  838|     58|        let is_u = match self.peek_char() {
                          ^8
  839|      8|            Some(b'u') => true,
  840|      0|            Some(b'U') => false,
  841|     50|            _ => return None,
  842|       |        };
  843|       |
  844|      8|        self.next_char(); // Consume u/U
  845|       |
  846|      8|        let digits_needed = if is_u { 4 } else { 8 };
                                                               ^0
  847|      8|        let mut hex_str = String::new();
  848|       |
  849|      8|        for _ in 0..digits_needed {
  850|     32|            if let Some(ch) = self.peek_char() {
  851|     32|                if ch.is_ascii_hexdigit() {
  852|     32|                    self.next_char();
  853|     32|                    hex_str.push(ch as char);
  854|     32|                } else {
  855|      0|                    break;
  856|       |                }
  857|       |            } else {
  858|      0|                break;
  859|       |            }
  860|       |        }
  861|       |
  862|      8|        let prefix = if is_u { "\\u" } else { "\\U" };
                                                            ^0
  863|      8|        let raw_string = format!("{}{}", prefix, hex_str);
  864|       |
  865|      8|        if hex_str.len() != digits_needed {
  866|      0|            return Some(Err(raw_string));
  867|      8|        }
  868|       |
  869|      8|        let code_point = u32::from_str_radix(&hex_str, 16).unwrap();
  870|       |
  871|       |        // Validation
  872|       |        // 1. Range
  873|      8|        if code_point > 0x10FFFF {
  874|      0|            return Some(Err(raw_string));
  875|      8|        }
  876|       |
  877|       |        // 2. Surrogates
  878|      8|        if (0xD800..=0xDFFF).contains(&code_point) {
  879|      0|            return Some(Err(raw_string));
  880|      8|        }
  881|       |
  882|       |        // 3. Basic Source Character Set
  883|       |        // 0000-009F excluding $, @, `
  884|      8|        if !allow_basic_charset && code_point < 0xA0 && code_point != 0x24 && code_point != 0x40 && code_point != 0x60 {
                                                 ^4                   ^0                    ^0                    ^0
  885|      0|            return Some(Err(raw_string));
  886|      8|        }
  887|       |
  888|      8|        if let Some(c) = char::from_u32(code_point) {
  889|      8|            Some(Ok((c, raw_string)))
  890|       |        } else {
  891|      0|            Some(Err(raw_string))
  892|       |        }
  893|     58|    }
  894|       |
  895|  7.06k|    fn lex_identifier(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
  896|       |        //  Bolt: Pre-allocate the string with a reasonable capacity to avoid
  897|       |        // multiple reallocations during identifier lexing.
  898|  7.06k|        let mut text = String::with_capacity(32);
  899|  7.06k|        let mut length = 0u16;
  900|       |
  901|       |        // Handle first character
  902|  7.06k|        if first_ch == b'\\' {
  903|       |            // Must be a valid UCN to start an identifier
  904|      2|            if let Some(Ok((c, raw))) = self.lex_ucn(false) {
  905|      2|                text.push(c);
  906|      2|                length += raw.len() as u16;
  907|      2|            } else {
  908|       |                // Not a valid UCN start. Return Unknown for the \
  909|      0|                return PPToken::new(
  910|      0|                    PPTokenKind::Unknown,
  911|      0|                    flags,
  912|      0|                    SourceLoc::new(self.source_id, start_pos),
  913|       |                    1,
  914|       |                );
  915|       |            }
  916|  7.06k|        } else if first_ch >= 0x80 {
  917|       |            // UTF-8 start
  918|      2|            if self.is_valid_utf8_start(first_ch) {
  919|      2|                let mut bytes = vec![first_ch];
  920|      4|                while let Some(continuation_ch) = self.peek_char() {
  921|      4|                    if (0x80..0xC0).contains(&continuation_ch) {
  922|      2|                        bytes.push(self.next_char().unwrap());
  923|      2|                    } else {
  924|      2|                        break;
  925|       |                    }
  926|       |                }
  927|      2|                if let Ok(s) = String::from_utf8(bytes) {
  928|      2|                    text.push_str(&s);
  929|      2|                    length = s.len() as u16;
  930|      2|                } else {
  931|      0|                    return PPToken::new(
  932|      0|                        PPTokenKind::Unknown,
  933|      0|                        flags,
  934|      0|                        SourceLoc::new(self.source_id, start_pos),
  935|       |                        1,
  936|       |                    );
  937|       |                }
  938|       |            } else {
  939|      0|                return PPToken::new(
  940|      0|                    PPTokenKind::Unknown,
  941|      0|                    flags,
  942|      0|                    SourceLoc::new(self.source_id, start_pos),
  943|       |                    1,
  944|       |                );
  945|       |            }
  946|  7.06k|        } else {
  947|  7.06k|            text.push(first_ch as char);
  948|  7.06k|            length += 1;
  949|  7.06k|        }
  950|       |
  951|       |        loop {
  952|       |            //  Bolt: Fast path for common ASCII identifier characters.
  953|       |            // We directly access the buffer to avoid the overhead of `peek_char` and `next_char`
  954|       |            // when there are no trigraphs ('?') or line splices ('\') to handle.
  955|  28.3k|            let pos = self.position as usize;
  956|  28.3k|            if pos < self.buffer.len() {
  957|  28.2k|                let ch = self.buffer[pos];
  958|  28.2k|                if ch != b'?' && ch != b'\\' {
                                               ^28.2k
  959|  28.2k|                    if ch.is_ascii_alphanumeric() || ch == b'_' {
                                                                   ^7.76k
  960|  21.3k|                        self.position += 1;
  961|  21.3k|                        text.push(ch as char);
  962|  21.3k|                        length += 1;
  963|  21.3k|                        continue;
  964|  6.98k|                    } else if ch < 0x80 {
  965|       |                        // Other ASCII, stop identifier
  966|  6.98k|                        break;
  967|      0|                    }
  968|      6|                }
  969|     82|            }
  970|       |
  971|       |            // Fallback for tricky cases (Trigraphs, Splices, UCNs, UTF-8)
  972|     88|            let ch = match self.peek_char() {
                              ^6
  973|      6|                Some(c) => c,
  974|     82|                None => break,
  975|       |            };
  976|       |
  977|       |            // Check for UCN
  978|      6|            if ch == b'\\' {
  979|      0|                let saved_pos = self.position;
  980|      0|                let saved_lines_len = self.line_starts.len();
  981|      0|                self.next_char(); // consume \
  982|       |
  983|      0|                match self.lex_ucn(false) {
  984|      0|                    Some(Ok((c, raw))) => {
  985|      0|                        text.push(c);
  986|      0|                        length += raw.len() as u16;
  987|      0|                    }
  988|       |                    _ => {
  989|       |                        // Not a valid UCN or not a UCN.
  990|       |                        // Backtrack and stop identifier
  991|      0|                        self.position = saved_pos;
  992|      0|                        self.line_starts.truncate(saved_lines_len);
  993|      0|                        break;
  994|       |                    }
  995|       |                }
  996|      0|                continue;
  997|      6|            }
  998|       |
  999|       |            // Check for UTF-8
 1000|      6|            if ch >= 0x80 && self.is_valid_utf8_start(ch) {
                                           ^0   ^0                  ^0
 1001|      0|                let saved_pos = self.position;
 1002|      0|                let saved_lines_len = self.line_starts.len();
 1003|       |
 1004|      0|                self.next_char(); // consume first
 1005|      0|                let mut bytes = vec![ch];
 1006|      0|                while let Some(cont) = self.peek_char() {
 1007|      0|                    if (0x80..0xC0).contains(&cont) {
 1008|      0|                        bytes.push(self.next_char().unwrap());
 1009|      0|                    } else {
 1010|      0|                        break;
 1011|       |                    }
 1012|       |                }
 1013|       |
 1014|      0|                if let Ok(s) = String::from_utf8(bytes) {
 1015|      0|                    text.push_str(&s);
 1016|      0|                    length += s.len() as u16;
 1017|      0|                } else {
 1018|       |                    // Invalid UTF-8, backtrack
 1019|      0|                    self.position = saved_pos;
 1020|      0|                    self.line_starts.truncate(saved_lines_len);
 1021|      0|                    break;
 1022|       |                }
 1023|      0|                continue;
 1024|      6|            }
 1025|       |
 1026|       |            // Regular identifier char reached via slow path (e.g. after a splice)
 1027|      6|            if ch.is_ascii_alphanumeric() || ch == b'_' {
                                                           ^0
 1028|      6|                self.next_char();
 1029|      6|                text.push(ch as char);
 1030|      6|                length += 1;
 1031|      6|                continue;
 1032|      0|            }
 1033|       |
 1034|      0|            break;
 1035|       |        }
 1036|       |
 1037|  7.06k|        let symbol = StringId::new(&text);
 1038|  7.06k|        PPToken::new(
 1039|  7.06k|            PPTokenKind::Identifier(symbol),
 1040|  7.06k|            flags,
 1041|  7.06k|            SourceLoc::new(self.source_id, start_pos),
 1042|  7.06k|            length,
 1043|       |        )
 1044|  7.06k|    }
 1045|       |
 1046|  1.42k|    fn lex_number(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
 1047|  1.42k|        self.lex_textual_token(
 1048|  1.42k|            start_pos,
 1049|  1.42k|            first_ch,
 1050|  1.42k|            flags,
 1051|       |            false,
 1052|  2.09k|            |seen_e, ch| {
 1053|  2.09k|                if ch.is_ascii_digit() || ch == b'.' || ch.is_ascii_alphabetic() || ch == b'_' {
                                                        ^1.61k        ^1.57k^1.57k                   ^1.38k
 1054|    708|                    if ch == b'e' || ch == b'E' || ch == b'p' || ch == b'P' {
                                                   ^707          ^707          ^704
 1055|      5|                        *seen_e = true;
 1056|    703|                    }
 1057|    708|                    true
 1058|  1.38k|                } else if (ch == b'+' || ch == b'-') && *seen_e {
                                                       ^1.38k         ^6
 1059|       |                    // Allow + or - after e/E for scientific notation
 1060|      4|                    *seen_e = false; // Reset so we don't allow multiple +/- immediately
 1061|      4|                    true
 1062|       |                } else {
 1063|  1.38k|                    false
 1064|       |                }
 1065|  2.09k|            },
 1066|       |            PPTokenKind::Number,
 1067|       |        )
 1068|  1.42k|    }
 1069|       |
 1070|    246|    fn lex_common_literal_body(&mut self, delimiter: u8, chars: &mut Vec<u8>, has_invalid_ucn: &mut bool) {
 1071|  2.62k|        while let Some(ch) = self.next_char() {
 1072|  2.62k|            chars.push(ch);
 1073|  2.62k|            if ch == delimiter {
 1074|    246|                break; // End of literal
 1075|  2.38k|            } else if ch == b'\\' {
 1076|       |                // Handle escape sequences, including line splicing
 1077|       |
 1078|       |                // Check for UCN first
 1079|     52|                match self.lex_ucn(true) {
 1080|      4|                    Some(Ok((_, raw))) => {
 1081|       |                        // Valid UCN. Append raw bytes.
 1082|       |                        // \ is already pushed. raw contains \u...
 1083|       |                        // So append raw[1..]
 1084|      4|                        chars.extend_from_slice(&raw.as_bytes()[1..]);
 1085|      4|                        continue;
 1086|       |                    }
 1087|      0|                    Some(Err(raw)) => {
 1088|       |                        // Invalid UCN.
 1089|      0|                        *has_invalid_ucn = true;
 1090|      0|                        chars.extend_from_slice(&raw.as_bytes()[1..]);
 1091|      0|                        continue;
 1092|       |                    }
 1093|     48|                    None => {
 1094|     48|                        // Not a UCN (e.g. \n or \t or whatever)
 1095|     48|                        // Fall through to existing logic
 1096|     48|                    }
 1097|       |                }
 1098|       |
 1099|     48|                if let Some(next_ch) = self.next_char() {
 1100|     48|                    chars.push(next_ch);
 1101|     48|                }
                              ^0
 1102|  2.33k|            } else if ch >= 0x80 {
 1103|       |                // Handle UTF-8 multi-byte characters
 1104|     28|                if self.is_valid_utf8_start(ch) {
 1105|       |                    // Consume continuation bytes for valid UTF-8 sequences
 1106|     62|                    while let Some(continuation_ch) = self.peek_char() {
 1107|     62|                        if (0x80..0xC0).contains(&continuation_ch) {
 1108|     34|                            chars.push(self.next_char().unwrap());
 1109|     34|                        } else {
 1110|     28|                            break;
 1111|       |                        }
 1112|       |                    }
 1113|      0|                }
 1114|  2.30k|            }
 1115|       |        }
 1116|    246|    }
 1117|       |
 1118|       |    /// Shared logic for lexing quoted literals (strings and chars)
 1119|    246|    fn lex_quoted_literal(&mut self, prefix: &[u8], delimiter: u8) -> (String, StringId, bool) {
 1120|    246|        let mut chars = prefix.to_vec();
 1121|       |
 1122|    246|        if prefix.is_empty() || prefix.last() != Some(&delimiter) {
 1123|     21|            // consume the quote
 1124|     21|            let quote = self.next_char().unwrap();
 1125|     21|            chars.push(quote);
 1126|    225|        }
 1127|       |
 1128|    246|        let mut has_invalid_ucn = false;
 1129|    246|        self.lex_common_literal_body(delimiter, &mut chars, &mut has_invalid_ucn);
 1130|       |
 1131|    246|        let text = String::from_utf8(chars).unwrap();
 1132|    246|        let symbol = StringId::new(&text);
 1133|    246|        (text, symbol, has_invalid_ucn)
 1134|    246|    }
 1135|       |
 1136|    215|    fn lex_string_literal(&mut self, start_pos: u32, prefix: &[u8], flags: PPTokenFlags) -> PPToken {
 1137|    215|        let (text, symbol, invalid_ucn) = self.lex_quoted_literal(prefix, b'"');
 1138|    215|        let mut final_flags = flags;
 1139|    215|        if invalid_ucn {
 1140|      0|            final_flags |= PPTokenFlags::HAS_INVALID_UCN;
 1141|    215|        }
 1142|       |
 1143|    215|        PPToken::text(
 1144|    215|            PPTokenKind::StringLiteral(symbol),
 1145|    215|            final_flags,
 1146|    215|            SourceLoc::new(self.source_id, start_pos),
 1147|    215|            &text,
 1148|       |        )
 1149|    215|    }
 1150|       |
 1151|       |    /// Check if a byte is a valid start of a UTF-8 sequence
 1152|       |    /// Returns true if this could be the start of a valid UTF-8 sequence
 1153|     32|    fn is_valid_utf8_start(&self, byte: u8) -> bool {
 1154|       |        // Valid UTF-8 start bytes:
 1155|       |        // 0x00-0x7F: ASCII (single byte, handled elsewhere)
 1156|       |        // 0xC2-0xF4: Start of multi-byte sequence
 1157|       |        // Invalid starts: 0x80-0xBF (continuation bytes), 0xC0, 0xC1, 0xF5-0xFF
 1158|     32|        (0xC2..=0xF4).contains(&byte)
 1159|     32|    }
 1160|       |
 1161|     31|    fn lex_char_literal(&mut self, start_pos: u32, prefix: &[u8], flags: PPTokenFlags) -> PPToken {
 1162|     31|        let (text, symbol, invalid_ucn) = self.lex_quoted_literal(prefix, b'\'');
 1163|     31|        let mut final_flags = flags;
 1164|     31|        if invalid_ucn {
 1165|      0|            final_flags |= PPTokenFlags::HAS_INVALID_UCN;
 1166|     31|        }
 1167|     31|        let chars = text.as_bytes();
 1168|       |
 1169|       |        // Parse character literal content
 1170|     31|        let quote_start = if !prefix.is_empty() && prefix.last() == Some(&b'\'') {
 1171|     27|            prefix.len() - 1
 1172|       |        } else {
 1173|      4|            prefix.len()
 1174|       |        };
 1175|     31|        let content_start = quote_start + 1;
 1176|       |
 1177|     31|        let content_end = if chars.last() == Some(&b'\'') && chars.len() > content_start {
 1178|     31|            chars.len() - 1
 1179|       |        } else {
 1180|      0|            chars.len()
 1181|       |        };
 1182|       |
 1183|       |        // Safety: content indices are within bounds derived from text
 1184|     31|        let content_str = &text[content_start..content_end];
 1185|       |
 1186|     31|        let codepoint = if !content_str.is_empty() {
 1187|       |            // Use unified parsing for all char literals to handle UCNs and escapes correctly
 1188|     31|            literal_parsing::parse_char_literal(content_str)
 1189|     31|                .map(|c| c as u64)
 1190|     31|                .unwrap_or(0)
 1191|       |        } else {
 1192|      0|            0
 1193|       |        };
 1194|       |
 1195|     31|        PPToken::new(
 1196|     31|            PPTokenKind::CharLiteral(codepoint, symbol),
 1197|     31|            final_flags,
 1198|     31|            SourceLoc::new(self.source_id, start_pos),
 1199|     31|            text.len() as u16,
 1200|       |        )
 1201|     31|    }
 1202|       |
 1203|      4|    pub(crate) fn get_current_line(&self) -> u32 {
 1204|      4|        self.line_starts.len() as u32 + self.line_offset
 1205|      4|    }
 1206|       |
 1207|       |    ///  Bolt: Moves the `line_starts` vector out of the lexer.
 1208|       |    /// This avoids a clone when the lexer is destroyed and its line information
 1209|       |    /// is transferred to the SourceManager, which is a performance optimization.
 1210|    916|    pub(crate) fn take_line_starts(self) -> Vec<u32> {
 1211|    916|        self.line_starts
 1212|    916|    }
 1213|       |}

/app/src/pp/preprocessor.rs:
    1|       |use crate::ast::StringId;
    2|       |use crate::diagnostic::{Diagnostic, DiagnosticEngine, DiagnosticLevel};
    3|       |use crate::lang_options::LangOptions;
    4|       |use crate::source_manager::{SourceId, SourceLoc, SourceManager, SourceSpan};
    5|       |use chrono::{DateTime, Datelike, Timelike, Utc};
    6|       |use hashbrown::HashMap;
    7|       |use std::borrow::Cow;
    8|       |use std::collections::{HashSet, VecDeque};
    9|       |use std::sync::Arc;
   10|       |
   11|       |use super::pp_lexer::PPLexer;
   12|       |use crate::pp::interpreter::Interpreter;
   13|       |use crate::pp::{HeaderSearch, PPToken, PPTokenFlags, PPTokenKind};
   14|       |use std::path::{Path, PathBuf};
   15|       |use target_lexicon::{Architecture, OperatingSystem, Triple};
   16|       |
   17|       |/// Preprocessor directive kinds
   18|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   19|       |pub enum DirectiveKind {
   20|       |    Define,
   21|       |    Undef,
   22|       |    Include,
   23|       |    IncludeNext,
   24|       |    If,
   25|       |    Ifdef,
   26|       |    Ifndef,
   27|       |    Elif,
   28|       |    Else,
   29|       |    Endif,
   30|       |    Line,
   31|       |    Pragma,
   32|       |    Error,
   33|       |    Warning,
   34|       |}
   35|       |
   36|       |/// Table of pre-interned preprocessor directive names for O(1) keyword recognition
   37|       |#[derive(Clone)]
   38|       |pub(crate) struct DirectiveKeywordTable {
   39|       |    define: StringId,
   40|       |    undef: StringId,
   41|       |    include: StringId,
   42|       |    include_next: StringId,
   43|       |    if_: StringId,
   44|       |    ifdef: StringId,
   45|       |    ifndef: StringId,
   46|       |    elif: StringId,
   47|       |    else_: StringId,
   48|       |    endif: StringId,
   49|       |    line: StringId,
   50|       |    pragma: StringId,
   51|       |    error: StringId,
   52|       |    warning: StringId,
   53|       |    defined: StringId, // For the defined operator in expressions
   54|       |    has_include: StringId,
   55|       |    line_macro: StringId,
   56|       |    file_macro: StringId,
   57|       |    counter_macro: StringId,
   58|       |    pragma_operator: StringId,
   59|       |}
   60|       |
   61|       |impl Default for DirectiveKeywordTable {
   62|      0|    fn default() -> Self {
   63|      0|        Self::new()
   64|      0|    }
   65|       |}
   66|       |
   67|       |impl DirectiveKeywordTable {
   68|    920|    pub(crate) fn new() -> Self {
   69|    920|        DirectiveKeywordTable {
   70|    920|            define: StringId::new("define"),
   71|    920|            undef: StringId::new("undef"),
   72|    920|            include: StringId::new("include"),
   73|    920|            include_next: StringId::new("include_next"),
   74|    920|            if_: StringId::new("if"),
   75|    920|            ifdef: StringId::new("ifdef"),
   76|    920|            ifndef: StringId::new("ifndef"),
   77|    920|            elif: StringId::new("elif"),
   78|    920|            else_: StringId::new("else"),
   79|    920|            endif: StringId::new("endif"),
   80|    920|            line: StringId::new("line"),
   81|    920|            pragma: StringId::new("pragma"),
   82|    920|            error: StringId::new("error"),
   83|    920|            warning: StringId::new("warning"),
   84|    920|            defined: StringId::new("defined"),
   85|    920|            has_include: StringId::new("__has_include"),
   86|    920|            line_macro: StringId::new("__LINE__"),
   87|    920|            file_macro: StringId::new("__FILE__"),
   88|    920|            counter_macro: StringId::new("__COUNTER__"),
   89|    920|            pragma_operator: StringId::new("_Pragma"),
   90|    920|        }
   91|    920|    }
   92|       |
   93|    381|    pub(crate) fn is_directive(&self, symbol: StringId) -> Option<DirectiveKind> {
   94|    381|        if symbol == self.define {
   95|     95|            Some(DirectiveKind::Define)
   96|    286|        } else if symbol == self.undef {
   97|      3|            Some(DirectiveKind::Undef)
   98|    283|        } else if symbol == self.include {
   99|     32|            Some(DirectiveKind::Include)
  100|    251|        } else if symbol == self.include_next {
  101|      3|            Some(DirectiveKind::IncludeNext)
  102|    248|        } else if symbol == self.if_ {
  103|     72|            Some(DirectiveKind::If)
  104|    176|        } else if symbol == self.ifdef {
  105|      9|            Some(DirectiveKind::Ifdef)
  106|    167|        } else if symbol == self.ifndef {
  107|      9|            Some(DirectiveKind::Ifndef)
  108|    158|        } else if symbol == self.elif {
  109|     11|            Some(DirectiveKind::Elif)
  110|    147|        } else if symbol == self.else_ {
  111|     39|            Some(DirectiveKind::Else)
  112|    108|        } else if symbol == self.endif {
  113|     88|            Some(DirectiveKind::Endif)
  114|     20|        } else if symbol == self.line {
  115|      5|            Some(DirectiveKind::Line)
  116|     15|        } else if symbol == self.pragma {
  117|      9|            Some(DirectiveKind::Pragma)
  118|      6|        } else if symbol == self.error {
  119|      3|            Some(DirectiveKind::Error)
  120|      3|        } else if symbol == self.warning {
  121|      2|            Some(DirectiveKind::Warning)
  122|       |        } else {
  123|      1|            None
  124|       |        }
  125|    381|    }
  126|       |
  127|       |    /// Get the interned symbol for the "defined" operator
  128|      7|    pub(crate) fn defined_symbol(&self) -> StringId {
  129|      7|        self.defined
  130|      7|    }
  131|       |
  132|       |    /// Get the interned symbol for the "__has_include" operator
  133|      6|    pub(crate) fn has_include_symbol(&self) -> StringId {
  134|      6|        self.has_include
  135|      6|    }
  136|       |}
  137|       |
  138|       |// Packed boolean flags for macro properties
  139|       |bitflags::bitflags! {
  140|       |    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
  141|       |    pub struct MacroFlags: u8 {
  142|       |        const FUNCTION_LIKE = 1 << 0;
  143|       |        const C99_VARARGS = 1 << 1;
  144|       |        const GNU_VARARGS = 1 << 2;
  145|       |        const BUILTIN = 1 << 3;
  146|       |        const DISABLED = 1 << 4;
  147|       |        const USED = 1 << 5;
  148|       |    }
  149|       |}
  150|       |
  151|       |/// Represents a macro definition
  152|       |#[derive(Clone)]
  153|       |pub(crate) struct MacroInfo {
  154|       |    pub(crate) location: SourceLoc,
  155|       |    pub(crate) flags: MacroFlags, // Packed boolean flags
  156|       |    pub(crate) tokens: Arc<[PPToken]>,
  157|       |    pub(crate) parameter_list: Arc<[StringId]>,
  158|       |    pub(crate) variadic_arg: Option<StringId>,
  159|       |}
  160|       |
  161|       |/// Represents conditional compilation state
  162|       |#[derive(Debug, Clone)]
  163|       |pub(crate) struct PPConditionalInfo {
  164|       |    was_skipping: bool,
  165|       |    found_else: bool,
  166|       |    found_non_skipping: bool,
  167|       |}
  168|       |
  169|       |/// Include stack information
  170|       |#[derive(Clone)]
  171|       |pub(crate) struct IncludeStackInfo {
  172|       |    pub(crate) file_id: SourceId,
  173|       |    // pub location: SourceLoc,
  174|       |}
  175|       |
  176|       |/// Configuration for preprocessor
  177|       |#[derive(Debug, Clone)]
  178|       |pub struct PPConfig {
  179|       |    pub max_include_depth: usize,
  180|       |    pub system_include_paths: Vec<PathBuf>,
  181|       |    pub quoted_include_paths: Vec<PathBuf>,
  182|       |    pub angled_include_paths: Vec<PathBuf>,
  183|       |    pub framework_paths: Vec<PathBuf>,
  184|       |    pub lang_options: LangOptions,
  185|       |    pub target: Triple,
  186|       |    pub current_time: Option<DateTime<Utc>>,
  187|       |}
  188|       |
  189|       |impl Default for PPConfig {
  190|    920|    fn default() -> Self {
  191|    920|        Self {
  192|    920|            max_include_depth: 200,
  193|    920|            system_include_paths: Vec::new(),
  194|    920|            quoted_include_paths: Vec::new(),
  195|    920|            angled_include_paths: Vec::new(),
  196|    920|            framework_paths: Vec::new(),
  197|    920|            lang_options: LangOptions::default(),
  198|    920|            target: Triple::host(),
  199|    920|            current_time: None,
  200|    920|        }
  201|    920|    }
  202|       |}
  203|       |
  204|       |/// Main preprocessor structure
  205|       |pub struct Preprocessor<'src> {
  206|       |    sm: &'src mut SourceManager,
  207|       |    diag: &'src mut DiagnosticEngine,
  208|       |    lang_opts: LangOptions,
  209|       |    target: Triple,
  210|       |
  211|       |    // Pre-interned directive keywords for fast comparison
  212|       |    directive_keywords: DirectiveKeywordTable,
  213|       |
  214|       |    // Macro management
  215|       |    macros: HashMap<StringId, MacroInfo>,
  216|       |    macro_stack: HashMap<StringId, Vec<Option<MacroInfo>>>,
  217|       |
  218|       |    // Include management
  219|       |    once_included: HashSet<SourceId>,
  220|       |
  221|       |    // Conditional compilation state
  222|       |    conditional_stack: Vec<PPConditionalInfo>,
  223|       |
  224|       |    // Include handling
  225|       |    include_stack: Vec<IncludeStackInfo>,
  226|       |    header_search: HeaderSearch,
  227|       |    built_in_headers: HashMap<&'static str, &'static str>,
  228|       |    built_in_file_ids: HashMap<String, SourceId>,
  229|       |
  230|       |    // Token management
  231|       |    lexer_stack: Vec<PPLexer>,
  232|       |    pending_tokens: VecDeque<PPToken>,
  233|       |
  234|       |    // State
  235|       |    include_depth: usize,
  236|       |    max_include_depth: usize,
  237|       |    counter: u32,
  238|       |}
  239|       |
  240|       |/// Preprocessor errors
  241|       |#[derive(Debug, thiserror::Error)]
  242|       |pub enum PPErrorKind {
  243|       |    #[error("File not found: {path}")]
  244|       |    FileNotFound { path: String },
  245|       |    #[error("Invalid UTF-8 sequence")]
  246|       |    InvalidUtf8,
  247|       |    #[error("Include depth exceeded")]
  248|       |    IncludeDepthExceeded,
  249|       |    #[error("Macro redefinition")]
  250|       |    MacroRedefinition,
  251|       |    #[error("Expected identifier")]
  252|       |    ExpectedIdentifier,
  253|       |    #[error("Invalid directive")]
  254|       |    InvalidDirective,
  255|       |    #[error("Unexpected end of file")]
  256|       |    UnexpectedEndOfFile,
  257|       |    #[error("Invalid macro parameter")]
  258|       |    InvalidMacroParameter,
  259|       |    #[error("Invalid include path")]
  260|       |    InvalidIncludePath,
  261|       |    #[error("Unmatched #endif")]
  262|       |    UnmatchedEndif,
  263|       |    #[error("#error directive: {0}")]
  264|       |    ErrorDirective(String),
  265|       |    #[error("Invalid conditional expression")]
  266|       |    InvalidConditionalExpression,
  267|       |    #[error("Invalid #line directive")]
  268|       |    InvalidLineDirective,
  269|       |    #[error("Multiple #else directives")]
  270|       |    MultipleElse,
  271|       |    #[error("#elif after #else")]
  272|       |    ElifAfterElse,
  273|       |    #[error("#elif without #if")]
  274|       |    ElifWithoutIf,
  275|       |    #[error("#else without #if")]
  276|       |    ElseWithoutIf,
  277|       |    #[error("Macro expansion recursion detected")]
  278|       |    MacroRecursion,
  279|       |    #[error("Invalid token pasting")]
  280|       |    InvalidTokenPasting,
  281|       |    #[error("Invalid stringification")]
  282|       |    InvalidStringification,
  283|       |    #[error("Circular include detected")]
  284|       |    CircularInclude,
  285|       |    #[error("Expected end of directive")]
  286|       |    ExpectedEod,
  287|       |    #[error("Unknown pragma: {0}")]
  288|       |    UnknownPragma(String),
  289|       |    #[error("Pragma error: {0}")]
  290|       |    PragmaError(String),
  291|       |    #[error("Unclosed preprocessor conditional directive")]
  292|       |    UnclosedConditional,
  293|       |    #[error("Invalid universal character name")]
  294|       |    InvalidUniversalCharacterName,
  295|       |}
  296|       |
  297|       |#[derive(Debug)]
  298|       |pub struct PPError {
  299|       |    pub kind: PPErrorKind,
  300|       |    pub span: SourceSpan,
  301|       |}
  302|       |
  303|       |impl std::fmt::Display for PPError {
  304|      0|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  305|      0|        write!(f, "{}", self.kind)
  306|      0|    }
  307|       |}
  308|       |
  309|       |impl std::error::Error for PPError {
  310|      0|    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
  311|      0|        Some(&self.kind)
  312|      0|    }
  313|       |}
  314|       |
  315|       |impl From<PPError> for Diagnostic {
  316|      0|    fn from(val: PPError) -> Self {
  317|      0|        let level = DiagnosticLevel::Error;
  318|       |
  319|      0|        Diagnostic {
  320|      0|            level,
  321|      0|            message: val.kind.to_string(),
  322|      0|            span: val.span,
  323|      0|            ..Default::default()
  324|      0|        }
  325|      0|    }
  326|       |}
  327|       |
  328|       |impl crate::diagnostic::IntoDiagnostic for PPError {
  329|      0|    fn into_diagnostic(self) -> Vec<Diagnostic> {
  330|      0|        let span = self.span;
  331|      0|        let kind = self.kind;
  332|      0|        let mut diag = Diagnostic {
  333|      0|            level: DiagnosticLevel::Error,
  334|      0|            message: kind.to_string(),
  335|      0|            span,
  336|      0|            ..Default::default()
  337|      0|        };
  338|       |
  339|       |        // Add hints for certain error types
  340|      0|        match &kind {
  341|      0|            PPErrorKind::ElifWithoutIf => {
  342|      0|                diag.hints.push("perhaps you meant to use #if?".to_string());
  343|      0|            }
  344|      0|            PPErrorKind::ElseWithoutIf => {
  345|      0|                diag.hints
  346|      0|                    .push("perhaps you meant to use #ifdef or #ifndef?".to_string());
  347|      0|            }
  348|      0|            PPErrorKind::UnmatchedEndif => {
  349|      0|                diag.hints
  350|      0|                    .push("this #endif does not have a matching #if, #ifdef, or #ifndef".to_string());
  351|      0|            }
  352|      0|            PPErrorKind::MultipleElse => {
  353|      0|                diag.hints
  354|      0|                    .push("there can only be one #else directive per conditional level".to_string());
  355|      0|            }
  356|      0|            PPErrorKind::ElifAfterElse => {
  357|      0|                diag.hints
  358|      0|                    .push("#elif directives must come before the #else directive".to_string());
  359|      0|            }
  360|      0|            _ => {}
  361|       |        }
  362|       |
  363|      0|        vec![diag]
  364|      0|    }
  365|       |}
  366|       |
  367|       |impl<'src> Preprocessor<'src> {
  368|       |    /// Create a new preprocessor
  369|    919|    pub(crate) fn new(
  370|    919|        source_manager: &'src mut SourceManager,
  371|    919|        diag: &'src mut DiagnosticEngine,
  372|    919|        config: &PPConfig,
  373|    919|    ) -> Self {
  374|    919|        let mut header_search = HeaderSearch {
  375|    919|            system_path: Vec::new(),
  376|    919|            framework_path: Vec::new(),
  377|    919|            quoted_includes: Vec::new(),
  378|    919|            angled_includes: Vec::new(),
  379|    919|        };
  380|       |
  381|       |        // Populate the new fields
  382|    948|        for path in &config.system_include_paths {
                          ^29
  383|     29|            header_search.add_system_path(path.clone());
  384|     29|        }
  385|    921|        for path in &config.quoted_include_paths {
                          ^2
  386|      2|            header_search.add_quoted_path(path.clone());
  387|      2|        }
  388|    922|        for path in &config.angled_include_paths {
                          ^3
  389|      3|            header_search.add_angled_path(path.clone());
  390|      3|        }
  391|    919|        for path in &config.framework_paths {
                          ^0
  392|      0|            header_search.add_framework_path(path.clone());
  393|      0|        }
  394|       |
  395|    919|        let mut built_in_headers = HashMap::new();
  396|    919|        built_in_headers.insert("stddef.h", include_str!("../../custom-include/stddef.h"));
  397|    919|        built_in_headers.insert("stdint.h", include_str!("../../custom-include/stdint.h"));
  398|    919|        built_in_headers.insert("stdarg.h", include_str!("../../custom-include/stdarg.h"));
  399|    919|        built_in_headers.insert("stdbool.h", include_str!("../../custom-include/stdbool.h"));
  400|    919|        built_in_headers.insert("limits.h", include_str!("../../custom-include/limits.h"));
  401|       |
  402|    919|        let mut preprocessor = Preprocessor {
  403|    919|            sm: source_manager,
  404|    919|            diag,
  405|    919|            lang_opts: config.lang_options,
  406|    919|            directive_keywords: DirectiveKeywordTable::new(),
  407|    919|            macros: HashMap::new(),
  408|    919|            macro_stack: HashMap::new(),
  409|    919|            once_included: HashSet::new(),
  410|    919|            conditional_stack: Vec::new(),
  411|    919|            include_stack: Vec::new(),
  412|    919|            header_search,
  413|    919|            built_in_headers,
  414|    919|            built_in_file_ids: HashMap::new(),
  415|    919|            lexer_stack: Vec::new(),
  416|    919|            pending_tokens: VecDeque::new(),
  417|    919|            include_depth: 0,
  418|    919|            max_include_depth: config.max_include_depth,
  419|    919|            target: config.target.clone(),
  420|    919|            counter: 0,
  421|    919|        };
  422|       |
  423|       |        // Initialize built-in headers
  424|  5.51k|        for (name, content) in &preprocessor.built_in_headers {
                           ^4.59k^4.59k
  425|  4.59k|            let source_id = preprocessor.sm.add_buffer(
  426|  4.59k|                content.as_bytes().to_vec(),
  427|  4.59k|                name,
  428|  4.59k|                None, // No include location for initialization
  429|  4.59k|            );
  430|  4.59k|            preprocessor.built_in_file_ids.insert(name.to_string(), source_id);
  431|  4.59k|        }
  432|       |
  433|    919|        preprocessor.initialize_builtin_macros(config.current_time);
  434|    919|        preprocessor
  435|    919|    }
  436|       |
  437|       |    /// Try to expand a magic macro (e.g. __LINE__, __FILE__, __COUNTER__)
  438|  7.11k|    fn try_expand_magic_macro(&mut self, token: &PPToken) -> Option<PPToken> {
  439|  7.11k|        let PPTokenKind::Identifier(symbol) = token.kind else {
                                                  ^6.48k
  440|    627|            return None;
  441|       |        };
  442|       |
  443|  6.48k|        let (kind, text) = if symbol == self.directive_keywords.line_macro {
                           ^9    ^9
  444|      2|            let line = self.sm.get_presumed_location(token.location).map(|p| p.0).unwrap_or(1);
  445|      2|            let text = line.to_string();
  446|      2|            (PPTokenKind::Number(StringId::new(&text)), text)
  447|  6.48k|        } else if symbol == self.directive_keywords.file_macro {
  448|      2|            let filename = self
  449|      2|                .sm
  450|      2|                .get_presumed_location(token.location)
  451|      2|                .and_then(|p| p.2)
  452|      2|                .unwrap_or("<unknown>");
  453|      2|            let text = format!("\"{}\"", filename);
  454|      2|            (PPTokenKind::StringLiteral(StringId::new(&text)), text)
  455|  6.48k|        } else if symbol == self.directive_keywords.counter_macro {
  456|      5|            let text = self.get_next_counter().to_string();
  457|      5|            (PPTokenKind::Number(StringId::new(&text)), text)
  458|       |        } else {
  459|  6.48k|            return None;
  460|       |        };
  461|       |
  462|      9|        Some(PPToken::text(kind, PPTokenFlags::empty(), token.location, &text))
  463|  7.11k|    }
  464|       |
  465|       |    /// Get the next value for __COUNTER__
  466|      5|    fn get_next_counter(&mut self) -> u32 {
  467|      5|        let val = self.counter;
  468|      5|        self.counter += 1;
  469|      5|        val
  470|      5|    }
  471|       |
  472|       |    /// Initialize built-in macros
  473|    919|    fn initialize_builtin_macros(&mut self, current_time: Option<DateTime<Utc>>) {
  474|    919|        let now: DateTime<Utc> = current_time.unwrap_or_else(Utc::now);
  475|       |
  476|       |        // __DATE__
  477|    919|        let date_str = format!("\"{:02} {:02} {}\"", now.format("%b"), now.day(), now.year());
  478|    919|        self.define_builtin_macro_string("__DATE__", &date_str);
  479|       |
  480|       |        // __TIME__
  481|    919|        let time_str = format!("\"{:02}:{:02}:{:02}\"", now.hour(), now.minute(), now.second());
  482|    919|        self.define_builtin_macro_string("__TIME__", &time_str);
  483|       |
  484|       |        // Other built-ins
  485|    919|        self.define_builtin_macro_one("__STDC__");
  486|       |
  487|       |        // Target specific macros
  488|       |        // Architecture
  489|    919|        match self.target.architecture {
  490|       |            Architecture::X86_64 => {
  491|  4.59k|                for macro_name in &["__x86_64__", "__x86_64", "__amd64__", "__amd64"] {
                                  ^3.67k
  492|  3.67k|                    self.define_builtin_macro_one(macro_name);
  493|  3.67k|                }
  494|       |            }
  495|       |            Architecture::X86_32(_) => {
  496|      0|                for macro_name in &["__i386__", "__i386"] {
  497|      0|                    self.define_builtin_macro_one(macro_name);
  498|      0|                }
  499|       |            }
  500|      0|            Architecture::Aarch64(_) => {
  501|      0|                self.define_builtin_macro_one("__aarch64__");
  502|      0|            }
  503|      0|            Architecture::Arm(_) => {
  504|      0|                self.define_builtin_macro_one("__arm__");
  505|      0|            }
  506|      0|            _ => {}
  507|       |        }
  508|       |
  509|       |        // Pointer width
  510|    919|        if self.target.pointer_width().ok().map(|w| w.bits()).unwrap_or(64) == 64 {
  511|  2.75k|            for macro_name in &["__LP64__", "_LP64"] {
                              ^1.83k
  512|  1.83k|                self.define_builtin_macro_one(macro_name);
  513|  1.83k|            }
  514|       |        } else {
  515|      0|            for macro_name in &["__ILP32__", "_ILP32"] {
  516|      0|                self.define_builtin_macro_one(macro_name);
  517|      0|            }
  518|       |        }
  519|       |
  520|       |        // OS
  521|    919|        match self.target.operating_system {
  522|       |            OperatingSystem::Linux => {
  523|  6.43k|                for macro_name in &["__linux__", "__linux", "__unix__", "__unix", "__ELF__", "__gnu_linux__"] {
                                  ^5.51k
  524|  5.51k|                    self.define_builtin_macro_one(macro_name);
  525|  5.51k|                }
  526|       |            }
  527|       |            OperatingSystem::Darwin(_) => {
  528|      0|                for macro_name in &["__APPLE__", "__MACH__"] {
  529|      0|                    self.define_builtin_macro_one(macro_name);
  530|      0|                }
  531|       |            }
  532|       |            OperatingSystem::Windows => {
  533|      0|                self.define_builtin_macro_one("_WIN32");
  534|      0|                if self.target.pointer_width().ok().map(|w| w.bits()).unwrap_or(32) == 64 {
  535|      0|                    self.define_builtin_macro_one("_WIN64");
  536|      0|                }
  537|       |            }
  538|      0|            _ => {}
  539|       |        }
  540|       |
  541|       |        // GCC version macros for compatibility with glibc headers
  542|       |        // We define these to match what Clang does for GCC compatibility
  543|    919|        self.define_builtin_macro("__extension__", vec![]);
  544|    919|        self.define_builtin_macro("__restrict", vec![]);
  545|    919|        self.define_builtin_macro_with_val("__GNUC__", "4");
  546|    919|        self.define_builtin_macro_with_val("__GNUC_MINOR__", "2");
  547|    919|        self.define_builtin_macro_with_val("__GNUC_PATCHLEVEL__", "1");
  548|       |
  549|    919|        if self.lang_opts.is_c11() {
  550|      1|            self.define_builtin_macro_with_val("__STDC_VERSION__", "201112");
  551|      1|            self.define_builtin_macro_one("__STDC_HOSTED__");
  552|      1|            self.define_builtin_macro_one("__STDC_MB_MIGHT_NEQ_WC__");
  553|      1|            self.define_builtin_macro_one("__STDC_IEC_559__");
  554|      1|            self.define_builtin_macro_one("__STDC_IEC_559_COMPLEX__");
  555|      1|            self.define_builtin_macro_with_val("__STDC_ISO_10646__", "201103L");
  556|      1|            self.define_builtin_macro_one("__STDC_UTF_16__");
  557|      1|            self.define_builtin_macro_one("__STDC_UTF_32__");
  558|    918|        }
  559|    919|    }
  560|       |
  561|       |    /// Helper to define a built-in macro with value "1"
  562|  11.9k|    fn define_builtin_macro_one(&mut self, name: &str) {
  563|  11.9k|        self.define_builtin_macro_with_val(name, "1");
  564|  11.9k|    }
  565|       |
  566|       |    /// Helper to define a built-in macro with a specific number value
  567|  14.7k|    fn define_builtin_macro_with_val(&mut self, name: &str, value: &str) {
  568|  14.7k|        self.define_builtin_macro(
  569|  14.7k|            name,
  570|  14.7k|            vec![PPToken::new(
  571|  14.7k|                PPTokenKind::Number(StringId::new(value)),
  572|  14.7k|                PPTokenFlags::empty(),
  573|  14.7k|                SourceLoc::builtin(),
  574|  14.7k|                value.len() as u16,
  575|       |            )],
  576|       |        );
  577|  14.7k|    }
  578|       |
  579|       |    /// Helper to define a built-in macro with a string value
  580|  1.83k|    fn define_builtin_macro_string(&mut self, name: &str, value: &str) {
  581|  1.83k|        self.define_builtin_macro(
  582|  1.83k|            name,
  583|  1.83k|            vec![PPToken::new(
  584|  1.83k|                PPTokenKind::StringLiteral(StringId::new(value)),
  585|  1.83k|                PPTokenFlags::empty(),
  586|  1.83k|                SourceLoc::builtin(),
  587|  1.83k|                value.len() as u16,
  588|       |            )],
  589|       |        );
  590|  1.83k|    }
  591|       |
  592|       |    /// Define a built-in macro
  593|  18.3k|    fn define_builtin_macro(&mut self, name: &str, tokens: Vec<PPToken>) {
  594|  18.3k|        let symbol = StringId::new(name);
  595|  18.3k|        let macro_info = MacroInfo {
  596|  18.3k|            location: SourceLoc::builtin(),
  597|  18.3k|            flags: MacroFlags::BUILTIN,
  598|  18.3k|            tokens: Arc::from(tokens),
  599|  18.3k|            parameter_list: Arc::from([]),
  600|  18.3k|            variadic_arg: None,
  601|  18.3k|        };
  602|  18.3k|        self.macros.insert(symbol, macro_info);
  603|  18.3k|    }
  604|       |
  605|       |    /// Check if a macro is defined
  606|      7|    pub(crate) fn is_macro_defined(&self, symbol: &StringId) -> bool {
  607|      7|        self.macros.contains_key(symbol)
  608|      7|    }
  609|       |
  610|       |    /// Get the interned symbol for the "defined" operator
  611|      7|    pub(crate) fn defined_symbol(&self) -> StringId {
  612|      7|        self.directive_keywords.defined_symbol()
  613|      7|    }
  614|       |
  615|       |    /// Get the interned symbol for the "__has_include" operator
  616|      6|    pub(crate) fn has_include_symbol(&self) -> StringId {
  617|      6|        self.directive_keywords.has_include_symbol()
  618|      6|    }
  619|       |
  620|       |    /// Get the text associated with a token
  621|      9|    pub(crate) fn get_token_text(&self, token: &PPToken) -> &str {
  622|      9|        let buffer = self.sm.get_buffer(token.location.source_id());
  623|      9|        let start = token.location.offset() as usize;
  624|      9|        let end = start + token.length as usize;
  625|      9|        if end <= buffer.len() {
  626|      9|            unsafe { std::str::from_utf8_unchecked(&buffer[start..end]) }
  627|       |        } else {
  628|      0|            ""
  629|       |        }
  630|      9|    }
  631|       |
  632|       |    /// Check if a header exists
  633|      6|    pub(crate) fn check_header_exists(&self, path: &str, is_angled: bool) -> bool {
  634|      6|        let current_dir = self
  635|      6|            .lexer_stack
  636|      6|            .last()
  637|      6|            .and_then(|lexer| self.sm.get_file_info(lexer.source_id))
  638|      6|            .and_then(|info| info.path.parent())
  639|      6|            .unwrap_or(Path::new("."));
  640|       |
  641|      6|        if is_angled && self.built_in_headers.contains_key(path) {
                                      ^3                    ^3           ^3
  642|      3|            return true;
  643|      3|        }
  644|       |
  645|      3|        self.header_search.resolve_path(path, is_angled, current_dir).is_some()
  646|      3|            || (!is_angled && self.sm.get_file_id(path).is_some())
  647|      6|    }
  648|       |
  649|       |    /// Expect and consume an Eod token or end of file
  650|    171|    fn expect_eod(&mut self) -> Result<(), PPError> {
  651|    171|        match self.lex_token() {
  652|    171|            Some(token) if token.kind == PPTokenKind::Eod => Ok(()),
  653|      0|            None => Ok(()), // End of file is acceptable
  654|      0|            Some(token) => self.emit_error_loc(PPErrorKind::ExpectedEod, token.location),
  655|       |        }
  656|    171|    }
  657|       |
  658|       |    /// Expect a token, and fail with UnexpectedEndOfFile if None is returned
  659|    761|    fn expect_token(&mut self) -> Result<PPToken, PPError> {
  660|    761|        self.lex_token()
  661|    761|            .ok_or_else(|| self.error(PPErrorKind::UnexpectedEndOfFile, self.get_current_span()))
                                         ^0   ^0    ^0                                ^0   ^0
  662|    761|    }
  663|       |
  664|       |    /// Expect a token of a specific kind
  665|     18|    fn expect_kind(&mut self, kind: PPTokenKind) -> Result<PPToken, PPError> {
  666|     18|        let token = self.expect_token()?;
                                                     ^0
  667|     18|        if token.kind == kind {
  668|     18|            Ok(token)
  669|       |        } else {
  670|      0|            self.emit_error_loc(PPErrorKind::InvalidDirective, token.location)
  671|       |        }
  672|     18|    }
  673|       |
  674|       |    /// Expect a string literal token
  675|      6|    fn expect_string_literal(&mut self) -> Result<(StringId, SourceLoc), PPError> {
  676|      6|        let token = self.expect_token()?;
                                                     ^0
  677|      6|        if let PPTokenKind::StringLiteral(s) = token.kind {
  678|      6|            Ok((s, token.location))
  679|       |        } else {
  680|      0|            self.emit_error_loc(PPErrorKind::InvalidDirective, token.location)
  681|       |        }
  682|      6|    }
  683|       |
  684|       |    /// Expect an identifier token
  685|    126|    fn expect_identifier(&mut self) -> Result<(PPToken, StringId), PPError> {
  686|    126|        let token = self.expect_token()?;
                                                     ^0
  687|    126|        if let PPTokenKind::Identifier(sym) = token.kind {
  688|    126|            Ok((token, sym))
  689|       |        } else {
  690|      0|            self.emit_error_loc(PPErrorKind::ExpectedIdentifier, token.location)
  691|       |        }
  692|    126|    }
  693|       |
  694|       |    /// Collect tokens balanced between open and close delimiters.
  695|       |    /// Assumes the opening delimiter has NOT been consumed yet and will consume it.
  696|      6|    fn collect_balanced_tokens(&mut self, open: PPTokenKind, close: PPTokenKind) -> Result<Vec<PPToken>, PPError> {
  697|      6|        self.expect_kind(open)?;
                                            ^0
  698|      6|        let mut tokens = Vec::new();
  699|      6|        let mut depth = 1;
  700|     12|        while let Some(t) = self.lex_token() {
  701|     12|            if t.kind == PPTokenKind::Eod {
  702|      0|                return self.emit_error_loc(PPErrorKind::UnexpectedEndOfFile, t.location);
  703|     12|            }
  704|     12|            if t.kind == open {
  705|      0|                depth += 1;
  706|     12|            } else if t.kind == close {
  707|      6|                depth -= 1;
  708|      6|                if depth == 0 {
  709|      6|                    return Ok(tokens);
  710|      0|                }
  711|      6|            }
  712|      6|            tokens.push(t);
  713|       |        }
  714|      0|        self.emit_error_loc(PPErrorKind::UnexpectedEndOfFile, self.get_current_location())
  715|      6|    }
  716|       |
  717|       |    /// Helper to extract content of a string literal, stripping quotes.
  718|     23|    fn extract_string_literal_content(
  719|     23|        &self,
  720|     23|        symbol: StringId,
  721|     23|        location: SourceLoc,
  722|     23|        error_kind: PPErrorKind,
  723|     23|    ) -> Result<String, PPError> {
  724|     23|        let s = symbol.as_str();
  725|     23|        s.strip_prefix('"')
  726|     23|            .and_then(|s| s.strip_suffix('"'))
  727|     23|            .map(|s| s.to_string())
  728|     23|            .ok_or_else(|| self.error_loc(error_kind, location))
                                         ^0   ^0        ^0          ^0
  729|     23|    }
  730|       |
  731|       |    /// Process source file and return preprocessed tokens
  732|    917|    pub(crate) fn process(&mut self, source_id: SourceId, _config: &PPConfig) -> Result<Vec<PPToken>, PPError> {
  733|       |        // Initialize lexer for main file
  734|    917|        let buffer_len = self.sm.get_buffer(source_id).len() as u32;
  735|    917|        let buffer = self.sm.get_buffer_arc(source_id);
  736|       |
  737|    917|        self.lexer_stack.push(PPLexer::new(source_id, buffer));
  738|    917|        self.sm.calculate_line_starts(source_id);
  739|       |
  740|    917|        let mut result_tokens = Vec::new();
  741|       |
  742|  17.1k|        while let Some(token) = self.lex_token() {
                                     ^16.2k
  743|  15.8k|            match token.kind {
  744|       |                // Handle directive
  745|    381|                PPTokenKind::Hash if !token.flags.contains(PPTokenFlags::MACRO_EXPANDED) => {
  746|    381|                    self.handle_directive()?;
                                                         ^16
  747|       |                }
  748|       |                // Skip tokens when in conditional compilation skip mode
  749|  15.8k|                _ if self.is_currently_skipping() => continue,
                                                              ^76  ^76
  750|       |                // Skip Eod tokens
  751|      1|                PPTokenKind::Eod => continue,
  752|       |                // Handle identifiers (macros, magic macros, _Pragma)
  753|  6.28k|                PPTokenKind::Identifier(symbol) => {
  754|  6.28k|                    if let Some(magic) = self.try_expand_magic_macro(&token) {
                                              ^8
  755|      8|                        result_tokens.push(magic);
  756|  6.27k|                    } else if symbol == self.directive_keywords.pragma_operator {
  757|      2|                        self.handle_pragma_operator()?;
                                                                   ^0
  758|  6.27k|                    } else if let Some(expanded) = self.expand_macro(&token)? {
                                                     ^62                                  ^0
  759|    344|                        for t in expanded.into_iter().rev() {
                                               ^62      ^62         ^62
  760|    344|                            self.pending_tokens.push_front(t);
  761|    344|                        }
  762|  6.21k|                    } else {
  763|  6.21k|                        result_tokens.push(token);
  764|  6.21k|                    }
  765|       |                }
  766|       |                // All other tokens
  767|  9.51k|                _ => result_tokens.push(token),
  768|       |            }
  769|       |        }
  770|       |
  771|       |        // Add EOF token
  772|    901|        result_tokens.push(PPToken::new(
  773|    901|            PPTokenKind::Eof,
  774|    901|            PPTokenFlags::empty(),
  775|    901|            SourceLoc::new(source_id, buffer_len),
  776|       |            0,
  777|       |        ));
  778|       |
  779|    901|        if !self.conditional_stack.is_empty() {
  780|      0|            let loc = self.get_current_location();
  781|      0|            return self.emit_error_loc(PPErrorKind::UnclosedConditional, loc);
  782|    901|        }
  783|       |
  784|    901|        Ok(result_tokens)
  785|    917|    }
  786|       |
  787|       |    /// Get the current location from the lexer stack
  788|     10|    fn get_current_location(&self) -> SourceLoc {
  789|     10|        if let Some(lexer) = self.lexer_stack.last() {
  790|     10|            SourceLoc::new(lexer.source_id, lexer.position)
  791|       |        } else {
  792|      0|            SourceLoc::builtin()
  793|       |        }
  794|     10|    }
  795|       |
  796|      0|    fn get_current_span(&self) -> SourceSpan {
  797|      0|        let loc = self.get_current_location();
  798|      0|        SourceSpan::new(loc, loc)
  799|      0|    }
  800|       |
  801|      0|    fn error(&self, kind: PPErrorKind, span: SourceSpan) -> PPError {
  802|      0|        PPError { kind, span }
  803|      0|    }
  804|       |
  805|      2|    fn error_loc(&self, kind: PPErrorKind, loc: SourceLoc) -> PPError {
  806|      2|        PPError {
  807|      2|            kind,
  808|      2|            span: SourceSpan::new(loc, loc),
  809|      2|        }
  810|      2|    }
  811|       |
  812|      0|    fn emit_error<T>(&self, kind: PPErrorKind, span: SourceSpan) -> Result<T, PPError> {
  813|      0|        Err(PPError { kind, span })
  814|      0|    }
  815|       |
  816|     14|    fn emit_error_loc<T>(&self, kind: PPErrorKind, loc: SourceLoc) -> Result<T, PPError> {
  817|     14|        Err(PPError {
  818|     14|            kind,
  819|     14|            span: SourceSpan::new(loc, loc),
  820|     14|        })
  821|     14|    }
  822|       |
  823|       |    /// Check if we are currently skipping tokens
  824|  16.1k|    fn is_currently_skipping(&self) -> bool {
  825|       |        // Check if any conditional in the stack is currently skipping
  826|  16.1k|        self.conditional_stack.iter().any(|info| info.was_skipping)
  827|  16.1k|    }
  828|       |
  829|       |    /// Set the skipping state for the current conditional level
  830|      3|    fn set_skipping(&mut self, skipping: bool) {
  831|      3|        if let Some(info) = self.conditional_stack.last_mut() {
  832|      3|            info.was_skipping = skipping;
  833|      3|        } else {
  834|      0|            // No conditionals, don't skip
  835|      0|        }
  836|      3|    }
  837|       |
  838|       |    /// Parse a conditional expression for #if and #elif
  839|     75|    fn parse_conditional_expression(&mut self) -> Result<Vec<PPToken>, PPError> {
  840|     75|        let mut tokens = Vec::new();
  841|    396|        while let Some(token) = self.lex_token() {
  842|    396|            if token.kind == PPTokenKind::Eod {
  843|     75|                break;
  844|    321|            }
  845|    321|            tokens.push(token);
  846|       |        }
  847|       |
  848|     75|        if tokens.is_empty() {
  849|      0|            let loc = self.get_current_location();
  850|      0|            return self.emit_error_loc(PPErrorKind::InvalidConditionalExpression, loc);
  851|     75|        }
  852|       |
  853|     75|        Ok(tokens)
  854|     75|    }
  855|       |
  856|       |    /// Evaluate a conditional expression (simplified - handle defined and basic arithmetic)
  857|     75|    fn evaluate_conditional_expression(&mut self, tokens: Vec<PPToken>) -> Result<bool, PPError> {
  858|       |        // Bolt : Removed redundant filtering of Eod tokens and a buggy optimization.
  859|       |        // parse_conditional_expression already ensures no Eod tokens are present.
  860|       |        // This avoids two allocations and two full clones of the token list.
  861|       |        // The buggy 'defined' optimization was also removed as it incorrectly
  862|       |        // returned early for complex expressions like '#if defined(FOO) && 0'.
  863|       |        // Bolt : Optimized to take tokens by value, avoiding a redundant `to_vec()` clone.
  864|     75|        if tokens.is_empty() {
  865|       |            // For empty expressions, treat as false
  866|      0|            return Ok(false);
  867|     75|        }
  868|       |
  869|       |        // First, expand macros in the expression
  870|     75|        let mut expanded_tokens = tokens;
  871|     75|        match self.expand_tokens(&mut expanded_tokens, true) {
  872|     75|            Ok(_) => {}
  873|      0|            Err(_e) => {
  874|       |                // If macro expansion fails, emit diagnostic and treat as false
  875|      0|                self.report_warning(
  876|       |                    "Failed to expand macros in conditional expression",
  877|      0|                    self.get_current_location(),
  878|       |                );
  879|      0|                return Ok(false);
  880|       |            }
  881|       |        }
  882|       |
  883|     75|        self.evaluate_arithmetic_expression(&expanded_tokens)
  884|     75|    }
  885|       |
  886|       |    /// Evaluate a simple arithmetic expression for #if/#elif
  887|     75|    fn evaluate_arithmetic_expression(&mut self, tokens: &[PPToken]) -> Result<bool, PPError> {
  888|     75|        if tokens.is_empty() {
  889|      0|            let loc = self.get_current_location();
  890|      0|            return self.emit_error_loc(PPErrorKind::InvalidConditionalExpression, loc);
  891|     75|        }
  892|       |
  893|     75|        let mut interpreter = Interpreter::new(tokens, self);
  894|     75|        let result = interpreter.evaluate();
  895|       |
  896|     75|        match result {
  897|     73|            Ok(val) => Ok(val.is_truthy()),
  898|       |            Err(_) => {
  899|       |                // For complex expressions that can't be parsed, emit a warning and treat as false
  900|      2|                self.report_warning(
  901|       |                    "Invalid conditional expression in preprocessor directive",
  902|      2|                    self.get_current_location(),
  903|       |                );
  904|       |                // Return false for unparseable expressions to allow compilation to continue
  905|      2|                Ok(false)
  906|       |            }
  907|       |        }
  908|     75|    }
  909|       |
  910|       |    /// Lex the next token
  911|    916|    fn pop_finished_lexer(&mut self) -> bool {
  912|       |        // EOF reached, pop the lexer
  913|    916|        let popped_lexer = self.lexer_stack.pop().unwrap();
  914|       |
  915|       |        // If this was an included file, pop from include stack and decrement depth.
  916|    916|        if let Some(include_info) = self.include_stack.last()
                                  ^15
  917|     15|            && include_info.file_id == popped_lexer.source_id
  918|     15|        {
  919|     15|            self.include_stack.pop();
  920|     15|            self.include_depth -= 1;
  921|    901|        }
  922|       |
  923|       |        //  Bolt: Use `take_line_starts` to move the line_starts vector
  924|       |        // instead of cloning it. This is a performance optimization that
  925|       |        // avoids a potentially large allocation when a file is finished lexing.
  926|    916|        self.sm
  927|    916|            .set_line_starts(popped_lexer.source_id, popped_lexer.take_line_starts());
  928|       |
  929|    916|        !self.lexer_stack.is_empty()
  930|    916|    }
  931|       |
  932|       |    /// Lex the next token
  933|  19.2k|    fn lex_token(&mut self) -> Option<PPToken> {
  934|  19.2k|        if let Some(token) = self.pending_tokens.pop_front() {
                                  ^497
  935|    497|            return Some(token);
  936|  18.7k|        }
  937|       |
  938|       |        loop {
  939|  18.7k|            if let Some(lexer) = self.lexer_stack.last_mut() {
  940|  18.7k|                if let Some(token) = lexer.next_token() {
                                          ^17.8k
  941|  17.8k|                    if token.flags.contains(PPTokenFlags::HAS_INVALID_UCN) {
  942|      0|                        let err = self.error_loc(PPErrorKind::InvalidUniversalCharacterName, token.location);
  943|      0|                        self.report_pp_error(err);
  944|  17.8k|                    }
  945|  17.8k|                    return Some(token);
  946|       |                } else {
  947|       |                    // Current lexer finished
  948|    916|                    if !self.pop_finished_lexer() {
  949|    901|                        return None;
  950|     15|                    }
  951|       |                    // Continue to try the next lexer in the stack
  952|       |                }
  953|       |            } else {
  954|      0|                return None;
  955|       |            }
  956|       |        }
  957|  19.2k|    }
  958|       |
  959|       |    /// Handle preprocessor directives
  960|    381|    fn handle_directive(&mut self) -> Result<(), PPError> {
  961|    381|        let token = self.expect_token()?;
                                                     ^0
  962|       |
  963|    381|        match token.kind {
  964|    379|            PPTokenKind::Identifier(sym) => match self.directive_keywords.is_directive(sym) {
  965|    379|                Some(kind) => match kind {
  966|       |                    DirectiveKind::If
  967|       |                    | DirectiveKind::Ifdef
  968|       |                    | DirectiveKind::Ifndef
  969|       |                    | DirectiveKind::Elif
  970|       |                    | DirectiveKind::Else
  971|    228|                    | DirectiveKind::Endif => self.handle_conditional_directive(kind, token.location),
  972|       |                    _ => {
  973|    151|                        if self.is_currently_skipping() {
  974|      8|                            self.skip_directive()
  975|       |                        } else {
  976|    143|                            self.execute_directive(kind)
  977|       |                        }
  978|       |                    }
  979|       |                },
  980|      0|                None => self.emit_error_loc(PPErrorKind::InvalidDirective, token.location),
  981|       |            },
  982|      2|            PPTokenKind::Eod => Ok(()),
  983|      0|            _ => self.emit_error_loc(PPErrorKind::InvalidDirective, token.location),
  984|       |        }
  985|    381|    }
  986|       |
  987|    228|    fn handle_conditional_directive(&mut self, kind: DirectiveKind, location: SourceLoc) -> Result<(), PPError> {
  988|    228|        match kind {
  989|       |            DirectiveKind::If | DirectiveKind::Ifdef | DirectiveKind::Ifndef => {
  990|     90|                if self.is_currently_skipping() {
  991|      3|                    self.push_skipped_conditional();
  992|      3|                    self.skip_directive()
  993|       |                } else {
  994|     87|                    match kind {
  995|       |                        DirectiveKind::If => {
  996|     69|                            let tokens = self.parse_conditional_expression().unwrap_or_default();
  997|     69|                            let cond = self.evaluate_conditional_expression(tokens).unwrap_or(false);
  998|     69|                            self.handle_if_directive(cond)
  999|       |                        }
 1000|      9|                        DirectiveKind::Ifdef => self.handle_ifdef(),
 1001|      9|                        DirectiveKind::Ifndef => self.handle_ifndef(),
 1002|      0|                        _ => unreachable!(),
 1003|       |                    }
 1004|       |                }
 1005|       |            }
 1006|       |            DirectiveKind::Elif => {
 1007|     11|                if self.should_evaluate_conditional() {
 1008|      6|                    let tokens = self.parse_conditional_expression().unwrap_or_default();
 1009|      6|                    let cond = self.evaluate_conditional_expression(tokens).unwrap_or(false);
 1010|      6|                    self.handle_elif_directive(cond, location)
 1011|       |                } else {
 1012|      5|                    self.handle_elif_directive(false, location)
 1013|       |                }
 1014|       |            }
 1015|     39|            DirectiveKind::Else => self.handle_else(location),
 1016|     88|            DirectiveKind::Endif => self.handle_endif(location),
 1017|      0|            _ => unreachable!(),
 1018|       |        }
 1019|    228|    }
 1020|       |
 1021|    143|    fn execute_directive(&mut self, kind: DirectiveKind) -> Result<(), PPError> {
 1022|    143|        match kind {
 1023|     93|            DirectiveKind::Define => self.handle_define(),
 1024|      2|            DirectiveKind::Undef => self.handle_undef(),
 1025|     31|            DirectiveKind::Include => self.handle_include(),
 1026|      3|            DirectiveKind::IncludeNext => self.handle_include_next(),
 1027|      4|            DirectiveKind::Line => self.handle_line(),
 1028|      8|            DirectiveKind::Pragma => self.handle_pragma(),
 1029|      1|            DirectiveKind::Error => self.handle_error(),
 1030|      1|            DirectiveKind::Warning => self.handle_warning(),
 1031|      0|            _ => unreachable!("Conditional directives handled separately"),
 1032|       |        }
 1033|    143|    }
 1034|       |
 1035|       |    /// Handle _Pragma("...") operator
 1036|      2|    fn handle_pragma_operator(&mut self) -> Result<(), PPError> {
 1037|       |        // We have already consumed the `_Pragma` identifier.
 1038|      2|        self.expect_kind(PPTokenKind::LeftParen)?;
                                                              ^0
 1039|      2|        let (symbol, _) = self.expect_string_literal()?;
                                                                    ^0
 1040|      2|        let pragma_content = self.destringize(symbol.as_str());
 1041|      2|        self.expect_kind(PPTokenKind::RightParen)?;
                                                               ^0
 1042|       |
 1043|      2|        self.perform_pragma(&pragma_content);
 1044|       |
 1045|      2|        Ok(())
 1046|      2|    }
 1047|       |
 1048|       |    /// Destringize a string literal (remove quotes and handle escapes)
 1049|     23|    pub(crate) fn destringize(&self, full_str: &str) -> String {
 1050|     23|        crate::ast::literal_parsing::unescape_string(&full_str[1..full_str.len() - 1])
 1051|     23|    }
 1052|       |
 1053|       |    /// Tokenize the content of a pragma directive
 1054|      5|    fn tokenize_pragma_content(&mut self, pragma_content: &str) -> Vec<PPToken> {
 1055|       |        // Create a buffer for the pragma content
 1056|      5|        let source_id = self
 1057|      5|            .sm
 1058|      5|            .add_buffer(pragma_content.as_bytes().to_vec(), "<_Pragma>", None);
 1059|      5|        let buffer = self.sm.get_buffer_arc(source_id);
 1060|      5|        let mut temp_lexer = PPLexer::new(source_id, buffer);
 1061|       |
 1062|       |        // Collect all tokens from the pragma content
 1063|      5|        let mut tokens = Vec::new();
 1064|     19|        while let Some(token) = temp_lexer.next_token() {
                                     ^14
 1065|     14|            if matches!(token.kind, PPTokenKind::Eod | PPTokenKind::Eof) {
 1066|      0|                continue;
 1067|     14|            }
 1068|     14|            tokens.push(token);
 1069|       |        }
 1070|       |
 1071|       |        // Determine location for the synthetic EOD
 1072|      5|        let eod_loc = if let Some(last) = tokens.last() {
 1073|      5|            last.location
 1074|       |        } else {
 1075|      0|            SourceLoc::new(source_id, 0)
 1076|       |        };
 1077|       |
 1078|       |        // Append EOD token to mark end of pragma
 1079|      5|        tokens.push(PPToken::new(PPTokenKind::Eod, PPTokenFlags::empty(), eod_loc, 0));
 1080|       |
 1081|      5|        tokens
 1082|      5|    }
 1083|       |
 1084|       |    /// Perform the action of a pragma directive
 1085|      5|    fn perform_pragma(&mut self, pragma_content: &str) {
 1086|      5|        let tokens = self.tokenize_pragma_content(pragma_content);
 1087|       |
 1088|       |        // Push to pending_tokens in reverse order so they come out in correct order
 1089|     19|        for token in tokens.into_iter().rev() {
                                   ^5     ^5          ^5
 1090|     19|            self.pending_tokens.push_front(token);
 1091|     19|        }
 1092|       |
 1093|       |        // Execute pragma handler
 1094|       |        // handle_pragma will consume tokens from pending_tokens
 1095|      5|        if self.handle_pragma().is_err() {
 1096|       |            // If handle_pragma failed (e.g. unknown pragma), it might not have consumed all tokens.
 1097|       |            // We must consume the remaining tokens of this pragma until EOD to ensure they don't leak.
 1098|      0|            while let Some(token) = self.lex_token() {
 1099|      0|                if token.kind == PPTokenKind::Eod {
 1100|      0|                    break;
 1101|      0|                }
 1102|       |            }
 1103|      5|        }
 1104|      5|    }
 1105|       |
 1106|       |    /// Handle #define directive
 1107|     93|    fn parse_define_args(&mut self, name: &str) -> Result<(MacroFlags, Vec<StringId>, Option<StringId>), PPError> {
 1108|     93|        let Some(token) = self.lex_token() else {
 1109|      0|            return Ok((MacroFlags::empty(), Vec::new(), None));
 1110|       |        };
 1111|       |
 1112|     93|        if token.kind == PPTokenKind::LeftParen && !token.flags.contains(PPTokenFlags::LEADING_SPACE) {
                                                                 ^39
 1113|     37|            let first_param = self.expect_token()?;
                                                               ^0
 1114|       |
 1115|      0|            if matches!(
 1116|     37|                first_param.kind,
 1117|       |                PPTokenKind::RightParen | PPTokenKind::Identifier(_) | PPTokenKind::Ellipsis
 1118|       |            ) {
 1119|     37|                self.pending_tokens.push_front(first_param);
 1120|     37|                return self.parse_macro_definition_params(name);
 1121|      0|            }
 1122|       |
 1123|      0|            self.pending_tokens.push_front(first_param);
 1124|      0|            self.pending_tokens.push_front(token);
 1125|      0|            return Ok((MacroFlags::empty(), Vec::new(), None));
 1126|     56|        }
 1127|       |
 1128|     56|        self.pending_tokens.push_front(token);
 1129|     56|        Ok((MacroFlags::empty(), Vec::new(), None))
 1130|     93|    }
 1131|       |
 1132|     93|    fn check_macro_redefinition(&mut self, name: StringId, name_token: &PPToken, macro_info: &MacroInfo) -> bool {
 1133|     93|        if let Some(existing) = self.macros.get(&name) {
                                  ^3
 1134|      3|            if existing.flags.contains(MacroFlags::BUILTIN) {
 1135|      1|                self.report_warning(
 1136|      1|                    format!("Redefinition of built-in macro '{}'", name),
 1137|      1|                    name_token.location,
 1138|       |                );
 1139|      1|                return false;
 1140|      2|            }
 1141|       |
 1142|       |            // Check if definition is different
 1143|       |            // Mask out runtime state flags (USED, DISABLED) that don't affect definition identity
 1144|      2|            let definition_flags_mask =
 1145|      2|                MacroFlags::FUNCTION_LIKE | MacroFlags::C99_VARARGS | MacroFlags::GNU_VARARGS | MacroFlags::BUILTIN;
 1146|      2|            let is_different = (existing.flags & definition_flags_mask) != (macro_info.flags & definition_flags_mask)
 1147|      2|                || existing.parameter_list != macro_info.parameter_list
 1148|      2|                || existing.variadic_arg != macro_info.variadic_arg
 1149|      2|                || existing.tokens.len() != macro_info.tokens.len()
 1150|      2|                || existing
 1151|      2|                    .tokens
 1152|      2|                    .iter()
 1153|      2|                    .zip(macro_info.tokens.iter())
 1154|      2|                    .any(|(a, b)| a.kind != b.kind);
 1155|       |
 1156|      2|            if is_different {
 1157|      1|                self.report_warning(
 1158|      1|                    format!("Redefinition of macro '{}'", name.as_str()),
 1159|      1|                    name_token.location,
 1160|      1|                );
 1161|      1|            }
 1162|     90|        }
 1163|     92|        true
 1164|     93|    }
 1165|       |
 1166|     93|    fn handle_define(&mut self) -> Result<(), PPError> {
 1167|     93|        let (name_token, name) = self.expect_identifier()?;
                                                                       ^0
 1168|       |
 1169|     93|        let (flags, params, variadic) = self.parse_define_args(name.as_str())?;
                                                                                           ^0
 1170|       |
 1171|       |        // Collect body tokens
 1172|       |        // Use collect_tokens_until_eod which handles the loop and checking for Eod
 1173|     93|        let tokens = self.collect_tokens_until_eod();
 1174|       |
 1175|       |        // Store the macro
 1176|     93|        let macro_info = MacroInfo {
 1177|     93|            location: name_token.location,
 1178|     93|            flags,
 1179|     93|            tokens: Arc::from(tokens),
 1180|     93|            parameter_list: Arc::from(params),
 1181|     93|            variadic_arg: variadic,
 1182|     93|        };
 1183|       |
 1184|     93|        if self.check_macro_redefinition(name, &name_token, &macro_info) {
 1185|     92|            self.macros.insert(name, macro_info);
 1186|     92|        }
                      ^1
 1187|     93|        Ok(())
 1188|     93|    }
 1189|       |
 1190|      2|    fn handle_undef(&mut self) -> Result<(), PPError> {
 1191|      2|        let (name_token, name) = self.expect_identifier()?;
                                                                       ^0
 1192|       |
 1193|      2|        if let Some(existing) = self.macros.get(&name)
 1194|      2|            && existing.flags.contains(MacroFlags::BUILTIN)
 1195|       |        {
 1196|      1|            self.report_warning(
 1197|      1|                format!("Undefining built-in macro '{}'", name.as_str()),
 1198|      1|                name_token.location,
 1199|       |            );
 1200|      1|            self.expect_eod()?;
                                           ^0
 1201|      1|            return Ok(());
 1202|      1|        }
 1203|       |
 1204|       |        // Remove the macro from the table if it exists
 1205|      1|        self.macros.remove(&name);
 1206|       |
 1207|      1|        self.expect_eod()?;
                                       ^0
 1208|       |
 1209|      1|        Ok(())
 1210|      2|    }
 1211|       |
 1212|     34|    fn do_handle_include(&mut self, is_next: bool) -> Result<(), PPError> {
 1213|     34|        let token = self.expect_token()?;
                                                     ^0
 1214|     34|        let mut eod_consumed = false;
 1215|       |
 1216|     34|        let (path_str, is_angled) = match token.kind {
                           ^29       ^29
 1217|     17|            PPTokenKind::StringLiteral(symbol) => {
 1218|     17|                let path =
 1219|     17|                    self.extract_string_literal_content(symbol, token.location, PPErrorKind::InvalidIncludePath)?;
                                                                                                                              ^0
 1220|     17|                (path, false)
 1221|       |            }
 1222|       |            PPTokenKind::Less => {
 1223|      9|                let mut path_parts = Vec::new();
 1224|     36|                while let Some(t) = self.lex_token() {
 1225|     36|                    if t.kind == PPTokenKind::Greater {
 1226|      9|                        break;
 1227|     27|                    }
 1228|     27|                    path_parts.push(t);
 1229|       |                }
 1230|      9|                (self.tokens_to_string(&path_parts), true)
 1231|       |            }
 1232|       |            _ => {
 1233|       |                // Computed include
 1234|      8|                let mut tokens = vec![token];
 1235|     14|                while let Some(t) = self.lex_token() {
 1236|     14|                    if t.kind == PPTokenKind::Eod {
 1237|      8|                        break;
 1238|      6|                    }
 1239|      6|                    tokens.push(t);
 1240|       |                }
 1241|      8|                eod_consumed = true;
 1242|      8|                self.expand_tokens(&mut tokens, false)?;
                                                                    ^0
 1243|       |
 1244|      8|                if tokens.is_empty() {
 1245|      1|                    return self.emit_error_loc(PPErrorKind::InvalidIncludePath, token.location);
 1246|      7|                }
 1247|       |
 1248|      7|                let first = &tokens[0];
 1249|      7|                match first.kind {
 1250|      2|                    PPTokenKind::StringLiteral(symbol) => {
 1251|      2|                        if tokens.len() > 1 {
 1252|      1|                            return self.emit_error_loc(PPErrorKind::ExpectedEod, tokens[1].location);
 1253|      1|                        }
 1254|      1|                        let path = self.extract_string_literal_content(
 1255|      1|                            symbol,
 1256|      1|                            first.location,
 1257|      1|                            PPErrorKind::InvalidIncludePath,
 1258|      0|                        )?;
 1259|      1|                        (path, false)
 1260|       |                    }
 1261|       |                    PPTokenKind::Less => {
 1262|      4|                        let mut path_parts = Vec::new();
 1263|      4|                        let mut greater_idx = None;
 1264|     15|                        for (i, t) in tokens.iter().enumerate().skip(1) {
                                                    ^4            ^4          ^4
 1265|     15|                            if t.kind == PPTokenKind::Greater {
 1266|      3|                                greater_idx = Some(i);
 1267|      3|                                break;
 1268|     12|                            }
 1269|     12|                            path_parts.push(*t);
 1270|       |                        }
 1271|      4|                        let idx = greater_idx
                                          ^3
 1272|      4|                            .ok_or_else(|| self.error_loc(PPErrorKind::InvalidIncludePath, token.location))?;
                                                         ^1   ^1        ^1                               ^1              ^1
 1273|      3|                        if idx + 1 < tokens.len() {
 1274|      1|                            return self.emit_error_loc(PPErrorKind::ExpectedEod, tokens[idx + 1].location);
 1275|      2|                        }
 1276|      2|                        (self.tokens_to_string(&path_parts), true)
 1277|       |                    }
 1278|       |                    _ => {
 1279|      1|                        return self.emit_error_loc(PPErrorKind::InvalidIncludePath, token.location);
 1280|       |                    }
 1281|       |                }
 1282|       |            }
 1283|       |        };
 1284|       |
 1285|     29|        if self.include_depth >= self.max_include_depth {
 1286|      1|            return self.emit_error_loc(PPErrorKind::IncludeDepthExceeded, token.location);
 1287|     28|        }
 1288|       |
 1289|     28|        let include_source_id = if is_next {
                          ^26
 1290|      3|            self.resolve_next_include_path(&path_str, is_angled, token.location)?
                                                                                              ^0
 1291|       |        } else {
 1292|     25|            self.resolve_include_path(&path_str, is_angled, token.location)?
                                                                                         ^2
 1293|       |        };
 1294|       |
 1295|     26|        if self.once_included.contains(&include_source_id) {
 1296|      1|            return Ok(());
 1297|     25|        }
 1298|       |
 1299|     25|        self.include_stack.push(IncludeStackInfo {
 1300|     25|            file_id: include_source_id,
 1301|     25|        });
 1302|       |
 1303|     25|        if !eod_consumed {
 1304|     24|            self.expect_eod()?;
                                           ^0
 1305|      1|        }
 1306|       |
 1307|     25|        let buffer = self.sm.get_buffer_arc(include_source_id);
 1308|     25|        self.lexer_stack.push(PPLexer::new(include_source_id, buffer));
 1309|     25|        self.include_depth += 1;
 1310|       |
 1311|     25|        Ok(())
 1312|     34|    }
 1313|       |
 1314|     31|    fn handle_include(&mut self) -> Result<(), PPError> {
 1315|     31|        self.do_handle_include(false)
 1316|     31|    }
 1317|       |
 1318|      3|    fn handle_include_next(&mut self) -> Result<(), PPError> {
 1319|      3|        self.do_handle_include(true)
 1320|      3|    }
 1321|       |
 1322|     25|    fn resolve_include_path(&mut self, path: &str, is_angled: bool, loc: SourceLoc) -> Result<SourceId, PPError> {
 1323|     25|        let current_dir = self
 1324|     25|            .lexer_stack
 1325|     25|            .last()
 1326|     25|            .and_then(|lexer| self.sm.get_file_info(lexer.source_id))
 1327|     25|            .and_then(|info| info.path.parent())
 1328|     25|            .unwrap_or(Path::new("."));
 1329|       |
 1330|     25|        let resolved = self.header_search.resolve_path(path, is_angled, current_dir);
 1331|       |
 1332|     25|        if let Some(path_buf) = resolved {
                                  ^5
 1333|      5|            return self
 1334|      5|                .sm
 1335|      5|                .add_file_from_path(&path_buf, Some(loc))
 1336|      5|                .map_err(|_| self.error_loc(PPErrorKind::FileNotFound { path: path.to_string() }, loc));
                                           ^0   ^0        ^0                                                    ^0
 1337|     20|        }
 1338|       |
 1339|     20|        let fallback_id = if is_angled {
 1340|      5|            self.built_in_file_ids.get(path).copied()
 1341|       |        } else {
 1342|     15|            self.sm.get_file_id(path)
 1343|       |        };
 1344|       |
 1345|     20|        if let Some(id) = fallback_id {
                                  ^18
 1346|     18|            Ok(id)
 1347|       |        } else {
 1348|      2|            self.emit_error_loc(PPErrorKind::FileNotFound { path: path.to_string() }, loc)
 1349|       |        }
 1350|     25|    }
 1351|       |
 1352|      3|    fn resolve_next_include_path(&mut self, path: &str, is_angled: bool, loc: SourceLoc) -> Result<SourceId, PPError> {
 1353|      3|        let current_dir = self
 1354|      3|            .lexer_stack
 1355|      3|            .last()
 1356|      3|            .and_then(|lexer| self.sm.get_file_info(lexer.source_id))
 1357|      3|            .and_then(|info| info.path.parent())
 1358|      3|            .unwrap_or(Path::new("."));
 1359|       |
 1360|      3|        let resolved = self.header_search.resolve_next_path(path, is_angled, current_dir);
 1361|       |
 1362|      3|        if let Some(path_buf) = resolved {
                                  ^2
 1363|      2|            return self
 1364|      2|                .sm
 1365|      2|                .add_file_from_path(&path_buf, Some(loc))
 1366|      2|                .map_err(|_| self.error_loc(PPErrorKind::FileNotFound { path: path.to_string() }, loc));
                                           ^0   ^0        ^0                                                    ^0
 1367|      1|        }
 1368|       |
 1369|      1|        if is_angled && let Some(id) = self.built_in_file_ids.get(path).copied() {
 1370|      1|            let is_recursive = if let Some(current) = self.lexer_stack.last() {
 1371|      1|                current.source_id == id
 1372|       |            } else {
 1373|      0|                false
 1374|       |            };
 1375|       |
 1376|      1|            if !is_recursive {
 1377|      1|                return Ok(id);
 1378|      0|            }
 1379|      0|        }
 1380|       |
 1381|      0|        self.emit_error_loc(PPErrorKind::FileNotFound { path: path.to_string() }, loc)
 1382|      3|    }
 1383|     87|    fn handle_if_directive(&mut self, condition: bool) -> Result<(), PPError> {
 1384|     87|        self.conditional_stack.push(PPConditionalInfo {
 1385|     87|            was_skipping: !condition,
 1386|     87|            found_else: false,
 1387|     87|            found_non_skipping: condition,
 1388|     87|        });
 1389|     87|        Ok(())
 1390|     87|    }
 1391|       |
 1392|     18|    fn handle_conditional_def(&mut self, is_ifdef: bool) -> Result<(), PPError> {
 1393|     18|        let (_, sym) = self.expect_identifier()?;
                                                             ^0
 1394|       |
 1395|     18|        let condition = self.macros.contains_key(&sym) == is_ifdef;
 1396|     18|        self.handle_if_directive(condition)?;
                                                         ^0
 1397|     18|        self.expect_eod()
 1398|     18|    }
 1399|       |
 1400|      9|    fn handle_ifdef(&mut self) -> Result<(), PPError> {
 1401|      9|        self.handle_conditional_def(true)
 1402|      9|    }
 1403|       |
 1404|      9|    fn handle_ifndef(&mut self) -> Result<(), PPError> {
 1405|      9|        self.handle_conditional_def(false)
 1406|      9|    }
 1407|       |
 1408|     11|    fn handle_elif_directive(&mut self, condition: bool, location: SourceLoc) -> Result<(), PPError> {
 1409|     11|        if self.conditional_stack.is_empty() {
 1410|      1|            return self.emit_error_loc(PPErrorKind::ElifWithoutIf, location);
 1411|     10|        }
 1412|     10|        let current = self.conditional_stack.last_mut().unwrap();
 1413|       |
 1414|     10|        if current.found_else {
 1415|      1|            return self.emit_error_loc(PPErrorKind::ElifAfterElse, location);
 1416|      9|        }
 1417|       |
 1418|      9|        let should_process = !current.found_non_skipping && condition;
                                                                          ^7
 1419|      9|        if should_process {
 1420|      3|            current.found_non_skipping = true;
 1421|      6|        }
 1422|      9|        current.was_skipping = !should_process;
 1423|       |
 1424|      9|        Ok(())
 1425|     11|    }
 1426|       |
 1427|     39|    fn handle_else(&mut self, location: SourceLoc) -> Result<(), PPError> {
 1428|     39|        if self.conditional_stack.is_empty() {
 1429|      0|            return self.emit_error_loc(PPErrorKind::ElseWithoutIf, location);
 1430|     39|        }
 1431|     39|        let current = self.conditional_stack.last_mut().unwrap();
 1432|       |
 1433|     39|        if current.found_else {
 1434|      0|            return self.emit_error_loc(PPErrorKind::MultipleElse, location);
 1435|     39|        }
 1436|       |
 1437|     39|        current.found_else = true;
 1438|     39|        let should_process = !current.found_non_skipping;
 1439|     39|        current.was_skipping = !should_process;
 1440|       |
 1441|     39|        self.expect_eod()
 1442|     39|    }
 1443|       |
 1444|     88|    fn handle_endif(&mut self, location: SourceLoc) -> Result<(), PPError> {
 1445|     88|        if self.conditional_stack.pop().is_none() {
 1446|      0|            return self.emit_error_loc(PPErrorKind::UnmatchedEndif, location);
 1447|     88|        }
 1448|     88|        self.expect_eod()
 1449|     88|    }
 1450|       |
 1451|    110|    fn collect_tokens_until_eod(&mut self) -> Vec<PPToken> {
 1452|    110|        let mut tokens = Vec::new();
 1453|    406|        while let Some(token) = self.lex_token() {
 1454|    406|            if token.kind == PPTokenKind::Eod {
 1455|    110|                break;
 1456|    296|            }
 1457|    296|            tokens.push(token);
 1458|       |        }
 1459|    110|        tokens
 1460|    110|    }
 1461|       |
 1462|      4|    fn parse_line_directive_args(&self, tokens: &[PPToken]) -> Result<(u32, Option<String>), PPError> {
 1463|      4|        let (first, rest) = tokens
 1464|      4|            .split_first()
 1465|      4|            .ok_or_else(|| self.error_loc(PPErrorKind::InvalidLineDirective, SourceLoc::builtin()))?;
                                         ^0   ^0        ^0                                 ^0                    ^0
 1466|       |
 1467|      4|        let PPTokenKind::Number(symbol) = first.kind else {
                                              ^3
 1468|      1|            return self.emit_error_loc(PPErrorKind::InvalidLineDirective, first.location);
 1469|       |        };
 1470|       |
 1471|      3|        let line_num = symbol
                          ^2
 1472|      3|            .as_str()
 1473|      3|            .parse::<u32>()
 1474|      3|            .ok()
 1475|      3|            .filter(|&n| n > 0)
 1476|      3|            .ok_or_else(|| self.error_loc(PPErrorKind::InvalidLineDirective, first.location))?;
                                         ^1   ^1        ^1                                 ^1              ^1
 1477|       |
 1478|      2|        let filename = match rest {
                          ^1
 1479|      2|            [] => None,
                                ^0
 1480|      2|            [t] => {
 1481|      2|                let PPTokenKind::StringLiteral(s) = t.kind else {
                                                             ^1
 1482|      1|                    return self.emit_error_loc(PPErrorKind::InvalidLineDirective, t.location);
 1483|       |                };
 1484|      1|                Some(self.extract_string_literal_content(s, t.location, PPErrorKind::InvalidLineDirective)?)
                                                                                                                        ^0
 1485|       |            }
 1486|      0|            _ => return self.emit_error_loc(PPErrorKind::InvalidLineDirective, first.location),
 1487|       |        };
 1488|       |
 1489|      1|        Ok((line_num, filename))
 1490|      4|    }
 1491|       |
 1492|      4|    fn handle_line(&mut self) -> Result<(), PPError> {
 1493|      4|        let start_line = if let Some(lexer) = self.lexer_stack.last() {
 1494|      4|            lexer.get_current_line()
 1495|       |        } else {
 1496|      0|            0
 1497|       |        };
 1498|       |
 1499|       |        // Collect tokens until end of line
 1500|      4|        let mut tokens = self.collect_tokens_until_eod();
 1501|       |
 1502|      4|        if tokens.is_empty() {
 1503|      0|            let loc = self.get_current_location();
 1504|      0|            return self.emit_error_loc(PPErrorKind::InvalidLineDirective, loc);
 1505|      4|        }
 1506|       |
 1507|       |        // Expand macros in tokens
 1508|      4|        self.expand_tokens(&mut tokens, false)?;
                                                            ^0
 1509|       |
 1510|      4|        let (logical_line, logical_file) = self.parse_line_directive_args(&tokens)?;
                           ^1            ^1                                                     ^3
 1511|       |
 1512|       |        // Get current physical line (where #line directive appears)
 1513|      1|        let physical_line = start_line;
 1514|       |
 1515|       |        // The #line directive sets the line number for the following line,
 1516|       |        // so we need to adjust the logical_line for the entry
 1517|      1|        let entry_logical_line = logical_line - 1;
 1518|       |
 1519|       |        // Add entry to LineMap
 1520|      1|        if let Some(lexer) = self.lexer_stack.last()
 1521|      1|            && let Some(line_map) = self.sm.get_line_map_mut(lexer.source_id)
 1522|      1|        {
 1523|      1|            let entry = crate::source_manager::LineDirective::new(physical_line, entry_logical_line, logical_file);
 1524|      1|            line_map.add_entry(entry);
 1525|      1|        }
                      ^0
 1526|       |
 1527|      1|        Ok(())
 1528|      4|    }
 1529|     13|    fn handle_pragma(&mut self) -> Result<(), PPError> {
 1530|     13|        let (token, symbol) = self.expect_identifier()?;
                                                                    ^0
 1531|       |
 1532|     13|        let pragma_name = symbol.as_str();
 1533|     13|        match pragma_name {
 1534|     13|            "once" => {
 1535|      2|                if let Some(lexer) = self.lexer_stack.last() {
 1536|      2|                    self.once_included.insert(lexer.source_id);
 1537|      2|                }
                              ^0
 1538|       |            }
 1539|     11|            "push_macro" => self.handle_push_macro()?,
                                          ^2   ^2                 ^0
 1540|      9|            "pop_macro" => self.handle_pop_macro()?,
                                         ^2   ^2                ^0
 1541|      7|            "message" => self.handle_pragma_message()?,
                                       ^4   ^4                     ^0
 1542|      3|            "warning" => self.handle_pragma_warning()?,
                                       ^1   ^1                     ^0
 1543|      2|            "error" => self.handle_pragma_error()?,
                                     ^1   ^1                   ^1
 1544|       |            _ => {
 1545|      1|                return self.emit_error_loc(PPErrorKind::UnknownPragma(pragma_name.to_string()), token.location);
 1546|       |            }
 1547|       |        }
 1548|       |
 1549|     11|        self.collect_tokens_until_eod();
 1550|     11|        Ok(())
 1551|     13|    }
 1552|       |
 1553|      4|    fn parse_pragma_macro_name(&mut self) -> Result<StringId, PPError> {
 1554|      4|        self.expect_kind(PPTokenKind::LeftParen)?;
                                                              ^0
 1555|      4|        let (symbol, token_loc) = self.expect_string_literal()?;
                                                                            ^0
 1556|       |
 1557|      4|        let name = self.extract_string_literal_content(symbol, token_loc, PPErrorKind::InvalidDirective)?;
                                                                                                                      ^0
 1558|       |
 1559|      4|        self.expect_kind(PPTokenKind::RightParen)?;
                                                               ^0
 1560|       |
 1561|      4|        Ok(StringId::new(name))
 1562|      4|    }
 1563|       |
 1564|      2|    fn handle_push_macro(&mut self) -> Result<(), PPError> {
 1565|      2|        let name = self.parse_pragma_macro_name()?;
                                                               ^0
 1566|       |
 1567|      2|        let info = self.macros.get(&name).cloned();
 1568|       |
 1569|      2|        self.macro_stack.entry(name).or_default().push(info);
 1570|       |
 1571|      2|        Ok(())
 1572|      2|    }
 1573|       |
 1574|      2|    fn handle_pop_macro(&mut self) -> Result<(), PPError> {
 1575|      2|        let name = self.parse_pragma_macro_name()?;
                                                               ^0
 1576|       |
 1577|      2|        if let Some(stack) = self.macro_stack.get_mut(&name)
 1578|      2|            && let Some(info_opt) = stack.pop()
 1579|       |        {
 1580|      2|            if let Some(info) = info_opt {
                                      ^1
 1581|      1|                self.macros.insert(name, info);
 1582|      1|            } else {
 1583|      1|                self.macros.remove(&name);
 1584|      1|            }
 1585|      0|        }
 1586|       |
 1587|      2|        Ok(())
 1588|      2|    }
 1589|       |
 1590|      6|    fn parse_pragma_message_content(&mut self) -> Result<String, PPError> {
 1591|      6|        let mut tokens = self.collect_balanced_tokens(PPTokenKind::LeftParen, PPTokenKind::RightParen)?;
                                                                                                                    ^0
 1592|      6|        self.expand_tokens(&mut tokens, false)?;
                                                            ^0
 1593|       |
 1594|      6|        tokens.into_iter().try_fold(String::new(), |mut acc, t| {
 1595|      6|            let PPTokenKind::StringLiteral(symbol) = t.kind else {
 1596|      0|                return self.emit_error_loc(PPErrorKind::InvalidDirective, t.location);
 1597|       |            };
 1598|      6|            acc.push_str(&self.destringize(symbol.as_str()));
 1599|      6|            Ok(acc)
 1600|      6|        })
 1601|      6|    }
 1602|       |
 1603|      6|    fn handle_pragma_diagnostic_message(&mut self, level: DiagnosticLevel) -> Result<(), PPError> {
 1604|      6|        let message = self.parse_pragma_message_content()?;
                                                                       ^0
 1605|      6|        let loc = self.get_current_location();
 1606|      6|        let diag = Diagnostic {
 1607|      6|            level,
 1608|      6|            message: message.clone(),
 1609|      6|            span: SourceSpan::new(loc, loc),
 1610|      6|            ..Default::default()
 1611|      6|        };
 1612|      6|        self.diag.report_diagnostic(diag);
 1613|       |
 1614|      6|        if level == DiagnosticLevel::Error {
 1615|      1|            self.emit_error_loc(PPErrorKind::PragmaError(message), loc)
 1616|       |        } else {
 1617|      5|            Ok(())
 1618|       |        }
 1619|      6|    }
 1620|       |
 1621|      4|    fn handle_pragma_message(&mut self) -> Result<(), PPError> {
 1622|      4|        self.handle_pragma_diagnostic_message(DiagnosticLevel::Note)
 1623|      4|    }
 1624|       |
 1625|      1|    fn handle_pragma_warning(&mut self) -> Result<(), PPError> {
 1626|      1|        self.handle_pragma_diagnostic_message(DiagnosticLevel::Warning)
 1627|      1|    }
 1628|       |
 1629|      1|    fn handle_pragma_error(&mut self) -> Result<(), PPError> {
 1630|      1|        self.handle_pragma_diagnostic_message(DiagnosticLevel::Error)
 1631|      1|    }
 1632|       |
 1633|      2|    fn handle_diagnostic_directive(&mut self, is_error: bool) -> Result<(), PPError> {
 1634|      2|        let directive_location = self.get_current_location();
 1635|      2|        let message = self.read_directive_message();
 1636|       |
 1637|      2|        let formatted_message = if is_error {
 1638|      1|            format!("#error directive: {}", message)
 1639|       |        } else {
 1640|      1|            message.clone()
 1641|       |        };
 1642|       |
 1643|      2|        if is_error {
 1644|      1|            self.report_error(formatted_message, directive_location);
 1645|      1|        } else {
 1646|      1|            self.report_warning(formatted_message, directive_location);
 1647|      1|        }
 1648|       |
 1649|      2|        if is_error {
 1650|      1|            self.emit_error_loc(PPErrorKind::ErrorDirective(message), directive_location)
 1651|       |        } else {
 1652|      1|            Ok(())
 1653|       |        }
 1654|      2|    }
 1655|       |
 1656|      1|    fn handle_error(&mut self) -> Result<(), PPError> {
 1657|      1|        self.handle_diagnostic_directive(true)
 1658|      1|    }
 1659|       |
 1660|      1|    fn handle_warning(&mut self) -> Result<(), PPError> {
 1661|      1|        self.handle_diagnostic_directive(false)
 1662|      1|    }
 1663|       |
 1664|      2|    fn read_directive_message(&mut self) -> String {
 1665|      2|        let tokens = self.collect_tokens_until_eod();
 1666|      2|        self.tokens_to_string(&tokens)
 1667|      2|    }
 1668|       |
 1669|       |    /// Expand a macro if it exists
 1670|  6.47k|    pub(crate) fn expand_macro(&mut self, token: &PPToken) -> Result<Option<Vec<PPToken>>, PPError> {
 1671|  6.47k|        let PPTokenKind::Identifier(symbol) = token.kind else {
 1672|      0|            return Ok(None);
 1673|       |        };
 1674|       |
 1675|  6.47k|        let macro_info = self
 1676|  6.47k|            .macros
 1677|  6.47k|            .get(&symbol)
 1678|  6.47k|            .filter(|m| !m.flags.contains(MacroFlags::DISABLED))
                                       ^85     ^85
 1679|  6.47k|            .cloned();
 1680|       |
 1681|  6.47k|        let Some(macro_info) = macro_info else {
                               ^85
 1682|  6.38k|            return Ok(None);
 1683|       |        };
 1684|       |
 1685|       |        // Bolt : Check for recursive expansion here to avoid walking include stack for non-macros.
 1686|     85|        if self.is_recursive_expansion(token.location, symbol.as_str()) {
 1687|      0|            return Ok(None);
 1688|     85|        }
 1689|       |
 1690|     85|        if macro_info.flags.contains(MacroFlags::FUNCTION_LIKE) {
 1691|     41|            let next = self.lex_token();
 1692|     41|            let is_call = matches!(next, Some(ref t) if t.kind == PPTokenKind::LeftParen);
                                        ^40                                                          ^40
 1693|     41|            if let Some(t) = next {
 1694|     41|                self.pending_tokens.push_front(t);
 1695|     41|            }
                          ^0
 1696|     41|            if !is_call {
 1697|      1|                return Ok(None);
 1698|     40|            }
 1699|     44|        }
 1700|       |
 1701|     84|        if let Some(m) = self.macros.get_mut(&symbol) {
 1702|     84|            m.flags |= MacroFlags::USED | MacroFlags::DISABLED;
 1703|     84|        }
                      ^0
 1704|       |
 1705|     84|        let result = if macro_info.flags.contains(MacroFlags::FUNCTION_LIKE) {
 1706|     40|            self.expand_function_macro(&macro_info, &symbol, token)
 1707|       |        } else {
 1708|     44|            self.expand_object_macro(&macro_info, &symbol, token)
 1709|       |        };
 1710|       |
 1711|     84|        if let Some(m) = self.macros.get_mut(&symbol) {
 1712|     84|            m.flags.remove(MacroFlags::DISABLED);
 1713|     84|        }
                      ^0
 1714|       |
 1715|     84|        result.map(Some)
 1716|  6.47k|    }
 1717|       |
 1718|       |    /// Helper to convert tokens to their string representation
 1719|     13|    fn tokens_to_string(&self, tokens: &[PPToken]) -> String {
 1720|       |        // Bolt : Optimized two-pass string building.
 1721|       |        // We use the token's length field for the first pass as it's a fast u16 access.
 1722|     35|        let total_len: usize = tokens.iter().map(|t| t.length as usize).sum();
                          ^13        ^13     ^13    ^13    ^13                        ^13
 1723|       |
 1724|     13|        let mut result = String::with_capacity(total_len);
 1725|     13|        let mut cache = SourceBufferCache::new(self.sm);
 1726|       |
 1727|     48|        for token in tokens {
                          ^35
 1728|     35|            result.push_str(cache.get_token_text(token));
 1729|     35|        }
 1730|     13|        result
 1731|     13|    }
 1732|       |
 1733|       |    /// Expand an object-like macro
 1734|     44|    fn expand_object_macro(
 1735|     44|        &mut self,
 1736|     44|        macro_info: &MacroInfo,
 1737|     44|        symbol: &StringId,
 1738|     44|        token: &PPToken,
 1739|     44|    ) -> Result<Vec<PPToken>, PPError> {
 1740|       |        // For Level B: Create a virtual buffer containing the replacement text
 1741|     44|        let mut expanded = self.create_virtual_buffer_tokens(&macro_info.tokens, symbol.as_str(), token.location);
 1742|       |
 1743|       |        // Recursively expand any macros in the replacement
 1744|     44|        self.expand_tokens(&mut expanded, false)?;
                                                              ^0
 1745|       |
 1746|     44|        Ok(expanded)
 1747|     44|    }
 1748|       |
 1749|       |    /// Expand a function-like macro
 1750|     40|    fn expand_function_macro(
 1751|     40|        &mut self,
 1752|     40|        macro_info: &MacroInfo,
 1753|     40|        symbol: &StringId,
 1754|     40|        token: &PPToken,
 1755|     40|    ) -> Result<Vec<PPToken>, PPError> {
 1756|       |        // Parse arguments from lexer
 1757|     40|        let args = match self.parse_macro_args_from_lexer(macro_info) {
 1758|     40|            Ok(args) => args,
 1759|       |            Err(PPError {
 1760|       |                kind: PPErrorKind::InvalidMacroParameter,
 1761|       |                ..
 1762|       |            }) => {
 1763|      0|                return self.emit_error_loc(PPErrorKind::InvalidMacroParameter, token.location);
 1764|       |            }
 1765|      0|            Err(e) => return Err(e),
 1766|       |        };
 1767|       |
 1768|       |        // Pre-expand arguments (prescan)
 1769|     40|        let mut expanded_args = Vec::with_capacity(args.len());
 1770|    102|        for arg in &args {
                          ^62
 1771|     62|            let mut arg_clone = arg.clone();
 1772|     62|            self.expand_tokens(&mut arg_clone, false)?;
                                                                   ^0
 1773|     62|            expanded_args.push(arg_clone);
 1774|       |        }
 1775|       |
 1776|       |        // Substitute parameters in macro body
 1777|     40|        let substituted = self.substitute_macro(macro_info, &args, &expanded_args)?;
                                                                                                ^0
 1778|       |
 1779|       |        // For Level B: Create a virtual buffer containing the substituted text
 1780|     40|        let mut expanded = self.create_virtual_buffer_tokens(&substituted, symbol.as_str(), token.location);
 1781|       |
 1782|       |        // Recursively expand any macros in the replacement
 1783|     40|        self.expand_tokens(&mut expanded, false)?;
                                                              ^0
 1784|       |
 1785|     40|        Ok(expanded)
 1786|     40|    }
 1787|       |
 1788|       |    /// Parse macro arguments from the current lexer
 1789|     40|    fn parse_macro_args_from_lexer(&mut self, macro_info: &MacroInfo) -> Result<Vec<Vec<PPToken>>, PPError> {
 1790|     40|        let token = self.expect_token()?;
                                                     ^0
 1791|     40|        if token.kind != PPTokenKind::LeftParen {
 1792|      0|            self.pending_tokens.push_front(token);
 1793|      0|            return self.emit_error_loc(PPErrorKind::InvalidMacroParameter, token.location);
 1794|     40|        }
 1795|       |
 1796|     40|        let mut args = Vec::new();
 1797|     40|        let mut current_arg = Vec::new();
 1798|     40|        let mut depth = 0;
 1799|       |
 1800|    146|        while let Some(t) = self.lex_token() {
 1801|     23|            match t.kind {
 1802|      0|                PPTokenKind::Eof => break,
 1803|      1|                PPTokenKind::LeftParen => {
 1804|      1|                    depth += 1;
 1805|      1|                    current_arg.push(t);
 1806|      1|                }
 1807|     41|                PPTokenKind::RightParen if depth > 0 => {
                                                                 ^1
 1808|      1|                    depth -= 1;
 1809|      1|                    current_arg.push(t);
 1810|      1|                }
 1811|       |                PPTokenKind::RightParen => {
 1812|     40|                    if !current_arg.is_empty() || !args.is_empty() {
                                                                ^1
 1813|     40|                        args.push(current_arg);
 1814|     40|                    }
                                  ^0
 1815|       |
 1816|     40|                    let expected = macro_info.parameter_list.len();
 1817|     40|                    let valid = if macro_info.variadic_arg.is_some() {
 1818|      6|                        args.len() >= expected
 1819|       |                    } else {
 1820|     34|                        args.len() == expected
 1821|       |                    };
 1822|       |
 1823|     40|                    if valid {
 1824|     40|                        return Ok(args);
 1825|      0|                    }
 1826|       |
 1827|      0|                    return self.emit_error_loc(PPErrorKind::InvalidMacroParameter, macro_info.location);
 1828|       |                }
 1829|     23|                PPTokenKind::Comma if depth == 0 => {
                                                             ^22
 1830|     22|                    args.push(std::mem::take(&mut current_arg));
 1831|     22|                }
 1832|     82|                _ => current_arg.push(t),
 1833|       |            }
 1834|       |        }
 1835|       |
 1836|      0|        self.emit_error(PPErrorKind::UnexpectedEndOfFile, self.get_current_span())
 1837|     40|    }
 1838|       |
 1839|       |    /// Helper to collect variadic arguments with commas inserted
 1840|      6|    fn collect_variadic_args_with_commas(
 1841|      6|        &mut self,
 1842|      6|        args: &[Vec<PPToken>],
 1843|      6|        start_index: usize,
 1844|      6|        trigger_loc: SourceLoc,
 1845|      6|    ) -> Vec<PPToken> {
 1846|      6|        let mut result = Vec::new();
 1847|      6|        let mut first = true;
 1848|       |
 1849|       |        // We need a source for the comma token.
 1850|       |        // We create a virtual buffer for it to ensure stringification works correctly.
 1851|       |        // We only create it if we actually need a comma.
 1852|      6|        let comma_source_id = if args.len() > start_index + 1 {
 1853|      3|            Some(self.sm.add_virtual_buffer(b",".to_vec(), "<comma>", Some(trigger_loc)))
 1854|       |        } else {
 1855|      3|            None
 1856|       |        };
 1857|       |
 1858|      9|        for arg in args.iter().skip(start_index) {
                                 ^6   ^6     ^6   ^6
 1859|      9|            if !first && let Some(sid) = comma_source_id {
                                                ^5     ^5
 1860|      5|                result.push(PPToken::new(
 1861|      5|                    PPTokenKind::Comma,
 1862|      5|                    PPTokenFlags::empty(),
 1863|      5|                    SourceLoc::new(sid, 0),
 1864|      5|                    1,
 1865|      5|                ));
 1866|      5|            }
                          ^4
 1867|      9|            result.extend(arg.clone());
 1868|      9|            first = false;
 1869|       |        }
 1870|      6|        result
 1871|      6|    }
 1872|       |
 1873|    113|    fn is_macro_param(&self, macro_info: &MacroInfo, symbol: StringId) -> bool {
 1874|    113|        macro_info.variadic_arg == Some(symbol) || macro_info.parameter_list.contains(&symbol)
                                                                 ^112
 1875|    113|    }
 1876|       |
 1877|     63|    fn get_macro_param_tokens<'a>(
 1878|     63|        &mut self,
 1879|     63|        macro_info: &MacroInfo,
 1880|     63|        symbol: StringId,
 1881|     63|        args: &'a [Vec<PPToken>],
 1882|     63|        location: SourceLoc,
 1883|     63|    ) -> Option<Cow<'a, [PPToken]>> {
 1884|     78|        if let Some(idx) = macro_info.parameter_list.iter().position(|&p| p == symbol) {
                                  ^57    ^63                              ^63
 1885|     57|            return Some(Cow::Borrowed(&args[idx]));
 1886|      6|        }
 1887|      6|        if macro_info.variadic_arg == Some(symbol) {
 1888|      6|            let start = macro_info.parameter_list.len();
 1889|      6|            return Some(Cow::Owned(
 1890|      6|                self.collect_variadic_args_with_commas(args, start, location),
 1891|      6|            ));
 1892|      0|        }
 1893|      0|        None
 1894|     63|    }
 1895|       |
 1896|       |    /// Substitute parameters in macro body
 1897|     45|    fn substitute_macro(
 1898|     45|        &mut self,
 1899|     45|        macro_info: &MacroInfo,
 1900|     45|        args: &[Vec<PPToken>],
 1901|     45|        expanded_args: &[Vec<PPToken>],
 1902|     45|    ) -> Result<Vec<PPToken>, PPError> {
 1903|       |        // Bolt : Pre-allocate result vector to minimize reallocations during substitution.
 1904|     45|        let mut result = Vec::with_capacity(macro_info.tokens.len());
 1905|     45|        let mut i = 0;
 1906|     45|        let mut last_token_produced_output = false;
 1907|       |
 1908|    371|        while i < macro_info.tokens.len() {
 1909|    326|            let token = &macro_info.tokens[i];
 1910|       |
 1911|      2|            match token.kind {
 1912|      2|                PPTokenKind::Hash if i + 1 < macro_info.tokens.len() => {
 1913|      2|                    let next = &macro_info.tokens[i + 1];
 1914|      2|                    if let PPTokenKind::Identifier(sym) = next.kind
 1915|      2|                        && let Some(arg) = self.get_macro_param_tokens(macro_info, sym, args, token.location)
 1916|       |                    {
 1917|      2|                        let stringified = self.stringify_tokens(&arg, token.location)?;
                                                                                                   ^0
 1918|      2|                        result.push(stringified);
 1919|      2|                        last_token_produced_output = true;
 1920|      2|                        i += 2;
 1921|      2|                        continue;
 1922|      0|                    }
 1923|       |                }
 1924|     11|                PPTokenKind::HashHash if i + 1 < macro_info.tokens.len() => {
 1925|     11|                    let right_token = &macro_info.tokens[i + 1];
 1926|     11|                    let left = if last_token_produced_output { result.pop() } else { None };
                                                                             ^7     ^7             ^4
 1927|       |
 1928|     11|                    let (pasted, produced_output) = self.perform_token_pasting(macro_info, left, right_token, args)?;
                                                                                                                                 ^0
 1929|       |
 1930|     11|                    result.extend(pasted);
 1931|     11|                    last_token_produced_output = produced_output;
 1932|     11|                    i += 2;
 1933|     11|                    continue;
 1934|       |                }
 1935|    113|                PPTokenKind::Identifier(sym) if self.is_macro_param(macro_info, sym) => {
                                                      ^50                                        ^50
 1936|     50|                    let next_is_hh =
 1937|     50|                        i + 1 < macro_info.tokens.len() && macro_info.tokens[i + 1].kind == PPTokenKind::HashHash;
                                                                         ^45
 1938|     50|                    let src = if next_is_hh { args } else { expanded_args };
                                                            ^6            ^44
 1939|     50|                    if let Some(param_tokens) = self.get_macro_param_tokens(macro_info, sym, src, token.location) {
 1940|     50|                        if param_tokens.is_empty() {
 1941|      3|                            last_token_produced_output = false;
 1942|     47|                        } else {
 1943|     47|                            result.extend(param_tokens.iter().copied());
 1944|     47|                            last_token_produced_output = true;
 1945|     47|                        }
 1946|      0|                    } else {
 1947|      0|                        last_token_produced_output = false;
 1948|      0|                    }
 1949|       |                }
 1950|    263|                _ => {
 1951|    263|                    result.push(*token);
 1952|    263|                    last_token_produced_output = true;
 1953|    263|                }
 1954|       |            }
 1955|    313|            i += 1;
 1956|       |        }
 1957|       |
 1958|     45|        Ok(result)
 1959|     45|    }
 1960|       |
 1961|       |    /// Perform token pasting logic for the ## operator, including GNU comma swallowing.
 1962|     11|    fn perform_token_pasting(
 1963|     11|        &mut self,
 1964|     11|        macro_info: &MacroInfo,
 1965|     11|        left: Option<PPToken>,
 1966|     11|        right_token: &PPToken,
 1967|     11|        args: &[Vec<PPToken>],
 1968|     11|    ) -> Result<(Vec<PPToken>, bool), PPError> {
 1969|     11|        let right_tokens = if let PPTokenKind::Identifier(sym) = right_token.kind {
 1970|     11|            self.get_macro_param_tokens(macro_info, sym, args, right_token.location)
 1971|     11|                .unwrap_or(Cow::Borrowed(std::slice::from_ref(right_token)))
 1972|       |        } else {
 1973|      0|            Cow::Borrowed(std::slice::from_ref(right_token))
 1974|       |        };
 1975|       |
 1976|     11|        if right_tokens.is_empty() {
 1977|       |            // Right operand is empty (placemarker).
 1978|      4|            let is_comma = left.as_ref().is_some_and(|t| t.kind == PPTokenKind::Comma);
                                                                       ^3        ^3
 1979|      4|            let is_variadic =
 1980|      4|                matches!(right_token.kind, PPTokenKind::Identifier(s) if macro_info.variadic_arg == Some(s));
                              ^2                                                 ^2                                     ^2
 1981|       |
 1982|      4|            if is_comma && is_variadic {
                                         ^2
 1983|       |                // GNU Comma Swallowing extension: swallow the comma.
 1984|      2|                Ok((Vec::new(), false))
 1985|      2|            } else if let Some(l) = left {
                                             ^1
 1986|       |                // Standard behavior: paste left with empty -> left.
 1987|      1|                Ok((vec![l], true))
 1988|       |            } else {
 1989|      1|                Ok((Vec::new(), false))
 1990|       |            }
 1991|      7|        } else if let Some(l) = left {
                                         ^4
 1992|       |            // Right is not empty, Left is not empty: paste left with right[0].
 1993|      4|            let mut pasted = self.paste_tokens(&l, &right_tokens[0])?;
                                                                                  ^0
 1994|      4|            let pasted_count = pasted.len();
 1995|      4|            pasted.extend(right_tokens.iter().skip(1).copied());
 1996|      4|            Ok((pasted, pasted_count > 0 || right_tokens.len() > 1))
                                                          ^0
 1997|       |        } else {
 1998|       |            // Right is not empty, Left is empty: empty ## right -> right.
 1999|      3|            Ok((right_tokens.into_owned(), true))
 2000|       |        }
 2001|     11|    }
 2002|       |
 2003|       |    /// Stringify tokens for # operator
 2004|      4|    pub(crate) fn stringify_tokens(&self, tokens: &[PPToken], location: SourceLoc) -> Result<PPToken, PPError> {
 2005|       |        // Bolt : Use a two-pass approach to build the stringified token efficiently.
 2006|      4|        let mut total_len = 2; // For the opening and closing quotes
 2007|      4|        let mut cache = SourceBufferCache::new(self.sm);
 2008|       |
 2009|     10|        for (i, token) in tokens.iter().enumerate() {
                                        ^4     ^4     ^4
 2010|     10|            if i > 0 && token.flags.contains(PPTokenFlags::LEADING_SPACE) {
                                      ^6          ^6
 2011|      4|                total_len += 1;
 2012|      6|            }
 2013|     10|            let bytes = cache.get_token_bytes(token);
 2014|     35|            for &b in bytes {
                               ^25
 2015|     25|                match b {
 2016|      2|                    b'"' | b'\\' => total_len += 2,
 2017|     23|                    _ => total_len += 1,
 2018|       |                }
 2019|       |            }
 2020|       |        }
 2021|       |
 2022|      4|        let mut result = String::with_capacity(total_len);
 2023|      4|        result.push('"');
 2024|       |
 2025|      4|        cache.reset();
 2026|     10|        for (i, token) in tokens.iter().enumerate() {
                                        ^4     ^4     ^4
 2027|     10|            if i > 0 && token.flags.contains(PPTokenFlags::LEADING_SPACE) {
                                      ^6          ^6
 2028|      4|                result.push(' ');
 2029|      6|            }
 2030|       |
 2031|     10|            let bytes = cache.get_token_bytes(token);
 2032|     10|            let mut last_start = 0;
 2033|     25|            for (j, &b) in bytes.iter().enumerate() {
                                         ^10   ^10    ^10
 2034|     25|                if b == b'"' || b == b'\\' {
                                              ^24
 2035|      2|                    if j > last_start {
 2036|      2|                        result.push_str(unsafe { std::str::from_utf8_unchecked(&bytes[last_start..j]) });
 2037|      2|                    }
                                  ^0
 2038|      2|                    result.push('\\');
 2039|      2|                    result.push(b as char);
 2040|      2|                    last_start = j + 1;
 2041|     23|                }
 2042|       |            }
 2043|     10|            if last_start < bytes.len() {
 2044|     10|                result.push_str(unsafe { std::str::from_utf8_unchecked(&bytes[last_start..]) });
 2045|     10|            }
                          ^0
 2046|       |        }
 2047|       |
 2048|      4|        result.push('"');
 2049|       |
 2050|      4|        Ok(PPToken::new(
 2051|      4|            PPTokenKind::StringLiteral(StringId::new(&result)),
 2052|      4|            PPTokenFlags::empty(),
 2053|      4|            location,
 2054|      4|            result.len() as u16,
 2055|      4|        ))
 2056|      4|    }
 2057|       |
 2058|       |    /// Paste tokens for ## operator
 2059|      4|    fn paste_tokens(&mut self, left: &PPToken, right: &PPToken) -> Result<Vec<PPToken>, PPError> {
 2060|       |        // Get text of both tokens
 2061|      4|        let left_buffer = self.sm.get_buffer(left.location.source_id());
 2062|      4|        let left_start = left.location.offset() as usize;
 2063|      4|        let left_end = left_start + left.length as usize;
 2064|      4|        let left_text = if left_end <= left_buffer.len() {
 2065|      4|            unsafe { std::str::from_utf8_unchecked(&left_buffer[left_start..left_end]) }
 2066|       |        } else {
 2067|      0|            return self.emit_error_loc(PPErrorKind::InvalidTokenPasting, left.location);
 2068|       |        };
 2069|       |
 2070|      4|        let right_buffer = self.sm.get_buffer(right.location.source_id());
 2071|      4|        let right_start = right.location.offset() as usize;
 2072|      4|        let right_end = right_start + right.length as usize;
 2073|      4|        let right_text = if right_end <= right_buffer.len() {
 2074|      4|            unsafe { std::str::from_utf8_unchecked(&right_buffer[right_start..right_end]) }
 2075|       |        } else {
 2076|      0|            return self.emit_error_loc(PPErrorKind::InvalidTokenPasting, right.location);
 2077|       |        };
 2078|       |
 2079|      4|        let pasted_text = format!("{}{}", left_text, right_text);
 2080|       |
 2081|       |        // Create a virtual buffer containing the pasted text
 2082|      4|        let virtual_buffer = pasted_text.clone().into_bytes();
 2083|      4|        let virtual_id = self.sm.add_virtual_buffer(virtual_buffer, "<pasted-tokens>", None);
 2084|       |
 2085|       |        // Create a temporary lexer to lex the pasted text
 2086|      4|        let buffer = self.sm.get_buffer_arc(virtual_id);
 2087|      4|        let mut lexer = PPLexer::new(virtual_id, buffer);
 2088|       |
 2089|      4|        let mut tokens = Vec::new();
 2090|      9|        while let Some(token) = lexer.next_token() {
                                     ^5
 2091|      5|            if matches!(token.kind, PPTokenKind::Eod | PPTokenKind::Eof) {
 2092|      0|                continue;
 2093|      5|            }
 2094|      5|            tokens.push(token);
 2095|       |        }
 2096|       |
 2097|       |        // If the result is not a valid preprocessing token, the behavior is undefined.
 2098|       |        // We will return whatever tokens we got.
 2099|      4|        Ok(tokens)
 2100|      4|    }
 2101|       |
 2102|       |    /// Finds the range of tokens between balanced parentheses, starting at `start_index`.
 2103|       |    /// Returns the end index (exclusive) if successful.
 2104|     12|    fn find_balanced_paren_range(&self, tokens: &[PPToken], start_index: usize) -> Option<usize> {
 2105|     12|        if start_index >= tokens.len() || tokens[start_index].kind != PPTokenKind::LeftParen {
 2106|      0|            return None;
 2107|     12|        }
 2108|       |
 2109|     12|        let mut depth = 0;
 2110|     53|        for (i, t) in tokens.iter().enumerate().skip(start_index) {
                                    ^12    ^12    ^12         ^12  ^12
 2111|     53|            match t.kind {
 2112|     15|                PPTokenKind::LeftParen => depth += 1,
 2113|       |                PPTokenKind::RightParen => {
 2114|     15|                    depth -= 1;
 2115|     15|                    if depth == 0 {
 2116|     12|                        return Some(i + 1);
 2117|      3|                    }
 2118|       |                }
 2119|     23|                _ => {}
 2120|       |            }
 2121|       |        }
 2122|      0|        None
 2123|     12|    }
 2124|       |
 2125|       |    /// Collects macro arguments from a slice of tokens.
 2126|      5|    fn collect_macro_args_from_slice(
 2127|      5|        &self,
 2128|      5|        tokens: &[PPToken],
 2129|      5|        start_index: usize,
 2130|      5|        end_index: usize,
 2131|      5|    ) -> Vec<Vec<PPToken>> {
 2132|      5|        let mut args = Vec::new();
 2133|      5|        let mut current_arg = Vec::new();
 2134|      5|        let mut depth = 0;
 2135|     18|        for token in &tokens[start_index..end_index] {
                                    ^5    ^5
 2136|      2|            match token.kind {
 2137|      3|                PPTokenKind::LeftParen => {
 2138|      3|                    depth += 1;
 2139|      3|                    current_arg.push(*token);
 2140|      3|                }
 2141|      3|                PPTokenKind::RightParen => {
 2142|      3|                    depth -= 1;
 2143|      3|                    current_arg.push(*token);
 2144|      3|                }
 2145|      2|                PPTokenKind::Comma if depth == 0 => {
 2146|      2|                    args.push(std::mem::take(&mut current_arg));
 2147|      2|                }
 2148|     10|                _ => current_arg.push(*token),
 2149|       |            }
 2150|       |        }
 2151|      5|        if !current_arg.is_empty() || !args.is_empty() {
                                                    ^0
 2152|      5|            args.push(current_arg);
 2153|      5|        }
                      ^0
 2154|      5|        args
 2155|      5|    }
 2156|       |
 2157|      4|    fn expand_has_include_computed_args(&mut self, args: &mut Vec<PPToken>) {
 2158|      4|        let mut j = 0;
 2159|      4|        let mut expansions = 0;
 2160|      8|        while j < args.len() && expansions < 1000 {
 2161|      8|            if j == 0
 2162|      8|                && !args.is_empty()
 2163|      8|                && (args[0].kind == PPTokenKind::Less || matches!(args[0].kind, PPTokenKind::StringLiteral(_)))
                                                                       ^4       ^6
 2164|       |            {
 2165|      4|                break;
 2166|      4|            }
 2167|      4|            if let Some(expanded) = self.expand_macro(&args[j]).unwrap_or_default() {
 2168|      4|                args.splice(j..j + 1, expanded);
 2169|      4|                expansions += 1;
 2170|      4|                continue;
 2171|      0|            }
 2172|      0|            j += 1;
 2173|       |        }
 2174|      4|    }
 2175|       |
 2176|    300|    fn try_handle_conditional_operator(
 2177|    300|        &mut self,
 2178|    300|        tokens: &mut Vec<PPToken>,
 2179|    300|        i: usize,
 2180|    300|    ) -> Result<Option<usize>, PPError> {
 2181|    300|        let PPTokenKind::Identifier(sym) = tokens[i].kind else {
                                                  ^15
 2182|    285|            return Ok(None);
 2183|       |        };
 2184|       |
 2185|     15|        if sym == self.directive_keywords.defined {
 2186|      1|            let next = i + 1;
 2187|      1|            let end = match tokens.get(next).map(|t| &t.kind) {
 2188|      1|                Some(PPTokenKind::LeftParen) => self.find_balanced_paren_range(tokens, next).unwrap_or(next),
 2189|      0|                _ => next + 1,
 2190|       |            };
 2191|      1|            return Ok(Some(end.min(tokens.len())));
 2192|     14|        }
 2193|     14|        if sym == self.directive_keywords.has_include {
 2194|      6|            let next = i + 1;
 2195|      6|            if let Some(PPTokenKind::LeftParen) = tokens.get(next).map(|t| &t.kind) {
 2196|      6|                let arg_start = next + 1;
 2197|      6|                if let Some(arg_t) = tokens.get(arg_start)
 2198|      6|                    && let Some(arg_end) = self.find_balanced_paren_range(tokens, next)
 2199|       |                {
 2200|      6|                    match arg_t.kind {
 2201|       |                        PPTokenKind::Less | PPTokenKind::StringLiteral(_) => {
 2202|      2|                            return Ok(Some(arg_end));
 2203|       |                        }
 2204|       |                        _ => {
 2205|       |                            // Computed form: __has_include(MACRO)
 2206|      4|                            let mut args = tokens[arg_start..arg_end - 1].to_vec();
 2207|      4|                            self.expand_has_include_computed_args(&mut args);
 2208|      4|                            let len = args.len();
 2209|      4|                            tokens.splice(arg_start..arg_end - 1, args);
 2210|      4|                            return Ok(Some(arg_start + len + 1));
 2211|       |                        }
 2212|       |                    }
 2213|      0|                }
 2214|      0|            }
 2215|      0|            return Ok(Some(next.min(tokens.len())));
 2216|      8|        }
 2217|       |
 2218|      8|        Ok(None)
 2219|    300|    }
 2220|       |
 2221|    198|    fn try_expand_function_macro_in_tokens(
 2222|    198|        &mut self,
 2223|    198|        tokens: &mut Vec<PPToken>,
 2224|    198|        i: usize,
 2225|    198|        in_conditional: bool,
 2226|    198|    ) -> Result<bool, PPError> {
 2227|    198|        let symbol_token = tokens[i];
 2228|    198|        let PPTokenKind::Identifier(symbol) = symbol_token.kind else {
 2229|      0|            return Ok(false);
 2230|       |        };
 2231|       |
 2232|    198|        let macro_info = self.macros.get(&symbol).cloned();
 2233|    198|        let Some(macro_info) = macro_info else {
                               ^23
 2234|    175|            return Ok(false);
 2235|       |        };
 2236|       |
 2237|       |        // Bolt : Check for recursive expansion here to avoid walking include stack for non-macros.
 2238|     23|        if self.is_recursive_expansion(symbol_token.location, symbol.as_str()) {
 2239|      0|            return Ok(false);
 2240|     23|        }
 2241|       |
 2242|     23|        if !macro_info.flags.contains(MacroFlags::FUNCTION_LIKE) || macro_info.flags.contains(MacroFlags::DISABLED) {
                                                                                  ^5               ^5
 2243|     18|            return Ok(false);
 2244|      5|        }
 2245|       |
 2246|      5|        if i + 1 >= tokens.len() || tokens[i + 1].kind != PPTokenKind::LeftParen {
 2247|      0|            return Ok(false);
 2248|      5|        }
 2249|       |
 2250|      5|        let Some(end_j) = self.find_balanced_paren_range(tokens, i + 1) else {
 2251|      0|            return Ok(false);
 2252|       |        };
 2253|       |
 2254|      5|        let args = self.collect_macro_args_from_slice(tokens, i + 2, end_j - 1);
 2255|       |
 2256|       |        // Validate argument count
 2257|      5|        if args.len() != macro_info.parameter_list.len() {
 2258|       |            // For conditional expressions, just skip problematic macro expansions
 2259|      0|            return Ok(false);
 2260|      5|        }
 2261|       |
 2262|       |        // Pre-expand arguments (prescan)
 2263|      5|        let mut expanded_args = Vec::with_capacity(args.len());
 2264|     12|        for arg in &args {
                          ^7
 2265|      7|            let mut arg_clone = arg.clone();
 2266|      7|            let _ = self.expand_tokens(&mut arg_clone, in_conditional);
 2267|      7|            expanded_args.push(arg_clone);
 2268|      7|        }
 2269|       |
 2270|      5|        let substituted = self.substitute_macro(&macro_info, &args, &expanded_args)?;
                                                                                                 ^0
 2271|      5|        let substituted = self.create_virtual_buffer_tokens(&substituted, symbol.as_str(), symbol_token.location);
 2272|       |
 2273|      5|        if substituted.len() > 10000 {
 2274|      0|            return Ok(false);
 2275|      5|        }
 2276|       |
 2277|      5|        tokens.splice(i..end_j, substituted);
 2278|      5|        if let Some(m) = self.macros.get_mut(&symbol) {
 2279|      5|            m.flags |= MacroFlags::USED;
 2280|      5|        }
                      ^0
 2281|       |
 2282|      5|        Ok(true)
 2283|    198|    }
 2284|       |
 2285|    175|    fn try_handle_pragma_operator(&mut self, tokens: &mut Vec<PPToken>, i: usize) -> bool {
 2286|    175|        let token = tokens[i];
 2287|    175|        if !matches!(token.kind, PPTokenKind::Identifier(s) if s == self.directive_keywords.pragma_operator) {
                          ^3                                           ^3                                               ^3
 2288|    172|            return false;
 2289|      3|        }
 2290|       |
 2291|       |        // Need at least 3 more tokens: ( "string" )
 2292|      3|        if i + 3 < tokens.len()
 2293|      3|            && tokens[i + 1].kind == PPTokenKind::LeftParen
 2294|      3|            && let PPTokenKind::StringLiteral(sym) = tokens[i + 2].kind
 2295|      3|            && tokens[i + 3].kind == PPTokenKind::RightParen
 2296|       |        {
 2297|      3|            let content = self.destringize(sym.as_str());
 2298|      3|            self.perform_pragma(&content);
 2299|      3|            tokens.drain(i..i + 4);
 2300|      3|            return true;
 2301|      0|        }
 2302|      0|        false
 2303|    175|    }
 2304|       |
 2305|       |    /// Expand tokens by rescanning for further macro expansion
 2306|    246|    fn expand_tokens(&mut self, tokens: &mut Vec<PPToken>, in_conditional: bool) -> Result<(), PPError> {
 2307|    246|        let mut i = 0;
 2308|  1.07k|        while i < tokens.len() {
 2309|    833|            let token = tokens[i];
 2310|       |
 2311|    833|            if let Some(magic) = self.try_expand_magic_macro(&token) {
                                      ^1
 2312|      1|                tokens[i] = magic;
 2313|      1|                i += 1;
 2314|      1|                continue;
 2315|    832|            }
 2316|       |
 2317|    832|            if in_conditional && let Some(new_i) = self.try_handle_conditional_operator(tokens, i)? {
                                                        ^7       ^300 ^300                            ^300    ^300^0
 2318|      7|                i = new_i;
 2319|      7|                continue;
 2320|    825|            }
 2321|       |
 2322|    825|            if !matches!(token.kind, PPTokenKind::Identifier(_)) {
                              ^627
 2323|    627|                i += 1;
 2324|    627|                continue;
 2325|    198|            }
 2326|       |
 2327|    198|            if self.try_expand_function_macro_in_tokens(tokens, i, in_conditional)? {
                                                                                                ^0
 2328|      5|                continue;
 2329|    193|            }
 2330|       |
 2331|    193|            if let Some(expanded) = self.expand_macro(&tokens[i])? {
                                      ^18                                      ^0
 2332|     18|                tokens.splice(i..i + 1, expanded);
 2333|     18|                continue;
 2334|    175|            }
 2335|       |
 2336|    175|            if self.try_handle_pragma_operator(tokens, i) {
 2337|      3|                continue;
 2338|    172|            }
 2339|       |
 2340|    172|            i += 1;
 2341|       |        }
 2342|       |
 2343|    246|        Ok(())
 2344|    246|    }
 2345|       |
 2346|       |    /// Skip current directive tokens until EOD
 2347|     11|    fn skip_directive(&mut self) -> Result<(), PPError> {
 2348|     24|        while let Some(token) = self.lex_token() {
 2349|     24|            if token.kind == PPTokenKind::Eod {
 2350|     11|                break;
 2351|     13|            }
 2352|       |        }
 2353|     11|        Ok(())
 2354|     11|    }
 2355|       |
 2356|       |    /// Push a conditional that is lazily skipped (nested in a skipped block)
 2357|      3|    fn push_skipped_conditional(&mut self) {
 2358|       |        // Equivalent to handle_if_directive(false)
 2359|      3|        let info = PPConditionalInfo {
 2360|      3|            was_skipping: self.is_currently_skipping(),
 2361|      3|            found_else: false,
 2362|      3|            found_non_skipping: false, // Condition treated as false
 2363|      3|        };
 2364|      3|        self.conditional_stack.push(info);
 2365|       |        // Force skipping for this level
 2366|      3|        self.set_skipping(true);
 2367|      3|    }
 2368|       |
 2369|       |    /// Check if we should evaluate conditional expression (e.g. for #elif)
 2370|     11|    fn should_evaluate_conditional(&self) -> bool {
 2371|       |        // We should evaluate ONLY if no parent is skipping
 2372|       |        // The current level (which we are about to replace with elif) is at index len()-1.
 2373|       |        // The parent is at index len()-2.
 2374|     11|        if self.conditional_stack.len() > 1 {
 2375|      2|            let parent_index = self.conditional_stack.len() - 2;
 2376|      2|            let parent_skipping = self.conditional_stack[parent_index].was_skipping;
 2377|      2|            if parent_skipping {
 2378|      2|                return false;
 2379|      0|            }
 2380|      9|        }
 2381|       |
 2382|       |        // And if we haven't found a true branch in this level yet
 2383|      9|        if let Some(current) = self.conditional_stack.last() {
                                  ^8
 2384|      8|            !current.found_non_skipping
 2385|       |        } else {
 2386|      1|            false
 2387|       |        }
 2388|     11|    }
 2389|       |
 2390|    108|    fn is_recursive_expansion(&self, location: SourceLoc, macro_name: &str) -> bool {
 2391|       |        // Bolt : Optimization: avoid format! and Path allocation in a hot loop.
 2392|       |        // We check the path directly by string prefix/suffix which is much faster.
 2393|    122|        std::iter::successors(self.sm.get_file_info(location.source_id()), |info| {
                      ^108                  ^108    ^108          ^108     ^108
 2394|    122|            info.include_loc.and_then(|loc| self.sm.get_file_info(loc.source_id()))
                                                          ^14     ^14           ^14 ^14
 2395|    122|        })
 2396|    108|        .take(100)
 2397|    122|        .any(|info| {
                       ^108
 2398|    122|            let path_str = info.path.to_str().unwrap_or("");
 2399|       |            // Bolt : Prefix "<macro_" is 7 chars, suffix ">" is 1 char. Total 8.
 2400|    122|            path_str.len() == macro_name.len() + 8
 2401|      0|                && path_str.starts_with("<macro_")
 2402|      0|                && path_str.ends_with('>')
 2403|      0|                && &path_str[7..path_str.len() - 1] == macro_name
 2404|    122|        })
 2405|    108|    }
 2406|       |
 2407|     89|    fn create_virtual_buffer_tokens(
 2408|     89|        &mut self,
 2409|     89|        tokens: &[PPToken],
 2410|     89|        macro_name: &str,
 2411|     89|        trigger_location: SourceLoc,
 2412|     89|    ) -> Vec<PPToken> {
 2413|       |        // Bolt : Optimized macro expansion token creation.
 2414|       |        // This function is a hot path during macro expansion. We've optimized it by:
 2415|       |        // 1. Using a single pass to build the virtual buffer and collect token metadata.
 2416|       |        // 2. Caching SourceId lookups and 'is_pasted' checks to avoid redundant HashMap
 2417|       |        //    lookups and string comparisons for tokens from the same source.
 2418|       |        // 3. Avoiding redundant calls to `get_text()` by using the buffer lengths directly.
 2419|       |        // 4. Pre-allocating all necessary vectors with the correct capacity.
 2420|       |
 2421|       |        // Pass 0: Sum up lengths for capacity hint.
 2422|    416|        let total_upper_bound: usize = tokens.iter().map(|t| t.length as usize).sum();
                          ^89                ^89     ^89    ^89    ^89                        ^89
 2423|     89|        let mut buffer = Vec::with_capacity(total_upper_bound);
 2424|       |
 2425|       |        // Metadata to avoid re-calculating things in the final mapping pass.
 2426|       |        // (is_pasted, offset_in_new_buffer, length_in_new_buffer)
 2427|     89|        let mut token_metadata = Vec::with_capacity(tokens.len());
 2428|       |
 2429|     89|        let mut last_is_pasted_sid = None;
 2430|     89|        let mut last_is_pasted_val = false;
 2431|       |
 2432|       |        {
 2433|     89|            let mut cache = SourceBufferCache::new(self.sm);
 2434|       |
 2435|    505|            for t in tokens {
                              ^416
 2436|    416|                let sid = t.location.source_id();
 2437|       |
 2438|       |                // Optimized is_pasted check with caching.
 2439|    416|                let is_pasted = if Some(sid) == last_is_pasted_sid {
 2440|    290|                    last_is_pasted_val
 2441|       |                } else {
 2442|    126|                    let val = self.sm.get_file_info(sid).is_some_and(|info| {
                                                                                          ^116
 2443|    116|                        let p = info.path.to_str().unwrap_or("");
 2444|    116|                        p == "<<pasted-tokens>>" || p == "<pasted-tokens>"
                                                                  ^112
 2445|    116|                    });
 2446|    126|                    last_is_pasted_sid = Some(sid);
 2447|    126|                    last_is_pasted_val = val;
 2448|    126|                    val
 2449|       |                };
 2450|       |
 2451|    416|                let start_offset = buffer.len() as u32;
 2452|       |
 2453|       |                // Build buffer efficiently using cache
 2454|    416|                let bytes = cache.get_token_bytes(t);
 2455|    416|                buffer.extend_from_slice(bytes);
 2456|       |
 2457|    416|                let len = (buffer.len() as u32 - start_offset) as u16;
 2458|    416|                token_metadata.push((is_pasted, start_offset, len));
 2459|       |            }
 2460|       |        }
 2461|       |
 2462|     89|        let virtual_id = self
 2463|     89|            .sm
 2464|     89|            .add_virtual_buffer(buffer, &format!("macro_{}", macro_name), Some(trigger_location));
 2465|       |
 2466|       |        // Final pass: Construct new tokens using the pre-calculated metadata.
 2467|     89|        tokens
 2468|     89|            .iter()
 2469|     89|            .zip(token_metadata)
 2470|    416|            .map(|(t, (is_pasted, offset, len))| {
                           ^89
 2471|    416|                let loc = if is_pasted {
 2472|      5|                    t.location
 2473|       |                } else {
 2474|    411|                    SourceLoc::new(virtual_id, offset)
 2475|       |                };
 2476|       |
 2477|    416|                PPToken::new(t.kind, t.flags | PPTokenFlags::MACRO_EXPANDED, loc, len)
 2478|    416|            })
 2479|     89|            .collect()
 2480|     89|    }
 2481|       |
 2482|       |    /// Helper to report diagnostics
 2483|      7|    fn report_diagnostic(
 2484|      7|        &mut self,
 2485|      7|        level: DiagnosticLevel,
 2486|      7|        message: impl Into<String>,
 2487|      7|        span: SourceSpan,
 2488|      7|        code: Option<String>,
 2489|      7|        hints: Vec<String>,
 2490|      7|        related: Vec<SourceSpan>,
 2491|      7|    ) {
 2492|      7|        let diag = Diagnostic {
 2493|      7|            level,
 2494|      7|            message: message.into(),
 2495|      7|            span,
 2496|      7|            code,
 2497|      7|            hints,
 2498|      7|            related,
 2499|      7|        };
 2500|      7|        self.diag.report_diagnostic(diag);
 2501|      7|    }
 2502|       |
 2503|       |    /// Helper to report error diagnostics from PPError
 2504|      0|    fn report_pp_error(&mut self, err: PPError) {
 2505|       |        use crate::diagnostic::IntoDiagnostic;
 2506|      0|        let diags = err.into_diagnostic();
 2507|      0|        for diag in diags {
 2508|      0|            self.diag.report_diagnostic(diag);
 2509|      0|        }
 2510|      0|    }
 2511|       |
 2512|       |    /// Helper to report error diagnostics
 2513|      1|    fn report_error(&mut self, message: impl Into<String>, loc: SourceLoc) {
 2514|      1|        let span = SourceSpan::new(loc, loc);
 2515|      1|        self.report_diagnostic(DiagnosticLevel::Error, message, span, None, Vec::new(), Vec::new());
 2516|      1|    }
 2517|       |
 2518|       |    /// Helper to report warning diagnostics
 2519|      6|    fn report_warning(&mut self, message: impl Into<String>, loc: SourceLoc) {
 2520|      6|        let span = SourceSpan::new(loc, loc);
 2521|      6|        self.report_diagnostic(DiagnosticLevel::Warning, message, span, None, Vec::new(), Vec::new());
 2522|      6|    }
 2523|       |
 2524|     37|    fn parse_macro_definition_params(
 2525|     37|        &mut self,
 2526|     37|        macro_name: &str,
 2527|     37|    ) -> Result<(MacroFlags, Vec<StringId>, Option<StringId>), PPError> {
 2528|     37|        let mut flags = MacroFlags::FUNCTION_LIKE;
 2529|     37|        let mut params = Vec::new();
 2530|     37|        let mut variadic = None;
 2531|       |
 2532|       |        'param_parsing: loop {
 2533|     61|            let param_token = self.expect_token()?;
                                                               ^0
 2534|     61|            match param_token.kind {
 2535|      0|                PPTokenKind::RightParen => break,
 2536|       |                PPTokenKind::Ellipsis => {
 2537|      3|                    flags |= MacroFlags::C99_VARARGS;
 2538|      3|                    variadic = Some(StringId::new("__VA_ARGS__"));
 2539|      3|                    if !matches!(self.lex_token().map(|t| t.kind), Some(PPTokenKind::RightParen)) {
                                      ^0
 2540|      0|                        return self.emit_error_loc(PPErrorKind::InvalidMacroParameter, param_token.location);
 2541|      3|                    }
 2542|      3|                    break;
 2543|       |                }
 2544|     58|                PPTokenKind::Identifier(sym) => {
 2545|     58|                    if params.contains(&sym) {
 2546|      0|                        return self.emit_error_loc(PPErrorKind::InvalidMacroParameter, param_token.location);
 2547|     58|                    }
 2548|     58|                    params.push(sym);
 2549|       |
 2550|     58|                    let sep = self.expect_token()?;
                                                               ^0
 2551|     58|                    match sep.kind {
 2552|     24|                        PPTokenKind::Comma => continue,
 2553|     32|                        PPTokenKind::RightParen => break,
 2554|       |                        PPTokenKind::Ellipsis => {
 2555|      2|                            variadic = Some(params.pop().unwrap());
 2556|      2|                            flags |= MacroFlags::GNU_VARARGS;
 2557|      2|                            if !matches!(self.lex_token().map(|t| t.kind), Some(PPTokenKind::RightParen)) {
                                              ^0
 2558|      0|                                return self.emit_error_loc(PPErrorKind::InvalidMacroParameter, sep.location);
 2559|      2|                            }
 2560|      2|                            break;
 2561|       |                        }
 2562|       |                        _ => {
 2563|       |                            // Not a standard parameter list separator; treat as start of body.
 2564|       |                            // This pushes back both the separator and the identifier.
 2565|      0|                            self.pending_tokens.push_front(sep);
 2566|      0|                            self.pending_tokens.push_front(param_token);
 2567|      0|                            break 'param_parsing;
 2568|       |                        }
 2569|       |                    }
 2570|       |                }
 2571|       |                _ => {
 2572|      0|                    self.report_warning(
 2573|      0|                        format!("Invalid macro parameter token in #define '{}'", macro_name),
 2574|      0|                        param_token.location,
 2575|       |                    );
 2576|       |
 2577|       |                    // Skip to the next divider
 2578|      0|                    while let Some(t) = self.lex_token() {
 2579|      0|                        if matches!(t.kind, PPTokenKind::Comma | PPTokenKind::RightParen) {
 2580|      0|                            self.pending_tokens.push_front(t);
 2581|      0|                            break;
 2582|      0|                        }
 2583|       |                    }
 2584|       |                }
 2585|       |            }
 2586|       |        }
 2587|       |
 2588|     37|        Ok((flags, params, variadic))
 2589|     37|    }
 2590|       |}
 2591|       |
 2592|       |/// Helper to cache source buffers for efficient token text retrieval
 2593|       |struct SourceBufferCache<'a> {
 2594|       |    sm: &'a SourceManager,
 2595|       |    last_sid: Option<SourceId>,
 2596|       |    last_buffer: Option<&'a [u8]>,
 2597|       |}
 2598|       |
 2599|       |impl<'a> SourceBufferCache<'a> {
 2600|    106|    fn new(sm: &'a SourceManager) -> Self {
 2601|    106|        Self {
 2602|    106|            sm,
 2603|    106|            last_sid: None,
 2604|    106|            last_buffer: None,
 2605|    106|        }
 2606|    106|    }
 2607|       |
 2608|      4|    fn reset(&mut self) {
 2609|      4|        self.last_sid = None;
 2610|      4|        self.last_buffer = None;
 2611|      4|    }
 2612|       |
 2613|    471|    fn get_token_bytes<'b>(&'b mut self, token: &'b PPToken) -> &'b [u8] {
 2614|    471|        let sid = token.location.source_id();
 2615|    471|        let buffer = if self.last_sid == Some(sid) {
                          ^461
 2616|    316|            self.last_buffer.unwrap()
 2617|    155|        } else if let Some(b) = self.sm.get_buffer_safe(sid) {
                                         ^145
 2618|       |            // Bolt : Cache the buffer for the current source ID.
 2619|    145|            self.last_sid = Some(sid);
 2620|    145|            self.last_buffer = Some(b);
 2621|    145|            b
 2622|       |        } else {
 2623|       |            // Fallback for built-in tokens or tokens without a physical buffer.
 2624|     10|            return token.get_text().as_bytes();
 2625|       |        };
 2626|       |
 2627|    461|        let start = token.location.offset() as usize;
 2628|    461|        let end = start + token.length as usize;
 2629|    461|        if end <= buffer.len() {
 2630|    461|            &buffer[start..end]
 2631|       |        } else {
 2632|      0|            token.get_text().as_bytes()
 2633|       |        }
 2634|    471|    }
 2635|       |
 2636|     35|    fn get_token_text<'b>(&'b mut self, token: &'b PPToken) -> &'b str {
 2637|       |        // Safety: Tokens are guaranteed to be valid UTF-8 by the lexer.
 2638|     35|        unsafe { std::str::from_utf8_unchecked(self.get_token_bytes(token)) }
 2639|     35|    }
 2640|       |}
 2641|       |
 2642|       |#[cfg(test)]
 2643|       |mod tests {
 2644|       |    use super::*;
 2645|       |    use crate::ast::StringId;
 2646|       |
 2647|       |    #[test]
 2648|      1|    fn test_is_directive() {
 2649|      1|        let table = DirectiveKeywordTable::new();
 2650|       |
 2651|       |        // Test known directive
 2652|      1|        let define_sym = StringId::new("define");
 2653|      1|        assert_eq!(table.is_directive(define_sym), Some(DirectiveKind::Define));
 2654|       |
 2655|       |        // Test unknown directive (this covers the else { None } branch)
 2656|      1|        let unknown_sym = StringId::new("not_a_directive");
 2657|      1|        assert_eq!(table.is_directive(unknown_sym), None);
 2658|      1|    }
 2659|       |}

/app/src/semantic/analyzer.rs:
    1|       |use crate::{
    2|       |    ast::{nodes::*, *},
    3|       |    diagnostic::{DiagnosticEngine, SemanticError},
    4|       |    semantic::{
    5|       |        ArraySizeType, BuiltinType, QualType, StructMember, SymbolKind, SymbolTable, TypeKind, TypeQualifiers, TypeRef,
    6|       |        TypeRegistry,
    7|       |        const_eval::ConstEvalCtx,
    8|       |        conversions::{integer_promotion, usual_arithmetic_conversions},
    9|       |    },
   10|       |};
   11|       |
   12|       |use smallvec::{SmallVec, smallvec};
   13|       |use std::collections::{HashMap, HashSet};
   14|       |
   15|       |/// Side table containing semantic information for AST nodes.
   16|       |/// Parallel vectors indexed by node index (NodeRef.index()).
   17|       |#[derive(Debug, Clone)]
   18|       |pub struct SemanticInfo {
   19|       |    pub types: Vec<Option<QualType>>,
   20|       |    pub conversions: Vec<SmallVec<[Conversion; 1]>>,
   21|       |    pub value_categories: Vec<ValueCategory>,
   22|       |    pub generic_selections: HashMap<usize, NodeRef>, // Maps NodeIndex of GenericSelection to selected result_expr
   23|       |    pub offsetof_results: HashMap<usize, i64>,       // Maps NodeIndex of BuiltinOffsetof to computed offset
   24|       |}
   25|       |
   26|       |impl SemanticInfo {
   27|    323|    pub(crate) fn with_capacity(n: usize) -> Self {
   28|    323|        Self {
   29|    323|            types: vec![None; n],
   30|    323|            conversions: vec![SmallVec::new(); n],
   31|    323|            value_categories: vec![ValueCategory::RValue; n],
   32|    323|            generic_selections: HashMap::new(),
   33|    323|            offsetof_results: HashMap::new(),
   34|    323|        }
   35|    323|    }
   36|       |}
   37|       |
   38|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   39|       |pub enum ValueCategory {
   40|       |    LValue,
   41|       |    RValue,
   42|       |}
   43|       |
   44|       |/// Implicit Conversions
   45|       |#[derive(Debug, Clone, PartialEq, Eq)]
   46|       |pub enum Conversion {
   47|       |    /// LValue  RValue
   48|       |    LValueToRValue,
   49|       |
   50|       |    /// Array/function  pointer
   51|       |    PointerDecay { to: TypeRef },
   52|       |
   53|       |    /// char/short  int (store types as TypeRef)
   54|       |    IntegerPromotion { from: TypeRef, to: TypeRef },
   55|       |
   56|       |    /// int  long, unsigned  unsigned long, etc
   57|       |    IntegerCast { from: TypeRef, to: TypeRef },
   58|       |
   59|       |    /// void*  T*
   60|       |    PointerCast { from: TypeRef, to: TypeRef },
   61|       |
   62|       |    /// add/remove const/volatile
   63|       |    QualifierAdjust { from: TypeQualifiers, to: TypeQualifiers },
   64|       |
   65|       |    /// 0 / NULL  T*
   66|       |    NullPointerConstant,
   67|       |}
   68|       |
   69|       |/// Run Semantic Analyzer in our AST and return analysist result in SemanticInfo
   70|       |/// which contains resolved type, conversion table, and value category
   71|    323|pub(crate) fn visit_ast(
   72|    323|    ast: &Ast,
   73|    323|    diag: &mut DiagnosticEngine,
   74|    323|    symbol_table: &SymbolTable,
   75|    323|    registry: &mut TypeRegistry,
   76|    323|) -> SemanticInfo {
   77|    323|    let mut semantic_info = SemanticInfo::with_capacity(ast.kinds.len());
   78|    323|    let mut resolver = SemanticAnalyzer {
   79|    323|        ast,
   80|    323|        diag,
   81|    323|        symbol_table,
   82|    323|        registry,
   83|    323|        semantic_info: &mut semantic_info,
   84|    323|        current_function_ret_type: None,
   85|    323|        current_function_name: None,
   86|    323|        current_function_is_noreturn: false,
   87|    323|        deferred_checks: Vec::new(),
   88|    323|        loop_depth: 0,
   89|    323|        switch_depth: 0,
   90|    323|        switch_cases: SmallVec::new(),
   91|    323|        switch_default_seen: SmallVec::new(),
   92|    323|        checked_types: HashSet::new(),
   93|    323|    };
   94|    323|    let root = ast.get_root();
   95|    323|    resolver.visit_node(root);
   96|    323|    resolver.process_deferred_checks();
   97|    323|    semantic_info
   98|    323|}
   99|       |
  100|       |enum DeferredCheck {
  101|       |    StaticAssert(NodeRef),
  102|       |}
  103|       |
  104|       |struct SemanticAnalyzer<'a> {
  105|       |    ast: &'a Ast,
  106|       |    diag: &'a mut DiagnosticEngine,
  107|       |    symbol_table: &'a SymbolTable,
  108|       |    registry: &'a mut TypeRegistry,
  109|       |    semantic_info: &'a mut SemanticInfo,
  110|       |    current_function_ret_type: Option<QualType>,
  111|       |    current_function_name: Option<String>,
  112|       |    current_function_is_noreturn: bool,
  113|       |    deferred_checks: Vec<DeferredCheck>,
  114|       |    loop_depth: usize,
  115|       |    switch_depth: usize,
  116|       |    // Bolt : Use SmallVec for switch state to avoid heap allocations for nested switches.
  117|       |    switch_cases: SmallVec<[HashSet<i64>; 4]>,
  118|       |    switch_default_seen: SmallVec<[bool; 4]>,
  119|       |    checked_types: HashSet<TypeRef>,
  120|       |}
  121|       |
  122|       |impl<'a> SemanticAnalyzer<'a> {
  123|     78|    fn report_error(&mut self, error: SemanticError) {
  124|     78|        self.diag.report(error);
  125|     78|    }
  126|       |
  127|    766|    fn push_conversion(&mut self, node_ref: NodeRef, conv: Conversion) {
  128|    766|        self.semantic_info.conversions[node_ref.index()].push(conv);
  129|    766|    }
  130|       |
  131|     40|    fn unwrap_initializer_item(&self, node_ref: NodeRef) -> (NodeRef, NodeRef, u16) {
  132|     40|        if let NodeKind::InitializerItem(item) = self.ast.get_kind(node_ref) {
  133|     40|            (item.initializer, item.designator_start, item.designator_len)
  134|       |        } else {
  135|      0|            (node_ref, NodeRef::new(1).unwrap(), 0)
  136|       |        }
  137|     40|    }
  138|       |
  139|     44|    fn const_ctx(&self) -> ConstEvalCtx<'_> {
  140|     44|        ConstEvalCtx {
  141|     44|            ast: self.ast,
  142|     44|            symbol_table: self.symbol_table,
  143|     44|            registry: self.registry,
  144|     44|            semantic_info: Some(self.semantic_info),
  145|     44|        }
  146|     44|    }
  147|       |
  148|       |    /// Recursively visit type to find any expressions (e.g. VLA sizes) and resolve them.
  149|    906|    fn visit_type_expressions(&mut self, qt: QualType) {
  150|    906|        let ty = qt.ty();
  151|       |        //  Bolt: Optimized duplicate check.
  152|       |        // `HashSet::insert` returns `false` if the value was already present.
  153|       |        // This is faster than calling `contains` and then `insert`, as it
  154|       |        // performs a single lookup instead of two.
  155|    906|        if !self.checked_types.insert(ty) {
  156|    258|            return;
  157|    648|        }
  158|       |
  159|       |        // To avoid infinite recursion on recursive types (e.g. struct A { struct A *next; }),
  160|       |        // we rely on checked_types.
  161|       |        // Note: We need to clone the kind to avoid borrowing self.registry while calling self methods
  162|    648|        let kind = self.registry.get(ty).kind.clone();
  163|       |
  164|    648|        match kind {
  165|     49|            TypeKind::Array { element_type, size } => {
  166|     49|                if let ArraySizeType::Variable(expr) = size {
                                                             ^2
  167|      2|                    self.visit_node(expr);
  168|     47|                }
  169|     49|                self.visit_type_expressions(QualType::unqualified(element_type));
  170|       |            }
  171|     90|            TypeKind::Pointer { pointee } => {
  172|     90|                self.visit_type_expressions(pointee);
  173|     90|            }
  174|       |            TypeKind::Function {
  175|     45|                return_type,
  176|     45|                parameters,
  177|       |                ..
  178|       |            } => {
  179|     45|                self.visit_type_expressions(QualType::unqualified(return_type));
  180|     45|                for param in parameters.iter() {
                                  ^40
  181|     40|                    self.visit_type_expressions(param.param_type);
  182|     40|                }
  183|       |            }
  184|     21|            TypeKind::Complex { base_type } => {
  185|     21|                self.visit_type_expressions(QualType::unqualified(base_type));
  186|     21|            }
  187|       |            // For Records and Enums, we don't need to traverse members because
  188|       |            // they cannot contain VLAs (C11 6.7.2.1).
  189|       |            // Even if they did, the members would be visited during their declaration processing.
  190|    443|            _ => {}
  191|       |        }
  192|    906|    }
  193|       |
  194|      5|    fn can_fall_through(&self, node_ref: NodeRef) -> bool {
  195|      5|        match self.ast.get_kind(node_ref) {
  196|      2|            NodeKind::Return(_) | NodeKind::Break | NodeKind::Continue | NodeKind::Goto(_, _) => false,
  197|      0|            NodeKind::If(if_stmt) => {
  198|      0|                let then_ft = self.can_fall_through(if_stmt.then_branch);
  199|      0|                let else_ft = if_stmt.else_branch.is_none_or(|e| self.can_fall_through(e));
  200|      0|                then_ft || else_ft
  201|       |            }
  202|      0|            NodeKind::ExpressionStatement(Some(expr_ref)) => {
  203|      0|                if let NodeKind::FunctionCall(call) = self.ast.get_kind(*expr_ref)
  204|      0|                    && let Some(callee_type) = self.semantic_info.types[call.callee.index()]
  205|      0|                    && let TypeKind::Function { is_noreturn, .. } = &self.registry.get(callee_type.ty()).kind
  206|       |                {
  207|      0|                    return !*is_noreturn;
  208|      0|                }
  209|      0|                true
  210|       |            }
  211|       |            NodeKind::While(_) => {
  212|       |                // While loop can only be exited via break, so it can fall through.
  213|      0|                true
  214|       |            }
  215|      0|            NodeKind::For(for_stmt) => {
  216|       |                // A for loop without a condition is infinite unless there's a break.
  217|      0|                for_stmt.condition.is_some()
  218|       |            }
  219|      3|            NodeKind::CompoundStatement(cs) => {
  220|      3|                if cs.stmt_len > 0 {
  221|      2|                    let last_item_idx = cs.stmt_start.get() + (cs.stmt_len - 1) as u32;
  222|      2|                    let last_item_ref = NodeRef::new(last_item_idx).unwrap();
  223|      2|                    self.can_fall_through(last_item_ref)
  224|       |                } else {
  225|      1|                    true
  226|       |                }
  227|       |            }
  228|      0|            _ => true,
  229|       |        }
  230|      5|    }
  231|       |
  232|  3.30k|    fn is_lvalue(&self, node_ref: NodeRef) -> bool {
  233|  3.30k|        let node_kind = self.ast.get_kind(node_ref);
  234|    989|        match node_kind {
  235|    853|            NodeKind::Ident(_, symbol_ref) => {
  236|    853|                let symbol = self.symbol_table.get_symbol(*symbol_ref);
  237|    853|                matches!(symbol.kind, SymbolKind::Variable { .. } | SymbolKind::Function { .. })
                              ^7
  238|       |            }
  239|     96|            NodeKind::UnaryOp(op, _) => matches!(*op, UnaryOp::Deref),
                                                      ^85
  240|     49|            NodeKind::IndexAccess(..) => true,
  241|    161|            NodeKind::MemberAccess(obj_ref, _, is_arrow) => *is_arrow || self.is_lvalue(*obj_ref),
                                                                                       ^147 ^147      ^147
  242|     71|            NodeKind::Literal(literal::Literal::String(_)) => true,
  243|      9|            NodeKind::CompoundLiteral(..) => true,
  244|       |            NodeKind::GenericSelection(_) => {
  245|     54|                if let Some(&selected) = self.semantic_info.generic_selections.get(&node_ref.index()) {
  246|     54|                    self.is_lvalue(selected)
  247|       |                } else {
  248|      0|                    false
  249|       |                }
  250|       |            }
  251|  2.01k|            _ => false,
  252|       |        }
  253|  3.30k|    }
  254|       |
  255|     61|    fn is_bitfield(&self, node_ref: NodeRef) -> bool {
  256|     61|        let node_kind = self.ast.get_kind(node_ref);
  257|     61|        match node_kind {
  258|      4|            NodeKind::MemberAccess(obj_ref, field_name, is_arrow) => {
  259|      4|                let Some(obj_ty) = self.semantic_info.types[obj_ref.index()] else {
  260|      0|                    return false;
  261|       |                };
  262|      4|                let record_ty_ref = if *is_arrow {
  263|      0|                    let Some(pointee) = self.registry.get_pointee(obj_ty.ty()) else {
  264|      0|                        return false;
  265|       |                    };
  266|      0|                    pointee.ty()
  267|       |                } else {
  268|      4|                    obj_ty.ty()
  269|       |                };
  270|       |
  271|      4|                fn find_bitfield(registry: &TypeRegistry, record_ty: TypeRef, name: NameId) -> bool {
  272|      4|                    if let TypeKind::Record { members, .. } = &registry.get(record_ty).kind {
  273|      4|                        if let Some(member) = members.iter().find(|m| m.name == Some(name)) {
  274|      4|                            return member.bit_field_size.is_some();
  275|      0|                        }
  276|      0|                        for member in members.iter() {
  277|      0|                            if member.name.is_none() && find_bitfield(registry, member.member_type.ty(), name) {
  278|      0|                                return true;
  279|      0|                            }
  280|       |                        }
  281|      0|                    }
  282|      0|                    false
  283|      4|                }
  284|       |
  285|      4|                find_bitfield(self.registry, record_ty_ref, *field_name)
  286|       |            }
  287|       |            NodeKind::GenericSelection(_) => {
  288|      2|                if let Some(&selected) = self.semantic_info.generic_selections.get(&node_ref.index()) {
  289|      2|                    self.is_bitfield(selected)
  290|       |                } else {
  291|      0|                    false
  292|       |                }
  293|       |            }
  294|     55|            _ => false,
  295|       |        }
  296|     61|    }
  297|       |
  298|     26|    fn is_register_variable(&self, node_ref: NodeRef) -> bool {
  299|     26|        let node_kind = self.ast.get_kind(node_ref);
  300|     26|        match node_kind {
  301|     19|            NodeKind::Ident(_, symbol_ref) => {
  302|     19|                let symbol = self.symbol_table.get_symbol(*symbol_ref);
  303|     19|                if let SymbolKind::Variable { storage, .. } = &symbol.kind {
                                                            ^18
  304|     18|                    return *storage == Some(StorageClass::Register);
  305|      1|                }
  306|      1|                false
  307|       |            }
  308|       |            NodeKind::GenericSelection(_) => {
  309|      0|                if let Some(&selected) = self.semantic_info.generic_selections.get(&node_ref.index()) {
  310|      0|                    self.is_register_variable(selected)
  311|       |                } else {
  312|      0|                    false
  313|       |                }
  314|       |            }
  315|      7|            _ => false,
  316|       |        }
  317|     26|    }
  318|       |
  319|    149|    fn is_null_pointer_constant(&self, node_ref: NodeRef) -> bool {
  320|    149|        let node_kind = self.ast.get_kind(node_ref);
  321|     78|        match node_kind {
  322|     21|            NodeKind::Literal(literal::Literal::Int { val: 0, .. }) => true,
  323|      6|            NodeKind::Cast(ty, inner) if ty.ty() == self.registry.type_void_ptr => {
  324|      6|                self.is_null_pointer_constant(*inner)
  325|       |            }
  326|    122|            _ => false,
  327|       |        }
  328|    149|    }
  329|       |
  330|       |    /// Checks if the node is an LValue and is not const-qualified.
  331|       |    /// Reports errors if check fails.
  332|    130|    fn check_lvalue_and_modifiable(&mut self, node_ref: NodeRef, ty: QualType, span: SourceSpan) -> bool {
  333|    130|        if !self.is_lvalue(node_ref) {
  334|      7|            self.report_error(SemanticError::NotAnLvalue { span });
  335|      7|            false
  336|    123|        } else if self.registry.is_const_recursive(ty) {
  337|      8|            self.report_error(SemanticError::AssignmentToReadOnly { span });
  338|      8|            false
  339|       |        } else {
  340|    115|            true
  341|       |        }
  342|    130|    }
  343|       |
  344|       |    /// Validates assignment constraints and records implicit conversions.
  345|       |    /// Returns true if assignment is valid, false otherwise.
  346|     89|    fn validate_and_record_assignment(
  347|     89|        &mut self,
  348|     89|        lhs_ty: QualType,
  349|     89|        rhs_ty: QualType,
  350|     89|        rhs_ref: NodeRef,
  351|     89|        span: SourceSpan,
  352|     89|    ) -> bool {
  353|     89|        if self.check_assignment_constraints(lhs_ty, rhs_ty, rhs_ref) {
  354|     81|            self.record_implicit_conversions(lhs_ty, rhs_ty, rhs_ref);
  355|     81|            true
  356|       |        } else {
  357|      8|            let lhs_kind = &self.registry.get(lhs_ty.ty()).kind;
  358|      8|            let rhs_kind = &self.registry.get(rhs_ty.ty()).kind;
  359|      8|            self.report_error(SemanticError::TypeMismatch {
  360|      8|                expected: lhs_kind.to_string(),
  361|      8|                found: rhs_kind.to_string(),
  362|      8|                span,
  363|      8|            });
  364|      8|            false
  365|       |        }
  366|     89|    }
  367|       |
  368|     70|    fn check_scalar_condition(&mut self, condition: NodeRef) {
  369|     70|        if let Some(cond_ty) = self.visit_node(condition)
  370|     70|            && !cond_ty.is_scalar()
  371|      0|        {
  372|      0|            // report error
  373|     70|        }
  374|     70|    }
  375|       |
  376|     63|    fn visit_if_statement(&mut self, stmt: &IfStmt) {
  377|     63|        self.check_scalar_condition(stmt.condition);
  378|     63|        self.visit_node(stmt.then_branch);
  379|     63|        if let Some(else_branch) = stmt.else_branch {
                                  ^4
  380|      4|            self.visit_node(else_branch);
  381|     59|        }
  382|     63|    }
  383|       |
  384|      3|    fn visit_while_statement(&mut self, stmt: &WhileStmt) {
  385|      3|        self.check_scalar_condition(stmt.condition);
  386|      3|        self.loop_depth += 1;
  387|      3|        self.visit_node(stmt.body);
  388|      3|        self.loop_depth -= 1;
  389|      3|    }
  390|       |
  391|      4|    fn visit_for_statement(&mut self, stmt: &ForStmt) {
  392|      4|        if let Some(init) = stmt.init {
                                  ^2
  393|      2|            self.visit_node(init);
  394|      2|        }
  395|      4|        if let Some(cond) = stmt.condition {
  396|      4|            self.check_scalar_condition(cond);
  397|      4|        }
                      ^0
  398|      4|        if let Some(inc) = stmt.increment {
                                  ^3
  399|      3|            self.visit_node(inc);
  400|      3|        }
                      ^1
  401|      4|        self.loop_depth += 1;
  402|      4|        self.visit_node(stmt.body);
  403|      4|        self.loop_depth -= 1;
  404|      4|    }
  405|       |
  406|    264|    fn visit_return_statement(&mut self, expr: &Option<NodeRef>, span: SourceSpan) {
  407|    264|        if self.current_function_is_noreturn {
  408|      2|            self.report_error(SemanticError::NoreturnFunctionHasReturn {
  409|      2|                name: self.current_function_name.clone().unwrap(),
  410|      2|                span,
  411|      2|            });
  412|    262|        }
  413|       |
  414|    264|        let ret_ty = self.current_function_ret_type;
  415|    264|        let is_void_func = ret_ty.is_some_and(|ty| ty.is_void());
  416|    264|        let func_name = self.current_function_name.as_deref().unwrap_or("<unknown>");
  417|       |
  418|    264|        let Some(expr_ref) = expr else {
                               ^261
  419|      3|            if !is_void_func {
  420|      0|                self.report_error(SemanticError::NonVoidReturnWithoutValue {
  421|      0|                    name: func_name.to_string(),
  422|      0|                    span,
  423|      0|                });
  424|      3|            }
  425|      3|            return;
  426|       |        };
  427|       |
  428|    261|        if is_void_func {
  429|      1|            let err_span = self.ast.get_span(*expr_ref);
  430|      1|            self.report_error(SemanticError::VoidReturnWithValue {
  431|      1|                name: func_name.to_string(),
  432|      1|                span: err_span,
  433|      1|            });
  434|    260|        }
  435|       |
  436|    261|        if let Some(expr_ty) = self.visit_node(*expr_ref)
  437|    261|            && let Some(target_ty) = ret_ty
  438|    261|        {
  439|    261|            self.record_implicit_conversions(target_ty, expr_ty, *expr_ref);
  440|    261|        }
                      ^0
  441|    264|    }
  442|       |
  443|     99|    fn visit_unary_op(&mut self, op: UnaryOp, operand_ref: NodeRef, span: SourceSpan) -> Option<QualType> {
  444|     99|        let operand_ty = self.visit_node(operand_ref)?;
                                                                   ^0
  445|       |
  446|     99|        match op {
  447|       |            UnaryOp::AddrOf => {
  448|     30|                if !self.is_lvalue(operand_ref) {
  449|      2|                    self.report_error(SemanticError::NotAnLvalue { span });
  450|      2|                    return None;
  451|     28|                }
  452|     28|                if self.is_bitfield(operand_ref) {
  453|      2|                    self.report_error(SemanticError::AddressOfBitfield { span });
  454|      2|                    return None;
  455|     26|                }
  456|     26|                if self.is_register_variable(operand_ref) {
  457|      2|                    self.report_error(SemanticError::AddressOfRegister { span });
  458|      2|                    return None;
  459|     24|                }
  460|     24|                if operand_ty.is_array() || operand_ty.is_function() {
  461|      1|                    let decayed = self.registry.decay(operand_ty, TypeQualifiers::empty());
  462|      1|                    self.push_conversion(operand_ref, Conversion::PointerDecay { to: decayed.ty() });
  463|      1|                    return Some(decayed);
  464|     23|                }
  465|     23|                Some(QualType::unqualified(self.registry.pointer_to(operand_ty)))
  466|       |            }
  467|       |            UnaryOp::Deref => {
  468|      7|                let actual_ty = if operand_ty.is_array() || operand_ty.is_function() {
  469|      0|                    let decayed = self.registry.decay(operand_ty, TypeQualifiers::empty());
  470|      0|                    self.push_conversion(operand_ref, Conversion::PointerDecay { to: decayed.ty() });
  471|      0|                    decayed
  472|       |                } else {
  473|      7|                    operand_ty
  474|       |                };
  475|       |
  476|      7|                if actual_ty.is_pointer() {
  477|      7|                    self.registry.get_pointee(actual_ty.ty())
  478|       |                } else {
  479|      0|                    None
  480|       |                }
  481|       |            }
  482|       |            UnaryOp::Real | UnaryOp::Imag => {
  483|      4|                if let TypeKind::Complex { base_type } = &self.registry.get(operand_ty.ty()).kind {
                                                         ^2
  484|      2|                    Some(QualType::new(*base_type, operand_ty.qualifiers()))
  485|      2|                } else if operand_ty.is_real() {
  486|      2|                    if op == UnaryOp::Real {
  487|      1|                        Some(operand_ty)
  488|       |                    } else {
  489|       |                        // __imag__ on real type returns zero of that type
  490|      1|                        Some(self.registry.strip_all(operand_ty))
  491|       |                    }
  492|       |                } else {
  493|      0|                    let type_kind = &self.registry.get(operand_ty.ty()).kind;
  494|      0|                    self.report_error(SemanticError::InvalidUnaryOperand {
  495|      0|                        ty: type_kind.to_string(),
  496|      0|                        span,
  497|      0|                    });
  498|      0|                    None
  499|       |                }
  500|       |            }
  501|       |            UnaryOp::PreIncrement | UnaryOp::PreDecrement => {
  502|      4|                self.check_lvalue_and_modifiable(operand_ref, operand_ty, span);
  503|      4|                if operand_ty.is_scalar() { Some(operand_ty) } else { None }
                                                                                    ^0
  504|       |            }
  505|       |            UnaryOp::Plus | UnaryOp::Minus => {
  506|     27|                if operand_ty.is_arithmetic() {
  507|       |                    // C11 6.5.3.3: The integer promotions are performed on the operand,
  508|       |                    // and the result has the promoted type.
  509|     27|                    let promoted = self.apply_and_record_integer_promotion(operand_ref, operand_ty);
  510|       |
  511|       |                    // Strip all qualifiers for unary plus/minus operations
  512|     27|                    let stripped = self.registry.strip_all(promoted);
  513|     27|                    if stripped.qualifiers() != promoted.qualifiers() {
  514|      0|                        self.push_conversion(
  515|      0|                            operand_ref,
  516|      0|                            Conversion::QualifierAdjust {
  517|      0|                                from: promoted.qualifiers(),
  518|      0|                                to: stripped.qualifiers(),
  519|      0|                            },
  520|      0|                        );
  521|     27|                    }
  522|     27|                    Some(stripped)
  523|       |                } else {
  524|      0|                    let type_kind = &self.registry.get(operand_ty.ty()).kind;
  525|      0|                    self.report_error(SemanticError::InvalidUnaryOperand {
  526|      0|                        ty: type_kind.to_string(),
  527|      0|                        span,
  528|      0|                    });
  529|      0|                    None
  530|       |                }
  531|       |            }
  532|       |            UnaryOp::LogicNot => {
  533|       |                // Logical NOT always returns int type (C11 6.5.3.3)
  534|     20|                Some(QualType::unqualified(self.registry.type_int))
  535|       |            }
  536|       |            UnaryOp::BitNot => {
  537|      7|                if operand_ty.is_integer() {
  538|      3|                    Some(self.apply_and_record_integer_promotion(operand_ref, operand_ty))
  539|      4|                } else if operand_ty.is_complex() {
  540|      3|                    Some(operand_ty)
  541|       |                } else {
  542|      1|                    let type_kind = &self.registry.get(operand_ty.ty()).kind;
  543|      1|                    self.report_error(SemanticError::InvalidUnaryOperand {
  544|      1|                        ty: type_kind.to_string(),
  545|      1|                        span,
  546|      1|                    });
  547|      1|                    None
  548|       |                }
  549|       |            }
  550|       |        }
  551|     99|    }
  552|       |
  553|    452|    fn apply_and_record_integer_promotion(&mut self, node_ref: NodeRef, ty: QualType) -> QualType {
  554|    452|        let promoted = integer_promotion(self.registry, ty);
  555|    452|        if promoted.ty() != ty.ty() {
  556|     31|            self.push_conversion(
  557|     31|                node_ref,
  558|     31|                Conversion::IntegerPromotion {
  559|     31|                    from: ty.ty(),
  560|     31|                    to: promoted.ty(),
  561|     31|                },
  562|     31|            );
  563|    421|        }
  564|    452|        promoted
  565|    452|    }
  566|       |
  567|    210|    fn analyze_binary_operation_types(
  568|    210|        &mut self,
  569|    210|        op: BinaryOp,
  570|    210|        lhs_promoted: QualType,
  571|    210|        rhs_promoted: QualType,
  572|    210|        span: SourceSpan,
  573|    210|    ) -> Option<(QualType, QualType)> {
  574|     30|        match op {
  575|       |            // Pointer + integer = pointer
  576|     32|            BinaryOp::Add if lhs_promoted.is_pointer() && rhs_promoted.is_integer() => {
                                                                        ^2           ^2         ^2
  577|      2|                Some((lhs_promoted, lhs_promoted))
  578|       |            }
  579|     30|            BinaryOp::Add if lhs_promoted.is_integer() && rhs_promoted.is_pointer() => {
                                                                        ^25          ^25        ^0
  580|      0|                Some((rhs_promoted, rhs_promoted))
  581|       |            }
  582|       |
  583|       |            // Pointer - integer = pointer
  584|     22|            BinaryOp::Sub if lhs_promoted.is_pointer() && rhs_promoted.is_integer() => {
                                                                        ^3           ^3         ^2
  585|      2|                Some((lhs_promoted, lhs_promoted))
  586|       |            }
  587|       |
  588|       |            // Pointer - pointer = integer (ptrdiff_t)
  589|     20|            BinaryOp::Sub if lhs_promoted.is_pointer() && rhs_promoted.is_pointer() => {
                                                                        ^1           ^1         ^1
  590|      1|                Some((QualType::unqualified(self.registry.type_int), lhs_promoted))
  591|       |            }
  592|       |
  593|       |            // Pointer/Integer comparisons
  594|       |            BinaryOp::Equal | BinaryOp::NotEqual => {
  595|     83|                let common = if lhs_promoted.is_pointer() && rhs_promoted.is_pointer() {
                                                                           ^5           ^5
  596|      5|                    let lhs_base = self.registry.get_pointee(lhs_promoted.ty()).unwrap();
  597|      5|                    let rhs_base = self.registry.get_pointee(rhs_promoted.ty()).unwrap();
  598|       |
  599|      5|                    if lhs_base.ty() == self.registry.type_void || rhs_base.ty() == self.registry.type_void {
  600|      0|                        QualType::unqualified(self.registry.type_void_ptr)
  601|      5|                    } else if lhs_base == rhs_base {
  602|      4|                        lhs_promoted
  603|       |                    } else {
  604|      1|                        let lhs_str = self.registry.display_type(lhs_promoted.ty());
  605|      1|                        let rhs_str = self.registry.display_type(rhs_promoted.ty());
  606|      1|                        self.report_error(SemanticError::IncompatiblePointerComparison {
  607|      1|                            lhs: lhs_str,
  608|      1|                            rhs: rhs_str,
  609|      1|                            span,
  610|      1|                        });
  611|      1|                        lhs_promoted
  612|       |                    }
  613|     78|                } else if lhs_promoted.is_pointer() {
  614|      0|                    lhs_promoted
  615|     78|                } else if rhs_promoted.is_pointer() {
  616|      0|                    rhs_promoted
  617|       |                } else {
  618|     78|                    usual_arithmetic_conversions(self.registry, lhs_promoted, rhs_promoted)?
                                                                                                         ^0
  619|       |                };
  620|     83|                Some((QualType::unqualified(self.registry.type_int), common))
  621|       |            }
  622|       |
  623|       |            BinaryOp::Less | BinaryOp::LessEqual | BinaryOp::Greater | BinaryOp::GreaterEqual => {
  624|     18|                let common = if lhs_promoted.is_pointer() && rhs_promoted.is_pointer() {
                                  ^17                                      ^0           ^0
  625|      0|                    let lhs_base = self.registry.get_pointee(lhs_promoted.ty()).unwrap();
  626|      0|                    let rhs_base = self.registry.get_pointee(rhs_promoted.ty()).unwrap();
  627|      0|                    if lhs_base != rhs_base {
  628|      0|                        let lhs_str = self.registry.display_type(lhs_promoted.ty());
  629|      0|                        let rhs_str = self.registry.display_type(rhs_promoted.ty());
  630|      0|                        self.report_error(SemanticError::IncompatiblePointerComparison {
  631|      0|                            lhs: lhs_str,
  632|      0|                            rhs: rhs_str,
  633|      0|                            span,
  634|      0|                        });
  635|      0|                    }
  636|      0|                    lhs_promoted
  637|     18|                } else if lhs_promoted.is_real() && rhs_promoted.is_real() {
                                                                  ^17          ^17
  638|     17|                    usual_arithmetic_conversions(self.registry, lhs_promoted, rhs_promoted)?
                                                                                                         ^0
  639|       |                } else {
  640|      1|                    let lhs_str = self.registry.display_qual_type(lhs_promoted);
  641|      1|                    let rhs_str = self.registry.display_qual_type(rhs_promoted);
  642|      1|                    self.report_error(SemanticError::InvalidBinaryOperands {
  643|      1|                        left_ty: lhs_str,
  644|      1|                        right_ty: rhs_str,
  645|      1|                        span,
  646|      1|                    });
  647|      1|                    return None;
  648|       |                };
  649|     17|                Some((QualType::unqualified(self.registry.type_int), common))
  650|       |            }
  651|       |
  652|       |            // Logical operations
  653|       |            BinaryOp::LogicAnd | BinaryOp::LogicOr => {
  654|       |                // Result has type int (C11 6.5.13/6.5.14)
  655|     25|                Some((QualType::unqualified(self.registry.type_int), lhs_promoted))
  656|       |            }
  657|       |
  658|       |            // Shift operations
  659|       |            BinaryOp::LShift | BinaryOp::RShift => {
  660|       |                // C11 6.5.7: result is type of promoted left operand
  661|      2|                Some((lhs_promoted, lhs_promoted))
  662|       |            }
  663|       |
  664|       |            // For other operations, use usual arithmetic conversions
  665|       |            _ => {
  666|     77|                let ty = usual_arithmetic_conversions(self.registry, lhs_promoted, rhs_promoted)?;
                                                                                                              ^0
  667|     77|                Some((ty, ty))
  668|       |            }
  669|       |        }
  670|    210|    }
  671|       |
  672|    203|    fn visit_binary_op(
  673|    203|        &mut self,
  674|    203|        op: BinaryOp,
  675|    203|        lhs_ref: NodeRef,
  676|    203|        rhs_ref: NodeRef,
  677|    203|        span: SourceSpan,
  678|    203|    ) -> Option<QualType> {
  679|    203|        debug_assert!(
  680|    203|            !op.is_assignment(),
  681|      0|            "visit_binary_op called with assignment operator: {:?}",
  682|       |            op
  683|       |        );
  684|    203|        let lhs_ty = self.visit_node(lhs_ref)?;
                                                           ^0
  685|    203|        let rhs_ty = self.visit_node(rhs_ref)?;
                                                           ^0
  686|       |
  687|       |        // Perform array/function decay first
  688|    203|        let mut lhs_decayed = lhs_ty;
  689|    203|        if lhs_ty.is_array() || lhs_ty.is_function() {
                                              ^202   ^202
  690|      1|            lhs_decayed = self.registry.decay(lhs_ty, TypeQualifiers::empty());
  691|      1|            self.push_conversion(lhs_ref, Conversion::PointerDecay { to: lhs_decayed.ty() });
  692|    202|        }
  693|       |
  694|    203|        let mut rhs_decayed = rhs_ty;
  695|    203|        if rhs_ty.is_array() || rhs_ty.is_function() {
  696|      0|            rhs_decayed = self.registry.decay(rhs_ty, TypeQualifiers::empty());
  697|      0|            self.push_conversion(rhs_ref, Conversion::PointerDecay { to: rhs_decayed.ty() });
  698|    203|        }
  699|       |
  700|    203|        if op == BinaryOp::Comma {
  701|      3|            return Some(rhs_decayed);
  702|    200|        }
  703|       |
  704|       |        // Perform integer promotions and record them
  705|    200|        let lhs_promoted = self.apply_and_record_integer_promotion(lhs_ref, lhs_decayed);
  706|    200|        let rhs_promoted = self.apply_and_record_integer_promotion(rhs_ref, rhs_decayed);
  707|       |
  708|    200|        if op == BinaryOp::Mod && (!lhs_promoted.is_integer() || !rhs_promoted.is_integer()) {
                                                 ^3                            ^2
  709|      1|            let lhs_kind = &self.registry.get(lhs_promoted.ty()).kind;
  710|      1|            let rhs_kind = &self.registry.get(rhs_promoted.ty()).kind;
  711|      1|            self.report_error(SemanticError::InvalidBinaryOperands {
  712|      1|                left_ty: lhs_kind.to_string(),
  713|      1|                right_ty: rhs_kind.to_string(),
  714|      1|                span,
  715|      1|            });
  716|      1|            return None;
  717|    199|        }
  718|       |
  719|    199|        let (result_ty, common_ty) = self.analyze_binary_operation_types(op, lhs_promoted, rhs_promoted, span)?;
                           ^198       ^198                                                                                  ^1
  720|       |
  721|       |        // For arithmetic/comparison operations, operands should be converted to a common type.
  722|    198|        let lhs_kind = self.ast.get_kind(lhs_ref);
  723|    198|        let rhs_kind = self.ast.get_kind(rhs_ref);
  724|       |
  725|    357|        let is_literal = |kind: &NodeKind| {
                          ^198
  726|    223|            matches!(
  727|    134|                kind,
  728|       |                NodeKind::Literal(literal::Literal::Int { .. })
  729|       |                    | NodeKind::Literal(literal::Literal::Char(_))
  730|       |                    | NodeKind::Literal(literal::Literal::Float { .. })
  731|       |            )
  732|    357|        };
  733|       |
  734|    198|        if lhs_promoted.ty() != common_ty.ty() || is_literal(lhs_kind) {
                                                                ^191
  735|     49|            self.push_conversion(
  736|     49|                lhs_ref,
  737|     49|                Conversion::IntegerCast {
  738|     49|                    from: lhs_promoted.ty(),
  739|     49|                    to: common_ty.ty(),
  740|     49|                },
  741|     49|            );
  742|    149|        }
  743|    198|        if rhs_promoted.ty() != common_ty.ty() || is_literal(rhs_kind) {
                                                                ^166
  744|    124|            self.push_conversion(
  745|    124|                rhs_ref,
  746|    124|                Conversion::IntegerCast {
  747|    124|                    from: rhs_promoted.ty(),
  748|    124|                    to: common_ty.ty(),
  749|    124|                },
  750|    124|            );
  751|    124|        }
                      ^74
  752|       |
  753|    198|        Some(result_ty)
  754|    203|    }
  755|       |
  756|    112|    fn visit_assignment(
  757|    112|        &mut self,
  758|    112|        node_ref: NodeRef,
  759|    112|        op: BinaryOp,
  760|    112|        lhs_ref: NodeRef,
  761|    112|        rhs_ref: NodeRef,
  762|    112|        span: SourceSpan,
  763|    112|    ) -> Option<QualType> {
  764|    112|        debug_assert!(
  765|    112|            op.is_assignment(),
  766|      0|            "visit_assignment called with non-assignment operator: {:?}",
  767|       |            op
  768|       |        );
  769|       |
  770|    112|        let lhs_ty = self.visit_node(lhs_ref)?;
                          ^110                             ^2
  771|    110|        let rhs_ty = self.visit_node(rhs_ref)?;
                                                           ^0
  772|       |
  773|    110|        if !self.check_lvalue_and_modifiable(lhs_ref, lhs_ty, span) {
  774|     10|            return None;
  775|    100|        }
  776|       |
  777|       |        // For compound assignments like +=, we need to check if the underlying arithmetic is valid.
  778|    100|        let (effective_rhs_ty, final_assignment_cast_target) = if let Some(arithmetic_op) = op.without_assignment() {
                                                                                         ^11
  779|       |            // Reuse visit_binary_op logic conceptually, but for compound assignment operands.
  780|       |            // For p += 1, LHS is pointer, RHS is integer.
  781|     11|            let lhs_promoted = self.apply_and_record_integer_promotion(lhs_ref, lhs_ty);
  782|     11|            let rhs_promoted = self.apply_and_record_integer_promotion(rhs_ref, rhs_ty);
  783|       |
  784|     11|            if let Some((_, common_ty)) =
  785|     11|                self.analyze_binary_operation_types(arithmetic_op, lhs_promoted, rhs_promoted, span)
  786|       |            {
  787|       |                // Record conversions from promoted operands to the common type.
  788|       |                // This is what the binary operation will actually work with.
  789|     11|                if lhs_promoted.ty() != common_ty.ty() {
  790|      1|                    self.push_conversion(
  791|      1|                        lhs_ref,
  792|      1|                        Conversion::IntegerCast {
  793|      1|                            from: lhs_promoted.ty(),
  794|      1|                            to: common_ty.ty(),
  795|      1|                        },
  796|      1|                    );
  797|     10|                }
  798|     11|                if rhs_promoted.ty() != common_ty.ty() {
  799|      3|                    self.push_conversion(
  800|      3|                        rhs_ref,
  801|      3|                        Conversion::IntegerCast {
  802|      3|                            from: rhs_promoted.ty(),
  803|      3|                            to: common_ty.ty(),
  804|      3|                        },
  805|      3|                    );
  806|      8|                }
  807|       |
  808|       |                // For compound assignment, the result of (lhs op rhs) is converted back to lhs type.
  809|       |                // We record this conversion on the assignment node itself.
  810|     11|                (common_ty, Some(lhs_ty))
  811|       |            } else {
  812|      0|                let lhs_kind = &self.registry.get(lhs_promoted.ty()).kind;
  813|      0|                let rhs_kind = &self.registry.get(rhs_promoted.ty()).kind;
  814|      0|                self.report_error(SemanticError::InvalidBinaryOperands {
  815|      0|                    left_ty: lhs_kind.to_string(),
  816|      0|                    right_ty: rhs_kind.to_string(),
  817|      0|                    span,
  818|      0|                });
  819|      0|                return None;
  820|       |            }
  821|       |        } else {
  822|     89|            (rhs_ty, None)
  823|       |        };
  824|       |
  825|       |        // For compound assignment, we record the final cast on the assignment node.
  826|    100|        if let Some(target_ty) = final_assignment_cast_target {
                                  ^11
  827|       |            // Check assignment constraints (C11 6.5.16.1)
  828|     11|            if !self.check_assignment_constraints(lhs_ty, effective_rhs_ty, rhs_ref) {
  829|      0|                let lhs_kind = &self.registry.get(lhs_ty.ty()).kind;
  830|      0|                let rhs_kind = &self.registry.get(effective_rhs_ty.ty()).kind;
  831|       |
  832|      0|                self.report_error(SemanticError::TypeMismatch {
  833|      0|                    expected: lhs_kind.to_string(),
  834|      0|                    found: rhs_kind.to_string(),
  835|      0|                    span,
  836|      0|                });
  837|      0|                return None;
  838|     11|            }
  839|       |
  840|     11|            if target_ty.ty() != effective_rhs_ty.ty() {
  841|      2|                self.push_conversion(
  842|      2|                    node_ref,
  843|      2|                    Conversion::IntegerCast {
  844|      2|                        from: effective_rhs_ty.ty(),
  845|      2|                        to: target_ty.ty(),
  846|      2|                    },
  847|      2|                );
  848|      9|            }
  849|       |        } else {
  850|       |            // Simple assignment
  851|     89|            if !self.validate_and_record_assignment(lhs_ty, effective_rhs_ty, rhs_ref, span) {
  852|      8|                return None;
  853|     81|            }
  854|       |        }
  855|       |
  856|     92|        Some(lhs_ty)
  857|    112|    }
  858|       |
  859|    309|    fn check_assignment_constraints(&self, lhs_ty: QualType, rhs_ty: QualType, rhs_ref: NodeRef) -> bool {
  860|       |        // 1. Arithmetic types
  861|    309|        if lhs_ty.is_arithmetic() && rhs_ty.is_arithmetic() {
                                                   ^258   ^258
  862|    252|            return true;
  863|     57|        }
  864|       |
  865|       |        // 2. Structure or Union types
  866|     57|        if lhs_ty.is_record() || rhs_ty.is_record() {
                                               ^47    ^47
  867|     11|            return lhs_ty.is_record() && rhs_ty.is_record() && lhs_ty.ty() == rhs_ty.ty();
                                                       ^10    ^10            ^9
  868|     46|        }
  869|       |
  870|       |        // 3. Pointers
  871|     46|        if lhs_ty.is_pointer() {
  872|     41|            if self.is_null_pointer_constant(rhs_ref) {
  873|      5|                return true;
  874|     36|            }
  875|       |
  876|       |            // Resolve implicit decay for RHS to check compatibility
  877|     36|            let rhs_pointer_base = if rhs_ty.is_array() {
  878|      2|                self.registry.get_array_element(rhs_ty.ty())
  879|     34|            } else if rhs_ty.is_function() {
  880|      2|                Some(rhs_ty.ty()) // Function decays to pointer
  881|     32|            } else if rhs_ty.is_pointer() {
  882|     31|                self.registry.get_pointee(rhs_ty.ty()).map(|qt| qt.ty())
  883|       |            } else {
  884|      1|                None
  885|       |            };
  886|       |
  887|     36|            if let Some(rhs_base) = rhs_pointer_base {
                                      ^35
  888|       |                // Check compatibility
  889|     35|                let lhs_base = self.registry.get_pointee(lhs_ty.ty()).unwrap();
  890|       |
  891|       |                // void* wildcard
  892|     35|                if lhs_base.ty() == self.registry.type_void || rhs_base == self.registry.type_void {
                                                                             ^29
  893|      7|                    return true;
  894|     28|                }
  895|       |
  896|     28|                return lhs_base.ty() == rhs_base;
  897|      1|            }
  898|       |
  899|      1|            return false;
  900|      5|        }
  901|       |
  902|       |        // 4. _Bool = Pointer
  903|      5|        if lhs_ty.ty() == self.registry.type_bool && (rhs_ty.is_pointer() || rhs_ty.is_array() || rhs_ty.is_function())
                                                                    ^1     ^1              ^0     ^0            ^0     ^0
  904|       |        {
  905|      1|            return true;
  906|      4|        }
  907|       |
  908|      4|        false
  909|    309|    }
  910|       |
  911|    663|    fn record_implicit_conversions(&mut self, lhs_ty: QualType, rhs_ty: QualType, rhs_ref: NodeRef) {
  912|    663|        let mut current_rhs_ty = rhs_ty;
  913|       |
  914|       |        // 1. Null pointer constant conversion (0 or (void*)0 -> T*)
  915|    663|        if lhs_ty.is_pointer() && self.is_null_pointer_constant(rhs_ref) {
                                                ^98  ^98                      ^98
  916|     12|            self.push_conversion(rhs_ref, Conversion::NullPointerConstant);
  917|     12|            if lhs_ty.ty() != self.registry.type_void_ptr {
  918|      7|                self.push_conversion(
  919|      7|                    rhs_ref,
  920|      7|                    Conversion::PointerCast {
  921|      7|                        from: self.registry.type_void_ptr,
  922|      7|                        to: lhs_ty.ty(),
  923|      7|                    },
  924|      7|                );
  925|      7|            }
                          ^5
  926|     12|            return;
  927|    651|        }
  928|       |
  929|       |        // 2. Array/Function-to-pointer decay
  930|    651|        if lhs_ty.is_pointer() && (current_rhs_ty.is_array() || current_rhs_ty.is_function()) {
                                                 ^86            ^86           ^84            ^84
  931|      4|            current_rhs_ty = self.registry.decay(current_rhs_ty, TypeQualifiers::empty());
  932|      4|            self.push_conversion(
  933|      4|                rhs_ref,
  934|      4|                Conversion::PointerDecay {
  935|      4|                    to: current_rhs_ty.ty(),
  936|      4|                },
  937|      4|            );
  938|    647|        }
  939|       |
  940|       |        // 3. Qualifier adjustment
  941|    651|        if lhs_ty.ty() == current_rhs_ty.ty() && lhs_ty.qualifiers() != current_rhs_ty.qualifiers() {
                                                               ^472
  942|     11|            self.push_conversion(
  943|     11|                rhs_ref,
  944|     11|                Conversion::QualifierAdjust {
  945|     11|                    from: current_rhs_ty.qualifiers(),
  946|     11|                    to: lhs_ty.qualifiers(),
  947|     11|                },
  948|     11|            );
  949|    640|        }
  950|       |
  951|       |        // 4. Casts (Integer or Pointer)
  952|    651|        let is_literal = matches!(
                                       ^319
  953|    651|            self.ast.get_kind(rhs_ref),
  954|       |            NodeKind::Literal(literal::Literal::Int { .. })
  955|       |                | NodeKind::Literal(literal::Literal::Char(_))
  956|       |                | NodeKind::Literal(literal::Literal::Float { .. })
  957|       |        );
  958|       |
  959|    651|        let is_arithmetic_cast = lhs_ty.is_arithmetic() && current_rhs_ty.is_arithmetic();
                                                                         ^543           ^543
  960|    651|        let is_pointer_cast = lhs_ty.is_pointer() && current_rhs_ty.is_pointer();
                                                                   ^86            ^86
  961|       |
  962|    651|        if (is_arithmetic_cast || is_pointer_cast) && (lhs_ty.ty() != current_rhs_ty.ty() || is_literal) {
                                                ^109                 ^628                                  ^454
  963|    467|            let conv = if is_pointer_cast {
  964|     55|                Conversion::PointerCast {
  965|     55|                    from: current_rhs_ty.ty(),
  966|     55|                    to: lhs_ty.ty(),
  967|     55|                }
  968|       |            } else {
  969|    412|                Conversion::IntegerCast {
  970|    412|                    from: current_rhs_ty.ty(),
  971|    412|                    to: lhs_ty.ty(),
  972|    412|                }
  973|       |            };
  974|    467|            self.push_conversion(rhs_ref, conv);
  975|    184|        }
  976|    663|    }
  977|       |
  978|    208|    fn check_assignment_and_record(&mut self, target_ty: QualType, init_ty: QualType, init_ref: NodeRef) {
  979|    208|        if !self.check_assignment_constraints(target_ty, init_ty, init_ref) {
  980|      2|            let lhs_kind = &self.registry.get(target_ty.ty()).kind;
  981|      2|            let rhs_kind = &self.registry.get(init_ty.ty()).kind;
  982|      2|            let span = self.ast.get_span(init_ref);
  983|      2|
  984|      2|            self.report_error(SemanticError::TypeMismatch {
  985|      2|                expected: lhs_kind.to_string(),
  986|      2|                found: rhs_kind.to_string(),
  987|      2|                span,
  988|      2|            });
  989|    206|        } else {
  990|    206|            self.record_implicit_conversions(target_ty, init_ty, init_ref);
  991|    206|        }
  992|    208|    }
  993|       |
  994|    280|    fn visit_initializer(&mut self, init_ref: NodeRef, target_ty: QualType) {
  995|    280|        match self.ast.get_kind(init_ref) {
  996|     57|            NodeKind::InitializerList(list) => {
  997|     57|                self.semantic_info.types[init_ref.index()] = Some(target_ty);
  998|     57|                let list = *list;
  999|     57|                self.visit_initializer_list(&list, target_ty);
 1000|     57|            }
 1001|     11|            NodeKind::Literal(literal::Literal::String(_)) if target_ty.is_array() => {
 1002|     11|                let Some(init_ty) = self.visit_node(init_ref) else {
 1003|      0|                    return;
 1004|       |                };
 1005|       |
 1006|     11|                let lhs_elem = self.registry.get_array_element(target_ty.ty()).unwrap();
 1007|     11|                let rhs_elem = self.registry.get_array_element(init_ty.ty()).unwrap();
 1008|       |
 1009|     11|                let is_rhs_char = rhs_elem == self.registry.type_char;
 1010|     11|                let is_lhs_char_type = [
 1011|     11|                    self.registry.type_char,
 1012|     11|                    self.registry.type_schar,
 1013|     11|                    self.registry.type_char_unsigned,
 1014|     11|                ]
 1015|     11|                .contains(&lhs_elem);
 1016|       |
 1017|     11|                let compatible = if is_rhs_char {
 1018|      8|                    is_lhs_char_type
 1019|       |                } else {
 1020|      3|                    self.registry
 1021|      3|                        .is_compatible(QualType::unqualified(lhs_elem), QualType::unqualified(rhs_elem))
 1022|       |                };
 1023|       |
 1024|     11|                if compatible {
 1025|     11|                    self.record_implicit_conversions(target_ty, init_ty, init_ref);
 1026|     11|                } else {
 1027|      0|                    self.report_error(SemanticError::TypeMismatch {
 1028|      0|                        expected: self.registry.get(target_ty.ty()).kind.to_string(),
 1029|      0|                        found: self.registry.get(init_ty.ty()).kind.to_string(),
 1030|      0|                        span: self.ast.get_span(init_ref),
 1031|      0|                    });
 1032|      0|                }
 1033|       |            }
 1034|       |            _ => {
 1035|    212|                if let Some(init_ty) = self.visit_node(init_ref) {
                                          ^206
 1036|    206|                    self.check_assignment_and_record(target_ty, init_ty, init_ref);
 1037|    206|                }
                              ^6
 1038|       |            }
 1039|       |        }
 1040|    280|    }
 1041|       |
 1042|     57|    fn visit_initializer_list(&mut self, list: &InitializerListData, target_ty: QualType) {
 1043|     57|        if target_ty.is_scalar() {
 1044|      3|            let mut items = list.init_start.range(list.init_len);
 1045|       |
 1046|      3|            if let Some(first_ref) = items.next() {
                                      ^2
 1047|      2|                let (expr, _, _) = self.unwrap_initializer_item(first_ref);
 1048|      2|                if let Some(init_ty) = self.visit_node(expr) {
 1049|      2|                    self.check_assignment_and_record(target_ty, init_ty, expr);
 1050|      2|                }
                              ^0
 1051|      1|            }
 1052|       |
 1053|      3|            for (i, item_ref) in items.enumerate() {
                               ^1 ^1
 1054|      1|                if i == 0 {
 1055|      1|                    self.report_error(SemanticError::ExcessElements {
 1056|      1|                        kind: "scalar".to_string(),
 1057|      1|                        span: self.ast.get_span(item_ref),
 1058|      1|                    });
 1059|      1|                }
                              ^0
 1060|      1|                let (expr, _, _) = self.unwrap_initializer_item(item_ref);
 1061|      1|                self.visit_node(expr);
 1062|       |            }
 1063|      3|            return;
 1064|     54|        }
 1065|       |
 1066|     54|        let target_type = self.registry.get(target_ty.ty()).clone();
 1067|     54|        match target_type.kind {
 1068|       |            TypeKind::Record { .. } => {
 1069|     34|                let mut flat_members = Vec::new();
 1070|     34|                target_type.flatten_members(self.registry, &mut flat_members);
 1071|       |
 1072|     63|                for item_ref in list.init_start.range(list.init_len) {
                                              ^34             ^34   ^34
 1073|     63|                    self.visit_initializer_item_record(item_ref, &flat_members, target_ty);
 1074|     63|                }
 1075|       |            }
 1076|       |            _ => {
 1077|     37|                for item_ref in list.init_start.range(list.init_len) {
                                              ^20             ^20   ^20
 1078|     37|                    let (expr, d_start, d_len) = self.unwrap_initializer_item(item_ref);
 1079|     37|                    for designator_ref in d_start.range(d_len) {
                                      ^17
 1080|     17|                        let NodeKind::Designator(d) = self.ast.get_kind(designator_ref) else {
 1081|      0|                            continue;
 1082|       |                        };
 1083|     17|                        match d {
 1084|     15|                            Designator::ArrayIndex(e) => {
 1085|     15|                                self.visit_node(*e);
 1086|     15|                            }
 1087|      2|                            Designator::GnuArrayRange(s, e) => {
 1088|      2|                                self.visit_node(*s);
 1089|      2|                                self.visit_node(*e);
 1090|      2|                            }
 1091|      0|                            Designator::FieldName(_) => {}
 1092|       |                        }
 1093|       |                    }
 1094|     37|                    self.visit_node(expr);
 1095|       |                }
 1096|       |            }
 1097|       |        }
 1098|     57|    }
 1099|       |
 1100|     63|    fn visit_initializer_item_record(&mut self, item_ref: NodeRef, members: &[StructMember], record_ty: QualType) {
 1101|     63|        let node_kind = self.ast.get_kind(item_ref);
 1102|     63|        if let NodeKind::InitializerItem(init) = node_kind {
 1103|       |            // 1. Validate designators
 1104|     63|            if init.designator_len > 0 {
 1105|     18|                let first_des_ref = init.designator_start;
 1106|     18|                if let NodeKind::Designator(Designator::FieldName(name)) = self.ast.get_kind(first_des_ref) {
 1107|       |                    // Check if member exists
 1108|     27|                    let found = members.iter().any(|m| m.name == Some(*name));
                                      ^18     ^18            ^18
 1109|       |
 1110|     18|                    if !found {
 1111|      1|                        let ty_str = self.registry.display_type(record_ty.ty());
 1112|      1|                        let span = self.ast.get_span(first_des_ref);
 1113|      1|                        self.report_error(SemanticError::MemberNotFound {
 1114|      1|                            name: *name,
 1115|      1|                            ty: ty_str,
 1116|      1|                            span,
 1117|      1|                        });
 1118|     17|                    }
 1119|      0|                }
 1120|     45|            }
 1121|       |
 1122|       |            // 2. Visit children (initializer and designators)
 1123|     63|            for designator_ref in init.designator_start.range(init.designator_len) {
                              ^19
 1124|     19|                if let NodeKind::Designator(d) = self.ast.get_kind(designator_ref) {
 1125|     19|                    match d {
 1126|      0|                        Designator::ArrayIndex(e) => {
 1127|      0|                            self.visit_node(*e);
 1128|      0|                        }
 1129|      0|                        Designator::GnuArrayRange(s, e) => {
 1130|      0|                            self.visit_node(*s);
 1131|      0|                            self.visit_node(*e);
 1132|      0|                        }
 1133|     19|                        Designator::FieldName(_) => {}
 1134|       |                    }
 1135|      0|                }
 1136|       |            }
 1137|       |            // Visit initializer value
 1138|       |            // Ideally we would recurse with correct member type, but for now just visit
 1139|     63|            self.visit_node(init.initializer);
 1140|      0|        }
 1141|     63|    }
 1142|       |
 1143|     82|    fn visit_function_call(&mut self, call_expr: &crate::ast::nodes::CallExpr) -> Option<QualType> {
 1144|     82|        let func_ty = self.visit_node(call_expr.callee)?;
                                                                     ^0
 1145|       |
 1146|     82|        let func_ty_ref = func_ty.ty();
 1147|       |        // Resolve function type (might be pointer to function)
 1148|     82|        let actual_func_ty_ref = if func_ty.is_pointer() {
 1149|       |            // Check if it's pointer to function
 1150|      2|            self.registry
 1151|      2|                .get_pointee(func_ty_ref)
 1152|      2|                .map(|qt| qt.ty())
 1153|      2|                .unwrap_or(func_ty_ref)
 1154|       |        } else {
 1155|     80|            func_ty_ref
 1156|       |        };
 1157|       |
 1158|       |        // Get function kind
 1159|     82|        let func_kind = self.registry.get(actual_func_ty_ref).kind.clone();
 1160|       |
 1161|       |        if let TypeKind::Function {
 1162|     81|            parameters,
 1163|     81|            is_variadic,
 1164|       |            ..
 1165|     82|        } = &func_kind
 1166|       |        {
 1167|     81|            let is_variadic = *is_variadic;
 1168|    133|            for (i, arg_node_ref) in call_expr.arg_start.range(call_expr.arg_len).enumerate() {
                                                   ^81                 ^81   ^81                ^81
 1169|    133|                let Some(arg_ty) = self.visit_node(arg_node_ref) else {
 1170|      0|                    continue;
 1171|       |                };
 1172|       |
 1173|    133|                if i < parameters.len() {
 1174|     66|                    let mut actual_arg_ty = arg_ty;
 1175|     66|                    if arg_ty.is_array() || arg_ty.is_function() {
                                                          ^16    ^16
 1176|     50|                        actual_arg_ty = self.registry.decay(arg_ty, TypeQualifiers::empty());
 1177|     50|                        self.push_conversion(arg_node_ref, Conversion::PointerDecay { to: actual_arg_ty.ty() });
 1178|     50|                    }
                                  ^16
 1179|     66|                    self.record_implicit_conversions(parameters[i].param_type, actual_arg_ty, arg_node_ref);
 1180|     67|                } else if is_variadic {
 1181|     67|                    let mut actual_arg_ty = arg_ty;
 1182|     67|                    if arg_ty.is_array() || arg_ty.is_function() {
                                                          ^64    ^64
 1183|      3|                        actual_arg_ty = self.registry.decay(arg_ty, TypeQualifiers::empty());
 1184|      3|                        self.push_conversion(arg_node_ref, Conversion::PointerDecay { to: actual_arg_ty.ty() });
 1185|     64|                    }
 1186|       |
 1187|     67|                    let promoted_ty =
 1188|     67|                        crate::semantic::conversions::default_argument_promotions(self.registry, actual_arg_ty);
 1189|       |
 1190|     67|                    if promoted_ty.ty() != actual_arg_ty.ty() {
 1191|     17|                        self.record_implicit_conversions(promoted_ty, actual_arg_ty, arg_node_ref);
 1192|     50|                    }
 1193|      0|                }
 1194|       |            }
 1195|       |        } else {
 1196|       |            // This is not a function or function pointer, report an error.
 1197|      1|            let ty_str = self.registry.display_type(actual_func_ty_ref);
 1198|      1|            let span = self.ast.get_span(call_expr.callee);
 1199|      1|            self.report_error(SemanticError::CalledNonFunctionType { ty: ty_str, span });
 1200|       |
 1201|       |            // Still visit arguments to catch other potential errors within them.
 1202|      1|            for arg_node_ref in call_expr.arg_start.range(call_expr.arg_len) {
                              ^0
 1203|      0|                self.visit_node(arg_node_ref);
 1204|      0|            }
 1205|      1|            return None; // Return None as the call is invalid
 1206|       |        }
 1207|       |
 1208|     81|        match func_kind {
 1209|     81|            TypeKind::Function { return_type, .. } => Some(QualType::unqualified(return_type)),
 1210|      0|            _ => None,
 1211|       |        }
 1212|     82|    }
 1213|       |
 1214|    116|    fn visit_member_access(
 1215|    116|        &mut self,
 1216|    116|        obj_ref: NodeRef,
 1217|    116|        field_name: NameId,
 1218|    116|        is_arrow: bool,
 1219|    116|        span: SourceSpan,
 1220|    116|    ) -> Option<QualType> {
 1221|    116|        let obj_ty = self.visit_node(obj_ref)?;
                                                           ^0
 1222|       |
 1223|    116|        let (record_ty_ref, base_quals) = if is_arrow {
 1224|     14|            let pointee = self.registry.get_pointee(obj_ty.ty())?;
                                                                              ^0
 1225|     14|            (pointee.ty(), pointee.qualifiers())
 1226|       |        } else {
 1227|    102|            (obj_ty.ty(), obj_ty.qualifiers())
 1228|       |        };
 1229|       |
 1230|       |        // Ensure layout is computed for the record type
 1231|    116|        let _ = self.registry.ensure_layout(record_ty_ref);
 1232|       |
 1233|       |        // Recursive helper to find member (handling anonymous structs/unions)
 1234|    140|        fn find_member(registry: &TypeRegistry, record_ty: crate::semantic::TypeRef, name: NameId) -> Option<QualType> {
 1235|    140|            if !record_ty.is_record() {
 1236|      0|                return None;
 1237|    140|            }
 1238|       |
 1239|    140|            if let TypeKind::Record { members, .. } = &registry.get(record_ty).kind {
 1240|       |                // 1. Check direct members
 1241|    233|                if let Some(member) = members.iter().find(|m| m.name == Some(name)) {
                                          ^114      ^140           ^140
 1242|    114|                    return Some(member.member_type);
 1243|     26|                }
 1244|       |
 1245|       |                // 2. Check anonymous members
 1246|     38|                for member in members.iter() {
                                            ^26     ^26
 1247|     38|                    if member.name.is_none() {
 1248|     26|                        let member_ty = member.member_type.ty();
 1249|     26|                        if member_ty.is_record()
 1250|     26|                            && let Some(found_ty) = find_member(registry, member_ty, name)
                                                      ^21
 1251|       |                        {
 1252|       |                            // Note: C11 6.7.2.1p13: "An unnamed member of structure type with no tag is called an anonymous structure;
 1253|       |                            // an unnamed member of union type with no tag is called an anonymous union."
 1254|       |                            // We don't need to merge qualifiers of the anonymous member ITSELF here because
 1255|       |                            // they will be merged with base_quals later.
 1256|     21|                            return Some(found_ty);
 1257|      5|                        }
 1258|     12|                    }
 1259|       |                }
 1260|      0|            }
 1261|      5|            None
 1262|    140|        }
 1263|       |
 1264|    116|        if !record_ty_ref.is_record() {
 1265|      1|            let ty_str = self.registry.get(record_ty_ref).kind.to_string();
 1266|      1|            self.report_error(SemanticError::MemberAccessOnNonRecord { ty: ty_str, span });
 1267|      1|            return None;
 1268|    115|        }
 1269|       |
 1270|       |        // Check if record is complete
 1271|    115|        if let TypeKind::Record { is_complete: false, .. } = &self.registry.get(record_ty_ref).kind {
 1272|      1|            let ty_str = self.registry.get(record_ty_ref).kind.to_string();
 1273|      1|            self.report_error(SemanticError::IncompleteType { ty: ty_str, span });
 1274|      1|            return None;
 1275|    114|        }
 1276|       |
 1277|    114|        if let Some(mut ty) = find_member(self.registry, record_ty_ref, field_name) {
 1278|       |            // C11 6.5.2.3p4: if the first expression has qualified type, the result has the so-qualified
 1279|       |            // version of the type of the designated member.
 1280|    114|            if !base_quals.is_empty() {
 1281|      0|                ty = self.registry.merge_qualifiers(ty, base_quals);
 1282|    114|            }
 1283|    114|            return Some(ty);
 1284|      0|        }
 1285|       |
 1286|      0|        let ty_str = self.registry.get(record_ty_ref).kind.to_string();
 1287|      0|        self.report_error(SemanticError::MemberNotFound {
 1288|      0|            name: field_name,
 1289|      0|            ty: ty_str,
 1290|      0|            span,
 1291|      0|        });
 1292|      0|        None
 1293|    116|    }
 1294|       |
 1295|     38|    fn visit_index_access(&mut self, arr_ref: NodeRef, idx_ref: NodeRef) -> Option<QualType> {
 1296|     38|        self.visit_node(idx_ref);
 1297|     38|        let arr_ty = self.visit_node(arr_ref)?;
                                                           ^0
 1298|       |
 1299|     38|        if arr_ty.is_array() {
 1300|       |            // Ensure layout is computed for array type
 1301|     38|            let _ = self.registry.ensure_layout(arr_ty.ty());
 1302|     38|            let element_type = self.registry.get_array_element(arr_ty.ty()).unwrap();
 1303|     38|            Some(QualType::new(element_type, arr_ty.qualifiers()))
 1304|       |        } else {
 1305|      0|            self.registry.get_pointee(arr_ty.ty())
 1306|       |        }
 1307|     38|    }
 1308|       |
 1309|  1.24k|    fn visit_declaration_node(&mut self, node_ref: NodeRef, kind: &NodeKind) -> Option<QualType> {
 1310|  1.24k|        match kind {
 1311|    323|            NodeKind::TranslationUnit(tu_data) => {
 1312|    571|                for decl_ref in tu_data.decl_start.range(tu_data.decl_len) {
                                              ^323               ^323  ^323
 1313|    571|                    self.visit_node(decl_ref);
 1314|    571|                }
 1315|    323|                None
 1316|       |            }
 1317|    291|            NodeKind::Function(data) => {
 1318|    291|                let func_ty = self.registry.get(data.ty).kind.clone();
 1319|    291|                if let TypeKind::Function { return_type, .. } = func_ty {
 1320|    291|                    self.current_function_ret_type = Some(QualType::unqualified(return_type));
 1321|    291|                    self.current_function_is_noreturn = data.is_noreturn;
 1322|    291|                };
                              ^0
 1323|       |
 1324|    291|                let symbol = self.symbol_table.get_symbol(data.symbol);
 1325|    291|                let prev_func_name = self.current_function_name.take();
 1326|    291|                self.current_function_name = Some(symbol.name.to_string());
 1327|       |
 1328|    291|                for param_ref in data.param_start.range(data.param_len) {
                                  ^51
 1329|     51|                    self.visit_node(param_ref);
 1330|     51|                }
 1331|       |
 1332|    291|                self.visit_node(data.body);
 1333|       |
 1334|    291|                if self.current_function_is_noreturn && self.can_fall_through(data.body) {
                                                                      ^3   ^3               ^3
 1335|      1|                    let span = self.ast.get_span(node_ref);
 1336|      1|                    self.report_error(SemanticError::NoreturnFunctionFallsOff {
 1337|      1|                        name: self.current_function_name.clone().unwrap(),
 1338|      1|                        span,
 1339|      1|                    });
 1340|    290|                }
 1341|       |
 1342|    291|                self.current_function_ret_type = None;
 1343|    291|                self.current_function_name = prev_func_name;
 1344|    291|                self.current_function_is_noreturn = false;
 1345|    291|                None
 1346|       |            }
 1347|     51|            NodeKind::Param(data) => {
 1348|     51|                self.visit_type_expressions(data.ty);
 1349|     51|                Some(data.ty)
 1350|       |            }
 1351|    413|            NodeKind::VarDecl(data) => {
 1352|    413|                if data.ty.ty() == self.registry.type_void {
 1353|      1|                    let span = self.ast.get_span(node_ref);
 1354|      1|                    self.report_error(SemanticError::VariableOfVoidType { span });
 1355|    412|                }
 1356|    413|                self.visit_type_expressions(data.ty);
 1357|    413|                let _ = self.registry.ensure_layout(data.ty.ty());
 1358|    413|                if data.init.is_some()
 1359|    271|                    && matches!(data.storage, Some(StorageClass::Extern))
                                              ^3
 1360|      1|                    && self.current_function_name.is_some()
 1361|      1|                {
 1362|      1|                    let span = self.ast.get_span(node_ref);
 1363|      1|                    self.report_error(SemanticError::InvalidInitializer { span });
 1364|    412|                }
 1365|       |
 1366|    413|                if let Some(init_ref) = data.init {
                                          ^272
 1367|    272|                    self.visit_initializer(init_ref, data.ty);
 1368|    272|                }
                              ^141
 1369|    413|                Some(data.ty)
 1370|       |            }
 1371|      0|            NodeKind::EnumConstant(_, value_expr) => {
 1372|      0|                if let Some(expr) = value_expr {
 1373|      0|                    self.visit_node(*expr);
 1374|      0|                }
 1375|      0|                Some(QualType::unqualified(self.registry.type_int))
 1376|       |            }
 1377|      9|            NodeKind::EnumDecl(data) => {
 1378|     15|                for member_ref in data.member_start.range(data.member_len) {
                                                ^9                ^9    ^9
 1379|     15|                    self.visit_node(member_ref);
 1380|     15|                }
 1381|      9|                None
 1382|       |            }
 1383|     15|            NodeKind::EnumMember(data) => {
 1384|     15|                if let Some(expr) = data.init_expr {
                                          ^7
 1385|      7|                    self.visit_node(expr);
 1386|      8|                }
 1387|     15|                Some(QualType::unqualified(self.registry.type_int))
 1388|       |            }
 1389|     66|            NodeKind::RecordDecl(_) => None,
 1390|      0|            NodeKind::FieldDecl(data) => {
 1391|      0|                self.visit_type_expressions(data.ty);
 1392|      0|                None
 1393|       |            }
 1394|     32|            NodeKind::TypedefDecl(data) => {
 1395|     32|                self.visit_type_expressions(data.ty);
 1396|     32|                None
 1397|       |            }
 1398|     40|            NodeKind::FunctionDecl(data) => {
 1399|     40|                self.visit_type_expressions(QualType::unqualified(data.ty));
 1400|     40|                let func_type = self.registry.get(data.ty).kind.clone();
 1401|       |                if let TypeKind::Function {
 1402|     40|                    return_type,
 1403|     40|                    parameters,
 1404|       |                    ..
 1405|     40|                } = func_type
 1406|       |                {
 1407|     40|                    if !self.registry.is_complete(return_type) && return_type != self.registry.type_void {
                                                                                ^5
 1408|      2|                        let span = self.ast.get_span(node_ref);
 1409|      2|                        self.report_error(SemanticError::IncompleteReturnType { span });
 1410|     38|                    }
 1411|       |
 1412|     40|                    for param in parameters.iter() {
                                      ^37
 1413|     37|                        let _ = self.registry.ensure_layout(param.param_type.ty());
 1414|     37|                    }
 1415|      0|                }
 1416|     40|                None
 1417|       |            }
 1418|      0|            _ => None,
 1419|       |        }
 1420|  1.24k|    }
 1421|       |
 1422|    928|    fn visit_statement_node(&mut self, node_ref: NodeRef, kind: &NodeKind) -> Option<QualType> {
 1423|       |        // let node = self.ast.get_node(node_ref); // For span access if needed
 1424|    928|        match kind {
 1425|    316|            NodeKind::CompoundStatement(cs) => {
 1426|    822|                for item_ref in cs.stmt_start.range(cs.stmt_len) {
                                              ^316          ^316  ^316
 1427|    822|                    self.visit_node(item_ref);
 1428|    822|                }
 1429|    316|                self.process_deferred_checks();
 1430|    316|                None
 1431|       |            }
 1432|       |
 1433|     63|            NodeKind::If(stmt) => {
 1434|     63|                self.visit_if_statement(stmt);
 1435|     63|                None
 1436|       |            }
 1437|      3|            NodeKind::While(stmt) => {
 1438|      3|                self.visit_while_statement(stmt);
 1439|      3|                None
 1440|       |            }
 1441|      4|            NodeKind::For(stmt) => {
 1442|      4|                self.visit_for_statement(stmt);
 1443|      4|                None
 1444|       |            }
 1445|      3|            NodeKind::DoWhile(body, condition) => {
 1446|      3|                self.loop_depth += 1;
 1447|      3|                self.visit_node(*body);
 1448|      3|                self.loop_depth -= 1;
 1449|      3|                self.visit_node(*condition);
 1450|      3|                None
 1451|       |            }
 1452|      2|            NodeKind::Switch(cond, body) => {
 1453|      2|                self.visit_node(*cond);
 1454|      2|                self.switch_depth += 1;
 1455|      2|                self.switch_cases.push(HashSet::new());
 1456|      2|                self.switch_default_seen.push(false);
 1457|      2|                self.visit_node(*body);
 1458|      2|                self.switch_default_seen.pop();
 1459|      2|                self.switch_cases.pop();
 1460|      2|                self.switch_depth -= 1;
 1461|      2|                None
 1462|       |            }
 1463|      5|            NodeKind::Case(expr, stmt) => {
 1464|      5|                if self.switch_depth == 0 {
 1465|      1|                    let span = self.ast.get_span(node_ref);
 1466|      1|                    self.report_error(SemanticError::CaseNotInSwitch { span });
 1467|      4|                } else if let Some(val) = crate::semantic::const_eval::eval_const_expr(&self.const_ctx(), *expr) {
 1468|      4|                    let is_duplicate = self.switch_cases.last_mut().is_some_and(|cases| !cases.insert(val));
 1469|      4|                    if is_duplicate {
 1470|      1|                        let span = self.ast.get_span(node_ref);
 1471|      1|                        self.report_error(SemanticError::DuplicateCase {
 1472|      1|                            value: val.to_string(),
 1473|      1|                            span,
 1474|      1|                        });
 1475|      3|                    }
 1476|      0|                }
 1477|      5|                self.visit_node(*expr);
 1478|      5|                self.visit_node(*stmt);
 1479|      5|                None
 1480|       |            }
 1481|      0|            NodeKind::CaseRange(start, end, stmt) => {
 1482|      0|                if self.switch_depth == 0 {
 1483|      0|                    let span = self.ast.get_span(node_ref);
 1484|      0|                    self.report_error(SemanticError::CaseNotInSwitch { span });
 1485|      0|                } else if let (Some(start_val), Some(end_val)) = (
 1486|      0|                    crate::semantic::const_eval::eval_const_expr(&self.const_ctx(), *start),
 1487|      0|                    crate::semantic::const_eval::eval_const_expr(&self.const_ctx(), *end),
 1488|       |                ) {
 1489|      0|                    let mut duplicate_val = None;
 1490|      0|                    if let Some(cases) = self.switch_cases.last_mut() {
 1491|      0|                        for val in start_val..=end_val {
 1492|      0|                            if !cases.insert(val) {
 1493|      0|                                duplicate_val = Some(val);
 1494|      0|                                break;
 1495|      0|                            }
 1496|       |                        }
 1497|      0|                    }
 1498|      0|                    if let Some(val) = duplicate_val {
 1499|      0|                        let span = self.ast.get_span(node_ref);
 1500|      0|                        self.report_error(SemanticError::DuplicateCase {
 1501|      0|                            value: val.to_string(),
 1502|      0|                            span,
 1503|      0|                        });
 1504|      0|                    }
 1505|      0|                }
 1506|      0|                self.visit_node(*start);
 1507|      0|                self.visit_node(*end);
 1508|      0|                self.visit_node(*stmt);
 1509|      0|                None
 1510|       |            }
 1511|      1|            NodeKind::Default(stmt) => {
 1512|      1|                if self.switch_depth == 0 {
 1513|      0|                    let span = self.ast.get_span(node_ref);
 1514|      0|                    self.report_error(SemanticError::CaseNotInSwitch { span });
 1515|      0|                } else {
 1516|      1|                    let is_duplicate = self
 1517|      1|                        .switch_default_seen
 1518|      1|                        .last_mut()
 1519|      1|                        .is_some_and(|seen| std::mem::replace(seen, true));
 1520|      1|                    if is_duplicate {
 1521|      0|                        let span = self.ast.get_span(node_ref);
 1522|      0|                        self.report_error(SemanticError::MultipleDefaultLabels { span });
 1523|      1|                    }
 1524|       |                }
 1525|      1|                self.visit_node(*stmt);
 1526|      1|                None
 1527|       |            }
 1528|    264|            NodeKind::Return(expr) => {
 1529|    264|                let span = self.ast.get_span(node_ref);
 1530|    264|                self.visit_return_statement(expr, span);
 1531|    264|                None
 1532|       |            }
 1533|    208|            NodeKind::ExpressionStatement(expr) => {
 1534|    208|                if let Some(expr_ref) = expr {
 1535|    208|                    self.visit_node(*expr_ref);
 1536|    208|                }
                              ^0
 1537|    208|                None
 1538|       |            }
 1539|       |            NodeKind::StaticAssert(..) => {
 1540|     38|                self.deferred_checks.push(DeferredCheck::StaticAssert(node_ref));
 1541|     38|                None
 1542|       |            }
 1543|       |            NodeKind::Break => {
 1544|      7|                if self.loop_depth == 0 && self.switch_depth == 0 {
 1545|      2|                    let span = self.ast.get_span(node_ref);
 1546|      2|                    self.report_error(SemanticError::BreakNotInLoop { span });
 1547|      5|                }
 1548|      7|                None
 1549|       |            }
 1550|       |            NodeKind::Continue => {
 1551|      1|                if self.loop_depth == 0 {
 1552|      1|                    let span = self.ast.get_span(node_ref);
 1553|      1|                    self.report_error(SemanticError::ContinueNotInLoop { span });
 1554|      1|                }
                              ^0
 1555|      1|                None
 1556|       |            }
 1557|      5|            NodeKind::Goto(_, _) => None,
 1558|      8|            NodeKind::Label(_, stmt, _) => {
 1559|      8|                self.visit_node(*stmt);
 1560|      8|                None
 1561|       |            }
 1562|      0|            _ => None,
 1563|       |        }
 1564|    928|    }
 1565|       |
 1566|  2.54k|    fn visit_expression_node(&mut self, node_ref: NodeRef, kind: &NodeKind) -> Option<QualType> {
 1567|  2.54k|        match kind {
 1568|    945|            NodeKind::Literal(literal) => self.visit_literal(literal),
 1569|    613|            NodeKind::Ident(_, symbol_ref) => {
 1570|    613|                let symbol = self.symbol_table.get_symbol(*symbol_ref);
 1571|    613|                match &symbol.kind {
 1572|      7|                    SymbolKind::EnumConstant { .. } => Some(QualType::unqualified(self.registry.type_int)),
 1573|    606|                    _ => Some(symbol.type_info),
 1574|       |                }
 1575|       |            }
 1576|     99|            NodeKind::UnaryOp(op, operand) => {
 1577|     99|                let span = self.ast.get_span(node_ref);
 1578|     99|                self.visit_unary_op(*op, *operand, span)
 1579|       |            }
 1580|    203|            NodeKind::BinaryOp(op, lhs, rhs) => {
 1581|    203|                let span = self.ast.get_span(node_ref);
 1582|    203|                self.visit_binary_op(*op, *lhs, *rhs, span)
 1583|       |            }
 1584|      7|            NodeKind::TernaryOp(cond, then, else_expr) => {
 1585|      7|                self.visit_node(*cond);
 1586|      7|                let then_ty = self.visit_node(*then);
 1587|      7|                let else_ty = self.visit_node(*else_expr);
 1588|       |
 1589|      7|                if let (Some(t), Some(e)) = (then_ty, else_ty) {
 1590|      7|                    let result_ty = match (t, e) {
 1591|      7|                        (t, e) if t.is_arithmetic() && e.is_arithmetic() => {
                                       ^2 ^2                         ^5^5
 1592|      2|                            usual_arithmetic_conversions(self.registry, t, e)
 1593|       |                        }
 1594|      5|                        (t, e) if t.ty() == e.ty() => Some(t),
                                       ^0 ^0                        ^0
 1595|      5|                        (t, _) if t.ty() == self.registry.type_void => Some(t),
                                       ^0                                            ^0
 1596|      5|                        (_, e) if e.ty() == self.registry.type_void => Some(e),
                                          ^1                                         ^1
 1597|      4|                        (t, _) if t.is_pointer() && self.is_null_pointer_constant(*else_expr) => Some(t),
                                       ^2                         ^2   ^2                       ^2             ^2
 1598|      2|                        (_, e) if e.is_pointer() && self.is_null_pointer_constant(*then) => Some(e),
 1599|      0|                        (t, e) if t.is_pointer() && e.is_pointer() => {
 1600|       |                            // C11 6.5.15: pointer to void and pointer to object -> pointer to void
 1601|      0|                            if t.ty() == self.registry.type_void_ptr || e.ty() == self.registry.type_void_ptr {
 1602|      0|                                Some(QualType::unqualified(self.registry.type_void_ptr))
 1603|       |                            } else {
 1604|       |                                // Should check compatibility, for now just use one or common
 1605|      0|                                Some(t)
 1606|       |                            }
 1607|       |                        }
 1608|      0|                        _ => usual_arithmetic_conversions(self.registry, t, e),
 1609|       |                    };
 1610|       |
 1611|      7|                    if let Some(res) = result_ty {
 1612|       |                        // Don't record conversions for void types
 1613|      7|                        if !res.is_void() {
 1614|      6|                            self.record_implicit_conversions(res, t, *then);
 1615|      6|                            self.record_implicit_conversions(res, e, *else_expr);
 1616|      6|                        }
                                      ^1
 1617|      7|                        return Some(res);
 1618|      0|                    }
 1619|      0|                    None
 1620|       |                } else {
 1621|      0|                    None
 1622|       |                }
 1623|       |            }
 1624|      2|            NodeKind::GnuStatementExpression(stmt, result_expr) => {
 1625|      2|                self.visit_node(*stmt);
 1626|       |
 1627|      2|                if let NodeKind::Dummy = self.ast.get_kind(*result_expr) {
 1628|      1|                    Some(QualType::unqualified(self.registry.type_void))
 1629|       |                } else {
 1630|      1|                    self.visit_node(*result_expr)
 1631|       |                }
 1632|       |            }
 1633|     11|            NodeKind::PostIncrement(expr) | NodeKind::PostDecrement(expr) => {
                                                                                  ^5
 1634|     16|                let ty = self.visit_node(*expr);
 1635|     16|                if self.check_lvalue_and_modifiable(*expr, ty.unwrap(), self.ast.get_span(node_ref)) {
 1636|     13|                    // ok
 1637|     13|                }
                              ^3
 1638|     16|                ty
 1639|       |            }
 1640|    112|            NodeKind::Assignment(op, lhs, rhs) => {
 1641|    112|                let span = self.ast.get_span(node_ref);
 1642|    112|                self.visit_assignment(node_ref, *op, *lhs, *rhs, span)
 1643|       |            }
 1644|     82|            NodeKind::FunctionCall(call_expr) => self.visit_function_call(call_expr),
 1645|    116|            NodeKind::MemberAccess(obj, field_name, is_arrow) => {
 1646|    116|                let span = self.ast.get_span(node_ref);
 1647|    116|                self.visit_member_access(*obj, *field_name, *is_arrow, span)
 1648|       |            }
 1649|     38|            NodeKind::IndexAccess(arr, idx) => self.visit_index_access(*arr, *idx),
 1650|     20|            NodeKind::Cast(ty, expr) => {
 1651|     20|                self.visit_type_expressions(*ty);
 1652|     20|                self.visit_node(*expr);
 1653|     20|                Some(*ty)
 1654|       |            }
 1655|     33|            NodeKind::SizeOfExpr(expr) => {
 1656|     33|                if let Some(ty) = self.visit_node(*expr) {
 1657|     33|                    let type_ref = ty.ty();
 1658|     33|                    if ty.is_function() {
 1659|      1|                        let span = self.ast.get_span(node_ref);
 1660|      1|                        self.report_error(SemanticError::SizeOfFunctionType { span });
 1661|     32|                    } else if !self.registry.is_complete(type_ref) {
 1662|      1|                        let span = self.ast.get_span(node_ref);
 1663|      1|                        self.report_error(SemanticError::SizeOfIncompleteType { ty: type_ref, span });
 1664|     31|                    } else if self.is_bitfield(*expr) {
 1665|      2|                        let span = self.ast.get_span(node_ref);
 1666|      2|                        self.report_error(SemanticError::SizeOfBitfield { span });
 1667|     29|                    } else {
 1668|     29|                        let _ = self.registry.ensure_layout(type_ref);
 1669|     29|                    }
 1670|      0|                }
 1671|     33|                Some(QualType::unqualified(self.registry.type_long_unsigned))
 1672|       |            }
 1673|     18|            NodeKind::SizeOfType(ty) => {
 1674|     18|                self.visit_type_expressions(*ty);
 1675|     18|                let type_ref = ty.ty();
 1676|     18|                if ty.is_function() {
 1677|      1|                    let span = self.ast.get_span(node_ref);
 1678|      1|                    self.report_error(SemanticError::SizeOfFunctionType { span });
 1679|     17|                } else if !self.registry.is_complete(type_ref) {
 1680|      2|                    let span = self.ast.get_span(node_ref);
 1681|      2|                    self.report_error(SemanticError::SizeOfIncompleteType { ty: type_ref, span });
 1682|     15|                } else {
 1683|     15|                    let _ = self.registry.ensure_layout(type_ref);
 1684|     15|                }
 1685|     18|                Some(QualType::unqualified(self.registry.type_long_unsigned))
 1686|       |            }
 1687|      5|            NodeKind::AlignOf(ty) => {
 1688|      5|                self.visit_type_expressions(*ty);
 1689|      5|                let type_ref = ty.ty();
 1690|      5|                if ty.is_function() {
 1691|      1|                    let span = self.ast.get_span(node_ref);
 1692|      1|                    self.report_error(SemanticError::AlignOfFunctionType { span });
 1693|      4|                } else if !self.registry.is_complete(type_ref) {
 1694|      2|                    let span = self.ast.get_span(node_ref);
 1695|      2|                    self.report_error(SemanticError::AlignOfIncompleteType { ty: type_ref, span });
 1696|      2|                } else {
 1697|      2|                    let _ = self.registry.ensure_layout(type_ref);
 1698|      2|                }
 1699|      5|                Some(QualType::unqualified(self.registry.type_long_unsigned))
 1700|       |            }
 1701|      8|            NodeKind::CompoundLiteral(ty, init) => {
 1702|      8|                self.visit_type_expressions(*ty);
 1703|      8|                let _ = self.registry.ensure_layout(ty.ty());
 1704|      8|                self.visit_initializer(*init, *ty);
 1705|      8|                Some(*ty)
 1706|       |            }
 1707|     48|            NodeKind::GenericSelection(gs) => self.visit_generic_selection(gs, node_ref),
 1708|     97|            NodeKind::GenericAssociation(ga) => {
 1709|     97|                if let Some(ty) = ga.ty {
                                          ^57
 1710|     57|                    self.visit_type_expressions(ty);
 1711|     57|                }
                              ^40
 1712|     97|                self.visit_node(ga.result_expr)
 1713|       |            }
 1714|     14|            NodeKind::InitializerList(list) => {
 1715|     32|                for item_ref in list.init_start.range(list.init_len) {
                                              ^14             ^14   ^14
 1716|     32|                    self.visit_node(item_ref);
 1717|     32|                }
 1718|     14|                None
 1719|       |            }
 1720|     32|            NodeKind::InitializerItem(init) => {
 1721|     32|                for designator_ref in init.designator_start.range(init.designator_len) {
                                  ^6
 1722|      6|                    if let NodeKind::Designator(d) = self.ast.get_kind(designator_ref) {
 1723|      6|                        match d {
 1724|      4|                            Designator::ArrayIndex(expr_ref) => {
 1725|      4|                                self.visit_node(*expr_ref);
 1726|      4|                            }
 1727|      0|                            Designator::GnuArrayRange(start_ref, end_ref) => {
 1728|      0|                                self.visit_node(*start_ref);
 1729|      0|                                self.visit_node(*end_ref);
 1730|      0|                            }
 1731|      2|                            Designator::FieldName(_) => {}
 1732|       |                        }
 1733|      0|                    }
 1734|       |                }
 1735|     32|                self.visit_node(init.initializer);
 1736|     32|                None
 1737|       |            }
 1738|      7|            NodeKind::BuiltinVaArg(ty, expr) => {
 1739|      7|                self.visit_type_expressions(*ty);
 1740|      7|                self.visit_node(*expr);
 1741|      7|                Some(*ty)
 1742|       |            }
 1743|      4|            NodeKind::BuiltinVaStart(ap, last) => {
 1744|      4|                self.visit_node(*ap);
 1745|      4|                self.visit_node(*last);
 1746|      4|                Some(QualType::unqualified(self.registry.type_void))
 1747|       |            }
 1748|      2|            NodeKind::BuiltinVaEnd(ap) => {
 1749|      2|                self.visit_node(*ap);
 1750|      2|                Some(QualType::unqualified(self.registry.type_void))
 1751|       |            }
 1752|      0|            NodeKind::BuiltinVaCopy(dst, src) => {
 1753|      0|                self.visit_node(*dst);
 1754|      0|                self.visit_node(*src);
 1755|      0|                Some(QualType::unqualified(self.registry.type_void))
 1756|       |            }
 1757|      3|            NodeKind::BuiltinExpect(exp, c) => {
 1758|      3|                let ty = self.visit_node(*exp);
 1759|      3|                self.visit_node(*c);
 1760|      3|                ty
 1761|       |            }
 1762|     10|            NodeKind::BuiltinOffsetof(ty, expr) => self.visit_builtin_offsetof(*ty, *expr, node_ref),
 1763|     13|            NodeKind::AtomicOp(op, args_start, args_len) => {
 1764|     13|                let span = self.ast.get_span(node_ref);
 1765|     13|                self.visit_atomic_op(*op, *args_start, *args_len, span)
 1766|       |            }
 1767|      1|            _ => None,
 1768|       |        }
 1769|  2.54k|    }
 1770|       |
 1771|     13|    fn visit_atomic_op(
 1772|     13|        &mut self,
 1773|     13|        op: AtomicOp,
 1774|     13|        args_start: NodeRef,
 1775|     13|        args_len: u16,
 1776|     13|        span: SourceSpan,
 1777|     13|    ) -> Option<QualType> {
 1778|       |        // Bolt : Optimized argument processing by using SmallVec and a single pass.
 1779|       |        // This avoids three Vec allocations and multiple iterations over the arguments.
 1780|       |        // Atomic operations have at most 6 arguments (CompareExchangeN).
 1781|     13|        let mut args = SmallVec::<[NodeRef; 6]>::new();
 1782|     13|        let mut arg_tys = SmallVec::<[QualType; 6]>::new();
 1783|     13|        let mut has_error = false;
 1784|       |
 1785|     42|        for arg_ref in args_start.range(args_len) {
                                     ^13        ^13   ^13
 1786|     42|            args.push(arg_ref);
 1787|     42|            if let Some(ty) = self.visit_node(arg_ref) {
 1788|     42|                arg_tys.push(ty);
 1789|     42|            } else {
 1790|      0|                has_error = true;
 1791|      0|            }
 1792|       |        }
 1793|       |
 1794|     13|        if has_error {
 1795|      0|            return None;
 1796|     13|        }
 1797|       |
 1798|     13|        let expected_args = match op {
 1799|      3|            AtomicOp::LoadN => 2,
 1800|      2|            AtomicOp::CompareExchangeN => 6,
 1801|      8|            _ => 3,
 1802|       |        };
 1803|       |
 1804|     13|        if args.len() != expected_args {
 1805|      0|            self.report_error(SemanticError::InvalidNumberOfArguments {
 1806|      0|                expected: expected_args,
 1807|      0|                found: args.len(),
 1808|      0|                span,
 1809|      0|            });
 1810|      0|            return None;
 1811|     13|        }
 1812|       |
 1813|       |        // Validate memory order arguments
 1814|     13|        let memorder_indices: SmallVec<[usize; 2]> = match op {
 1815|      3|            AtomicOp::LoadN => smallvec![1],
 1816|      2|            AtomicOp::CompareExchangeN => smallvec![4, 5],
 1817|      8|            _ => smallvec![2],
 1818|       |        };
 1819|       |
 1820|     28|        for &idx in &memorder_indices {
                           ^15
 1821|     15|            if !arg_tys[idx].is_integer() {
 1822|      1|                let ty_str = self.registry.display_qual_type(arg_tys[idx]);
 1823|      1|                self.report_error(SemanticError::InvalidAtomicArgument {
 1824|      1|                    ty: ty_str,
 1825|      1|                    span: self.ast.get_span(args[idx]),
 1826|      1|                });
 1827|     14|            }
 1828|       |        }
 1829|       |
 1830|       |        // Validate pointer argument (always index 0)
 1831|     13|        let pointee = if let Some(pointee) = self.registry.get_pointee(arg_tys[0].ty()) {
                          ^12                   ^12
 1832|     12|            pointee
 1833|       |        } else {
 1834|      1|            let ty_str = self.registry.display_qual_type(arg_tys[0]);
 1835|      1|            self.report_error(SemanticError::InvalidAtomicArgument {
 1836|      1|                ty: ty_str,
 1837|      1|                span: self.ast.get_span(args[0]),
 1838|      1|            });
 1839|      1|            return None; // Cannot proceed without valid pointer
 1840|       |        };
 1841|       |
 1842|     12|        match op {
 1843|      2|            AtomicOp::LoadN => Some(pointee),
 1844|       |            AtomicOp::StoreN => {
 1845|      1|                if !self.check_assignment_constraints(pointee, arg_tys[1], args[1]) {
 1846|      0|                    let ty_str = self.registry.display_qual_type(arg_tys[1]);
 1847|      0|                    self.report_error(SemanticError::InvalidAtomicArgument {
 1848|      0|                        ty: ty_str,
 1849|      0|                        span: self.ast.get_span(args[1]),
 1850|      0|                    });
 1851|      1|                } else {
 1852|      1|                    self.record_implicit_conversions(pointee, arg_tys[1], args[1]);
 1853|      1|                }
 1854|      1|                Some(QualType::unqualified(self.registry.type_void))
 1855|       |            }
 1856|       |            AtomicOp::ExchangeN => {
 1857|      1|                self.record_implicit_conversions(pointee, arg_tys[1], args[1]);
 1858|      1|                Some(pointee)
 1859|       |            }
 1860|       |            AtomicOp::CompareExchangeN => {
 1861|      2|                let expected_ptr_ty = arg_tys[1];
 1862|      2|                let desired_ty = arg_tys[2];
 1863|       |
 1864|      2|                if let Some(expected_pointee) = self.registry.get_pointee(expected_ptr_ty.ty()) {
 1865|      2|                    if !self
 1866|      2|                        .registry
 1867|      2|                        .is_compatible(QualType::unqualified(pointee.ty()), expected_pointee)
 1868|      0|                    {
 1869|      0|                        let expected_str = self.registry.display_qual_type(expected_pointee);
 1870|      0|                        self.report_error(SemanticError::InvalidAtomicArgument {
 1871|      0|                            ty: expected_str,
 1872|      0|                            span: self.ast.get_span(args[1]),
 1873|      0|                        });
 1874|      2|                    }
 1875|      0|                } else {
 1876|      0|                    let ty_str = self.registry.display_qual_type(expected_ptr_ty);
 1877|      0|                    self.report_error(SemanticError::InvalidAtomicArgument {
 1878|      0|                        ty: ty_str,
 1879|      0|                        span: self.ast.get_span(args[1]),
 1880|      0|                    });
 1881|      0|                }
 1882|      2|                self.record_implicit_conversions(pointee, desired_ty, args[2]);
 1883|      2|                Some(QualType::unqualified(self.registry.type_bool))
 1884|       |            }
 1885|       |            AtomicOp::FetchAdd | AtomicOp::FetchSub | AtomicOp::FetchAnd | AtomicOp::FetchOr | AtomicOp::FetchXor => {
 1886|      6|                if matches!(op, AtomicOp::FetchAnd | AtomicOp::FetchOr | AtomicOp::FetchXor) && !pointee.is_integer() {
                                 ^2                                                                           ^4
 1887|      1|                    let ty_str = self.registry.display_qual_type(pointee);
 1888|      1|                    self.report_error(SemanticError::InvalidAtomicArgument {
 1889|      1|                        ty: ty_str,
 1890|      1|                        span: self.ast.get_span(args[0]),
 1891|      1|                    });
 1892|      5|                }
 1893|       |
 1894|      6|                if pointee.is_integer() {
 1895|      5|                    self.record_implicit_conversions(pointee, arg_tys[1], args[1]);
 1896|      5|                }
                              ^1
 1897|      6|                Some(pointee)
 1898|       |            }
 1899|       |        }
 1900|     13|    }
 1901|       |
 1902|    945|    fn visit_literal(&mut self, literal: &literal::Literal) -> Option<QualType> {
 1903|    945|        match literal {
 1904|    833|            literal::Literal::Int { val, suffix } => {
 1905|    833|                let ty = match suffix {
                                             ^7
 1906|      1|                    Some(literal::IntegerSuffix::L) => self.registry.type_long,
 1907|      4|                    Some(literal::IntegerSuffix::LL) => self.registry.type_long_long,
 1908|      0|                    Some(literal::IntegerSuffix::U) => self.registry.type_int_unsigned,
 1909|      1|                    Some(literal::IntegerSuffix::UL) => self.registry.type_long_unsigned,
 1910|      1|                    Some(literal::IntegerSuffix::ULL) => self.registry.type_long_long_unsigned,
 1911|       |                    None => {
 1912|    826|                        let _ = self.registry.ensure_layout(self.registry.type_int);
 1913|    826|                        let _ = self.registry.ensure_layout(self.registry.type_long);
 1914|       |
 1915|    826|                        let int_layout = self.registry.get_layout(self.registry.type_int);
 1916|    826|                        let int_max = if int_layout.size >= 8 {
 1917|      0|                            i64::MAX
 1918|       |                        } else {
 1919|    826|                            (1i64 << (int_layout.size * 8 - 1)) - 1
 1920|       |                        };
 1921|       |
 1922|    826|                        let long_layout = self.registry.get_layout(self.registry.type_long);
 1923|    826|                        let long_max = if long_layout.size >= 8 {
 1924|    826|                            i64::MAX
 1925|       |                        } else {
 1926|      0|                            (1i64 << (long_layout.size * 8 - 1)) - 1
 1927|       |                        };
 1928|       |
 1929|    826|                        if *val >= 0 && *val <= int_max {
 1930|    820|                            self.registry.type_int
 1931|      6|                        } else if *val >= 0 && *val <= long_max {
 1932|      6|                            self.registry.type_long
 1933|       |                        } else {
 1934|      0|                            self.registry.type_long_long
 1935|       |                        }
 1936|       |                    }
 1937|       |                };
 1938|    833|                Some(QualType::unqualified(ty))
 1939|       |            }
 1940|     30|            literal::Literal::Float { suffix, .. } => {
 1941|     30|                let ty = match suffix {
                                             ^8
 1942|      5|                    Some(literal::FloatSuffix::F) => self.registry.type_float,
 1943|      3|                    Some(literal::FloatSuffix::L) => self.registry.type_long_double,
 1944|     22|                    None => self.registry.type_double,
 1945|       |                };
 1946|     30|                Some(QualType::unqualified(ty))
 1947|       |            }
 1948|     11|            literal::Literal::Char(_) => Some(QualType::unqualified(self.registry.type_int)),
 1949|     71|            literal::Literal::String(name) => {
 1950|     71|                let parsed = crate::semantic::literal_utils::parse_string_literal(*name);
 1951|     71|                let element_type = match parsed.builtin_type {
 1952|     65|                    BuiltinType::Char => self.registry.type_char,
 1953|      2|                    BuiltinType::Int => self.registry.type_int,
 1954|      2|                    BuiltinType::UShort => self.registry.type_short_unsigned,
 1955|      2|                    BuiltinType::UInt => self.registry.type_int_unsigned,
 1956|      0|                    _ => self.registry.type_char,
 1957|       |                };
 1958|       |
 1959|     71|                let array_type = self
 1960|     71|                    .registry
 1961|     71|                    .array_of(element_type, ArraySizeType::Constant(parsed.size));
 1962|     71|                let _ = self.registry.ensure_layout(array_type);
 1963|     71|                Some(QualType::new(array_type, TypeQualifiers::empty()))
 1964|       |            }
 1965|       |        }
 1966|    945|    }
 1967|  4.71k|    fn visit_node(&mut self, node_ref: NodeRef) -> Option<QualType> {
 1968|  4.71k|        let node_kind = self.ast.get_kind(node_ref);
 1969|  4.71k|        let result_type = match node_kind {
 1970|       |            // Declarations
 1971|       |            NodeKind::TranslationUnit(_)
 1972|       |            | NodeKind::Function(_)
 1973|       |            | NodeKind::VarDecl(_)
 1974|       |            | NodeKind::RecordDecl(_)
 1975|       |            | NodeKind::FieldDecl(_)
 1976|       |            | NodeKind::EnumDecl(_)
 1977|       |            | NodeKind::EnumMember(_)
 1978|       |            | NodeKind::TypedefDecl(_)
 1979|       |            | NodeKind::EnumConstant(..)
 1980|       |            | NodeKind::Param(_)
 1981|  1.24k|            | NodeKind::FunctionDecl(_) => self.visit_declaration_node(node_ref, node_kind),
 1982|       |
 1983|       |            // Statements
 1984|       |            NodeKind::CompoundStatement(_)
 1985|       |            | NodeKind::If(_)
 1986|       |            | NodeKind::While(_)
 1987|       |            | NodeKind::DoWhile(..)
 1988|       |            | NodeKind::For(_)
 1989|       |            | NodeKind::Return(_)
 1990|       |            | NodeKind::ExpressionStatement(_)
 1991|       |            | NodeKind::StaticAssert(..)
 1992|       |            | NodeKind::Switch(..)
 1993|       |            | NodeKind::Case(..)
 1994|       |            | NodeKind::CaseRange(..)
 1995|       |            | NodeKind::Default(_)
 1996|       |            | NodeKind::Break
 1997|       |            | NodeKind::Continue
 1998|       |            | NodeKind::Goto(..)
 1999|    928|            | NodeKind::Label(..) => self.visit_statement_node(node_ref, node_kind),
 2000|       |
 2001|       |            // Expressions (Catch-all)
 2002|  2.54k|            _ => self.visit_expression_node(node_ref, node_kind),
 2003|       |        };
 2004|       |
 2005|  4.71k|        if let Some(ty) = result_type {
                                  ^2.94k
 2006|       |            // set resolved type and value category for this node
 2007|  2.94k|            let idx = node_ref.index();
 2008|  2.94k|            self.semantic_info.types[idx] = Some(ty);
 2009|  2.94k|            let vc = if self.is_lvalue(node_ref) {
 2010|    849|                ValueCategory::LValue
 2011|       |            } else {
 2012|  2.09k|                ValueCategory::RValue
 2013|       |            };
 2014|  2.94k|            self.semantic_info.value_categories[idx] = vc;
 2015|  1.77k|        }
 2016|  4.71k|        result_type
 2017|  4.71k|    }
 2018|       |
 2019|    639|    fn process_deferred_checks(&mut self) {
 2020|    639|        if self.deferred_checks.is_empty() {
 2021|    627|            return;
 2022|     12|        }
 2023|       |
 2024|       |        // Bolt : Use std::mem::take and iterate to avoid heap allocation and copy from collect()
 2025|     12|        let checks = std::mem::take(&mut self.deferred_checks);
 2026|     50|        for check in checks {
                          ^38
 2027|     38|            match check {
 2028|     38|                DeferredCheck::StaticAssert(node_ref) => self.visit_static_assert(node_ref),
 2029|       |            }
 2030|       |        }
 2031|    639|    }
 2032|       |
 2033|     38|    fn visit_static_assert(&mut self, node_ref: NodeRef) {
 2034|     38|        let NodeKind::StaticAssert(cond, msg_ref) = *self.ast.get_kind(node_ref) else {
 2035|      0|            return;
 2036|       |        };
 2037|       |
 2038|     38|        self.visit_node(cond);
 2039|       |
 2040|     38|        match crate::semantic::const_eval::eval_const_expr(&self.const_ctx(), cond) {
 2041|       |            Some(0) => {
 2042|      3|                let message = match self.ast.get_kind(msg_ref) {
 2043|      3|                    NodeKind::Literal(literal::Literal::String(s)) => s.as_str().to_string(),
 2044|      0|                    _ => String::new(),
 2045|       |                };
 2046|       |
 2047|      3|                self.report_error(SemanticError::StaticAssertFailed {
 2048|      3|                    message,
 2049|      3|                    span: self.ast.get_span(node_ref),
 2050|      3|                });
 2051|       |            }
 2052|      1|            None => self.report_error(SemanticError::StaticAssertNotConstant {
 2053|      1|                span: self.ast.get_span(node_ref),
 2054|      1|            }),
 2055|     34|            _ => {}
 2056|       |        }
 2057|     38|    }
 2058|       |
 2059|     48|    fn visit_generic_selection(&mut self, gs: &GenericSelectionData, node_ref: NodeRef) -> Option<QualType> {
 2060|       |        // First, visit the controlling expression to determine its type.
 2061|     48|        let ctrl_ty = self.visit_node(gs.control)?;
                                                               ^0
 2062|       |
 2063|       |        // C11 6.5.1.1p3: The controlling expression of a generic selection is not evaluated.
 2064|       |        // C11 6.5.1.1p2: The type of the controlling expression is compared with the type name of each generic
 2065|       |        // association. Before comparison, array and function types decay to pointers.
 2066|     48|        let decayed_ctrl_ty = if ctrl_ty.is_array() || ctrl_ty.is_function() {
                                                                     ^46     ^46
 2067|       |            // Qualifiers on the array/function type itself are discarded during decay.
 2068|      4|            self.registry.decay(ctrl_ty, TypeQualifiers::empty())
 2069|       |        } else {
 2070|     44|            ctrl_ty
 2071|       |        };
 2072|       |
 2073|       |        // After decay, top-level qualifiers are removed for the compatibility check.
 2074|     48|        let unqualified_ctrl_ty = self.registry.strip_all(decayed_ctrl_ty);
 2075|       |
 2076|       |        // C11 6.5.1.1p2: The controlling expression... shall have a type that is a complete object type,
 2077|       |        // or a pointer to a function type, or a pointer to a complete object type...
 2078|     48|        if !self.registry.is_complete(decayed_ctrl_ty.ty()) {
 2079|      2|            self.report_error(SemanticError::GenericIncompleteControl {
 2080|      2|                ty: self.registry.display_qual_type(ctrl_ty),
 2081|      2|                span: self.ast.get_span(gs.control),
 2082|      2|            });
 2083|     46|        }
 2084|       |
 2085|       |        // It's crucial to visit *all* result expressions to ensure they are
 2086|       |        // fully type-checked, even if they are not the selected branch.
 2087|       |        // This resolves all identifier types within them.
 2088|     48|        let mut selected_expr_ref = None;
 2089|     48|        let mut default_expr_ref = None;
 2090|     48|        let mut default_first_span = None;
 2091|       |        // Bolt : Use SmallVec to avoid heap allocation for small generic selection lists.
 2092|     48|        let mut seen_types: SmallVec<[(QualType, SourceSpan); 8]> = SmallVec::new();
 2093|       |
 2094|     97|        for assoc_node_ref in gs.assoc_start.range(gs.assoc_len) {
                                            ^48            ^48   ^48
 2095|     97|            let NodeKind::GenericAssociation(ga) = *self.ast.get_kind(assoc_node_ref) else {
 2096|      0|                continue;
 2097|       |            };
 2098|       |
 2099|     97|            let assoc_span = self.ast.get_span(assoc_node_ref);
 2100|     97|            self.visit_node(assoc_node_ref);
 2101|       |
 2102|     97|            let Some(assoc_ty) = ga.ty else {
                                   ^57
 2103|       |                // This is the 'default' association.
 2104|       |                // Constraint 2: If a generic selection has a default association, there shall be only one such association.
 2105|     40|                if let Some(first_span) = default_first_span {
                                          ^1
 2106|      1|                    self.report_error(SemanticError::GenericMultipleDefault {
 2107|      1|                        span: assoc_span,
 2108|      1|                        first_def: first_span,
 2109|      1|                    });
 2110|     39|                } else {
 2111|     39|                    default_first_span = Some(assoc_span);
 2112|     39|                    default_expr_ref = Some(ga.result_expr);
 2113|     39|                }
 2114|     40|                continue;
 2115|       |            };
 2116|       |
 2117|       |            // C11 6.5.1.1p2: The type name in a generic association shall specify a complete object type...
 2118|     57|            if !self.registry.is_complete(assoc_ty.ty()) {
 2119|      2|                self.report_error(SemanticError::GenericIncompleteAssociation {
 2120|      2|                    ty: self.registry.display_qual_type(assoc_ty),
 2121|      2|                    span: assoc_span,
 2122|      2|                });
 2123|     55|            }
 2124|       |
 2125|       |            // C11 6.5.1.1p2: The controlling expression... shall have type compatible with at most one...
 2126|       |            // "No two generic associations in the same generic selection shall specify compatible types."
 2127|       |
 2128|       |            // Constraint 2: No two generic associations in the same generic selection shall specify compatible types.
 2129|     57|            let mut duplicate = false;
 2130|     70|            for (prev_ty, prev_span) in &seen_types {
                               ^15      ^15
 2131|     15|                if self.registry.is_compatible(assoc_ty, *prev_ty) {
 2132|      2|                    self.report_error(SemanticError::GenericDuplicateMatch {
 2133|      2|                        ty: self.registry.display_qual_type(assoc_ty),
 2134|      2|                        prev_ty: self.registry.display_qual_type(*prev_ty),
 2135|      2|                        span: assoc_span,
 2136|      2|                        first_def: *prev_span,
 2137|      2|                    });
 2138|      2|                    duplicate = true;
 2139|      2|                    break;
 2140|     13|                }
 2141|       |            }
 2142|       |
 2143|     57|            if !duplicate {
 2144|     55|                seen_types.push((assoc_ty, assoc_span));
 2145|     55|            }
                          ^2
 2146|       |
 2147|       |            // Constraint 1: The controlling expression... shall have type compatible with at most one...
 2148|       |            // unqualified_ctrl_ty is the controlling expression type after lvalue conversion (which strips qualifiers).
 2149|       |            // It is compared against the association type (which keeps qualifiers).
 2150|     57|            if self.registry.is_compatible(unqualified_ctrl_ty, assoc_ty) && selected_expr_ref.is_none() {
                                                                                           ^42               ^42
 2151|     41|                selected_expr_ref = Some(ga.result_expr);
 2152|     41|                self.semantic_info
 2153|     41|                    .generic_selections
 2154|     41|                    .insert(node_ref.index(), ga.result_expr);
 2155|     41|            }
                          ^16
 2156|       |        }
 2157|       |
 2158|       |        // If no specific type matches, use the default association if it exists.
 2159|     48|        if selected_expr_ref.is_none() {
 2160|      7|            selected_expr_ref = default_expr_ref;
 2161|      7|            if let Some(expr) = default_expr_ref {
                                      ^6
 2162|      6|                self.semantic_info.generic_selections.insert(node_ref.index(), expr);
 2163|      6|            }
                          ^1
 2164|     41|        }
 2165|       |
 2166|       |        // The type of the _Generic expression is the type of the selected result expression.
 2167|     48|        if let Some(expr_ref) = selected_expr_ref {
                                  ^47
 2168|       |            // The type should already be resolved from the earlier pass.
 2169|     47|            let idx = expr_ref.index();
 2170|     47|            self.semantic_info.types.get(idx).and_then(|t| *t)
 2171|       |        } else {
 2172|       |            // If no match is found and there's no default, it's a semantic error.
 2173|      1|            self.report_error(SemanticError::GenericNoMatch {
 2174|      1|                ty: self.registry.display_qual_type(ctrl_ty),
 2175|      1|                span: self.ast.get_span(node_ref),
 2176|      1|            });
 2177|      1|            None
 2178|       |        }
 2179|     48|    }
 2180|       |
 2181|     10|    fn visit_builtin_offsetof(&mut self, ty: QualType, expr_ref: NodeRef, node_ref: NodeRef) -> Option<QualType> {
 2182|     10|        self.visit_type_expressions(ty);
 2183|       |
 2184|     10|        let mut current_ty = ty;
 2185|     10|        let mut offset = 0i64;
 2186|       |
 2187|     10|        if !self.compute_offsetof_recursive(expr_ref, &mut current_ty, &mut offset) {
 2188|      0|            let res_ty = QualType::unqualified(self.registry.type_long_unsigned);
 2189|      0|            return Some(res_ty);
 2190|     10|        }
 2191|       |
 2192|     10|        self.semantic_info.offsetof_results.insert(node_ref.index(), offset);
 2193|     10|        let res_ty = QualType::unqualified(self.registry.type_long_unsigned);
 2194|     10|        Some(res_ty)
 2195|     10|    }
 2196|       |
 2197|     24|    fn compute_offsetof_recursive(&mut self, node_ref: NodeRef, current_ty: &mut QualType, offset: &mut i64) -> bool {
 2198|     24|        let kind = *self.ast.get_kind(node_ref);
 2199|     24|        match kind {
 2200|     10|            NodeKind::Dummy => true,
 2201|     12|            NodeKind::MemberAccess(base, member_name, is_arrow) => {
 2202|     12|                if !self.compute_offsetof_recursive(base, current_ty, offset) {
 2203|      0|                    return false;
 2204|     12|                }
 2205|       |
 2206|     12|                let record_ty = if is_arrow {
 2207|      0|                    self.registry.get_pointee(current_ty.ty()).map(|qt| qt.ty())
 2208|       |                } else {
 2209|     12|                    Some(current_ty.ty())
 2210|       |                };
 2211|       |
 2212|     12|                let Some(record_ty) = record_ty else {
 2213|      0|                    self.report_error(SemanticError::MemberAccessOnNonRecord {
 2214|      0|                        ty: self.registry.display_qual_type(*current_ty),
 2215|      0|                        span: self.ast.get_span(node_ref),
 2216|      0|                    });
 2217|      0|                    return false;
 2218|       |                };
 2219|       |
 2220|     12|                if !record_ty.is_record() {
 2221|      0|                    self.report_error(SemanticError::MemberAccessOnNonRecord {
 2222|      0|                        ty: self.registry.display_qual_type(QualType::unqualified(record_ty)),
 2223|      0|                        span: self.ast.get_span(node_ref),
 2224|      0|                    });
 2225|      0|                    return false;
 2226|     12|                }
 2227|       |
 2228|     12|                let mut flat_members = Vec::new();
 2229|     12|                let mut flat_offsets = Vec::new();
 2230|     12|                let ty_obj = self.registry.get(record_ty);
 2231|     12|                ty_obj.flatten_members_with_layouts(self.registry, &mut flat_members, &mut flat_offsets, 0);
 2232|       |
 2233|     22|                if let Some(idx) = flat_members.iter().position(|m| m.name == Some(member_name)) {
                                          ^12    ^12                 ^12
 2234|     12|                    *offset += flat_offsets[idx] as i64;
 2235|     12|                    *current_ty = flat_members[idx].member_type;
 2236|     12|                    true
 2237|       |                } else {
 2238|      0|                    self.report_error(SemanticError::MemberNotFound {
 2239|      0|                        name: member_name,
 2240|      0|                        ty: self.registry.display_type(record_ty),
 2241|      0|                        span: self.ast.get_span(node_ref),
 2242|      0|                    });
 2243|      0|                    false
 2244|       |                }
 2245|       |            }
 2246|      2|            NodeKind::IndexAccess(base, index) => {
 2247|      2|                if !self.compute_offsetof_recursive(base, current_ty, offset) {
 2248|      0|                    return false;
 2249|      2|                }
 2250|       |
 2251|      2|                let elem_ty = self.registry.get_array_element(current_ty.ty());
 2252|      2|                let Some(elem_ty) = elem_ty else {
 2253|      0|                    self.report_error(SemanticError::ExpectedArrayType {
 2254|      0|                        found: self.registry.display_qual_type(*current_ty),
 2255|      0|                        span: self.ast.get_span(node_ref),
 2256|      0|                    });
 2257|      0|                    return false;
 2258|       |                };
 2259|       |
 2260|      2|                self.visit_node(index);
 2261|      2|                let index_val = crate::semantic::const_eval::eval_const_expr(&self.const_ctx(), index);
 2262|      2|                let Some(index_val) = index_val else {
 2263|       |                    // C11 7.19p3: "integer constant expression"
 2264|      0|                    self.report_error(SemanticError::NonConstantInitializer {
 2265|      0|                        span: self.ast.get_span(index),
 2266|      0|                    });
 2267|      0|                    return false;
 2268|       |                };
 2269|       |
 2270|      2|                let layout = self.registry.get_layout(elem_ty);
 2271|      2|                *offset += index_val * (layout.size as i64);
 2272|      2|                *current_ty = QualType::unqualified(elem_ty);
 2273|      2|                true
 2274|       |            }
 2275|       |            _ => {
 2276|      0|                self.report_error(SemanticError::InvalidOffsetofDesignator {
 2277|      0|                    span: self.ast.get_span(node_ref),
 2278|      0|                });
 2279|      0|                false
 2280|       |            }
 2281|       |        }
 2282|     24|    }
 2283|       |}

/app/src/semantic/const_eval.rs:
    1|       |//! Constant expression evaluation
    2|       |//!
    3|       |//! This module provides the functionality to evaluate constant expressions
    4|       |//! at compile time, as required by the C11 standard for contexts like
    5|       |//! static assertions and array sizes.
    6|       |
    7|       |use crate::ast::{Ast, BinaryOp, NodeKind, NodeRef, UnaryOp, literal};
    8|       |use crate::semantic::{QualType, SemanticInfo, SymbolKind, SymbolTable, TypeRegistry};
    9|       |
   10|       |/// Context for constant expression evaluation
   11|       |pub(crate) struct ConstEvalCtx<'a> {
   12|       |    pub(crate) ast: &'a Ast,
   13|       |    pub(crate) symbol_table: &'a SymbolTable,
   14|       |    pub(crate) registry: &'a TypeRegistry,
   15|       |    pub(crate) semantic_info: Option<&'a SemanticInfo>,
   16|       |}
   17|       |
   18|       |/// Evaluate a constant expression node to an i64 value
   19|    837|pub(crate) fn eval_const_expr(ctx: &ConstEvalCtx, expr_node_ref: NodeRef) -> Option<i64> {
   20|    837|    let node_kind = ctx.ast.get_kind(expr_node_ref);
   21|    277|    match node_kind {
   22|    277|        NodeKind::Literal(literal::Literal::Int { val, .. }) => Some(*val),
   23|      0|        NodeKind::Literal(literal::Literal::Char(val)) => Some(*val as i64),
   24|    113|        NodeKind::Ident(_, sym_ref) => {
   25|    113|            let symbol = ctx.symbol_table.get_symbol(*sym_ref);
   26|    113|            if let SymbolKind::EnumConstant { value } = &symbol.kind {
                                                            ^6
   27|      6|                Some(*value)
   28|       |            } else {
   29|    107|                None
   30|       |            }
   31|       |        }
   32|    230|        NodeKind::BinaryOp(op, left_ref, right_ref) => {
   33|    230|            let left_val = eval_const_expr(ctx, *left_ref)?;
                              ^81                                       ^149
   34|       |
   35|       |            // Short-circuiting logic
   36|     81|            match op {
   37|       |                BinaryOp::LogicAnd => {
   38|      4|                    if left_val == 0 {
   39|      1|                        return Some(0);
   40|      3|                    }
   41|      3|                    let right_val = eval_const_expr(ctx, *right_ref)?;
                                                                                  ^0
   42|      3|                    return Some((right_val != 0) as i64);
   43|       |                }
   44|       |                BinaryOp::LogicOr => {
   45|      5|                    if left_val != 0 {
   46|      3|                        return Some(1);
   47|      2|                    }
   48|      2|                    let right_val = eval_const_expr(ctx, *right_ref)?;
                                                                                  ^0
   49|      2|                    return Some((right_val != 0) as i64);
   50|       |                }
   51|     72|                _ => {}
   52|       |            }
   53|       |
   54|     72|            let right_val = eval_const_expr(ctx, *right_ref)?;
                              ^71                                         ^1
   55|     71|            match op {
   56|      7|                BinaryOp::Add => Some(left_val.wrapping_add(right_val)),
   57|      6|                BinaryOp::Sub => Some(left_val.wrapping_sub(right_val)),
   58|      8|                BinaryOp::Mul => Some(left_val.wrapping_mul(right_val)),
   59|       |                BinaryOp::Div => {
   60|      3|                    if right_val != 0 {
   61|      2|                        Some(left_val.wrapping_div(right_val))
   62|       |                    } else {
   63|      1|                        None
   64|       |                    }
   65|       |                }
   66|      9|                BinaryOp::Equal => Some((left_val == right_val) as i64),
   67|     19|                BinaryOp::NotEqual => Some((left_val != right_val) as i64),
   68|      7|                BinaryOp::Less => Some((left_val < right_val) as i64),
   69|      2|                BinaryOp::LessEqual => Some((left_val <= right_val) as i64),
   70|      2|                BinaryOp::Greater => Some((left_val > right_val) as i64),
   71|      2|                BinaryOp::GreaterEqual => Some((left_val >= right_val) as i64),
   72|       |                // LogicAnd/LogicOr handled above
   73|      1|                BinaryOp::BitOr => Some(left_val | right_val),
   74|      1|                BinaryOp::BitAnd => Some(left_val & right_val),
   75|      1|                BinaryOp::BitXor => Some(left_val ^ right_val),
   76|       |                BinaryOp::LShift => {
   77|       |                    // Safe shift, handle overflow or large shift count by wrapping or masking
   78|      1|                    Some(left_val.wrapping_shl(right_val as u32))
   79|       |                }
   80|      1|                BinaryOp::RShift => Some(left_val.wrapping_shr(right_val as u32)),
   81|      1|                _ => None,
   82|       |            }
   83|       |        }
   84|     76|        NodeKind::UnaryOp(op, operand_ref) => {
   85|     76|            let operand_val = eval_const_expr(ctx, *operand_ref)?;
                              ^18                                             ^58
   86|     18|            match op {
   87|      5|                UnaryOp::LogicNot => Some((operand_val == 0) as i64),
   88|      1|                UnaryOp::Plus => Some(operand_val),
   89|     10|                UnaryOp::Minus => Some(operand_val.wrapping_neg()),
   90|      2|                UnaryOp::BitNot => Some(!operand_val),
   91|      0|                _ => None,
   92|       |            }
   93|       |        }
   94|     25|        NodeKind::SizeOfExpr(expr) => {
   95|     25|            let ty = ctx.ast.get_resolved_type(*expr).expect("Type not resolved");
   96|     25|            let layout = ctx.registry.get_layout(ty.ty());
   97|     25|            Some(layout.size as i64)
   98|       |        }
   99|      1|        NodeKind::AlignOf(ty) => {
  100|      1|            let layout = ctx.registry.get_layout(ty.ty());
  101|      1|            Some(layout.alignment as i64)
  102|       |        }
  103|     13|        NodeKind::SizeOfType(ty) => {
  104|     13|            let layout = ctx.registry.get_layout(ty.ty());
  105|     13|            Some(layout.size as i64)
  106|       |        }
  107|       |        NodeKind::GenericSelection(_) => {
  108|     17|            let info = ctx.semantic_info.or(ctx.ast.semantic_info.as_ref());
  109|     17|            if let Some(info) = info
  110|     17|                && let Some(selected_expr) = info.generic_selections.get(&expr_node_ref.index())
  111|       |            {
  112|     17|                return eval_const_expr(ctx, *selected_expr);
  113|      0|            }
  114|      0|            None
  115|       |        }
  116|      8|        NodeKind::TernaryOp(cond, then_ref, else_ref) => {
  117|      8|            let cond_val = eval_const_expr(ctx, *cond)?;
                              ^4                                    ^4
  118|      4|            if cond_val != 0 {
  119|      3|                eval_const_expr(ctx, *then_ref)
  120|       |            } else {
  121|      1|                eval_const_expr(ctx, *else_ref)
  122|       |            }
  123|       |        }
  124|      3|        NodeKind::Cast(_, expr) => eval_const_expr(ctx, *expr),
  125|     11|        NodeKind::BuiltinOffsetof(ty, expr) => eval_offsetof(ctx, *ty, *expr),
  126|     63|        _ => None,
  127|       |    }
  128|    837|}
  129|       |
  130|     11|pub(crate) fn eval_offsetof(ctx: &ConstEvalCtx, ty: QualType, expr_ref: NodeRef) -> Option<i64> {
  131|     11|    let mut current_ty = ty;
  132|     11|    let mut offset = 0i64;
  133|       |
  134|     26|    fn walk(ctx: &ConstEvalCtx, node_ref: NodeRef, current_ty: &mut QualType, offset: &mut i64) -> bool {
  135|     26|        match *ctx.ast.get_kind(node_ref) {
  136|     11|            NodeKind::Dummy => true,
  137|     13|            NodeKind::MemberAccess(base, member_name, is_arrow) => {
  138|     13|                if !walk(ctx, base, current_ty, offset) {
  139|      0|                    return false;
  140|     13|                }
  141|       |
  142|     13|                let record_ty = if is_arrow {
  143|      0|                    ctx.registry.get_pointee(current_ty.ty()).map(|qt| qt.ty())
  144|       |                } else {
  145|     13|                    Some(current_ty.ty())
  146|       |                };
  147|       |
  148|     13|                let Some(record_ty) = record_ty else {
  149|      0|                    return false;
  150|       |                };
  151|     13|                if !record_ty.is_record() {
  152|      0|                    return false;
  153|     13|                }
  154|       |
  155|     13|                let mut flat_members = Vec::new();
  156|     13|                let mut flat_offsets = Vec::new();
  157|     13|                let ty_obj = ctx.registry.get(record_ty);
  158|     13|                ty_obj.flatten_members_with_layouts(ctx.registry, &mut flat_members, &mut flat_offsets, 0);
  159|       |
  160|     24|                if let Some(idx) = flat_members.iter().position(|m| m.name == Some(member_name)) {
                                          ^13    ^13                 ^13
  161|     13|                    *offset += flat_offsets[idx] as i64;
  162|     13|                    *current_ty = flat_members[idx].member_type;
  163|     13|                    true
  164|       |                } else {
  165|      0|                    false
  166|       |                }
  167|       |            }
  168|      2|            NodeKind::IndexAccess(base, index) => {
  169|      2|                if !walk(ctx, base, current_ty, offset) {
  170|      0|                    return false;
  171|      2|                }
  172|       |
  173|      2|                let Some(elem_ty) = ctx.registry.get_array_element(current_ty.ty()) else {
  174|      0|                    return false;
  175|       |                };
  176|      2|                let Some(index_val) = eval_const_expr(ctx, index) else {
  177|      0|                    return false;
  178|       |                };
  179|       |
  180|      2|                let layout = ctx.registry.get_layout(elem_ty);
  181|      2|                *offset += index_val * (layout.size as i64);
  182|      2|                *current_ty = QualType::unqualified(elem_ty);
  183|      2|                true
  184|       |            }
  185|      0|            _ => false,
  186|       |        }
  187|     26|    }
  188|       |
  189|     11|    if walk(ctx, expr_ref, &mut current_ty, &mut offset) {
  190|     11|        Some(offset)
  191|       |    } else {
  192|      0|        None
  193|       |    }
  194|     11|}

/app/src/semantic/conversions.rs:
    1|       |//! Implements C11 semantic conversions, such as usual arithmetic conversions
    2|       |//! and integer promotions.
    3|       |
    4|       |use crate::semantic::{BuiltinType, QualType, TypeKind, TypeRef, TypeRegistry};
    5|       |
    6|       |/// Performs the "usual arithmetic conversions" as specified in C11 6.3.1.8.
    7|    174|pub(crate) fn usual_arithmetic_conversions(ctx: &mut TypeRegistry, lhs: QualType, rhs: QualType) -> Option<QualType> {
    8|    174|    let lt = lhs.ty();
    9|    174|    let rt = rhs.ty();
   10|       |
   11|    174|    if lt.is_floating() || rt.is_floating() {
                                         ^155^155
   12|     38|        let get_real_type = |registry: &TypeRegistry, ty: TypeRef| {
                          ^19
   13|     38|            if ty.is_complex() {
   14|     35|                match &registry.get(ty).kind {
   15|     35|                    TypeKind::Complex { base_type } => Some(*base_type),
   16|      0|                    _ => None,
   17|       |                }
   18|       |            } else {
   19|      3|                Some(ty)
   20|       |            }
   21|     38|        };
   22|       |
   23|     19|        let lr = get_real_type(ctx, lt)?;
                                                     ^0
   24|     19|        let rr = get_real_type(ctx, rt)?;
                                                     ^0
   25|       |
   26|     19|        let lb = lr.builtin();
   27|     19|        let rb = rr.builtin();
   28|       |
   29|     19|        let common_real = match (lb, rb) {
   30|      0|            (Some(BuiltinType::LongDouble), _) | (_, Some(BuiltinType::LongDouble)) => ctx.type_long_double,
   31|      6|            (Some(BuiltinType::Double), _) | (_, Some(BuiltinType::Double)) => ctx.type_double,
   32|     13|            _ => ctx.type_float,
   33|       |        };
   34|       |
   35|     19|        if lt.is_complex() || rt.is_complex() {
                                            ^1 ^1
   36|     19|            return Some(QualType::unqualified(ctx.complex_type(common_real)));
   37|       |        } else {
   38|      0|            return Some(QualType::unqualified(common_real));
   39|       |        }
   40|    155|    }
   41|       |
   42|       |    // Both types are promoted to at least 'int' or 'unsigned int'
   43|    155|    let lp = integer_promotion(ctx, lhs);
   44|    155|    let rp = integer_promotion(ctx, rhs);
   45|    155|    if lp == rp {
   46|    120|        return Some(lp);
   47|     35|    }
   48|       |
   49|     35|    let lbp = lp.ty().builtin()?;
                                             ^0
   50|     35|    let rbp = rp.ty().builtin()?;
                                             ^0
   51|     35|    let (ls, lr) = (lbp.is_signed(), lbp.rank());
   52|     35|    let (rs, rr) = (rbp.is_signed(), rbp.rank());
   53|       |
   54|       |    // Same signedness: higher rank wins
   55|     35|    if ls == rs {
   56|      5|        return Some(if lr >= rr { lp } else { rp });
                                                ^3          ^2
   57|     30|    }
   58|       |
   59|       |    // Different signedness: Higher rank usually wins; if ranks are equal, unsigned wins.
   60|     30|    let (ut, ur, st, sr) = if ls { (rp, rr, lp, lr) } else { (lp, lr, rp, rr) };
                                                 ^4^4  ^4                   ^26^26 ^26
   61|     30|    if ur >= sr {
   62|     29|        Some(ut)
   63|       |    } else {
   64|       |        // If the signed type can represent all values of the unsigned type, it wins.
   65|       |        // For currently supported targets (e.g. 32-bit int, 64-bit long), this holds.
   66|      1|        Some(st)
   67|       |    }
   68|    174|}
   69|       |
   70|       |/// Performs integer promotions as specified in C11 6.3.1.1.
   71|    827|pub(crate) fn integer_promotion(ctx: &TypeRegistry, ty: QualType) -> QualType {
   72|    827|    let t = ty.ty();
   73|    827|    if t.is_enum() {
   74|      0|        return QualType::unqualified(ctx.type_int);
   75|    827|    }
   76|    827|    match t.builtin() {
   77|    764|        Some(b) if b.is_integer() && b.rank() < BuiltinType::Int.rank() => QualType::unqualified(ctx.type_int),
                           ^46                     ^739^739     ^739             ^739 ^46  ^46                   ^46
   78|    781|        _ => ty,
   79|       |    }
   80|    827|}
   81|       |
   82|       |/// Performs default argument promotions as specified in C11 6.5.2.2.
   83|     67|pub(crate) fn default_argument_promotions(ctx: &TypeRegistry, ty: QualType) -> QualType {
   84|     67|    match ty.ty().builtin() {
   85|      2|        Some(BuiltinType::Float) => QualType::unqualified(ctx.type_double),
   86|     65|        _ => integer_promotion(ctx, ty),
   87|       |    }
   88|     67|}

/app/src/semantic/literal_utils.rs:
    1|       |use crate::ast::NameId;
    2|       |use crate::ast::literal_parsing;
    3|       |use crate::semantic::BuiltinType;
    4|       |
    5|       |enum StringLiteralPrefix {
    6|       |    None,
    7|       |    Wide,   // L"..." -> wchar_t (int)
    8|       |    Char16, // u"..." -> char16_t (uint16)
    9|       |    Char32, // U"..." -> char32_t (uint32)
   10|       |    Utf8,   // u8"..." -> char
   11|       |}
   12|       |
   13|       |pub struct ParsedStringLiteral {
   14|       |    pub builtin_type: BuiltinType,
   15|       |    pub values: Vec<i64>, // Store as i64 to handle all types
   16|       |    pub size: usize,
   17|       |}
   18|       |
   19|    153|pub(crate) fn parse_string_literal(name: NameId) -> ParsedStringLiteral {
   20|    153|    let raw = name.as_str();
   21|       |
   22|    153|    let (stripped, builtin_type, kind) = if let Some(s) = raw.strip_prefix("L\"") {
                                                                   ^6
   23|      6|        (Some(s), BuiltinType::Int, StringLiteralPrefix::Wide)
   24|    147|    } else if let Some(s) = raw.strip_prefix("u\"") {
                                     ^6
   25|      6|        (Some(s), BuiltinType::UShort, StringLiteralPrefix::Char16)
   26|    141|    } else if let Some(s) = raw.strip_prefix("U\"") {
                                     ^6
   27|      6|        (Some(s), BuiltinType::UInt, StringLiteralPrefix::Char32)
   28|    135|    } else if let Some(s) = raw.strip_prefix("u8\"") {
                                     ^0
   29|      0|        (Some(s), BuiltinType::Char, StringLiteralPrefix::Utf8)
   30|    135|    } else if let Some(s) = raw.strip_prefix("\"") {
                                     ^134
   31|    134|        (Some(s), BuiltinType::Char, StringLiteralPrefix::None)
   32|       |    } else {
   33|      1|        (None, BuiltinType::Char, StringLiteralPrefix::None)
   34|       |    };
   35|       |
   36|    153|    let content = match stripped {
   37|    152|        Some(s) => literal_parsing::unescape_string(s.strip_suffix('"').unwrap_or(s)),
   38|      1|        None => raw.to_string(),
   39|       |    };
   40|       |
   41|    153|    let mut values = Vec::new();
   42|    153|    match kind {
   43|       |        StringLiteralPrefix::None | StringLiteralPrefix::Utf8 => {
   44|  1.40k|            values.extend(content.bytes().map(|b| b as i64));
                          ^135   ^135   ^135            ^135
   45|       |        }
   46|       |        StringLiteralPrefix::Wide | StringLiteralPrefix::Char32 => {
   47|     54|            values.extend(content.chars().map(|c| c as u32 as i64));
                          ^12    ^12    ^12             ^12
   48|       |        }
   49|       |        StringLiteralPrefix::Char16 => {
   50|     21|            for c in content.chars() {
                                   ^6      ^6
   51|     21|                let mut buf = [0; 2];
   52|     21|                values.extend(c.encode_utf16(&mut buf).iter().map(|&u| u as i64));
   53|       |            }
   54|       |        }
   55|       |    }
   56|    153|    values.push(0); // Null terminator
   57|       |
   58|    153|    ParsedStringLiteral {
   59|    153|        builtin_type,
   60|    153|        size: values.len(),
   61|    153|        values,
   62|    153|    }
   63|    153|}

/app/src/semantic/lowering.rs:
    1|       |//! SemanticLowering
    2|       |//!
    3|       |//! Responsibility
    4|       |//! - Declaration Lowering (Declaration -> VarDecl/RecordDecl/EnumDecl/TypedefDecl, FunctionDef -> Function)
    5|       |//! - Scope Construction
    6|       |//! - Symbol Insertion to Symbol Table
    7|       |//! - Name lookup
    8|       |//! - Making Sure Struct with body is is_complete = true
    9|       |//!
   10|       |//! This module implements the semantic lowering phase that bridges the gap between the
   11|       |//! grammar-oriented parser AST and the type-resolved semantic AST (HIR). The lowering
   12|       |//! phase handles all C-style declaration forms
   13|       |
   14|       |use hashbrown::HashMap;
   15|       |use smallvec::{SmallVec, smallvec};
   16|       |
   17|       |use crate::ast::literal;
   18|       |use crate::ast::parsed::{
   19|       |    ParsedDeclarationData, ParsedDeclarator, ParsedFunctionDefData, ParsedNodeKind, ParsedNodeRef, ParsedTypeSpecifier,
   20|       |};
   21|       |use crate::ast::*;
   22|       |use crate::diagnostic::{DiagnosticEngine, SemanticError};
   23|       |use crate::semantic::const_eval::{self, ConstEvalCtx};
   24|       |use crate::semantic::symbol_table::{DefinitionState, SymbolTableError};
   25|       |use crate::semantic::{
   26|       |    ArraySizeType, BuiltinType, EnumConstant, ScopeId, StructMember, SymbolKind, SymbolRef, SymbolTable, TypeKind,
   27|       |    TypeQualifiers, TypeRef, TypeRegistry,
   28|       |};
   29|       |use crate::semantic::{FunctionParameter, QualType};
   30|       |use crate::source_manager::SourceSpan;
   31|       |use std::sync::Arc;
   32|       |
   33|       |#[derive(Clone, Copy)]
   34|       |struct DeclaratorContext {
   35|       |    in_parameter: bool,
   36|       |}
   37|       |
   38|       |/// Recursively apply parsed declarator to base type
   39|    232|fn apply_parsed_declarator(
   40|    232|    current_type: QualType,
   41|    232|    declarator_ref: ParsedDeclRef,
   42|    232|    ctx: &mut LowerCtx,
   43|    232|    span: SourceSpan,
   44|    232|    decl_ctx: DeclaratorContext,
   45|    232|) -> QualType {
   46|    232|    let declarator_node = ctx.parsed_ast.parsed_types.get_decl(declarator_ref);
   47|       |
   48|    232|    match declarator_node {
   49|    200|        ParsedDeclaratorNode::Identifier { .. } => current_type,
   50|     23|        ParsedDeclaratorNode::Pointer { qualifiers, inner } => {
   51|       |            // Pointer
   52|       |            // Apply Pointer modifier to the current type first (Top-Down)
   53|     23|            let pointer_type = ctx.registry.pointer_to(current_type);
   54|       |            // Pointer type is always compatible with restrict, but we use checked merge anyway for consistency
   55|     23|            let modified_current =
   56|     23|                ctx.merge_qualifiers_with_check(QualType::unqualified(pointer_type), qualifiers, span);
   57|     23|            apply_parsed_declarator(modified_current, inner, ctx, span, decl_ctx)
   58|       |        }
   59|      4|        ParsedDeclaratorNode::Array { size, inner } => {
   60|       |            // Array
   61|       |            // Apply Array modifier to the current type
   62|       |            // Propagate qualifiers from the element type to the array type (C11 6.7.3)
   63|       |
   64|       |            // C11 6.7.6.2p1: qualifiers and static in array declarator only allowed in function parameters
   65|       |            // and only in the outermost array type derivation.
   66|      4|            let has_quals = match &size {
   67|      1|                ParsedArraySize::Expression { qualifiers, .. } => !qualifiers.is_empty(),
   68|      0|                ParsedArraySize::Star { qualifiers } => !qualifiers.is_empty(),
   69|      0|                ParsedArraySize::VlaSpecifier { qualifiers, .. } => !qualifiers.is_empty(),
   70|      3|                ParsedArraySize::Incomplete => false,
   71|       |            };
   72|      4|            let has_static = matches!(size, ParsedArraySize::VlaSpecifier { is_static: true, .. });
                                           ^0
   73|       |
   74|      4|            if has_static || has_quals {
   75|      0|                let inner_node = ctx.parsed_ast.parsed_types.get_decl(inner);
   76|      0|                let is_outermost = matches!(inner_node, ParsedDeclaratorNode::Identifier { .. });
   77|       |
   78|      0|                if !decl_ctx.in_parameter {
   79|      0|                    if has_static {
   80|      0|                        ctx.report_error(SemanticError::ArrayStaticOutsideParameter { span });
   81|      0|                    }
   82|      0|                    if has_quals {
   83|      0|                        ctx.report_error(SemanticError::ArrayQualifierOutsideParameter { span });
   84|      0|                    }
   85|      0|                } else if !is_outermost {
   86|      0|                    if has_static {
   87|      0|                        ctx.report_error(SemanticError::ArrayStaticNotOutermost { span });
   88|      0|                    }
   89|      0|                    if has_quals {
   90|      0|                        ctx.report_error(SemanticError::ArrayQualifierNotOutermost { span });
   91|      0|                    }
   92|      0|                }
   93|      4|            }
   94|       |
   95|      4|            let array_size = convert_parsed_array_size(&size, ctx);
   96|      4|            let array_type_ref = ctx.registry.array_of(current_type.ty(), array_size);
   97|      4|            let qualified_array = ctx
   98|      4|                .registry
   99|      4|                .merge_qualifiers(QualType::unqualified(array_type_ref), current_type.qualifiers());
  100|      4|            apply_parsed_declarator(qualified_array, inner, ctx, span, decl_ctx)
  101|       |        }
  102|      5|        ParsedDeclaratorNode::Function { params, flags, inner } => {
  103|       |            // Function
  104|       |            // Process parameters separately
  105|      5|            let parsed_params: Vec<_> = ctx.parsed_ast.parsed_types.get_params(params).to_vec();
  106|      5|            let mut processed_params = Vec::new();
  107|      7|            for param in parsed_params {
                              ^2
  108|      2|                let param_type = convert_to_qual_type(ctx, param.ty, param.span, true).unwrap_or_else(|_| {
                                                                                                                        ^0
  109|       |                    // Create an error type if conversion fails
  110|      0|                    QualType::unqualified(ctx.registry.type_int)
  111|      0|                });
  112|       |
  113|       |                // Apply array-to-pointer decay for function parameters
  114|      2|                let ptr_quals = extract_array_param_qualifiers_from_ref(param.ty.declarator, ctx);
  115|      2|                let decayed_param_type = ctx.registry.decay(param_type, ptr_quals);
  116|       |
  117|      2|                processed_params.push(FunctionParameter {
  118|      2|                    param_type: decayed_param_type,
  119|      2|                    name: param.name,
  120|      2|                    storage: None,
  121|      2|                });
  122|       |            }
  123|       |
  124|       |            // Apply Function modifier to the current type
  125|      5|            let function_type_ref = ctx.registry.function_type(
  126|      5|                current_type.ty(),
  127|      5|                processed_params,
  128|      5|                flags.is_variadic,
  129|       |                false, // `_Noreturn` is a specifier, not part of declarator
  130|       |            );
  131|      5|            apply_parsed_declarator(QualType::unqualified(function_type_ref), inner, ctx, span, decl_ctx)
  132|       |        }
  133|       |    }
  134|    232|}
  135|       |
  136|      2|fn extract_array_param_qualifiers_from_ref(decl_ref: ParsedDeclRef, ctx: &LowerCtx) -> TypeQualifiers {
  137|      2|    let decl = ctx.parsed_ast.parsed_types.get_decl(decl_ref);
  138|      2|    match decl {
  139|      2|        ParsedDeclaratorNode::Identifier { .. } => TypeQualifiers::empty(),
  140|      0|        ParsedDeclaratorNode::Pointer { .. } => TypeQualifiers::empty(),
  141|      0|        ParsedDeclaratorNode::Function { .. } => TypeQualifiers::empty(),
  142|      0|        ParsedDeclaratorNode::Array { size, inner } => {
  143|      0|            let inner_quals = extract_array_param_qualifiers_from_ref(inner, ctx);
  144|      0|            if !inner_quals.is_empty() {
  145|      0|                return inner_quals;
  146|      0|            }
  147|      0|            match size {
  148|      0|                ParsedArraySize::Expression { qualifiers, .. } => qualifiers,
  149|      0|                ParsedArraySize::Star { qualifiers } => qualifiers,
  150|      0|                ParsedArraySize::VlaSpecifier { qualifiers, .. } => qualifiers,
  151|      0|                ParsedArraySize::Incomplete => TypeQualifiers::empty(),
  152|       |            }
  153|       |        }
  154|       |    }
  155|      2|}
  156|       |
  157|    271|fn extract_array_param_qualifiers(decl: &ParsedDeclarator) -> TypeQualifiers {
  158|    271|    match decl {
  159|    165|        ParsedDeclarator::Identifier(..) | ParsedDeclarator::Abstract => TypeQualifiers::empty(),
  160|     69|        ParsedDeclarator::Pointer(..) => TypeQualifiers::empty(),
  161|     31|        ParsedDeclarator::Array(inner, size) => {
  162|     31|            let inner_quals = extract_array_param_qualifiers(inner);
  163|     31|            if !inner_quals.is_empty() {
  164|      1|                return inner_quals;
  165|     30|            }
  166|     30|            match size {
  167|      9|                ParsedArraySize::Expression { qualifiers, .. } => *qualifiers,
  168|      0|                ParsedArraySize::Star { qualifiers } => *qualifiers,
  169|     17|                ParsedArraySize::VlaSpecifier { qualifiers, .. } => *qualifiers,
  170|      4|                ParsedArraySize::Incomplete => TypeQualifiers::empty(),
  171|       |            }
  172|       |        }
  173|      6|        ParsedDeclarator::Function { .. } => TypeQualifiers::empty(),
  174|      0|        ParsedDeclarator::BitField(inner, _) => extract_array_param_qualifiers(inner),
  175|      0|        ParsedDeclarator::AnonymousRecord(..) => TypeQualifiers::empty(),
  176|       |    }
  177|    271|}
  178|       |
  179|       |/// Convert ParsedArraySize to ArraySizeType
  180|      4|fn convert_parsed_array_size(size: &ParsedArraySize, ctx: &mut LowerCtx) -> ArraySizeType {
  181|      4|    match size {
  182|      1|        ParsedArraySize::Expression { expr, .. } => resolve_array_size(Some(*expr), ctx),
  183|      0|        ParsedArraySize::Star { .. } => ArraySizeType::Star,
  184|      3|        ParsedArraySize::Incomplete => ArraySizeType::Incomplete,
  185|      0|        ParsedArraySize::VlaSpecifier { size, .. } => resolve_array_size(*size, ctx),
  186|       |    }
  187|      4|}
  188|       |
  189|       |/// Helper function to resolve array size logic
  190|     89|fn resolve_array_size(size: Option<ParsedNodeRef>, ctx: &mut LowerCtx) -> ArraySizeType {
  191|     89|    if let Some(parsed_ref) = size {
  192|     89|        let expr_ref = ctx.visit_expression(parsed_ref);
  193|     89|        if let Some(val) = const_eval::eval_const_expr(&ctx.const_ctx(), expr_ref) {
                                  ^86
  194|     86|            if val < 0 {
  195|      1|                ctx.report_error(SemanticError::InvalidArraySize {
  196|      1|                    span: ctx.ast.get_span(expr_ref),
  197|      1|                });
  198|      1|                return ArraySizeType::Incomplete;
  199|     85|            }
  200|     85|            return ArraySizeType::Constant(val as usize);
  201|       |        } else {
  202|       |            // For now, we only support constant sizes (VLA support is future)
  203|       |            // Or maybe we should return Variable(expr_ref) and let ensure_layout fail?
  204|       |            // But verify what Variable does.
  205|       |            // ensure_layout returns "incomplete/VLA array layout" error.
  206|      3|            return ArraySizeType::Variable(expr_ref);
  207|       |        }
  208|      0|    }
  209|      0|    ArraySizeType::Incomplete
  210|     89|}
  211|       |
  212|       |/// Context for the semantic lowering phase
  213|       |pub(crate) struct LowerCtx<'a, 'src> {
  214|       |    pub(crate) parsed_ast: &'a ParsedAst,
  215|       |    pub(crate) ast: &'a mut Ast,
  216|       |    pub(crate) diag: &'src mut DiagnosticEngine,
  217|       |    pub(crate) symbol_table: &'a mut SymbolTable,
  218|       |    pub(crate) has_errors: bool,
  219|       |    pub(crate) registry: &'a mut TypeRegistry,
  220|       |    /// If Some, the next CompoundStatement lowering will use this scope instead of pushing a new one.
  221|       |    /// This is used for function bodies to share the parameter scope.
  222|       |    pub(crate) next_compound_uses_scope: Option<ScopeId>,
  223|       |}
  224|       |
  225|       |impl<'a, 'src> LowerCtx<'a, 'src> {
  226|       |    /// Create a new lowering context
  227|    534|    pub(crate) fn new(
  228|    534|        parsed_ast: &'a ParsedAst,
  229|    534|        ast: &'a mut Ast,
  230|    534|        diag: &'src mut DiagnosticEngine,
  231|    534|        symbol_table: &'a mut SymbolTable,
  232|    534|        registry: &'a mut TypeRegistry,
  233|    534|    ) -> Self {
  234|    534|        Self {
  235|    534|            parsed_ast,
  236|    534|            ast,
  237|    534|            diag,
  238|    534|            symbol_table,
  239|    534|            has_errors: false,
  240|    534|            registry,
  241|    534|            next_compound_uses_scope: None,
  242|    534|        }
  243|    534|    }
  244|       |
  245|       |    /// Report a semantic error and mark context as having errors
  246|     98|    pub(crate) fn report_error(&mut self, error: SemanticError) {
  247|     98|        self.has_errors = true;
  248|     98|        self.diag.report(error);
  249|     98|    }
  250|       |
  251|  3.23k|    pub(crate) fn merge_qualifiers_with_check(
  252|  3.23k|        &mut self,
  253|  3.23k|        base: QualType,
  254|  3.23k|        add: TypeQualifiers,
  255|  3.23k|        span: SourceSpan,
  256|  3.23k|    ) -> QualType {
  257|  3.23k|        if add.contains(TypeQualifiers::RESTRICT) {
  258|      5|            let is_valid = if let TypeKind::Pointer { pointee } = &self.registry.get(base.ty()).kind {
                                                                    ^3
  259|      3|                !pointee.is_function()
  260|       |            } else {
  261|      2|                false
  262|       |            };
  263|       |
  264|      5|            if !is_valid {
  265|      3|                self.report_error(SemanticError::InvalidRestrict { span });
  266|      3|            }
                          ^2
  267|  3.22k|        }
  268|  3.23k|        if add.contains(TypeQualifiers::ATOMIC) {
  269|      5|            if base.is_array() {
  270|      1|                self.report_error(SemanticError::InvalidAtomicQualifier {
  271|      1|                    type_kind: "array".to_string(),
  272|      1|                    span,
  273|      1|                });
  274|      4|            } else if base.is_function() {
  275|      1|                self.report_error(SemanticError::InvalidAtomicQualifier {
  276|      1|                    type_kind: "function".to_string(),
  277|      1|                    span,
  278|      1|                });
  279|      3|            }
  280|  3.22k|        }
  281|  3.23k|        self.registry.merge_qualifiers(base, add)
  282|  3.23k|    }
  283|       |
  284|  6.41k|    fn push_dummy(&mut self, span: SourceSpan) -> NodeRef {
  285|  6.41k|        self.ast.push_dummy(span)
  286|  6.41k|    }
  287|       |
  288|       |    /// Get the first slot from target_slots if available, otherwise push a new dummy node.
  289|       |    /// Also ensures scope is set on the node.
  290|  4.00k|    fn get_or_push_slot(&mut self, target_slots: Option<&[NodeRef]>, span: SourceSpan) -> NodeRef {
  291|  4.00k|        if let Some(target) = target_slots.and_then(|t| t.first()) {
                                  ^868                                ^868^868
  292|    868|            self.ast.spans[target.index()] = span;
  293|    868|            *target
  294|       |        } else {
  295|  3.13k|            self.push_dummy(span)
  296|       |        }
  297|  4.00k|    }
  298|       |
  299|  1.82k|    fn count_semantic_nodes(&self, node_ref: ParsedNodeRef) -> usize {
  300|  1.82k|        let node = self.parsed_ast.get_node(node_ref);
  301|  1.82k|        match &node.kind {
  302|    676|            ParsedNodeKind::Declaration(decl) => {
  303|    676|                if decl.init_declarators.is_empty() {
  304|      2|                    1
  305|       |                } else {
  306|    674|                    decl.init_declarators.len()
  307|       |                }
  308|       |            }
  309|      0|            ParsedNodeKind::TranslationUnit(decls) => decls.len(),
  310|  1.14k|            _ => 1,
  311|       |        }
  312|  1.82k|    }
  313|       |
  314|    133|    fn const_ctx(&self) -> ConstEvalCtx<'_> {
  315|    133|        ConstEvalCtx {
  316|    133|            ast: self.ast,
  317|    133|            symbol_table: self.symbol_table,
  318|    133|            registry: self.registry,
  319|    133|            semantic_info: None,
  320|    133|        }
  321|    133|    }
  322|       |}
  323|       |
  324|       |/// Information about declaration specifiers after processing
  325|       |#[derive(Debug, Clone, Default)]
  326|       |pub(crate) struct DeclSpecInfo {
  327|       |    pub(crate) storage: Option<StorageClass>,
  328|       |    pub(crate) is_thread_local: bool,
  329|       |    pub(crate) qualifiers: TypeQualifiers,
  330|       |    pub(crate) base_type: Option<QualType>,
  331|       |    pub(crate) is_typedef: bool,
  332|       |    pub(crate) is_inline: bool,
  333|       |    pub(crate) is_noreturn: bool,
  334|       |    pub(crate) alignment: Option<u32>,
  335|       |}
  336|       |
  337|       |/// Convert a ParsedBaseTypeNode to a QualType
  338|    200|fn convert_parsed_base_type_to_qual_type(
  339|    200|    ctx: &mut LowerCtx,
  340|    200|    parsed_base: &ParsedBaseTypeNode,
  341|    200|    span: SourceSpan,
  342|    200|) -> Result<QualType, SemanticError> {
  343|    200|    match parsed_base {
  344|    166|        ParsedBaseTypeNode::Builtin(ts) => resolve_type_specifier(ts, ctx, span),
  345|     31|        ParsedBaseTypeNode::Record { tag, members, is_union } => {
  346|       |            // Handle struct/union from parsed types
  347|     31|            let is_definition = members.is_some();
  348|     31|            let type_ref = resolve_record_tag(ctx, *tag, *is_union, is_definition, span)?;
                                                                                                      ^0
  349|       |
  350|       |            // Now handle members if it's a definition
  351|     31|            if let Some(members_range) = members {
                                      ^3
  352|       |                // Get the parsed members first to avoid borrowing conflicts
  353|      3|                let parsed_members: Vec<_> = ctx.parsed_ast.parsed_types.get_struct_members(*members_range).to_vec();
  354|       |
  355|       |                // Process member types separately to avoid borrowing conflicts
  356|      3|                let mut member_types = Vec::new();
  357|      7|                for parsed_member in &parsed_members {
                                  ^4
  358|      4|                    let member_type_ref = convert_to_qual_type(ctx, parsed_member.ty, span, false)?;
                                                                                                                ^0
  359|      4|                    member_types.push(member_type_ref);
  360|       |                }
  361|       |
  362|       |                // Now create struct members with the processed types
  363|      3|                let mut struct_members = Vec::new();
  364|       |
  365|      4|                for (i, parsed_member) in parsed_members.iter().enumerate() {
                                                        ^3                    ^3
  366|      4|                    struct_members.push(StructMember {
  367|      4|                        name: parsed_member.name,
  368|      4|                        member_type: member_types[i],
  369|      4|                        bit_field_size: parsed_member.bit_field_size,
  370|      4|                        alignment: parsed_member.alignment,
  371|      4|                        span: parsed_member.span,
  372|      4|                    });
  373|      4|                }
  374|       |
  375|      3|                complete_record_symbol(ctx, *tag, type_ref, struct_members)?;
                                                                                         ^0
  376|     28|            }
  377|       |
  378|     31|            Ok(QualType::unqualified(type_ref))
  379|       |        }
  380|      0|        ParsedBaseTypeNode::Enum { tag, enumerators } => {
  381|       |            // Handle enum from parsed types
  382|      0|            let is_definition = enumerators.is_some();
  383|      0|            let type_ref = resolve_enum_tag(ctx, *tag, is_definition, span)?;
  384|       |
  385|       |            // Process enumerators if it's a definition
  386|      0|            if let Some(enum_range) = enumerators {
  387|      0|                let parsed_enums = ctx.parsed_ast.parsed_types.get_enum_constants(*enum_range);
  388|      0|                let mut next_value = 0i64;
  389|      0|                let mut enumerators_list = Vec::new();
  390|       |
  391|      0|                for parsed_enum in parsed_enums {
  392|      0|                    let value = parsed_enum.value.unwrap_or(next_value);
  393|      0|                    next_value = value + 1;
  394|      0|
  395|      0|                    let enum_constant = EnumConstant {
  396|      0|                        name: parsed_enum.name,
  397|      0|                        value,
  398|      0|                        span: parsed_enum.span,
  399|      0|                        // We don't have the expression here as ParsedEnumConstant only stores the value.
  400|      0|                        // This path is used for nested enum definitions where resolution differs.
  401|      0|                        init_expr: None,
  402|      0|                    };
  403|      0|                    enumerators_list.push(enum_constant);
  404|      0|
  405|      0|                    // Register constant in symbol table
  406|      0|                    let _ = ctx
  407|      0|                        .symbol_table
  408|      0|                        .define_enum_constant(parsed_enum.name, value, type_ref, parsed_enum.span);
  409|      0|                }
  410|       |
  411|      0|                complete_enum_symbol(ctx, *tag, type_ref, enumerators_list)?;
  412|      0|            }
  413|       |
  414|      0|            Ok(QualType::unqualified(type_ref))
  415|       |        }
  416|      3|        ParsedBaseTypeNode::Typedef(name) => {
  417|       |            // Lookup typedef in symbol table
  418|      3|            if let Some((entry_ref, _scope_id)) = ctx.symbol_table.lookup_symbol(*name) {
  419|      3|                let entry = ctx.symbol_table.get_symbol(entry_ref);
  420|      3|                if let SymbolKind::Typedef { aliased_type } = entry.kind {
  421|      3|                    Ok(aliased_type)
  422|       |                } else {
  423|       |                    // Get the kind of the symbol as a string for the error message
  424|      0|                    let kind_string = format!("{:?}", entry.kind);
  425|      0|                    let found_kind_str = kind_string.split_whitespace().next().unwrap_or("symbol");
  426|      0|                    Err(SemanticError::TypeMismatch {
  427|      0|                        expected: "a typedef name".to_string(),
  428|      0|                        found: format!("a {}", found_kind_str.to_lowercase()),
  429|      0|                        span,
  430|      0|                    })
  431|       |                }
  432|       |            } else {
  433|       |                // Typedef not found during semantic lowering - this is expected
  434|       |                // when typedefs are defined later in the same scope.
  435|      0|                Ok(QualType::unqualified(ctx.registry.declare_record(Some(*name), false)))
  436|       |            }
  437|       |        }
  438|       |        ParsedBaseTypeNode::Error => {
  439|       |            // Create an error type
  440|      0|            Ok(QualType::unqualified(ctx.registry.type_error))
  441|       |        }
  442|       |    }
  443|    200|}
  444|       |
  445|       |/// Convert a ParsedType to a TypeRef
  446|    200|fn convert_to_qual_type(
  447|    200|    ctx: &mut LowerCtx,
  448|    200|    parsed_type: ParsedType,
  449|    200|    span: SourceSpan,
  450|    200|    in_parameter: bool,
  451|    200|) -> Result<QualType, SemanticError> {
  452|    200|    let base_type_node = {
  453|       |        // borrow immutable hanya di dalam block ini
  454|    200|        let parsed_types = &ctx.parsed_ast.parsed_types;
  455|    200|        parsed_types.get_base_type(parsed_type.base)
  456|       |    };
  457|       |
  458|    200|    let declarator_ref = parsed_type.declarator;
  459|    200|    let qualifiers = parsed_type.qualifiers;
  460|       |
  461|    200|    let base_type_ref = convert_parsed_base_type_to_qual_type(ctx, &base_type_node, span)?;
                                                                                                       ^0
  462|    200|    let qualified_base = ctx.merge_qualifiers_with_check(base_type_ref, qualifiers, span);
  463|       |
  464|    200|    let final_type = apply_parsed_declarator(
  465|    200|        qualified_base,
  466|    200|        declarator_ref,
  467|    200|        ctx,
  468|    200|        span,
  469|    200|        DeclaratorContext { in_parameter },
  470|       |    );
  471|    200|    Ok(final_type)
  472|    200|}
  473|       |
  474|       |/// Helper to resolve struct/union tags (lookup, forward decl, or definition validation)
  475|    246|fn resolve_record_tag(
  476|    246|    ctx: &mut LowerCtx,
  477|    246|    tag: Option<NameId>,
  478|    246|    is_union: bool,
  479|    246|    is_definition: bool,
  480|    246|    span: SourceSpan,
  481|    246|) -> Result<TypeRef, SemanticError> {
  482|    246|    let Some(tag_name) = tag else {
                           ^225
  483|       |        // Anonymous struct/union definition
  484|     21|        return Ok(ctx.registry.declare_record(None, is_union));
  485|       |    };
  486|       |
  487|    225|    let existing = ctx.symbol_table.lookup_tag(tag_name);
  488|       |
  489|    225|    if is_definition {
  490|       |        // DEFINITION: struct T { ... }
  491|       |        // Check if defined in CURRENT scope
  492|    101|        if let Some((entry_ref, scope_id)) = existing
                                   ^2         ^2
  493|      2|            && scope_id == ctx.symbol_table.current_scope()
  494|       |        {
  495|      1|            let (is_completed, def_span, ty) = {
  496|      1|                let entry = ctx.symbol_table.get_symbol(entry_ref);
  497|      1|                (entry.is_completed, entry.def_span, entry.type_info.ty())
  498|      1|            };
  499|       |
  500|      1|            if is_completed {
  501|      0|                ctx.report_error(SemanticError::Redefinition {
  502|      0|                    name: tag_name,
  503|      0|                    first_def: def_span,
  504|      0|                    span,
  505|      0|                });
  506|      1|            }
  507|      1|            return Ok(ty);
  508|    100|        }
  509|       |
  510|       |        // Not in current scope OR shadowing outer scope -> Create new record
  511|    100|        let ty = ctx.registry.declare_record(Some(tag_name), is_union);
  512|    100|        ctx.symbol_table.define_record(tag_name, ty, false, span);
  513|    100|        Ok(ty)
  514|       |    } else {
  515|       |        // USAGE or FORWARD DECL: struct T;
  516|    124|        if let Some((entry_ref, _)) = existing {
                                   ^109
  517|    109|            Ok(ctx.symbol_table.get_symbol(entry_ref).type_info.ty())
  518|       |        } else {
  519|       |            // Implicit forward declaration in current scope
  520|     15|            let ty = ctx.registry.declare_record(Some(tag_name), is_union);
  521|     15|            ctx.symbol_table.define_record(tag_name, ty, false, span);
  522|     15|            Ok(ty)
  523|       |        }
  524|       |    }
  525|    246|}
  526|       |
  527|       |/// Helper to resolve enum tags
  528|     22|fn resolve_enum_tag(
  529|     22|    ctx: &mut LowerCtx,
  530|     22|    tag: Option<NameId>,
  531|     22|    is_definition: bool,
  532|     22|    span: SourceSpan,
  533|     22|) -> Result<TypeRef, SemanticError> {
  534|     22|    let existing_entry = tag.and_then(|tag_name| ctx.symbol_table.lookup_tag(tag_name));
                                                               ^21              ^21        ^21
  535|       |
  536|     22|    if let Some(tag_name) = tag {
                              ^21
  537|     21|        if is_definition {
  538|       |            // This is a DEFINITION: enum T { ... };
  539|     14|            if let Some((entry_ref, scope_id)) = existing_entry
                                       ^0         ^0
  540|      0|                && scope_id == ctx.symbol_table.current_scope()
  541|       |            {
  542|       |                // Found in current scope, check if completed
  543|      0|                let (is_completed, first_def, type_info) = {
  544|      0|                    let entry = ctx.symbol_table.get_symbol(entry_ref);
  545|      0|                    (entry.is_completed, entry.def_span, entry.type_info)
  546|      0|                };
  547|      0|                if is_completed {
  548|      0|                    ctx.report_error(SemanticError::Redefinition {
  549|      0|                        name: tag_name,
  550|      0|                        first_def,
  551|      0|                        span,
  552|      0|                    });
  553|      0|                }
  554|      0|                Ok(type_info.ty())
  555|       |            } else {
  556|       |                // Not found in current scope, create new entry
  557|     14|                let new_type_ref = ctx.registry.declare_enum(Some(tag_name), ctx.registry.type_int);
  558|     14|                ctx.symbol_table.define_enum(tag_name, new_type_ref, span);
  559|     14|                Ok(new_type_ref)
  560|       |            }
  561|       |        } else {
  562|       |            // This is a USAGE or FORWARD DECL: enum T; or enum T e;
  563|      7|            if let Some((entry_ref, _)) = existing_entry {
                                       ^6
  564|      6|                let entry = ctx.symbol_table.get_symbol(entry_ref);
  565|      6|                Ok(entry.type_info.ty())
  566|       |            } else {
  567|       |                // Implicit forward declaration
  568|      1|                let forward_ref = ctx.registry.declare_enum(Some(tag_name), ctx.registry.type_int);
  569|       |
  570|      1|                ctx.symbol_table.define_enum(tag_name, forward_ref, span);
  571|      1|                Ok(forward_ref)
  572|       |            }
  573|       |        }
  574|       |    } else {
  575|       |        // Anonymous enum definition
  576|      1|        Ok(ctx.registry.declare_enum(None, ctx.registry.type_int))
  577|       |    }
  578|     22|}
  579|       |
  580|       |/// Recursively validates that there are no duplicate member names, descending into anonymous records.
  581|       |///
  582|       |///  Bolt: This function is optimized to avoid heap allocations.
  583|       |/// Instead of taking a mutable `LowerCtx` and cloning member lists to satisfy the
  584|       |/// borrow checker, it now takes an immutable `&TypeRegistry` and returns a `Vec`
  585|       |/// of diagnostics. This avoids expensive `members.clone()` operations, especially
  586|       |/// in deeply nested anonymous structs/unions.
  587|    137|fn validate_record_members(
  588|    137|    registry: &TypeRegistry,
  589|    137|    members: &[StructMember],
  590|    137|    seen_names: &mut HashMap<NameId, SourceSpan>,
  591|    137|) -> Vec<SemanticError> {
  592|    137|    let mut errors = Vec::new();
  593|       |
  594|    366|    for member in members {
                      ^229
  595|    229|        if let Some(name) = member.name {
                                  ^213
  596|    213|            if let Some(&first_def) = seen_names.get(&name) {
                                       ^3
  597|      3|                errors.push(SemanticError::DuplicateMember {
  598|      3|                    name,
  599|      3|                    span: member.span,
  600|      3|                    first_def,
  601|      3|                });
  602|    210|            } else {
  603|    210|                seen_names.insert(name, member.span);
  604|    210|            }
  605|       |        } else {
  606|       |            // Anonymous member, recurse
  607|     16|            let member_ty = member.member_type;
  608|     16|            if member_ty.is_record()
  609|       |                && let TypeKind::Record {
  610|     15|                    members: inner_members, ..
  611|     15|                } = &registry.get(member_ty.ty()).kind
  612|     15|            {
  613|     15|                errors.extend(validate_record_members(registry, inner_members, seen_names));
  614|     15|            }
                          ^1
  615|       |        }
  616|       |    }
  617|    137|    errors
  618|    137|}
  619|       |
  620|    122|fn complete_record_symbol(
  621|    122|    ctx: &mut LowerCtx,
  622|    122|    tag: Option<NameId>,
  623|    122|    type_ref: TypeRef,
  624|    122|    members: Vec<StructMember>,
  625|    122|) -> Result<(), SemanticError> {
  626|       |    // New: Validate for name conflicts across anonymous members
  627|    122|    let mut seen_names = HashMap::new();
  628|    122|    let validation_errors = validate_record_members(ctx.registry, &members, &mut seen_names);
  629|    125|    for error in validation_errors {
                      ^3
  630|      3|        ctx.report_error(error);
  631|      3|    }
  632|       |
  633|       |    // Update the type in AST and SymbolTable
  634|    122|    ctx.registry.complete_record(type_ref, members.clone());
  635|    122|    ctx.registry.ensure_layout(type_ref)?;
                                                      ^4
  636|       |
  637|    118|    if let Some(tag_name) = tag
                              ^97
  638|     97|        && let Some((entry_ref, _)) = ctx.symbol_table.lookup_tag(tag_name)
  639|       |    {
  640|     97|        let entry = ctx.symbol_table.get_symbol_mut(entry_ref);
  641|     97|        entry.is_completed = true;
  642|       |        if let SymbolKind::Record {
  643|     97|            is_complete,
  644|     97|            members: entry_members,
  645|       |            ..
  646|     97|        } = &mut entry.kind
  647|     97|        {
  648|     97|            *is_complete = true;
  649|     97|            *entry_members = Arc::from(members); // This is now the original value
  650|     97|        }
                      ^0
  651|     21|    }
  652|    118|    Ok(())
  653|    122|}
  654|       |
  655|     15|fn complete_enum_symbol(
  656|     15|    ctx: &mut LowerCtx,
  657|     15|    tag: Option<NameId>,
  658|     15|    type_ref: TypeRef,
  659|     15|    enumerators: Vec<EnumConstant>,
  660|     15|) -> Result<(), SemanticError> {
  661|       |    // Update the type in AST and SymbolTable using the proper completion function
  662|     15|    ctx.registry.complete_enum(type_ref, enumerators);
  663|     15|    ctx.registry.ensure_layout(type_ref)?;
                                                      ^0
  664|       |
  665|     15|    if let Some(tag_name) = tag
                              ^14
  666|     14|        && let Some((entry_ref, _)) = ctx.symbol_table.lookup_tag(tag_name)
  667|       |    {
  668|     14|        let entry = ctx.symbol_table.get_symbol_mut(entry_ref);
  669|     14|        entry.is_completed = true;
  670|     14|        if let SymbolKind::EnumTag { is_complete } = &mut entry.kind {
  671|     14|            *is_complete = true;
  672|     14|        }
                      ^0
  673|      1|    }
  674|     15|    Ok(())
  675|     15|}
  676|       |
  677|       |/// Resolve a type specifier to a QualType
  678|  1.90k|fn resolve_type_specifier(
  679|  1.90k|    ts: &ParsedTypeSpecifier,
  680|  1.90k|    ctx: &mut LowerCtx,
  681|  1.90k|    span: SourceSpan,
  682|  1.90k|) -> Result<QualType, SemanticError> {
  683|  1.90k|    match ts {
  684|    162|        ParsedTypeSpecifier::Void => Ok(QualType::unqualified(ctx.registry.type_void)),
  685|    105|        ParsedTypeSpecifier::Char => Ok(QualType::unqualified(ctx.registry.type_char)),
  686|     15|        ParsedTypeSpecifier::Short => Ok(QualType::unqualified(ctx.registry.type_short)),
  687|    925|        ParsedTypeSpecifier::Int => Ok(QualType::unqualified(ctx.registry.type_int)),
  688|     44|        ParsedTypeSpecifier::Long => Ok(QualType::unqualified(ctx.registry.type_long)),
  689|     59|        ParsedTypeSpecifier::LongLong => Ok(QualType::unqualified(ctx.registry.type_long_long)),
  690|       |        // New variants
  691|      6|        ParsedTypeSpecifier::UnsignedLong => Ok(QualType::unqualified(ctx.registry.type_long_unsigned)),
  692|      4|        ParsedTypeSpecifier::UnsignedLongLong => Ok(QualType::unqualified(ctx.registry.type_long_long_unsigned)),
  693|      4|        ParsedTypeSpecifier::UnsignedShort => Ok(QualType::unqualified(ctx.registry.type_short_unsigned)),
  694|      2|        ParsedTypeSpecifier::UnsignedChar => Ok(QualType::unqualified(ctx.registry.type_char_unsigned)),
  695|      2|        ParsedTypeSpecifier::SignedChar => Ok(QualType::unqualified(ctx.registry.type_schar)),
  696|      3|        ParsedTypeSpecifier::SignedShort => Ok(QualType::unqualified(ctx.registry.type_short)),
  697|      3|        ParsedTypeSpecifier::SignedLong => Ok(QualType::unqualified(ctx.registry.type_long)),
  698|      3|        ParsedTypeSpecifier::SignedLongLong => Ok(QualType::unqualified(ctx.registry.type_long_long)),
  699|       |
  700|     44|        ParsedTypeSpecifier::Float => Ok(QualType::unqualified(ctx.registry.type_float)),
  701|     33|        ParsedTypeSpecifier::Double => Ok(QualType::unqualified(ctx.registry.type_double)),
  702|     11|        ParsedTypeSpecifier::LongDouble => Ok(QualType::unqualified(ctx.registry.type_long_double)),
  703|       |        ParsedTypeSpecifier::ComplexFloat => {
  704|      5|            let complex_type = ctx.registry.complex_type(ctx.registry.type_float);
  705|      5|            Ok(QualType::unqualified(complex_type))
  706|       |        }
  707|       |        ParsedTypeSpecifier::ComplexDouble => {
  708|      4|            let complex_type = ctx.registry.complex_type(ctx.registry.type_double);
  709|      4|            Ok(QualType::unqualified(complex_type))
  710|       |        }
  711|       |        ParsedTypeSpecifier::ComplexLongDouble => {
  712|      3|            let complex_type = ctx.registry.complex_type(ctx.registry.type_long_double);
  713|      3|            Ok(QualType::unqualified(complex_type))
  714|       |        }
  715|       |        ParsedTypeSpecifier::Signed => {
  716|       |            // Signed modifier
  717|      6|            Ok(QualType::unqualified(ctx.registry.type_signed))
  718|       |        }
  719|       |        ParsedTypeSpecifier::Unsigned => {
  720|       |            // Unsigned modifier - return a special marker type that will be handled in merge_base_type
  721|     49|            Ok(QualType::unqualified(ctx.registry.type_int_unsigned))
  722|       |        }
  723|      5|        ParsedTypeSpecifier::Bool => Ok(QualType::unqualified(ctx.registry.type_bool)),
  724|     45|        ParsedTypeSpecifier::Complex => Ok(QualType::unqualified(ctx.registry.type_complex_marker)),
  725|     59|        ParsedTypeSpecifier::Atomic(parsed_type) => {
  726|       |            // Convert the ParsedType to a TypeRef by applying the declarator to the base type
  727|     59|            let qt = convert_to_qual_type(ctx, *parsed_type, span, false)?;
                                                                                       ^0
  728|       |
  729|       |            // C11 6.7.2.4p3: shall not be used if the type-name is an array type,
  730|       |            // a function type, an atomic type, or a qualified type.
  731|     59|            if qt.is_array() {
  732|      1|                ctx.report_error(SemanticError::InvalidAtomicSpecifier {
  733|      1|                    reason: "array type".to_string(),
  734|      1|                    span,
  735|      1|                });
  736|     58|            } else if qt.is_function() {
  737|      1|                ctx.report_error(SemanticError::InvalidAtomicSpecifier {
  738|      1|                    reason: "function type".to_string(),
  739|      1|                    span,
  740|      1|                });
  741|     57|            } else if qt.qualifiers().contains(TypeQualifiers::ATOMIC) {
  742|      3|                ctx.report_error(SemanticError::InvalidAtomicSpecifier {
  743|      3|                    reason: "atomic type".to_string(),
  744|      3|                    span,
  745|      3|                });
  746|     54|            } else if !qt.qualifiers().is_empty() {
  747|      2|                ctx.report_error(SemanticError::InvalidAtomicSpecifier {
  748|      2|                    reason: "qualified type".to_string(),
  749|      2|                    span,
  750|      2|                });
  751|     52|            }
  752|       |
  753|     59|            Ok(ctx.registry.merge_qualifiers(qt, TypeQualifiers::ATOMIC))
  754|       |        }
  755|    215|        ParsedTypeSpecifier::Record(is_union, tag, definition) => {
  756|       |            // ... resolve_record_tag works same args ...
  757|    215|            let is_definition = definition.is_some();
  758|    215|            let type_ref = resolve_record_tag(ctx, *tag, *is_union, is_definition, span)?;
                                                                                                      ^0
  759|       |
  760|       |            // Now handle members if it's a definition
  761|    215|            if let Some(def) = definition {
                                      ^119
  762|       |                // def is ParsedRecordDefData. members is Option<Vec<ParsedDeclarationData>>.
  763|       |                // visit_struct_members expects Vec<ParsedDeclarationData>?
  764|       |                // It expects &[DeclarationData] before.
  765|       |                // I need to update visit_struct_members as well.
  766|    119|                let members = def
  767|    119|                    .members
  768|    119|                    .as_ref()
  769|    119|                    .map(|decls| visit_struct_members(decls, ctx, span))
  770|    119|                    .unwrap_or_default();
  771|       |
  772|    119|                complete_record_symbol(ctx, *tag, type_ref, members)?;
                                                                                  ^4
  773|     96|            }
  774|       |
  775|    211|            Ok(QualType::unqualified(type_ref))
  776|       |        }
  777|     22|        ParsedTypeSpecifier::Enum(tag, enumerators) => {
  778|     22|            let is_definition = enumerators.is_some();
  779|     22|            let type_ref_to_use = resolve_enum_tag(ctx, *tag, is_definition, span)?;
                                                                                                ^0
  780|       |
  781|       |            // 2. Process enumerators if it's a definition
  782|     22|            if let Some(enums) = enumerators {
                                      ^15
  783|     15|                let mut next_value = 0i64;
  784|     15|                let mut enumerators_list = Vec::new();
  785|       |
  786|     46|                for &enum_ref in enums {
                                   ^31
  787|       |                    // Get node from PARSED ast
  788|     31|                    let enum_node = ctx.parsed_ast.get_node(enum_ref);
  789|     31|                    if let ParsedNodeKind::EnumConstant(name, value_expr_ref) = &enum_node.kind {
  790|     31|                        let (value, init_expr) = if let Some(v_ref) = value_expr_ref {
                                                                           ^12
  791|     12|                            let expr_ref = ctx.visit_expression(*v_ref);
  792|     12|                            if let Some(val) = const_eval::eval_const_expr(&ctx.const_ctx(), expr_ref) {
  793|     12|                                (val, Some(expr_ref))
  794|       |                            } else {
  795|      0|                                ctx.report_error(SemanticError::NonConstantInitializer { span: enum_node.span });
  796|      0|                                (0, Some(expr_ref))
  797|       |                            }
  798|       |                        } else {
  799|     19|                            (next_value, None)
  800|       |                        };
  801|     31|                        next_value = value + 1;
  802|       |
  803|     31|                        let enum_constant = EnumConstant {
  804|     31|                            name: *name,
  805|     31|                            value,
  806|     31|                            span: enum_node.span,
  807|     31|                            init_expr,
  808|     31|                        };
  809|     31|                        enumerators_list.push(enum_constant);
  810|       |
  811|       |                        // Register constant in symbol table
  812|     31|                        if let Err(SymbolTableError::InvalidRedefinition { existing, .. }) = ctx
                                                                                         ^1
  813|     31|                            .symbol_table
  814|     31|                            .define_enum_constant(*name, value, type_ref_to_use, enum_node.span)
  815|      1|                        {
  816|      1|                            let first_def = ctx.symbol_table.get_symbol(existing).def_span;
  817|      1|                            ctx.report_error(SemanticError::Redefinition {
  818|      1|                                name: *name,
  819|      1|                                first_def,
  820|      1|                                span: enum_node.span,
  821|      1|                            });
  822|     30|                        }
  823|      0|                    }
  824|       |                }
  825|       |
  826|     15|                complete_enum_symbol(ctx, *tag, type_ref_to_use, enumerators_list)?;
                                                                                                ^0
  827|      7|            }
  828|       |
  829|     22|            Ok(QualType::unqualified(type_ref_to_use))
  830|       |        }
  831|     55|        ParsedTypeSpecifier::TypedefName(name) => {
  832|       |            // Lookup typedef in symbol table
  833|     55|            if let Some((entry_ref, _scope_id)) = ctx.symbol_table.lookup_symbol(*name) {
  834|     55|                let entry = ctx.symbol_table.get_symbol(entry_ref);
  835|     55|                if let SymbolKind::Typedef { aliased_type } = entry.kind {
  836|     55|                    Ok(aliased_type)
  837|       |                } else {
  838|      0|                    let kind_string = format!("{:?}", entry.kind);
  839|      0|                    let found_kind_str = kind_string.split_whitespace().next().unwrap_or("symbol");
  840|      0|                    Err(SemanticError::ExpectedTypedefName {
  841|      0|                        found: format!("a {}", found_kind_str.to_lowercase()),
  842|      0|                        span,
  843|      0|                    })
  844|       |                }
  845|       |            } else {
  846|      0|                Ok(QualType::unqualified(ctx.registry.declare_record(Some(*name), false)))
  847|       |            }
  848|       |        }
  849|      7|        ParsedTypeSpecifier::VaList => Ok(QualType::unqualified(ctx.registry.type_valist)),
  850|       |    }
  851|  1.90k|}
  852|       |
  853|       |/// Merge base types according to C type combination rules
  854|  1.73k|fn merge_base_type(
  855|  1.73k|    existing: Option<QualType>,
  856|  1.73k|    new_type: QualType,
  857|  1.73k|    ctx: &mut LowerCtx,
  858|  1.73k|    span: SourceSpan,
  859|  1.73k|) -> Option<QualType> {
  860|  1.73k|    match existing {
  861|  1.61k|        None => Some(new_type),
  862|    116|        Some(existing_ref) => {
  863|    116|            let existing_type = ctx.registry.get(existing_ref.ty());
  864|    116|            let new_type_info = ctx.registry.get(new_type.ty());
  865|       |
  866|    116|            match (&existing_type.kind, &new_type_info.kind) {
  867|    116|                (TypeKind::Builtin(existing_builtin), TypeKind::Builtin(new_builtin)) => {
  868|    116|                    match (existing_builtin, new_builtin) {
  869|       |                        // 1. Same types (redundancy)
  870|    116|                        (a, b) if a == b => {
                                       ^1 ^1         ^1
  871|       |                            // C99/C11: int int is NOT allowed, but long long is.
  872|       |                            // However, many compilers allow redundant specifiers.
  873|       |                            // In Cendol, we'll allow it if they are identical,
  874|       |                            // EXCEPT for types that already have a combined form (like long long).
  875|      1|                            if *a == BuiltinType::Long {
  876|      1|                                Some(QualType::unqualified(ctx.registry.type_long_long))
  877|       |                            } else {
  878|      0|                                Some(existing_ref)
  879|       |                            }
  880|       |                        }
  881|       |
  882|       |                        // 2. Handle Signed as a modifier
  883|      1|                        (BuiltinType::Signed, BuiltinType::Int) => Some(new_type),
  884|      0|                        (BuiltinType::Int, BuiltinType::Signed) => Some(existing_ref),
  885|       |
  886|       |                        (BuiltinType::Signed, BuiltinType::Char) => {
  887|      3|                            Some(QualType::unqualified(ctx.registry.type_schar))
  888|       |                        }
  889|       |                        (BuiltinType::Char, BuiltinType::Signed) => {
  890|      0|                            Some(QualType::unqualified(ctx.registry.type_schar))
  891|       |                        }
  892|       |
  893|      0|                        (BuiltinType::Signed, BuiltinType::Short) => Some(new_type),
  894|      0|                        (BuiltinType::Short, BuiltinType::Signed) => Some(existing_ref),
  895|       |
  896|      2|                        (BuiltinType::Signed, BuiltinType::Long) => Some(new_type),
  897|      0|                        (BuiltinType::Long, BuiltinType::Signed) => Some(existing_ref),
  898|       |
  899|      0|                        (BuiltinType::Signed, BuiltinType::LongLong) => Some(new_type),
  900|      0|                        (BuiltinType::LongLong, BuiltinType::Signed) => Some(existing_ref),
  901|       |
  902|       |                        // 3. Unsigned overrides signed/marker
  903|      1|                        (BuiltinType::Int, BuiltinType::UInt) => Some(new_type),
  904|      6|                        (BuiltinType::UInt, BuiltinType::Int) => Some(existing_ref),
  905|       |
  906|      0|                        (BuiltinType::Signed, BuiltinType::UInt) => Some(new_type),
  907|      0|                        (BuiltinType::UInt, BuiltinType::Signed) => Some(existing_ref),
  908|       |
  909|       |                        // Char + Unsigned -> UChar
  910|       |                        (BuiltinType::Char, BuiltinType::UInt) => {
  911|      0|                            Some(QualType::unqualified(ctx.registry.type_char_unsigned))
  912|       |                        }
  913|       |                        (BuiltinType::UInt, BuiltinType::Char) => {
  914|      9|                            Some(QualType::unqualified(ctx.registry.type_char_unsigned))
  915|       |                        }
  916|       |
  917|       |                        // Short + Unsigned -> UShort
  918|       |                        (BuiltinType::Short, BuiltinType::UInt) => {
  919|      0|                            Some(QualType::unqualified(ctx.registry.type_short_unsigned))
  920|       |                        }
  921|       |                        (BuiltinType::UInt, BuiltinType::Short) => {
  922|      6|                            Some(QualType::unqualified(ctx.registry.type_short_unsigned))
  923|       |                        }
  924|       |
  925|       |                        // Long + Unsigned -> ULong
  926|       |                        (BuiltinType::Long, BuiltinType::UInt) => {
  927|      3|                            Some(QualType::unqualified(ctx.registry.type_long_unsigned))
  928|       |                        }
  929|       |                        (BuiltinType::UInt, BuiltinType::Long) => {
  930|     18|                            Some(QualType::unqualified(ctx.registry.type_long_unsigned))
  931|       |                        }
  932|       |
  933|       |                        // LongLong + Unsigned -> ULongLong
  934|       |                        (BuiltinType::LongLong, BuiltinType::UInt) => {
  935|      1|                            Some(QualType::unqualified(ctx.registry.type_long_long_unsigned))
  936|       |                        }
  937|       |                        (BuiltinType::UInt, BuiltinType::LongLong) => {
  938|      4|                            Some(QualType::unqualified(ctx.registry.type_long_long_unsigned))
  939|       |                        }
  940|       |
  941|       |                        // 4. Redundant 'int' combined with other specifiers
  942|      2|                        (BuiltinType::Short, BuiltinType::Int) => Some(existing_ref),
  943|      0|                        (BuiltinType::Int, BuiltinType::Short) => Some(new_type),
  944|      2|                        (BuiltinType::UShort, BuiltinType::Int) => Some(existing_ref),
  945|      0|                        (BuiltinType::Int, BuiltinType::UShort) => Some(new_type),
  946|       |
  947|      3|                        (BuiltinType::Long, BuiltinType::Int) => Some(existing_ref),
  948|      1|                        (BuiltinType::Int, BuiltinType::Long) => Some(new_type),
  949|      4|                        (BuiltinType::ULong, BuiltinType::Int) => Some(existing_ref),
  950|      0|                        (BuiltinType::Int, BuiltinType::ULong) => Some(new_type),
  951|       |
  952|      2|                        (BuiltinType::LongLong, BuiltinType::Int) => Some(existing_ref),
  953|      0|                        (BuiltinType::Int, BuiltinType::LongLong) => Some(new_type),
  954|      2|                        (BuiltinType::ULongLong, BuiltinType::Int) => Some(existing_ref),
  955|      0|                        (BuiltinType::Int, BuiltinType::ULongLong) => Some(new_type),
  956|       |
  957|       |                        // 5. Long + Long -> LongLong (handled by case 1 above partially, but let's be explicit if needed)
  958|       |                        // (BuiltinType::Long, BuiltinType::Long) is already handled in case 1.
  959|       |
  960|       |                        // Long + LongLong -> LongLong
  961|      0|                        (BuiltinType::Long, BuiltinType::LongLong) => Some(new_type),
  962|      0|                        (BuiltinType::LongLong, BuiltinType::Long) => Some(existing_ref),
  963|       |
  964|       |                        // ULong + Long -> ULongLong
  965|       |                        (BuiltinType::ULong, BuiltinType::Long) => {
  966|      1|                            Some(QualType::unqualified(ctx.registry.type_long_long_unsigned))
  967|       |                        }
  968|       |                        (BuiltinType::Long, BuiltinType::ULong) => {
  969|      0|                            Some(QualType::unqualified(ctx.registry.type_long_long_unsigned))
  970|       |                        }
  971|       |
  972|       |                        // Long + ULongLong -> ULongLong
  973|      0|                        (BuiltinType::Long, BuiltinType::ULongLong) => Some(new_type),
  974|      0|                        (BuiltinType::ULongLong, BuiltinType::Long) => Some(existing_ref),
  975|       |
  976|       |                        // Long + Double -> LongDouble
  977|       |                        (BuiltinType::Double, BuiltinType::Long) => {
  978|      0|                            Some(QualType::unqualified(ctx.registry.type_long_double))
  979|       |                        }
  980|       |                        (BuiltinType::Long, BuiltinType::Double) => {
  981|      0|                            Some(QualType::unqualified(ctx.registry.type_long_double))
  982|       |                        }
  983|       |
  984|       |                        // Complex combinations
  985|       |                        (BuiltinType::Complex, BuiltinType::Float) | (BuiltinType::Float, BuiltinType::Complex) => {
  986|     25|                            Some(QualType::unqualified(
  987|     25|                                ctx.registry.complex_type(ctx.registry.type_float),
  988|     25|                            ))
  989|       |                        }
  990|       |                        (BuiltinType::Complex, BuiltinType::Double) | (BuiltinType::Double, BuiltinType::Complex) => {
  991|     17|                            Some(QualType::unqualified(
  992|     17|                                ctx.registry.complex_type(ctx.registry.type_double),
  993|     17|                            ))
  994|       |                        }
  995|       |                        (BuiltinType::Complex, BuiltinType::LongDouble)
  996|      2|                        | (BuiltinType::LongDouble, BuiltinType::Complex) => Some(QualType::unqualified(
  997|      2|                            ctx.registry.complex_type(ctx.registry.type_long_double),
  998|      2|                        )),
  999|       |
 1000|       |                        // Error for other combinations (e.g. double int)
 1001|       |                        _ => {
 1002|      0|                            ctx.report_error(SemanticError::ConflictingTypeSpecifiers {
 1003|      0|                                prev: ctx.registry.display_qual_type(existing_ref),
 1004|      0|                                span,
 1005|      0|                            });
 1006|      0|                            Some(QualType::unqualified(ctx.registry.type_error))
 1007|       |                        }
 1008|       |                    }
 1009|       |                }
 1010|       |                _ => {
 1011|      0|                    ctx.report_error(SemanticError::ConflictingTypeSpecifiers {
 1012|      0|                        prev: ctx.registry.display_qual_type(existing_ref),
 1013|      0|                        span,
 1014|      0|                    });
 1015|      0|                    Some(QualType::unqualified(ctx.registry.type_error))
 1016|       |                }
 1017|       |            }
 1018|       |        }
 1019|       |    }
 1020|  1.73k|}
 1021|       |
 1022|       |/// Validate specifier combinations for semantic correctness
 1023|  1.61k|fn validate_specifier_combinations(info: &DeclSpecInfo, ctx: &mut LowerCtx, span: SourceSpan) {
 1024|       |    // Check typedef with other storage classes
 1025|  1.61k|    if info.is_typedef && (info.storage.is_some_and(|s| s != StorageClass::Typedef) || info.is_thread_local) {
                                         ^50          ^50             ^50  ^50                       ^49
 1026|      1|        ctx.report_error(SemanticError::ConflictingStorageClasses { span });
 1027|  1.61k|    }
 1028|       |
 1029|       |    // _Alignas constraints (C11 6.7.5p3)
 1030|  1.61k|    if info.alignment.is_some() && info.storage == Some(StorageClass::Register) {
                                                 ^14
 1031|      1|        ctx.report_error(SemanticError::AlignmentNotAllowed {
 1032|      1|            context: "register object".to_string(),
 1033|      1|            span,
 1034|      1|        });
 1035|  1.61k|    }
 1036|       |
 1037|       |    // _Thread_local constraints (C11 6.7.1p3)
 1038|  1.61k|    if info.is_thread_local {
 1039|       |        // Can only be used alone or with static/extern
 1040|      2|        if let Some(s) = info.storage
                                  ^0
 1041|      0|            && s != StorageClass::Static
 1042|      0|            && s != StorageClass::Extern
 1043|      0|        {
 1044|      0|            ctx.report_error(SemanticError::ConflictingStorageClasses { span });
 1045|      2|        }
 1046|  1.61k|    }
 1047|       |
 1048|       |    // Check for missing required specifiers (type specifier)
 1049|  1.61k|    if info.base_type.is_none() {
 1050|      0|        ctx.report_error(SemanticError::MissingTypeSpecifier { span });
 1051|  1.61k|    }
 1052|  1.61k|}
 1053|       |
 1054|       |/// Parse and validate declaration specifiers
 1055|  1.61k|fn visit_decl_specifiers(specs: &[ParsedDeclSpecifier], ctx: &mut LowerCtx, span: SourceSpan) -> DeclSpecInfo {
 1056|  1.61k|    let mut info = DeclSpecInfo::default();
 1057|       |
 1058|  3.55k|    for spec in specs {
                      ^1.93k
 1059|  1.93k|        match spec {
 1060|    106|            ParsedDeclSpecifier::StorageClass(sc) => {
 1061|    106|                if *sc == StorageClass::ThreadLocal {
 1062|      2|                    if info.is_thread_local {
 1063|      0|                        // duplicate _Thread_local
 1064|      0|                        ctx.report_error(SemanticError::ConflictingStorageClasses { span });
 1065|      2|                    }
 1066|      2|                    info.is_thread_local = true;
 1067|       |                } else {
 1068|    104|                    if info.storage.is_some() {
 1069|      2|                        ctx.report_error(SemanticError::ConflictingStorageClasses { span });
 1070|    102|                    }
 1071|    104|                    if *sc == StorageClass::Typedef {
 1072|     50|                        info.is_typedef = true;
 1073|     54|                    }
 1074|    104|                    info.storage = Some(*sc);
 1075|       |                }
 1076|       |            }
 1077|     72|            ParsedDeclSpecifier::TypeQualifier(tq) => {
 1078|     72|                let mask = match tq {
 1079|     65|                    TypeQualifier::Const => TypeQualifiers::CONST,
 1080|      1|                    TypeQualifier::Volatile => TypeQualifiers::VOLATILE,
 1081|      2|                    TypeQualifier::Restrict => TypeQualifiers::RESTRICT,
 1082|      4|                    TypeQualifier::Atomic => TypeQualifiers::ATOMIC,
 1083|       |                };
 1084|     72|                info.qualifiers.insert(mask);
 1085|       |            }
 1086|  1.73k|            ParsedDeclSpecifier::TypeSpecifier(ts) => {
 1087|  1.73k|                let ty = resolve_type_specifier(ts, ctx, span).unwrap_or_else(|e| {
                                                                                                ^4
 1088|      4|                    ctx.report_error(e);
 1089|      4|                    QualType::unqualified(ctx.registry.type_error)
 1090|      4|                });
 1091|  1.73k|                info.base_type = merge_base_type(info.base_type, ty, ctx, span);
 1092|       |            }
 1093|     18|            ParsedDeclSpecifier::AlignmentSpecifier(align) => {
 1094|     18|                let align_val: Option<u32> = match align {
 1095|      2|                    ParsedAlignmentSpecifier::Type(parsed_ty) => {
 1096|      2|                        let qt = convert_to_qual_type(ctx, *parsed_ty, span, false)
 1097|      2|                            .unwrap_or(QualType::unqualified(ctx.registry.type_error));
 1098|      2|                        match ctx.registry.ensure_layout(qt.ty()) {
 1099|      2|                            Ok(layout) => Some(layout.alignment as u32),
 1100|      0|                            Err(e) => {
 1101|      0|                                ctx.report_error(e);
 1102|      0|                                None
 1103|       |                            }
 1104|       |                        }
 1105|       |                    }
 1106|     16|                    ParsedAlignmentSpecifier::Expr(expr_ref) => {
 1107|     16|                        let lowered_expr = ctx.visit_expression(*expr_ref);
 1108|     16|                        let const_ctx = ctx.const_ctx();
 1109|     16|                        if let Some(val) = const_eval::eval_const_expr(&const_ctx, lowered_expr) {
                                                  ^15
 1110|     15|                            if val > 0 && (val as u64).is_power_of_two() {
                                                        ^14          ^14
 1111|     13|                                Some(val as u32)
 1112|      2|                            } else if val == 0 {
 1113|      1|                                None
 1114|       |                            } else {
 1115|      1|                                ctx.report_error(SemanticError::InvalidAlignment { value: val, span });
 1116|      1|                                None
 1117|       |                            }
 1118|       |                        } else {
 1119|      1|                            ctx.report_error(SemanticError::NonConstantAlignment { span });
 1120|      1|                            None
 1121|       |                        }
 1122|       |                    }
 1123|       |                };
 1124|       |
 1125|     18|                if let Some(val) = align_val {
                                          ^15
 1126|     15|                    info.alignment = Some(std::cmp::max(info.alignment.unwrap_or(0), val));
 1127|     15|                }
                              ^3
 1128|       |            }
 1129|      8|            ParsedDeclSpecifier::FunctionSpecifier(fs) => match fs {
 1130|      2|                FunctionSpecifier::Inline => info.is_inline = true,
 1131|      6|                FunctionSpecifier::Noreturn => info.is_noreturn = true,
 1132|       |            },
 1133|      0|            ParsedDeclSpecifier::Attribute => {
 1134|      0|                // Ignore attributes for now
 1135|      0|            }
 1136|       |        }
 1137|       |    }
 1138|       |
 1139|       |    // Finalize base type: 'signed' without anything else defaults to 'int'
 1140|  1.61k|    if let Some(base) = info.base_type {
 1141|  1.61k|        if base.ty() == ctx.registry.type_signed {
 1142|      0|            info.base_type = Some(QualType::unqualified(ctx.registry.type_int));
 1143|  1.61k|        } else if base.ty() == ctx.registry.type_complex_marker {
 1144|      1|            // Standalone _Complex defaults to double _Complex
 1145|      1|            info.base_type = Some(QualType::unqualified(
 1146|      1|                ctx.registry.complex_type(ctx.registry.type_double),
 1147|      1|            ));
 1148|  1.61k|        }
 1149|      0|    }
 1150|       |
 1151|  1.61k|    validate_specifier_combinations(&info, ctx, span);
 1152|  1.61k|    info
 1153|  1.61k|}
 1154|       |
 1155|    838|fn visit_function_parameters(
 1156|    838|    params: &[ParsedParamData],
 1157|    838|    ctx: &mut LowerCtx,
 1158|    838|    is_definition: bool,
 1159|    838|) -> Vec<FunctionParameter> {
 1160|    838|    let mut seen_names = HashMap::new();
 1161|    838|    params
 1162|    838|        .iter()
 1163|    838|        .map(|param| {
                                   ^253
 1164|    253|            let span = param.span;
 1165|    253|            let spec_info = visit_decl_specifiers(&param.specifiers, ctx, span);
 1166|       |
 1167|       |            // C standard: if type specifier is missing in a parameter, it defaults to int.
 1168|    253|            let mut base_ty = spec_info
 1169|    253|                .base_type
 1170|    253|                .unwrap_or_else(|| QualType::unqualified(ctx.registry.type_int));
                                                 ^0                    ^0
 1171|    253|            base_ty = ctx.registry.merge_qualifiers(base_ty, spec_info.qualifiers);
 1172|       |
 1173|    253|            let final_ty = if let Some(declarator) = &param.declarator {
                                                     ^240
 1174|    240|                apply_declarator(
 1175|    240|                    base_ty,
 1176|    240|                    declarator,
 1177|    240|                    ctx,
 1178|    240|                    span,
 1179|    240|                    &spec_info,
 1180|    240|                    DeclaratorContext { in_parameter: true },
 1181|       |                )
 1182|       |            } else {
 1183|     13|                base_ty
 1184|       |            };
 1185|       |
 1186|       |            // Apply array-to-pointer decay for function parameters (C11 6.7.6.3)
 1187|    253|            let ptr_quals = if let Some(decl) = &param.declarator {
                                                      ^240
 1188|    240|                extract_array_param_qualifiers(decl)
 1189|       |            } else {
 1190|     13|                TypeQualifiers::empty()
 1191|       |            };
 1192|    253|            let decayed_ty = ctx.registry.decay(final_ty, ptr_quals);
 1193|       |
 1194|    253|            let pname = param.declarator.as_ref().and_then(extract_name);
 1195|       |
 1196|       |            // C11 6.7.6.3p4: After adjustment, the parameters ... shall not have incomplete type.
 1197|       |            // C11 6.7.6.3p10: The special case of an unnamed parameter of type void as the only item
 1198|       |            // in the list specifies that the function has no parameters.
 1199|    253|            if is_definition && !ctx.registry.is_complete(decayed_ty.ty()) {
                                              ^85^85          ^85
 1200|      2|                let is_void_param_list = params.len() == 1 && decayed_ty.is_void() && pname.is_none();
                                                                            ^1         ^1           ^1    ^1
 1201|      2|                if !is_void_param_list {
 1202|      2|                    ctx.report_error(SemanticError::IncompleteType {
 1203|      2|                        ty: ctx.registry.display_qual_type(decayed_ty),
 1204|      2|                        span,
 1205|      2|                    });
 1206|      2|                }
                              ^0
 1207|    251|            }
 1208|       |
 1209|    253|            if let Some(name) = pname {
                                      ^212
 1210|    212|                if let Some(&first_def) = seen_names.get(&name) {
                                           ^3
 1211|      3|                    ctx.report_error(SemanticError::Redefinition { name, first_def, span });
 1212|    209|                } else {
 1213|    209|                    seen_names.insert(name, span);
 1214|    209|                }
 1215|     41|            }
 1216|       |
 1217|    253|            if spec_info.alignment.is_some() {
 1218|      2|                ctx.report_error(SemanticError::AlignmentNotAllowed {
 1219|      2|                    context: "function parameter".to_string(),
 1220|      2|                    span,
 1221|      2|                });
 1222|    251|            }
 1223|       |
 1224|       |            // C11 6.7.6.3p2: "The only storage-class specifier that shall occur in a parameter declaration is register."
 1225|    253|            if let Some(sc) = spec_info.storage
                                      ^12
 1226|     12|                && sc != StorageClass::Register
 1227|      8|            {
 1228|      8|                ctx.report_error(SemanticError::InvalidStorageClassForParameter { span });
 1229|    245|            }
 1230|    253|            if spec_info.is_thread_local {
 1231|      2|                ctx.report_error(SemanticError::InvalidStorageClassForParameter { span });
 1232|    251|            }
 1233|       |
 1234|       |            // Function specifiers are only allowed for functions
 1235|    253|            if spec_info.is_inline {
 1236|      2|                ctx.report_error(SemanticError::InvalidFunctionSpecifier {
 1237|      2|                    spec: "inline".to_string(),
 1238|      2|                    span,
 1239|      2|                });
 1240|    251|            }
 1241|    253|            if spec_info.is_noreturn {
 1242|      2|                ctx.report_error(SemanticError::InvalidFunctionSpecifier {
 1243|      2|                    spec: "_Noreturn".to_string(),
 1244|      2|                    span,
 1245|      2|                });
 1246|    251|            }
 1247|       |
 1248|    253|            FunctionParameter {
 1249|    253|                param_type: decayed_ty,
 1250|    253|                name: pname,
 1251|    253|                storage: spec_info.storage,
 1252|    253|            }
 1253|    253|        })
 1254|    838|        .collect()
 1255|    838|}
 1256|       |
 1257|       |/// Helper to get the actual parameters from the function declarator being defined.
 1258|       |/// This is necessary because interned function types in TypeRegistry might not have
 1259|       |/// the parameter names if the function was previously declared without them.
 1260|    748|fn get_definition_params(decl: &ParsedDeclarator, ctx: &mut LowerCtx) -> Option<Vec<FunctionParameter>> {
 1261|    748|    match decl {
 1262|    373|        ParsedDeclarator::Function { inner, params, .. } => {
 1263|    373|            if let Some(inner_params) = get_definition_params(inner, ctx) {
                                      ^0
 1264|      0|                Some(inner_params)
 1265|       |            } else {
 1266|    373|                Some(visit_function_parameters(params, ctx, true))
 1267|       |            }
 1268|       |        }
 1269|      2|        ParsedDeclarator::Pointer(_, inner) => inner.as_ref().and_then(|d| get_definition_params(d, ctx)),
 1270|      0|        ParsedDeclarator::Array(inner, _) => get_definition_params(inner, ctx),
 1271|      0|        ParsedDeclarator::BitField(inner, _) => get_definition_params(inner, ctx),
 1272|    373|        _ => None,
 1273|       |    }
 1274|    748|}
 1275|       |
 1276|  2.24k|fn extract_name(decl: &ParsedDeclarator) -> Option<NameId> {
 1277|  2.24k|    match decl {
 1278|  1.48k|        ParsedDeclarator::Identifier(name, _) => Some(*name),
 1279|    142|        ParsedDeclarator::Pointer(_, inner) => inner.as_ref().and_then(|d| extract_name(d)),
 1280|    123|        ParsedDeclarator::Array(inner, _) => extract_name(inner),
 1281|    465|        ParsedDeclarator::Function { inner, .. } => extract_name(inner),
 1282|      0|        ParsedDeclarator::BitField(inner, _) => extract_name(inner),
 1283|     29|        _ => None,
 1284|       |    }
 1285|  2.24k|}
 1286|       |
 1287|       |/// Apply declarator transformations to a base type
 1288|  2.24k|fn apply_declarator(
 1289|  2.24k|    base_type: QualType,
 1290|  2.24k|    declarator: &ParsedDeclarator,
 1291|  2.24k|    ctx: &mut LowerCtx,
 1292|  2.24k|    span: SourceSpan,
 1293|  2.24k|    spec_info: &DeclSpecInfo,
 1294|  2.24k|    decl_ctx: DeclaratorContext,
 1295|  2.24k|) -> QualType {
 1296|  2.24k|    match declarator {
 1297|    142|        ParsedDeclarator::Pointer(qualifiers, next) => {
 1298|    142|            let ty = ctx.registry.pointer_to(base_type);
 1299|       |            // Checked merge
 1300|    142|            let modified_ty = ctx.merge_qualifiers_with_check(QualType::unqualified(ty), *qualifiers, span);
 1301|    142|            if let Some(next_decl) = next {
 1302|    142|                apply_declarator(modified_ty, next_decl, ctx, span, spec_info, decl_ctx)
 1303|       |            } else {
 1304|      0|                modified_ty
 1305|       |            }
 1306|       |        }
 1307|  1.48k|        ParsedDeclarator::Identifier(_, qualifiers) => ctx.merge_qualifiers_with_check(base_type, *qualifiers, span),
 1308|    123|        ParsedDeclarator::Array(base, size) => {
 1309|       |            // C11 6.7.6.2 Array declarators
 1310|       |            // "The element type shall not be an incomplete or function type."
 1311|    123|            if !ctx.registry.is_complete(base_type.ty()) || base_type.ty().is_function() {
                                                                          ^122      ^122 ^122
 1312|      1|                let ty_str = ctx.registry.display_type(base_type.ty());
 1313|      1|                ctx.report_error(SemanticError::IncompleteType { ty: ty_str, span });
 1314|    122|            }
 1315|       |
 1316|       |            // C11 6.7.6.2p1: qualifiers and static in array declarator only allowed in function parameters
 1317|       |            // and only in the outermost array type derivation.
 1318|    123|            let has_quals = match &size {
 1319|     67|                ParsedArraySize::Expression { qualifiers, .. } => !qualifiers.is_empty(),
 1320|      0|                ParsedArraySize::Star { qualifiers } => !qualifiers.is_empty(),
 1321|     21|                ParsedArraySize::VlaSpecifier { qualifiers, .. } => !qualifiers.is_empty(),
 1322|     35|                ParsedArraySize::Incomplete => false,
 1323|       |            };
 1324|    123|            let has_static = matches!(size, ParsedArraySize::VlaSpecifier { is_static: true, .. });
                                           ^9
 1325|       |
 1326|    123|            if has_static || has_quals {
                                           ^114
 1327|     21|                let is_outermost = matches!(
                                                 ^6
 1328|     21|                    base.as_ref(),
 1329|       |                    ParsedDeclarator::Identifier(..)
 1330|       |                        | ParsedDeclarator::Abstract
 1331|       |                        | ParsedDeclarator::AnonymousRecord(..)
 1332|       |                );
 1333|       |
 1334|     21|                if !decl_ctx.in_parameter {
 1335|      2|                    if has_static {
 1336|      1|                        ctx.report_error(SemanticError::ArrayStaticOutsideParameter { span });
 1337|      1|                    }
 1338|      2|                    if has_quals {
 1339|      1|                        ctx.report_error(SemanticError::ArrayQualifierOutsideParameter { span });
 1340|      1|                    }
 1341|     19|                } else if !is_outermost {
 1342|      6|                    if has_static {
 1343|      4|                        ctx.report_error(SemanticError::ArrayStaticNotOutermost { span });
 1344|      4|                    }
                                  ^2
 1345|      6|                    if has_quals {
 1346|      2|                        ctx.report_error(SemanticError::ArrayQualifierNotOutermost { span });
 1347|      4|                    }
 1348|     13|                }
 1349|    102|            }
 1350|       |
 1351|    123|            let array_size = match size {
 1352|     67|                ParsedArraySize::Expression { expr, qualifiers: _ } => resolve_array_size(Some(*expr), ctx),
 1353|      0|                ParsedArraySize::Star { qualifiers: _ } => ArraySizeType::Star,
 1354|     35|                ParsedArraySize::Incomplete => ArraySizeType::Incomplete,
 1355|       |                ParsedArraySize::VlaSpecifier {
 1356|       |                    is_static: _,
 1357|       |                    qualifiers: _,
 1358|     21|                    size,
 1359|     21|                } => resolve_array_size(*size, ctx),
 1360|       |            };
 1361|       |
 1362|    123|            let ty = ctx.registry.array_of(base_type.ty(), array_size);
 1363|    123|            let array_qt = QualType::new(ty, base_type.qualifiers());
 1364|    123|            apply_declarator(array_qt, base, ctx, span, spec_info, decl_ctx)
 1365|       |        }
 1366|       |        ParsedDeclarator::Function {
 1367|    465|            inner: base,
 1368|    465|            params,
 1369|    465|            is_variadic,
 1370|       |        } => {
 1371|    465|            let parameters = visit_function_parameters(params, ctx, false);
 1372|    465|            let ty = ctx
 1373|    465|                .registry
 1374|    465|                .function_type(base_type.ty(), parameters, *is_variadic, spec_info.is_noreturn);
 1375|    465|            apply_declarator(QualType::unqualified(ty), base, ctx, span, spec_info, decl_ctx)
 1376|       |        }
 1377|      0|        ParsedDeclarator::AnonymousRecord(is_union, members) => {
 1378|       |            // Use struct_lowering helper
 1379|      0|            let ty = ctx.registry.declare_record(None, *is_union);
 1380|      0|            let struct_members = visit_struct_members(members, ctx, span);
 1381|      0|            if let Err(e) = complete_record_symbol(ctx, None, ty, struct_members) {
 1382|      0|                ctx.report_error(e);
 1383|      0|            }
 1384|      0|            QualType::unqualified(ty)
 1385|       |        }
 1386|      0|        ParsedDeclarator::BitField(base, _) => {
 1387|       |            // Bitfield logic handled in struct lowering usually. Here just type application.
 1388|      0|            apply_declarator(base_type, base, ctx, span, spec_info, decl_ctx)
 1389|       |        }
 1390|     29|        ParsedDeclarator::Abstract => base_type,
 1391|       |    }
 1392|  2.24k|}
 1393|       |
 1394|       |/// Finalize tentative definitions by converting them to defined state
 1395|    534|fn finalize_tentative_definitions(symbol_table: &mut SymbolTable) {
 1396|    534|    for entry in &mut symbol_table.entries {
                      ^0
 1397|      0|        if entry.scope_id == ScopeId::GLOBAL
 1398|      0|            && matches!(entry.kind, SymbolKind::Variable { .. })
 1399|      0|            && entry.def_state == DefinitionState::Tentative
 1400|      0|        {
 1401|      0|            entry.def_state = DefinitionState::Defined;
 1402|      0|        }
 1403|       |    }
 1404|    534|}
 1405|       |
 1406|       |/// Main entry point for semantic lowering on ParsedAst
 1407|    534|pub(crate) fn visit_ast(
 1408|    534|    parsed_ast: &ParsedAst,
 1409|    534|    ast: &mut Ast,
 1410|    534|    diag: &mut DiagnosticEngine,
 1411|    534|    symbol_table: &mut SymbolTable,
 1412|    534|    registry: &mut TypeRegistry,
 1413|    534|) {
 1414|       |    // Finalize tentative definitions
 1415|    534|    finalize_tentative_definitions(symbol_table);
 1416|       |
 1417|       |    // Create lowering context
 1418|    534|    let mut lower_ctx = LowerCtx::new(parsed_ast, ast, diag, symbol_table, registry);
 1419|       |
 1420|       |    // Perform recursive scope-aware lowering starting from root
 1421|    534|    let root = parsed_ast.get_root();
 1422|    534|    lower_ctx.visit_node(root);
 1423|    534|}
 1424|       |
 1425|       |impl<'a, 'src> LowerCtx<'a, 'src> {
 1426|  3.68k|    pub(crate) fn visit_node(&mut self, parsed_ref: ParsedNodeRef) -> SmallVec<[NodeRef; 1]> {
 1427|  3.68k|        self.visit_node_entry(parsed_ref, None)
 1428|  3.68k|    }
 1429|       |
 1430|  4.79k|    fn visit_node_entry(
 1431|  4.79k|        &mut self,
 1432|  4.79k|        parsed_ref: ParsedNodeRef,
 1433|  4.79k|        target_slots: Option<&[NodeRef]>,
 1434|  4.79k|    ) -> SmallVec<[NodeRef; 1]> {
 1435|  4.79k|        let parsed_node = self.parsed_ast.get_node(parsed_ref);
 1436|  4.79k|        let span = parsed_node.span;
 1437|  4.79k|        let kind = parsed_node.kind.clone();
 1438|       |
 1439|  4.79k|        match kind {
 1440|    534|            ParsedNodeKind::TranslationUnit(children) => {
 1441|    534|                smallvec![self.visit_translation_unit(&children, span)]
                                        ^0   ^0                     ^0         ^0
 1442|       |            }
 1443|    406|            ParsedNodeKind::CompoundStatement(stmts) => {
 1444|    406|                smallvec![self.visit_compound_statement(&stmts, target_slots, span)]
                                        ^0   ^0                       ^0      ^0            ^0
 1445|       |            }
 1446|    339|            ParsedNodeKind::Declaration(decl_data) => self.visit_declaration(&decl_data, span, target_slots),
 1447|      0|            ParsedNodeKind::FunctionDef(func_def) => {
 1448|      0|                let node = self.get_or_push_slot(target_slots, span);
 1449|      0|                self.visit_function_definition(&func_def, node, span);
 1450|      0|                smallvec![node]
 1451|       |            }
 1452|       |            // ... other top level kinds ...
 1453|  3.51k|            _ => self.visit_node_rest(parsed_ref, target_slots),
 1454|       |        }
 1455|  4.79k|    }
 1456|       |
 1457|    534|    fn visit_translation_unit(&mut self, children: &[ParsedNodeRef], span: SourceSpan) -> NodeRef {
 1458|    534|        self.symbol_table.set_current_scope(ScopeId::GLOBAL);
 1459|    534|        let tu_node = self.push_dummy(span);
 1460|       |
 1461|    534|        let mut semantic_node_counts = Vec::with_capacity(children.len());
 1462|    534|        let mut total_semantic_nodes = 0;
 1463|       |
 1464|  1.40k|        for &child_ref in children {
                           ^867
 1465|    867|            let child = self.parsed_ast.get_node(child_ref);
 1466|    867|            let count = match &child.kind {
 1467|    392|                ParsedNodeKind::FunctionDef(..) | ParsedNodeKind::StaticAssert(..) => 1,
 1468|    475|                ParsedNodeKind::Declaration(decl) => {
 1469|    475|                    if !decl.init_declarators.is_empty() {
 1470|    360|                        decl.init_declarators.len()
 1471|    115|                    } else if let Some(ParsedDeclSpecifier::TypeSpecifier(ts)) = decl
 1472|    115|                        .specifiers
 1473|    115|                        .iter()
 1474|    115|                        .find(|s| matches!(s, ParsedDeclSpecifier::TypeSpecifier(..)))
 1475|       |                    {
 1476|    100|                        match ts {
 1477|    100|                            ParsedTypeSpecifier::Record(_, _, is_def) if is_def.is_some() => 1,
                                                                                                      ^89  ^89
 1478|     15|                            ParsedTypeSpecifier::Enum(_, is_def) if is_def.is_some() => 1,
 1479|     11|                            _ => 0,
 1480|       |                        }
 1481|       |                    } else {
 1482|      0|                        0
 1483|       |                    }
 1484|       |                }
 1485|      0|                _ => 0,
 1486|       |            };
 1487|    867|            semantic_node_counts.push(count);
 1488|    867|            total_semantic_nodes += count;
 1489|       |        }
 1490|       |
 1491|    534|        let decl_len = total_semantic_nodes as u16;
 1492|    534|        let mut reserved_slots = Vec::with_capacity(decl_len as usize);
 1493|    857|        for _ in 0..decl_len {
                                  ^534
 1494|    857|            reserved_slots.push(self.push_dummy(span));
 1495|    857|        }
 1496|       |
 1497|    534|        let mut current_slot_idx = 0;
 1498|    867|        for (i, child_ref) in children.iter().enumerate() {
                                            ^534     ^534   ^534
 1499|    867|            let count = semantic_node_counts[i];
 1500|    867|            if count > 0 {
 1501|    856|                let target_slots = &reserved_slots[current_slot_idx..current_slot_idx + count];
 1502|    856|                self.visit_top_level_node(*child_ref, target_slots);
 1503|    856|                current_slot_idx += count;
 1504|    856|            }
                          ^11
 1505|       |        }
 1506|       |
 1507|    534|        let decl_start = if decl_len > 0 { reserved_slots[0] } else { NodeRef::ROOT };
                                                                                    ^0
 1508|    534|        self.ast.kinds[tu_node.index()] = NodeKind::TranslationUnit(TranslationUnitData {
 1509|    534|            decl_start,
 1510|    534|            decl_len,
 1511|    534|            scope_id: ScopeId::GLOBAL,
 1512|    534|        });
 1513|    534|        tu_node
 1514|    534|    }
 1515|       |
 1516|    406|    fn visit_compound_statement(
 1517|    406|        &mut self,
 1518|    406|        stmts: &[ParsedNodeRef],
 1519|    406|        target_slots: Option<&[NodeRef]>,
 1520|    406|        span: SourceSpan,
 1521|    406|    ) -> NodeRef {
 1522|    406|        let (scope_id, pushed) = if let Some(sid) = self.next_compound_uses_scope.take() {
                                                           ^373
 1523|    373|            (sid, false)
 1524|       |        } else {
 1525|     33|            (self.symbol_table.push_scope(), true)
 1526|       |        };
 1527|       |
 1528|    406|        let node = self.get_or_push_slot(target_slots, span);
 1529|       |
 1530|    406|        let mut total_stmt_nodes = 0;
 1531|  1.31k|        for &stmt_ref in stmts {
                           ^912
 1532|    912|            total_stmt_nodes += self.count_semantic_nodes(stmt_ref);
 1533|    912|        }
 1534|       |
 1535|    406|        let mut stmt_slots = Vec::with_capacity(total_stmt_nodes);
 1536|    926|        for _ in 0..total_stmt_nodes {
                                  ^406
 1537|    926|            stmt_slots.push(self.push_dummy(span));
 1538|    926|        }
 1539|       |
 1540|    406|        let stmt_start = stmt_slots.first().copied().unwrap_or(NodeRef::ROOT);
 1541|    406|        let stmt_len = stmt_slots.len() as u16;
 1542|       |
 1543|    406|        let old_scope = self.symbol_table.current_scope();
 1544|    406|        self.symbol_table.set_current_scope(scope_id);
 1545|       |
 1546|    406|        let mut current_slot_idx = 0;
 1547|  1.31k|        for &stmt_ref in stmts {
                           ^912
 1548|    912|            let count = self.count_semantic_nodes(stmt_ref);
 1549|    912|            if count > 0 {
 1550|    912|                let target = &stmt_slots[current_slot_idx..current_slot_idx + count];
 1551|    912|                self.visit_node_entry(stmt_ref, Some(target));
 1552|    912|                current_slot_idx += count;
 1553|    912|            }
                          ^0
 1554|       |        }
 1555|       |
 1556|    406|        if pushed {
 1557|     33|            self.symbol_table.pop_scope();
 1558|    373|        } else {
 1559|    373|            self.symbol_table.set_current_scope(old_scope);
 1560|    373|        }
 1561|       |
 1562|    406|        self.ast.kinds[node.index()] = NodeKind::CompoundStatement(CompoundStmtData {
 1563|    406|            stmt_start,
 1564|    406|            stmt_len,
 1565|    406|            scope_id,
 1566|    406|        });
 1567|    406|        node
 1568|    406|    }
 1569|       |
 1570|    856|    fn visit_top_level_node(&mut self, parsed_ref: ParsedNodeRef, target_slots: &[NodeRef]) {
 1571|    856|        let parsed_node = self.parsed_ast.get_node(parsed_ref);
 1572|    856|        let span = parsed_node.span;
 1573|       |
 1574|    856|        match &parsed_node.kind {
 1575|    464|            ParsedNodeKind::Declaration(decl) => {
 1576|    464|                self.visit_declaration(decl, span, Some(target_slots));
 1577|    464|            }
 1578|    373|            ParsedNodeKind::FunctionDef(func_def) => {
 1579|    373|                if let Some(target) = target_slots.first() {
 1580|    373|                    self.visit_function_definition(func_def, *target, span);
 1581|    373|                }
                              ^0
 1582|       |            }
 1583|       |            _ => {
 1584|     19|                if let ParsedNodeKind::StaticAssert(expr, msg) = &parsed_node.kind
 1585|     19|                    && let Some(target) = target_slots.first()
 1586|     19|                {
 1587|     19|                    let lowered_expr = self.visit_expression(*expr);
 1588|     19|                    let lowered_msg = self.visit_expression(*msg);
 1589|     19|                    self.ast.kinds[target.index()] = NodeKind::StaticAssert(lowered_expr, lowered_msg);
 1590|     19|                    self.ast.spans[target.index()] = span;
 1591|     19|                }
                              ^0
 1592|       |            }
 1593|       |        }
 1594|    856|    }
 1595|       |
 1596|  1.12k|    fn check_redeclaration_compatibility(
 1597|  1.12k|        &mut self,
 1598|  1.12k|        name: NameId,
 1599|  1.12k|        new_ty: QualType,
 1600|  1.12k|        span: SourceSpan,
 1601|  1.12k|        storage: Option<StorageClass>,
 1602|  1.12k|    ) -> QualType {
 1603|  1.12k|        let Some((existing_ref, existing_scope)) = self.symbol_table.lookup_symbol(name) else {
                                ^53           ^53
 1604|  1.06k|            return new_ty;
 1605|       |        };
 1606|       |
 1607|     53|        let current_scope = self.symbol_table.current_scope();
 1608|     53|        let existing = self.symbol_table.get_symbol(existing_ref);
 1609|     53|        let existing_type_info = existing.type_info;
 1610|     53|        let existing_def_span = existing.def_span;
 1611|     53|        let existing_has_linkage = existing.has_linkage();
 1612|     53|        let existing_storage = match &existing.kind {
 1613|     27|            SymbolKind::Variable { storage, .. } => Some(*storage),
 1614|     21|            SymbolKind::Function { storage } => Some(*storage),
 1615|      5|            _ => None,
 1616|       |        };
 1617|       |
 1618|     53|        let is_global = current_scope == ScopeId::GLOBAL;
 1619|     53|        let is_func = new_ty.is_function();
 1620|     53|        let new_has_linkage = is_global || storage == Some(StorageClass::Extern) || is_func;
                                                         ^17                                      ^16
 1621|     53|        let is_conflict = (existing_scope == current_scope) || (new_has_linkage && existing_has_linkage);
                                                                              ^11                ^1
 1622|       |
 1623|     53|        if !is_conflict {
 1624|     10|            return new_ty;
 1625|     43|        }
 1626|       |
 1627|       |        // Check for linkage conflict (C11 6.2.2)
 1628|     43|        if let Some(existing_s) = existing_storage {
                                  ^41
 1629|     41|            let existing_is_static = existing_s == Some(StorageClass::Static);
 1630|     41|            let new_is_static = storage == Some(StorageClass::Static);
 1631|       |
 1632|       |            // static followed by extern/plain is OK and inherits internal linkage.
 1633|       |            // extern/plain followed by static is an error.
 1634|     41|            if !existing_is_static && new_is_static {
                                                    ^32
 1635|      4|                self.report_error(SemanticError::ConflictingLinkage {
 1636|      4|                    name: name.to_string(),
 1637|      4|                    span,
 1638|      4|                    first_def: existing_def_span,
 1639|      4|                });
 1640|     37|            }
 1641|      2|        }
 1642|       |
 1643|       |        // C11 6.7p3: If an identifier has no linkage, there shall be no more than one declaration
 1644|       |        // in the same scope and name space.
 1645|     43|        if existing_scope == current_scope && (!existing_has_linkage || !new_has_linkage) {
                                                             ^42                      ^34
 1646|      8|            self.report_error(SemanticError::Redefinition {
 1647|      8|                name,
 1648|      8|                first_def: existing_def_span,
 1649|      8|                span,
 1650|      8|            });
 1651|      8|            return new_ty;
 1652|     35|        }
 1653|       |
 1654|     35|        let composite = self.registry.composite_type(existing_type_info, new_ty);
 1655|     35|        if composite.is_none() {
 1656|      3|            self.report_error(SemanticError::ConflictingTypes {
 1657|      3|                name: name.to_string(),
 1658|      3|                span,
 1659|      3|                first_def: existing_def_span,
 1660|      3|            });
 1661|      3|            return new_ty;
 1662|     32|        }
 1663|     32|        let composite = composite.unwrap();
 1664|       |
 1665|       |        // Update the existing symbol's type with the composite type
 1666|     32|        let existing_mut = self.symbol_table.get_symbol_mut(existing_ref);
 1667|     32|        existing_mut.type_info = composite;
 1668|       |
 1669|     32|        if new_ty.is_function() {
 1670|     19|            self.check_function_redeclaration(name, new_ty, span, existing_def_span, existing_type_info);
 1671|     19|        }
                      ^13
 1672|       |
 1673|     32|        composite
 1674|  1.12k|    }
 1675|       |
 1676|     19|    fn check_function_redeclaration(
 1677|     19|        &mut self,
 1678|     19|        name: NameId,
 1679|     19|        new_ty: QualType,
 1680|     19|        span: SourceSpan,
 1681|     19|        first_def: SourceSpan,
 1682|     19|        existing_ty: QualType,
 1683|     19|    ) {
 1684|       |        // Check for _Noreturn mismatch
 1685|     38|        let get_noreturn = |ty: QualType, registry: &TypeRegistry| {
                          ^19
 1686|     38|            if let TypeKind::Function { is_noreturn, .. } = &registry.get(ty.ty()).kind {
 1687|     38|                *is_noreturn
 1688|       |            } else {
 1689|      0|                false
 1690|       |            }
 1691|     38|        };
 1692|       |
 1693|     19|        let existing_is_noreturn = get_noreturn(existing_ty, self.registry);
 1694|     19|        let new_is_noreturn = get_noreturn(new_ty, self.registry);
 1695|       |
 1696|     19|        if existing_is_noreturn != new_is_noreturn {
 1697|      1|            self.report_error(SemanticError::ConflictingTypes {
 1698|      1|                name: name.to_string(),
 1699|      1|                span,
 1700|      1|                first_def,
 1701|      1|            });
 1702|     18|        }
 1703|     19|    }
 1704|       |
 1705|    373|    fn visit_function_definition(&mut self, func_def: &ParsedFunctionDefData, node: NodeRef, span: SourceSpan) {
 1706|    373|        let spec_info = visit_decl_specifiers(&func_def.specifiers, self, span);
 1707|    373|        let mut base_ty = spec_info
 1708|    373|            .base_type
 1709|    373|            .unwrap_or_else(|| QualType::unqualified(self.registry.type_int));
                                             ^0                    ^0
 1710|    373|        base_ty = self.merge_qualifiers_with_check(base_ty, spec_info.qualifiers, span);
 1711|       |
 1712|    373|        let mut final_ty = apply_declarator(
 1713|    373|            base_ty,
 1714|    373|            &func_def.declarator,
 1715|    373|            self,
 1716|    373|            span,
 1717|    373|            &spec_info,
 1718|    373|            DeclaratorContext { in_parameter: false },
 1719|       |        );
 1720|    373|        let func_name = extract_name(&func_def.declarator).expect("Function definition must have a name");
 1721|       |
 1722|    373|        final_ty = self.check_redeclaration_compatibility(func_name, final_ty, span, spec_info.storage);
 1723|       |
 1724|       |        // Check for _Noreturn on existing declarations
 1725|    373|        let existing_symbol_is_noreturn = if let Some((existing_ref, _)) = self.symbol_table.lookup_symbol(func_name) {
                                                                     ^13
 1726|     13|            let existing = self.symbol_table.get_symbol(existing_ref);
 1727|     13|            if let TypeKind::Function { is_noreturn, .. } = &self.registry.get(existing.type_info.ty()).kind {
 1728|     13|                *is_noreturn
 1729|       |            } else {
 1730|      0|                false
 1731|       |            }
 1732|       |        } else {
 1733|    360|            false
 1734|       |        };
 1735|       |
 1736|    373|        let final_is_noreturn = spec_info.is_noreturn || existing_symbol_is_noreturn;
                                                                       ^370
 1737|       |
 1738|    373|        if let Err(crate::semantic::symbol_table::SymbolTableError::InvalidRedefinition { existing, .. }) = self
                                                                                                        ^0
 1739|    373|            .symbol_table
 1740|    373|            .define_function(func_name, final_ty.ty(), spec_info.storage, true, span)
 1741|       |        {
 1742|      0|            let entry = self.symbol_table.get_symbol(existing);
 1743|      0|            if entry.def_state == DefinitionState::Defined {
 1744|      0|                let first_def = entry.def_span;
 1745|      0|                self.report_error(SemanticError::Redefinition {
 1746|      0|                    name: func_name,
 1747|      0|                    first_def,
 1748|      0|                    span,
 1749|      0|                });
 1750|      0|            }
 1751|    373|        }
 1752|    373|        let func_sym_ref = self.symbol_table.lookup_symbol(func_name).map(|(s, _)| s).unwrap();
 1753|       |
 1754|    373|        let scope_id = self.symbol_table.push_scope();
 1755|       |
 1756|       |        // Implement __func__ (C11 6.4.2.2)
 1757|    373|        {
 1758|    373|            let func_name_str = func_name.to_string();
 1759|    373|            let name_len = func_name_str.len();
 1760|    373|
 1761|    373|            // Create string literal for initializer
 1762|    373|            let func_name_id = crate::ast::StringId::new(&func_name_str);
 1763|    373|            let init_literal = literal::Literal::String(func_name_id);
 1764|    373|            let init_node = self.push_dummy(span);
 1765|    373|            self.ast.kinds[init_node.index()] = NodeKind::Literal(init_literal);
 1766|    373|
 1767|    373|            // Create type: const char[N]
 1768|    373|            let char_type = self.registry.type_char;
 1769|    373|            let array_size = ArraySizeType::Constant(name_len + 1);
 1770|    373|            let array_type = self.registry.array_of(char_type, array_size);
 1771|    373|
 1772|    373|            let qt = QualType::new(array_type, TypeQualifiers::CONST);
 1773|    373|            let _ = self.registry.ensure_layout(array_type);
 1774|    373|
 1775|    373|            // Define __func__
 1776|    373|            let func_id = crate::ast::StringId::new("__func__");
 1777|    373|            let storage = Some(StorageClass::Static);
 1778|    373|
 1779|    373|            // We define it in the current scope (function body).
 1780|    373|            // Note: If the user declares __func__ explicitly, it will be caught as a redefinition
 1781|    373|            // by the standard variable declaration logic because this one is inserted first.
 1782|    373|            let _ = self
 1783|    373|                .symbol_table
 1784|    373|                .define_variable(func_id, qt, storage, Some(init_node), None, span);
 1785|    373|
 1786|    373|            // Also define __PRETTY_FUNCTION__ (GCC extension)
 1787|    373|            let pretty_func_id = crate::ast::StringId::new("__PRETTY_FUNCTION__");
 1788|    373|            let _ = self
 1789|    373|                .symbol_table
 1790|    373|                .define_variable(pretty_func_id, qt, storage, Some(init_node), None, span);
 1791|    373|        }
 1792|       |
 1793|       |        // Pre-scan labels for forward goto support
 1794|    373|        self.collect_labels(func_def.body);
 1795|       |
 1796|    373|        let parameters = get_definition_params(&func_def.declarator, self).unwrap_or_default();
 1797|       |
 1798|    373|        let param_len = parameters.len() as u16;
 1799|    373|        let mut param_dummies = Vec::new();
 1800|    373|        for _ in 0..param_len {
 1801|     85|            param_dummies.push(self.push_dummy(span));
 1802|     85|        }
 1803|       |
 1804|    373|        for (i, param) in parameters.iter().enumerate() {
                           ^85^85
 1805|     85|            if let Some(pname) = param.name {
                                      ^84
 1806|       |                // Check if parameter name conflicts with something already in scope (like __func__)
 1807|     84|                self.check_redeclaration_compatibility(pname, param.param_type, span, None);
 1808|       |
 1809|     84|                if let Ok(sym) =
 1810|     84|                    self.symbol_table
 1811|     84|                        .define_variable(pname, param.param_type, param.storage, None, None, span)
 1812|     84|                {
 1813|     84|                    let param_ref = param_dummies[i];
 1814|     84|                    self.ast.kinds[param_ref.index()] = NodeKind::Param(ParamData {
 1815|     84|                        symbol: sym,
 1816|     84|                        ty: param.param_type,
 1817|     84|                    });
 1818|     84|                }
                              ^0
 1819|      1|            }
 1820|       |        }
 1821|       |
 1822|    373|        let param_start = if param_len > 0 { param_dummies[0] } else { NodeRef::ROOT };
                                                           ^59                       ^314
 1823|       |
 1824|       |        // Signal the body block (if it's a compound statement) to reuse the current scope
 1825|    373|        self.next_compound_uses_scope = Some(scope_id);
 1826|    373|        let body_node = self.visit_single_statement(func_def.body);
 1827|       |        // Ensure it's cleared even if it wasn't a compound statement
 1828|    373|        self.next_compound_uses_scope = None;
 1829|       |
 1830|    373|        self.symbol_table.pop_scope();
 1831|       |
 1832|    373|        self.ast.kinds[node.index()] = NodeKind::Function(FunctionData {
 1833|    373|            symbol: func_sym_ref,
 1834|    373|            ty: final_ty.ty(),
 1835|    373|            is_noreturn: final_is_noreturn,
 1836|    373|            param_start,
 1837|    373|            param_len,
 1838|    373|            body: body_node,
 1839|    373|            scope_id,
 1840|    373|        });
 1841|    373|        self.ast.spans[node.index()] = span;
 1842|    373|    }
 1843|       |
 1844|    803|    fn visit_declaration(
 1845|    803|        &mut self,
 1846|    803|        decl: &ParsedDeclarationData,
 1847|    803|        span: SourceSpan,
 1848|    803|        target_slots: Option<&[NodeRef]>,
 1849|    803|    ) -> SmallVec<[NodeRef; 1]> {
 1850|    803|        let spec_info = visit_decl_specifiers(&decl.specifiers, self, span);
 1851|    803|        let mut base_ty = spec_info
 1852|    803|            .base_type
 1853|    803|            .unwrap_or(QualType::unqualified(self.registry.type_int));
 1854|    803|        base_ty = self.merge_qualifiers_with_check(base_ty, spec_info.qualifiers, span);
 1855|       |
 1856|    803|        if decl.init_declarators.is_empty() {
 1857|    105|            return self.visit_tag_definition(&spec_info, span, target_slots);
 1858|    698|        }
 1859|       |
 1860|    698|        let mut nodes = SmallVec::new();
 1861|    713|        for (i, init) in decl.init_declarators.iter().enumerate() {
                                       ^698                         ^698
 1862|    713|            let target_slot = target_slots.and_then(|slots| slots.get(i)).copied();
                                                                          ^712  ^712^712
 1863|    713|            if let Some(node) = self.visit_single_declarator(init, base_ty, &spec_info, span, target_slot) {
 1864|    713|                nodes.push(node);
 1865|    713|            }
                          ^0
 1866|       |        }
 1867|    698|        nodes
 1868|    803|    }
 1869|       |
 1870|    105|    fn visit_tag_definition(
 1871|    105|        &mut self,
 1872|    105|        spec_info: &DeclSpecInfo,
 1873|    105|        span: SourceSpan,
 1874|    105|        target_slots: Option<&[NodeRef]>,
 1875|    105|    ) -> SmallVec<[NodeRef; 1]> {
 1876|    105|        let Some(qual_ty) = spec_info.base_type else {
 1877|      0|            return smallvec![];
 1878|       |        };
 1879|       |
 1880|       |        // Extract needed data from registry to avoid borrowing self.registry during node creation
 1881|       |        enum TypeData {
 1882|       |            Record(Option<NameId>, Arc<[StructMember]>, bool),
 1883|       |            Enum(Option<NameId>, Arc<[EnumConstant]>),
 1884|       |        }
 1885|       |
 1886|    105|        let type_ref = qual_ty.ty();
 1887|    105|        let type_info = self.registry.get(type_ref);
 1888|    105|        let type_data = match &type_info.kind {
 1889|       |            TypeKind::Record {
 1890|     86|                tag, members, is_union, ..
 1891|     86|            } => Some(TypeData::Record(*tag, members.clone(), *is_union)),
 1892|     15|            TypeKind::Enum { tag, enumerators, .. } => Some(TypeData::Enum(*tag, enumerators.clone())),
 1893|      4|            _ => None,
 1894|       |        };
 1895|       |
 1896|    105|        if let Some(data) = type_data {
                                  ^101
 1897|    101|            let node = self.get_or_push_slot(target_slots, span);
 1898|       |
 1899|    101|            match data {
 1900|     86|                TypeData::Record(tag, members, is_union) => {
 1901|     86|                    let member_start_idx = self.ast.kinds.len() as u32 + 1;
 1902|     86|                    let member_start = NodeRef::new(member_start_idx).expect("NodeRef overflow");
 1903|     86|                    let member_len = members.len() as u16;
 1904|       |
 1905|    138|                    for m in members.iter() {
                                           ^86     ^86
 1906|    138|                        self.ast.push_node(
 1907|    138|                            NodeKind::FieldDecl(FieldDeclData {
 1908|    138|                                name: m.name,
 1909|    138|                                ty: m.member_type,
 1910|    138|                                alignment: m.alignment,
 1911|    138|                            }),
 1912|    138|                            m.span,
 1913|    138|                        );
 1914|    138|                    }
 1915|       |
 1916|     86|                    self.ast.kinds[node.index()] = NodeKind::RecordDecl(RecordDeclData {
 1917|     86|                        name: tag,
 1918|     86|                        ty: qual_ty.ty(),
 1919|     86|                        member_start,
 1920|     86|                        member_len,
 1921|     86|                        is_union,
 1922|     86|                    });
 1923|       |                }
 1924|     15|                TypeData::Enum(tag, enumerators) => {
 1925|     15|                    let mut member_start = NodeRef::ROOT;
 1926|     15|                    let member_len = enumerators.len() as u16;
 1927|       |
 1928|     31|                    for (i, e) in enumerators.iter().enumerate() {
                                                ^15                ^15
 1929|     31|                        let member_ref = self.ast.push_node(
 1930|     31|                            NodeKind::EnumMember(EnumMemberData {
 1931|     31|                                name: e.name,
 1932|     31|                                value: e.value,
 1933|     31|                                init_expr: e.init_expr,
 1934|     31|                            }),
 1935|     31|                            e.span,
 1936|       |                        );
 1937|     31|                        if i == 0 {
 1938|     15|                            member_start = member_ref;
 1939|     16|                        }
 1940|       |                    }
 1941|       |
 1942|     15|                    self.ast.kinds[node.index()] = NodeKind::EnumDecl(EnumDeclData {
 1943|     15|                        name: tag,
 1944|     15|                        ty: qual_ty.ty(),
 1945|     15|                        member_start,
 1946|     15|                        member_len,
 1947|     15|                    });
 1948|       |                }
 1949|       |            }
 1950|    101|            return smallvec![node];
                                           ^0
 1951|      4|        }
 1952|       |
 1953|      4|        smallvec![]
 1954|    105|    }
 1955|       |
 1956|    713|    fn visit_single_declarator(
 1957|    713|        &mut self,
 1958|    713|        init: &crate::ast::parsed::ParsedInitDeclarator,
 1959|    713|        base_ty: QualType,
 1960|    713|        spec_info: &DeclSpecInfo,
 1961|    713|        span: SourceSpan,
 1962|    713|        target_slot: Option<NodeRef>,
 1963|    713|    ) -> Option<NodeRef> {
 1964|    713|        let final_ty = apply_declarator(
 1965|    713|            base_ty,
 1966|    713|            &init.declarator,
 1967|    713|            self,
 1968|    713|            init.span,
 1969|    713|            spec_info,
 1970|    713|            DeclaratorContext { in_parameter: false },
 1971|       |        );
 1972|    713|        let name = extract_name(&init.declarator).expect("Declarator must have identifier");
 1973|       |
 1974|    713|        let node = if let Some(slot) = target_slot {
                                             ^712
 1975|    712|            self.ast.spans[slot.index()] = span;
 1976|    712|            slot
 1977|       |        } else {
 1978|      1|            self.push_dummy(span)
 1979|       |        };
 1980|       |
 1981|    713|        if spec_info.is_typedef {
 1982|     48|            if spec_info.alignment.is_some() {
 1983|      1|                self.report_error(SemanticError::AlignmentNotAllowed {
 1984|      1|                    context: "typedef".to_string(),
 1985|      1|                    span: init.span,
 1986|      1|                });
 1987|     47|            }
 1988|       |
 1989|      3|            if let Err(SymbolTableError::InvalidRedefinition { existing, .. }) =
 1990|     48|                self.symbol_table.define_typedef(name, final_ty, span)
 1991|       |            {
 1992|      3|                let existing_symbol = self.symbol_table.get_symbol(existing);
 1993|      3|                if let SymbolKind::Typedef { aliased_type } = existing_symbol.kind {
                                                           ^2
 1994|      2|                    if !self.registry.is_compatible(aliased_type, final_ty) {
 1995|      1|                        self.report_error(SemanticError::RedefinitionWithDifferentType {
 1996|      1|                            name,
 1997|      1|                            first_def: existing_symbol.def_span,
 1998|      1|                            span,
 1999|      1|                        });
 2000|      1|                    }
 2001|      1|                } else {
 2002|      1|                    self.report_error(SemanticError::Redefinition {
 2003|      1|                        name,
 2004|      1|                        first_def: existing_symbol.def_span,
 2005|      1|                        span,
 2006|      1|                    });
 2007|      1|                }
 2008|     45|            }
 2009|     48|            self.ast.kinds[node.index()] = NodeKind::TypedefDecl(TypedefDeclData { name, ty: final_ty });
 2010|     48|            return Some(node);
 2011|    665|        }
 2012|       |
 2013|    665|        let init_expr = init.initializer.map(|init_node| self.visit_expression(init_node));
                                                                       ^301 ^301             ^301
 2014|    665|        let is_func = final_ty.is_function();
 2015|       |
 2016|    665|        if !is_func {
 2017|    586|            if spec_info.is_inline {
 2018|      0|                self.report_error(SemanticError::InvalidFunctionSpecifier {
 2019|      0|                    spec: "inline".to_string(),
 2020|      0|                    span,
 2021|      0|                });
 2022|    586|            }
 2023|    586|            if spec_info.is_noreturn {
 2024|      0|                self.report_error(SemanticError::InvalidFunctionSpecifier {
 2025|      0|                    spec: "_Noreturn".to_string(),
 2026|      0|                    span,
 2027|      0|                });
 2028|    586|            }
 2029|     79|        }
 2030|       |
 2031|    665|        if is_func {
 2032|     79|            self.visit_function_decl(node, name, final_ty, spec_info, span)
 2033|       |        } else {
 2034|    586|            self.visit_variable_decl(node, name, final_ty, spec_info, init_expr, span)
 2035|       |        }
 2036|    665|        Some(node)
 2037|    713|    }
 2038|       |
 2039|     79|    fn visit_function_decl(
 2040|     79|        &mut self,
 2041|     79|        node: NodeRef,
 2042|     79|        name: NameId,
 2043|     79|        final_ty: QualType,
 2044|     79|        spec_info: &DeclSpecInfo,
 2045|     79|        span: SourceSpan,
 2046|     79|    ) {
 2047|     79|        if spec_info.alignment.is_some() {
 2048|      1|            self.report_error(SemanticError::AlignmentNotAllowed {
 2049|      1|                context: "function".to_string(),
 2050|      1|                span,
 2051|      1|            });
 2052|     78|        }
 2053|       |
 2054|     79|        let final_ty = self.check_redeclaration_compatibility(name, final_ty, span, spec_info.storage);
 2055|     79|        let func_decl = FunctionDeclData {
 2056|     79|            name,
 2057|     79|            ty: final_ty.ty(),
 2058|     79|            storage: spec_info.storage,
 2059|     79|            body: None,
 2060|     79|            scope_id: self.symbol_table.current_scope(),
 2061|     79|        };
 2062|       |
 2063|     79|        if let Err(crate::semantic::symbol_table::SymbolTableError::InvalidRedefinition { existing, .. }) = self
                                                                                                        ^0
 2064|     79|            .symbol_table
 2065|     79|            .define_function(name, final_ty.ty(), spec_info.storage, false, span)
 2066|      0|        {
 2067|      0|            let first_def = self.symbol_table.get_symbol(existing).def_span;
 2068|      0|            self.report_error(SemanticError::Redefinition { name, first_def, span });
 2069|     79|        }
 2070|     79|        self.ast.kinds[node.index()] = NodeKind::FunctionDecl(func_decl);
 2071|     79|    }
 2072|       |
 2073|    586|    fn visit_variable_decl(
 2074|    586|        &mut self,
 2075|    586|        node: NodeRef,
 2076|    586|        name: NameId,
 2077|    586|        mut final_ty: QualType,
 2078|    586|        spec_info: &DeclSpecInfo,
 2079|    586|        init_expr: Option<NodeRef>,
 2080|    586|        span: SourceSpan,
 2081|    586|    ) {
 2082|    586|        if let Some(ie) = init_expr
                                  ^301
 2083|       |            && let TypeKind::Array {
 2084|     17|                element_type,
 2085|       |                size: ArraySizeType::Incomplete,
 2086|    301|            } = &self.registry.get(final_ty.ty()).kind
 2087|       |        {
 2088|     17|            let element_type = *element_type;
 2089|     17|            if let Some(deduced_size) = self.deduce_array_size_full(ie, element_type) {
 2090|     17|                let new_ty = self
 2091|     17|                    .registry
 2092|     17|                    .array_of(element_type, ArraySizeType::Constant(deduced_size));
 2093|     17|                final_ty = QualType::new(new_ty, final_ty.qualifiers());
 2094|     17|            }
                          ^0
 2095|    569|        }
 2096|       |
 2097|    586|        final_ty = self.check_redeclaration_compatibility(name, final_ty, span, spec_info.storage);
 2098|       |
 2099|       |        // C11 6.7p7: If an identifier for an object is declared with no linkage, the type for the object
 2100|       |        // shall be complete by the end of its declarator...
 2101|       |        // C11 6.9.2p3: If the declaration of an identifier for an object is a tentative definition
 2102|       |        // and has internal linkage, the declared type shall not be an incomplete type.
 2103|    586|        let current_scope = self.symbol_table.current_scope();
 2104|    586|        let is_global = current_scope == ScopeId::GLOBAL;
 2105|    586|        let has_internal_linkage = is_global && spec_info.storage == Some(StorageClass::Static);
                                                              ^234
 2106|    586|        let has_no_linkage = !is_global && spec_info.storage != Some(StorageClass::Extern);
                                                         ^352
 2107|       |
 2108|    586|        if (has_internal_linkage || has_no_linkage) && !self.registry.is_complete(final_ty.ty()) {
                                                  ^576               ^359^359          ^359
 2109|      7|            self.report_error(SemanticError::IncompleteType {
 2110|      7|                ty: self.registry.display_qual_type(final_ty),
 2111|      7|                span,
 2112|      7|            });
 2113|    579|        }
 2114|       |
 2115|    586|        let var_decl = VarDeclData {
 2116|    586|            name,
 2117|    586|            ty: final_ty,
 2118|    586|            storage: spec_info.storage,
 2119|    586|            init: init_expr,
 2120|    586|            alignment: spec_info.alignment.map(|a| a as u16),
                                                                 ^5
 2121|       |        };
 2122|       |
 2123|      4|        if let Err(SymbolTableError::InvalidRedefinition { existing, .. }) =
 2124|    586|            self.symbol_table
 2125|    586|                .define_variable(name, final_ty, spec_info.storage, init_expr, spec_info.alignment, span)
 2126|      4|        {
 2127|      4|            let first_def = self.symbol_table.get_symbol(existing).def_span;
 2128|      4|            self.report_error(SemanticError::Redefinition { name, first_def, span });
 2129|    582|        }
 2130|       |
 2131|    586|        if let Ok(layout) = self.registry.ensure_layout(final_ty.ty())
                                ^570
 2132|    570|            && let Some(req_align) = spec_info.alignment
                                      ^5
 2133|       |        {
 2134|      5|            let natural_align = layout.alignment as u32;
 2135|      5|            if req_align < natural_align {
 2136|      1|                self.report_error(SemanticError::AlignmentTooLoose {
 2137|      1|                    requested: req_align,
 2138|      1|                    natural: natural_align,
 2139|      1|                    span,
 2140|      1|                });
 2141|      4|            }
 2142|    581|        }
 2143|       |
 2144|    586|        self.ast.kinds[node.index()] = NodeKind::VarDecl(var_decl);
 2145|    586|    }
 2146|       |
 2147|  3.51k|    fn visit_node_rest(
 2148|  3.51k|        &mut self,
 2149|  3.51k|        parsed_ref: ParsedNodeRef,
 2150|  3.51k|        target_slots: Option<&[NodeRef]>,
 2151|  3.51k|    ) -> SmallVec<[NodeRef; 1]> {
 2152|  3.51k|        let parsed_node = self.parsed_ast.get_node(parsed_ref);
 2153|  3.51k|        let span = parsed_node.span;
 2154|  3.51k|        match &parsed_node.kind {
 2155|      0|            ParsedNodeKind::Declaration(decl) => self.visit_declaration(decl, span, target_slots),
 2156|     20|            ParsedNodeKind::StaticAssert(expr, msg) => {
 2157|     20|                let node = self.get_or_push_slot(target_slots, span);
 2158|     20|                let lowered_expr = self.visit_expression(*expr);
 2159|     20|                let lowered_msg = self.visit_expression(*msg);
 2160|     20|                self.ast.kinds[node.index()] = NodeKind::StaticAssert(lowered_expr, lowered_msg);
 2161|     20|                smallvec![node]
                                        ^0
 2162|       |            }
 2163|     64|            ParsedNodeKind::If(stmt) => {
 2164|     64|                let node = self.get_or_push_slot(target_slots, span);
 2165|     64|                let cond = self.visit_expression(stmt.condition);
 2166|     64|                let then = self.visit_single_statement(stmt.then_branch);
 2167|     64|                let else_branch = stmt.else_branch.map(|b| self.visit_single_statement(b));
                                                                         ^4   ^4                     ^4
 2168|     64|                self.ast.kinds[node.index()] = NodeKind::If(IfStmt {
 2169|     64|                    condition: cond,
 2170|     64|                    then_branch: then,
 2171|     64|                    else_branch,
 2172|     64|                });
 2173|     64|                smallvec![node]
                                        ^0
 2174|       |            }
 2175|      4|            ParsedNodeKind::While(stmt) => {
 2176|      4|                let node = self.get_or_push_slot(target_slots, span);
 2177|      4|                let cond = self.visit_expression(stmt.condition);
 2178|      4|                let body = self.visit_single_statement(stmt.body);
 2179|      4|                self.ast.kinds[node.index()] = NodeKind::While(WhileStmt { condition: cond, body });
 2180|      4|                smallvec![node]
                                        ^0
 2181|       |            }
 2182|      4|            ParsedNodeKind::DoWhile(body, cond) => {
 2183|      4|                let node = self.get_or_push_slot(target_slots, span);
 2184|      4|                let b = self.visit_single_statement(*body);
 2185|      4|                let c = self.visit_expression(*cond);
 2186|      4|                self.ast.kinds[node.index()] = NodeKind::DoWhile(b, c);
 2187|      4|                smallvec![node]
                                        ^0
 2188|       |            }
 2189|      5|            ParsedNodeKind::For(stmt) => {
 2190|      5|                let node = self.get_or_push_slot(target_slots, span);
 2191|      5|                let scope_id = self.symbol_table.push_scope();
 2192|       |
 2193|      5|                let init = stmt.init.map(|i| self.visit_node(i).first().cloned().unwrap());
                                                           ^2                         ^2       ^2
 2194|      5|                let cond = stmt.condition.map(|c| self.visit_expression(c));
                                                                ^4   ^4               ^4
 2195|      5|                let inc = stmt.increment.map(|i| self.visit_expression(i));
                                                               ^3   ^3               ^3
 2196|      5|                let body = self.visit_single_statement(stmt.body);
 2197|      5|                self.symbol_table.pop_scope();
 2198|       |
 2199|      5|                self.ast.kinds[node.index()] = NodeKind::For(crate::ast::ForStmt {
 2200|      5|                    init,
 2201|      5|                    condition: cond,
 2202|      5|                    increment: inc,
 2203|      5|                    body,
 2204|      5|                    scope_id,
 2205|      5|                });
 2206|      5|                smallvec![node]
                                        ^0
 2207|       |            }
 2208|      4|            ParsedNodeKind::Switch(cond, body) => {
 2209|      4|                let node = self.get_or_push_slot(target_slots, span);
 2210|      4|                let c = self.visit_expression(*cond);
 2211|      4|                let b = self.visit_single_statement(*body);
 2212|      4|                self.ast.kinds[node.index()] = NodeKind::Switch(c, b);
 2213|      4|                smallvec![node]
                                        ^0
 2214|       |            }
 2215|      6|            ParsedNodeKind::Case(expr, stmt) => {
 2216|      6|                let node = self.get_or_push_slot(target_slots, span);
 2217|      6|                let e = self.visit_expression(*expr);
 2218|      6|                let s = self.visit_single_statement(*stmt);
 2219|      6|                self.ast.kinds[node.index()] = NodeKind::Case(e, s);
 2220|      6|                smallvec![node]
                                        ^0
 2221|       |            }
 2222|      1|            ParsedNodeKind::CaseRange(start, end, stmt) => {
 2223|      1|                let node = self.get_or_push_slot(target_slots, span);
 2224|      1|                let s_expr = self.visit_expression(*start);
 2225|      1|                let e_expr = self.visit_expression(*end);
 2226|      1|                let s_stmt = self.visit_single_statement(*stmt);
 2227|      1|                self.ast.kinds[node.index()] = NodeKind::CaseRange(s_expr, e_expr, s_stmt);
 2228|      1|                smallvec![node]
                                        ^0
 2229|       |            }
 2230|      2|            ParsedNodeKind::Default(stmt) => {
 2231|      2|                let node = self.get_or_push_slot(target_slots, span);
 2232|      2|                let s = self.visit_single_statement(*stmt);
 2233|      2|                self.ast.kinds[node.index()] = NodeKind::Default(s);
 2234|      2|                smallvec![node]
                                        ^0
 2235|       |            }
 2236|       |            ParsedNodeKind::Break => {
 2237|      9|                let node = self.get_or_push_slot(target_slots, span);
 2238|      9|                self.ast.kinds[node.index()] = NodeKind::Break;
 2239|      9|                smallvec![node]
                                        ^0
 2240|       |            }
 2241|       |            ParsedNodeKind::Continue => {
 2242|      2|                let node = self.get_or_push_slot(target_slots, span);
 2243|      2|                self.ast.kinds[node.index()] = NodeKind::Continue;
 2244|      2|                smallvec![node]
                                        ^0
 2245|       |            }
 2246|      6|            ParsedNodeKind::Goto(name) => {
 2247|      6|                let sym = self.resolve_label(*name, span);
 2248|      6|                let node = self.get_or_push_slot(target_slots, span);
 2249|      6|                self.ast.kinds[node.index()] = NodeKind::Goto(*name, sym);
 2250|      6|                smallvec![node]
                                        ^0
 2251|       |            }
 2252|      9|            ParsedNodeKind::Label(name, inner) => {
 2253|      9|                let node = self.get_or_push_slot(target_slots, span);
 2254|      9|                let sym = self.define_label(*name, span);
 2255|      9|                let s = self.visit_single_statement(*inner);
 2256|      9|                self.ast.kinds[node.index()] = NodeKind::Label(*name, s, sym);
 2257|      9|                smallvec![node]
                                        ^0
 2258|       |            }
 2259|    285|            ParsedNodeKind::Return(expr) => {
 2260|    285|                let node = self.get_or_push_slot(target_slots, span);
 2261|    285|                let e = expr.map(|x| self.visit_expression(x));
                                                   ^282 ^282             ^282
 2262|    285|                self.ast.kinds[node.index()] = NodeKind::Return(e);
 2263|    285|                smallvec![node]
                                        ^0
 2264|       |            }
 2265|    224|            ParsedNodeKind::ExpressionStatement(expr) => {
 2266|    224|                let node = self.get_or_push_slot(target_slots, span);
 2267|    224|                let e = expr.map(|x| self.visit_expression(x));
 2268|    224|                self.ast.kinds[node.index()] = NodeKind::ExpressionStatement(e);
 2269|    224|                smallvec![node]
                                        ^0
 2270|       |            }
 2271|    218|            ParsedNodeKind::BinaryOp(op, lhs, rhs) => {
 2272|    218|                let node = self.get_or_push_slot(target_slots, span);
 2273|    218|                let l = self.visit_expression(*lhs);
 2274|    218|                let r = self.visit_expression(*rhs);
 2275|    218|                self.ast.kinds[node.index()] = NodeKind::BinaryOp(*op, l, r);
 2276|    218|                smallvec![node]
                                        ^0
 2277|       |            }
 2278|    119|            ParsedNodeKind::Assignment(op, lhs, rhs) => {
 2279|    119|                let node = self.get_or_push_slot(target_slots, span);
 2280|    119|                let l = self.visit_expression(*lhs);
 2281|    119|                let r = self.visit_expression(*rhs);
 2282|    119|                self.ast.kinds[node.index()] = NodeKind::Assignment(*op, l, r);
 2283|    119|                smallvec![node]
                                        ^0
 2284|       |            }
 2285|    106|            ParsedNodeKind::UnaryOp(op, operand) => {
 2286|    106|                let node = self.get_or_push_slot(target_slots, span);
 2287|    106|                let o = self.visit_expression(*operand);
 2288|    106|                self.ast.kinds[node.index()] = NodeKind::UnaryOp(*op, o);
 2289|    106|                smallvec![node]
                                        ^0
 2290|       |            }
 2291|  1.17k|            ParsedNodeKind::Literal(literal) => {
 2292|  1.17k|                let node = self.get_or_push_slot(target_slots, span);
 2293|  1.17k|                self.ast.kinds[node.index()] = NodeKind::Literal(*literal);
 2294|  1.17k|                smallvec![node]
                                        ^0
 2295|       |            }
 2296|    673|            ParsedNodeKind::Ident(name) => {
 2297|    673|                let sym = self.resolve_ident(*name, span);
 2298|    673|                let node = self.get_or_push_slot(target_slots, span);
 2299|    673|                self.ast.kinds[node.index()] = NodeKind::Ident(*name, sym);
 2300|    673|                smallvec![node]
                                        ^0
 2301|       |            }
 2302|     95|            ParsedNodeKind::FunctionCall(func, args) => {
 2303|       |                // Reserve a slot for the FunctionCall node to ensure parent < child index (when necessary)
 2304|       |                // If we have a target slot for the result, we can use it directly?
 2305|       |                // But FunctionCall needs to know ranges of args.
 2306|       |                // The structure is: CallNode -> FuncExpr, Arg1, Arg2...
 2307|       |                // FuncExpr and Args can be anywhere, but Args must be contiguous.
 2308|       |
 2309|     95|                let call_node_idx = self.get_or_push_slot(target_slots, span);
 2310|       |
 2311|     95|                let f = self.visit_expression(*func);
 2312|       |
 2313|       |                // Reserve slots for arguments to ensure contiguity
 2314|     95|                let mut arg_dummies = Vec::with_capacity(args.len());
 2315|    152|                for _ in 0..args.len() {
                                          ^95  ^95
 2316|    152|                    arg_dummies.push(self.push_dummy(span));
 2317|    152|                }
 2318|       |
 2319|       |                // Lower arguments into reserved slots
 2320|    152|                for (i, &arg_parsed_ref) in args.iter().enumerate() {
                                                          ^95         ^95
 2321|    152|                    self.visit_expression_into(arg_parsed_ref, arg_dummies[i]);
 2322|    152|                }
 2323|       |
 2324|     95|                let arg_start = if !arg_dummies.is_empty() {
 2325|     72|                    arg_dummies[0]
 2326|       |                } else {
 2327|     23|                    NodeRef::ROOT
 2328|       |                };
 2329|     95|                let arg_len = arg_dummies.len() as u16;
 2330|       |
 2331|       |                // Replace the reserved dummy node with the actual FunctionCall
 2332|     95|                self.ast.kinds[call_node_idx.index()] = NodeKind::FunctionCall(CallExpr {
 2333|     95|                    callee: f,
 2334|     95|                    arg_start,
 2335|     95|                    arg_len,
 2336|     95|                });
 2337|       |
 2338|     95|                smallvec![call_node_idx]
                                        ^0
 2339|       |            }
 2340|    133|            ParsedNodeKind::MemberAccess(base, member, is_arrow) => {
 2341|    133|                let node = self.get_or_push_slot(target_slots, span);
 2342|    133|                let b = self.visit_expression(*base);
 2343|    133|                self.ast.kinds[node.index()] = NodeKind::MemberAccess(b, *member, *is_arrow);
 2344|    133|                smallvec![node]
                                        ^0
 2345|       |            }
 2346|     22|            ParsedNodeKind::Cast(ty_name, expr) => {
 2347|     22|                let node = self.get_or_push_slot(target_slots, span);
 2348|     22|                let e = self.visit_expression(*expr);
 2349|     22|                let ty = convert_to_qual_type(self, *ty_name, span, false)
 2350|     22|                    .unwrap_or(QualType::unqualified(self.registry.type_error));
 2351|     22|                self.ast.kinds[node.index()] = NodeKind::Cast(ty, e);
 2352|     22|                smallvec![node]
                                        ^0
 2353|       |            }
 2354|     12|            ParsedNodeKind::PostIncrement(operand) => {
 2355|     12|                let node = self.get_or_push_slot(target_slots, span);
 2356|     12|                let o = self.visit_expression(*operand);
 2357|     12|                self.ast.kinds[node.index()] = NodeKind::PostIncrement(o);
 2358|     12|                smallvec![node]
                                        ^0
 2359|       |            }
 2360|      5|            ParsedNodeKind::PostDecrement(operand) => {
 2361|      5|                let node = self.get_or_push_slot(target_slots, span);
 2362|      5|                let o = self.visit_expression(*operand);
 2363|      5|                self.ast.kinds[node.index()] = NodeKind::PostDecrement(o);
 2364|      5|                smallvec![node]
                                        ^0
 2365|       |            }
 2366|     47|            ParsedNodeKind::IndexAccess(base, index) => {
 2367|     47|                let node = self.get_or_push_slot(target_slots, span);
 2368|     47|                let b = self.visit_expression(*base);
 2369|     47|                let i = self.visit_expression(*index);
 2370|     47|                self.ast.kinds[node.index()] = NodeKind::IndexAccess(b, i);
 2371|     47|                smallvec![node]
                                        ^0
 2372|       |            }
 2373|      9|            ParsedNodeKind::TernaryOp(cond, then_branch, else_branch) => {
 2374|      9|                let node = self.get_or_push_slot(target_slots, span);
 2375|      9|                let c = self.visit_expression(*cond);
 2376|      9|                let t = self.visit_expression(*then_branch);
 2377|      9|                let e = self.visit_expression(*else_branch);
 2378|      9|                self.ast.kinds[node.index()] = NodeKind::TernaryOp(c, t, e);
 2379|      9|                smallvec![node]
                                        ^0
 2380|       |            }
 2381|      3|            ParsedNodeKind::GnuStatementExpression(stmt, _expr) => {
 2382|      3|                let node = self.get_or_push_slot(target_slots, span);
 2383|      3|                let s = self.visit_single_statement(*stmt);
 2384|       |
 2385|      3|                let last_stmt = if let NodeKind::CompoundStatement(data) = self.ast.get_kind(s) {
 2386|      3|                    data.stmt_start.range(data.stmt_len).last()
 2387|       |                } else {
 2388|      0|                    None
 2389|       |                };
 2390|       |
 2391|      3|                let result_expr = last_stmt
 2392|      3|                    .and_then(|stmt| {
 2393|      3|                        if let NodeKind::ExpressionStatement(Some(e)) = self.ast.get_kind(stmt) {
                                                                                ^2
 2394|      2|                            Some(*e)
 2395|       |                        } else {
 2396|      1|                            None
 2397|       |                        }
 2398|      3|                    })
 2399|      3|                    .unwrap_or_else(|| self.push_dummy(span));
                                                     ^1   ^1         ^1
 2400|       |
 2401|      3|                self.ast.kinds[node.index()] = NodeKind::GnuStatementExpression(s, result_expr);
 2402|      3|                smallvec![node]
                                        ^0
 2403|       |            }
 2404|     34|            ParsedNodeKind::SizeOfExpr(expr) => {
 2405|     34|                let node = self.get_or_push_slot(target_slots, span);
 2406|     34|                let e = self.visit_expression(*expr);
 2407|     34|                self.ast.kinds[node.index()] = NodeKind::SizeOfExpr(e);
 2408|     34|                smallvec![node]
                                        ^0
 2409|       |            }
 2410|     19|            ParsedNodeKind::SizeOfType(ty_name) => {
 2411|     19|                let node = self.get_or_push_slot(target_slots, span);
 2412|     19|                let ty = convert_to_qual_type(self, *ty_name, span, false)
 2413|     19|                    .unwrap_or(QualType::unqualified(self.registry.type_error));
 2414|     19|                self.ast.kinds[node.index()] = NodeKind::SizeOfType(ty);
 2415|     19|                smallvec![node]
                                        ^0
 2416|       |            }
 2417|      6|            ParsedNodeKind::AlignOf(ty_name) => {
 2418|      6|                let node = self.get_or_push_slot(target_slots, span);
 2419|      6|                let ty = convert_to_qual_type(self, *ty_name, span, false)
 2420|      6|                    .unwrap_or(QualType::unqualified(self.registry.type_error));
 2421|      6|                self.ast.kinds[node.index()] = NodeKind::AlignOf(ty);
 2422|      6|                smallvec![node]
                                        ^0
 2423|       |            }
 2424|      7|            ParsedNodeKind::BuiltinVaArg(ty_name, expr) => {
 2425|      7|                let node = self.get_or_push_slot(target_slots, span);
 2426|      7|                let e = self.visit_expression(*expr);
 2427|      7|                let ty = convert_to_qual_type(self, *ty_name, span, false)
 2428|      7|                    .unwrap_or(QualType::unqualified(self.registry.type_error));
 2429|      7|                self.ast.kinds[node.index()] = NodeKind::BuiltinVaArg(ty, e);
 2430|      7|                smallvec![node]
                                        ^0
 2431|       |            }
 2432|     12|            ParsedNodeKind::BuiltinOffsetof(ty_name, expr) => {
 2433|     12|                let node = self.get_or_push_slot(target_slots, span);
 2434|     12|                let e = self.visit_expression(*expr);
 2435|     12|                let ty = convert_to_qual_type(self, *ty_name, span, false)
 2436|     12|                    .unwrap_or(QualType::unqualified(self.registry.type_error));
 2437|     12|                self.ast.kinds[node.index()] = NodeKind::BuiltinOffsetof(ty, e);
 2438|     12|                smallvec![node]
                                        ^0
 2439|       |            }
 2440|      4|            ParsedNodeKind::BuiltinVaStart(ap, last) => {
 2441|      4|                let node = self.get_or_push_slot(target_slots, span);
 2442|      4|                let a = self.visit_expression(*ap);
 2443|      4|                let l = self.visit_expression(*last);
 2444|      4|                self.ast.kinds[node.index()] = NodeKind::BuiltinVaStart(a, l);
 2445|      4|                smallvec![node]
                                        ^0
 2446|       |            }
 2447|      2|            ParsedNodeKind::BuiltinVaEnd(ap) => {
 2448|      2|                let node = self.get_or_push_slot(target_slots, span);
 2449|      2|                let a = self.visit_expression(*ap);
 2450|      2|                self.ast.kinds[node.index()] = NodeKind::BuiltinVaEnd(a);
 2451|      2|                smallvec![node]
                                        ^0
 2452|       |            }
 2453|      0|            ParsedNodeKind::BuiltinVaCopy(dst, src) => {
 2454|      0|                let node = self.get_or_push_slot(target_slots, span);
 2455|      0|                let d = self.visit_expression(*dst);
 2456|      0|                let s = self.visit_expression(*src);
 2457|      0|                self.ast.kinds[node.index()] = NodeKind::BuiltinVaCopy(d, s);
 2458|      0|                smallvec![node]
 2459|       |            }
 2460|      3|            ParsedNodeKind::BuiltinExpect(exp, c) => {
 2461|      3|                let node = self.get_or_push_slot(target_slots, span);
 2462|      3|                let e = self.visit_expression(*exp);
 2463|      3|                let expected = self.visit_expression(*c);
 2464|      3|                self.ast.kinds[node.index()] = NodeKind::BuiltinExpect(e, expected);
 2465|      3|                smallvec![node]
                                        ^0
 2466|       |            }
 2467|     13|            ParsedNodeKind::AtomicOp(op, args) => {
 2468|     13|                let node = self.get_or_push_slot(target_slots, span);
 2469|       |
 2470|       |                // Reserve slots for args to ensure contiguity
 2471|     13|                let mut arg_dummies = Vec::with_capacity(args.len());
 2472|     42|                for _ in 0..args.len() {
                                          ^13  ^13
 2473|     42|                    arg_dummies.push(self.push_dummy(span));
 2474|     42|                }
 2475|       |
 2476|       |                // Lower arguments into reserved slots
 2477|     42|                for (i, &arg_parsed_ref) in args.iter().enumerate() {
                                                          ^13         ^13
 2478|     42|                    self.visit_expression_into(arg_parsed_ref, arg_dummies[i]);
 2479|     42|                }
 2480|       |
 2481|     13|                let arg_start = if !arg_dummies.is_empty() {
 2482|     13|                    arg_dummies[0]
 2483|       |                } else {
 2484|      0|                    NodeRef::ROOT
 2485|       |                };
 2486|     13|                let arg_len = arg_dummies.len() as u16;
 2487|       |
 2488|     13|                self.ast.kinds[node.index()] = NodeKind::AtomicOp(*op, arg_start, arg_len);
 2489|     13|                smallvec![node]
                                        ^0
 2490|       |            }
 2491|      9|            ParsedNodeKind::CompoundLiteral(ty_name, init) => {
 2492|      9|                let node = self.get_or_push_slot(target_slots, span);
 2493|      9|                let mut ty = convert_to_qual_type(self, *ty_name, span, false)
 2494|      9|                    .unwrap_or(QualType::unqualified(self.registry.type_error));
 2495|      9|                let i = self.visit_expression(*init);
 2496|       |
 2497|       |                if let TypeKind::Array {
 2498|      3|                    element_type,
 2499|       |                    size: ArraySizeType::Incomplete,
 2500|      9|                } = &self.registry.get(ty.ty()).kind
 2501|       |                {
 2502|      3|                    let element_type = *element_type;
 2503|      3|                    if let Some(deduced_size) = self.deduce_array_size_full(i, element_type) {
 2504|      3|                        let new_ty = self
 2505|      3|                            .registry
 2506|      3|                            .array_of(element_type, ArraySizeType::Constant(deduced_size));
 2507|      3|                        ty = QualType::new(new_ty, ty.qualifiers());
 2508|      3|                    }
                                  ^0
 2509|      6|                }
 2510|       |
 2511|      9|                self.ast.kinds[node.index()] = NodeKind::CompoundLiteral(ty, i);
 2512|      9|                smallvec![node]
                                        ^0
 2513|       |            }
 2514|     49|            ParsedNodeKind::GenericSelection(control, associations) => {
 2515|     49|                let node = self.get_or_push_slot(target_slots, span);
 2516|     49|                let c = self.visit_expression(*control);
 2517|       |
 2518|     49|                let assoc_len = associations.len() as u16;
 2519|     49|                let mut assoc_dummies = Vec::new();
 2520|     99|                for _ in 0..assoc_len {
                                          ^49
 2521|     99|                    assoc_dummies.push(self.push_dummy(span));
 2522|     99|                }
 2523|       |
 2524|     99|                for (i, a) in associations.iter().enumerate() {
                                            ^49                 ^49
 2525|     99|                    let ty = a.type_name.map(|t| {
                                                               ^58
 2526|     58|                        convert_to_qual_type(self, t, span, false)
 2527|     58|                            .unwrap_or(QualType::unqualified(self.registry.type_error))
 2528|     58|                    });
 2529|     99|                    let expr = self.visit_expression(a.result_expr);
 2530|     99|                    let assoc_ref = assoc_dummies[i];
 2531|     99|                    self.ast.kinds[assoc_ref.index()] =
 2532|     99|                        NodeKind::GenericAssociation(GenericAssociationData { ty, result_expr: expr });
 2533|       |                }
 2534|       |
 2535|     49|                let assoc_start = if assoc_len > 0 { assoc_dummies[0] } else { NodeRef::ROOT };
                                                                                             ^0
 2536|       |
 2537|     49|                self.ast.kinds[node.index()] = NodeKind::GenericSelection(GenericSelectionData {
 2538|     49|                    control: c,
 2539|     49|                    assoc_start,
 2540|     49|                    assoc_len,
 2541|     49|                });
 2542|     49|                smallvec![node]
                                        ^0
 2543|       |            }
 2544|     76|            ParsedNodeKind::InitializerList(inits) => {
 2545|     76|                let node = self.get_or_push_slot(target_slots, span);
 2546|       |
 2547|       |                // Reserve slots for InitializerItems to ensure parent < child index
 2548|     76|                let mut init_dummies = Vec::new();
 2549|    145|                for _ in 0..inits.len() {
                                          ^76   ^76
 2550|    145|                    init_dummies.push(self.push_dummy(span));
 2551|    145|                }
 2552|       |
 2553|    145|                for (i, init) in inits.iter().enumerate() {
                                               ^76          ^76
 2554|    145|                    let expr = self.visit_expression(init.initializer);
 2555|       |
 2556|    145|                    let designator_count = init.designation.len() as u16;
 2557|    145|                    let mut designator_dummies = Vec::with_capacity(designator_count as usize);
 2558|       |
 2559|    145|                    for _ in 0..designator_count {
 2560|     46|                        designator_dummies.push(self.push_dummy(span));
 2561|     46|                    }
 2562|       |
 2563|    145|                    for (j, d) in init.designation.iter().enumerate() {
                                       ^46^46
 2564|     46|                        let node_kind = match d {
 2565|     23|                            ParsedDesignator::FieldName(name) => Designator::FieldName(*name),
 2566|     21|                            ParsedDesignator::ArrayIndex(idx) => Designator::ArrayIndex(self.visit_expression(*idx)),
 2567|      2|                            ParsedDesignator::GnuArrayRange(start, end) => {
 2568|      2|                                Designator::GnuArrayRange(self.visit_expression(*start), self.visit_expression(*end))
 2569|       |                            }
 2570|       |                        };
 2571|     46|                        let d_ref = designator_dummies[j];
 2572|     46|                        self.ast.kinds[d_ref.index()] = NodeKind::Designator(node_kind);
 2573|       |                    }
 2574|       |
 2575|    145|                    let designator_start = if designator_count > 0 {
 2576|     45|                        designator_dummies[0]
 2577|       |                    } else {
 2578|    100|                        NodeRef::ROOT
 2579|       |                    };
 2580|       |
 2581|    145|                    let di = DesignatedInitializer {
 2582|    145|                        designator_start,
 2583|    145|                        designator_len: designator_count,
 2584|    145|                        initializer: expr,
 2585|    145|                    };
 2586|       |
 2587|    145|                    let item_ref = init_dummies[i];
 2588|    145|                    self.ast.kinds[item_ref.index()] = NodeKind::InitializerItem(di);
 2589|       |                }
 2590|       |
 2591|     76|                let init_len = init_dummies.len() as u16;
 2592|     76|                let init_start = if init_len > 0 { init_dummies[0] } else { NodeRef::ROOT };
                                                                 ^74                      ^2
 2593|       |
 2594|     76|                self.ast.kinds[node.index()] = NodeKind::InitializerList(InitializerListData { init_start, init_len });
 2595|       |
 2596|     76|                smallvec![node]
                                        ^0
 2597|       |            }
 2598|       |            ParsedNodeKind::EmptyStatement => {
 2599|      2|                smallvec![]
 2600|       |            }
 2601|       |            _ => {
 2602|       |                // For unhandled nodes (or Dummy), push a Dummy node to avoid ICE
 2603|     12|                smallvec![self.push_dummy(span)]
                                        ^0   ^0         ^0
 2604|       |            }
 2605|       |        }
 2606|  3.51k|    }
 2607|       |
 2608|  3.14k|    pub(crate) fn visit_expression(&mut self, node: ParsedNodeRef) -> NodeRef {
 2609|  3.14k|        self.visit_node(node)
 2610|  3.14k|            .first()
 2611|  3.14k|            .copied()
 2612|  3.14k|            .unwrap_or_else(|| self.push_dummy(SourceSpan::default()))
                                             ^1   ^1         ^1
 2613|  3.14k|    }
 2614|       |
 2615|    194|    pub(crate) fn visit_expression_into(&mut self, node: ParsedNodeRef, target: NodeRef) -> NodeRef {
 2616|    194|        self.visit_node_entry(node, Some(&[target]))
 2617|    194|            .first()
 2618|    194|            .copied()
 2619|    194|            .unwrap_or(target)
 2620|    194|    }
 2621|       |
 2622|    479|    pub(crate) fn visit_single_statement(&mut self, node: ParsedNodeRef) -> NodeRef {
 2623|    479|        self.visit_expression(node)
 2624|    479|    }
 2625|       |
 2626|    673|    fn resolve_ident(&mut self, name: NameId, span: SourceSpan) -> SymbolRef {
 2627|    673|        if let Some((sym_ref, _)) = self.symbol_table.lookup_symbol(name) {
                                   ^670
 2628|    670|            sym_ref
 2629|       |        } else {
 2630|      3|            let name_str = name.as_str();
 2631|      3|            if name_str.starts_with("__builtin_")
 2632|      0|                && let Some(sym_ref) = self.handle_builtin_implicit_decl(name, name_str, span)
 2633|       |            {
 2634|      0|                return sym_ref;
 2635|      3|            }
 2636|      3|            self.report_error(SemanticError::UndeclaredIdentifier { name, span });
 2637|      3|            SymbolRef::new(1).expect("SymbolRef 1 creation failed")
 2638|       |        }
 2639|    673|    }
 2640|       |
 2641|      0|    fn handle_builtin_implicit_decl(&mut self, name: NameId, name_str: &str, span: SourceSpan) -> Option<SymbolRef> {
 2642|      0|        let (params, ret_ty) = match name_str {
 2643|      0|            "__builtin_nanf" | "__builtin_nan" => {
 2644|      0|                let char_const = QualType::new(self.registry.type_char, TypeQualifiers::CONST);
 2645|      0|                let char_ptr = QualType::unqualified(self.registry.pointer_to(char_const));
 2646|      0|                let params = vec![FunctionParameter {
 2647|      0|                    param_type: char_ptr,
 2648|      0|                    name: None,
 2649|      0|                    storage: None,
 2650|      0|                }];
 2651|      0|                let ret = if name_str == "__builtin_nanf" {
 2652|      0|                    self.registry.type_float
 2653|       |                } else {
 2654|      0|                    self.registry.type_double
 2655|       |                };
 2656|      0|                (params, ret)
 2657|       |            }
 2658|      0|            "__builtin_inff" | "__builtin_inf" | "__builtin_huge_val" | "__builtin_huge_valf" => {
 2659|      0|                let ret = if name_str.ends_with('f') {
 2660|      0|                    self.registry.type_float
 2661|       |                } else {
 2662|      0|                    self.registry.type_double
 2663|       |                };
 2664|      0|                (vec![], ret)
 2665|       |            }
 2666|      0|            _ => return None,
 2667|       |        };
 2668|       |
 2669|      0|        let func_ty = self.registry.function_type(ret_ty, params, false, false);
 2670|       |
 2671|       |        // Save current scope and switch to global for implicit decl
 2672|      0|        let old_scope = self.symbol_table.current_scope();
 2673|      0|        self.symbol_table.set_current_scope(ScopeId::GLOBAL);
 2674|      0|        let result = self.symbol_table.define_function(name, func_ty, None, false, span).ok();
 2675|      0|        self.symbol_table.set_current_scope(old_scope);
 2676|      0|        result
 2677|      0|    }
 2678|       |
 2679|     18|    fn define_label(&mut self, name: NameId, span: SourceSpan) -> SymbolRef {
 2680|     18|        match self.symbol_table.define_label(name, self.registry.type_void, span) {
 2681|     18|            Ok(sym) => sym,
 2682|       |            Err(_) => {
 2683|       |                // If already defined (e.g. by pre-scan), look it up
 2684|      0|                self.symbol_table
 2685|      0|                    .lookup_label(name)
 2686|      0|                    .map(|(s, _)| s)
 2687|      0|                    .unwrap_or_else(|| SymbolRef::new(1).unwrap())
 2688|       |            }
 2689|       |        }
 2690|     18|    }
 2691|       |
 2692|      6|    fn resolve_label(&mut self, name: NameId, span: SourceSpan) -> SymbolRef {
 2693|      6|        if let Some((sym_ref, _)) = self.symbol_table.lookup_label(name) {
 2694|      6|            sym_ref
 2695|       |        } else {
 2696|       |            // Forward references are okay because of pre-scan
 2697|       |            // But if NOT even in pre-scan, then it's undeclared
 2698|      0|            self.report_error(SemanticError::UndeclaredIdentifier { name, span });
 2699|      0|            SymbolRef::new(1).unwrap()
 2700|       |        }
 2701|      6|    }
 2702|       |
 2703|  3.64k|    fn collect_labels(&mut self, node: ParsedNodeRef) {
 2704|  3.64k|        let parsed_node = self.parsed_ast.get_node(node);
 2705|    285|        match &parsed_node.kind {
 2706|      9|            ParsedNodeKind::Label(name, inner) => {
 2707|      9|                let _ = self.define_label(*name, parsed_node.span);
 2708|      9|                self.collect_labels(*inner);
 2709|      9|            }
 2710|    406|            ParsedNodeKind::CompoundStatement(stmts) => {
 2711|  1.31k|                for stmt in stmts {
                                  ^912
 2712|    912|                    self.collect_labels(*stmt);
 2713|    912|                }
 2714|       |            }
 2715|     64|            ParsedNodeKind::If(stmt) => {
 2716|     64|                self.collect_labels(stmt.condition);
 2717|     64|                self.collect_labels(stmt.then_branch);
 2718|     64|                if let Some(eb) = stmt.else_branch {
                                          ^4
 2719|      4|                    self.collect_labels(eb);
 2720|     60|                }
 2721|       |            }
 2722|      4|            ParsedNodeKind::While(stmt) => {
 2723|      4|                self.collect_labels(stmt.condition);
 2724|      4|                self.collect_labels(stmt.body);
 2725|      4|            }
 2726|      4|            ParsedNodeKind::DoWhile(body, cond) => {
 2727|      4|                self.collect_labels(*body);
 2728|      4|                self.collect_labels(*cond);
 2729|      4|            }
 2730|      5|            ParsedNodeKind::For(stmt) => {
 2731|      5|                if let Some(init) = stmt.init {
                                          ^2
 2732|      2|                    self.collect_labels(init);
 2733|      3|                }
 2734|      5|                if let Some(cond) = stmt.condition {
                                          ^4
 2735|      4|                    self.collect_labels(cond);
 2736|      4|                }
                              ^1
 2737|      5|                if let Some(inc) = stmt.increment {
                                          ^3
 2738|      3|                    self.collect_labels(inc);
 2739|      3|                }
                              ^2
 2740|      5|                self.collect_labels(stmt.body);
 2741|       |            }
 2742|      4|            ParsedNodeKind::Switch(cond, body) => {
 2743|      4|                self.collect_labels(*cond);
 2744|      4|                self.collect_labels(*body);
 2745|      4|            }
 2746|      6|            ParsedNodeKind::Case(expr, stmt) => {
 2747|      6|                self.collect_labels(*expr);
 2748|      6|                self.collect_labels(*stmt);
 2749|      6|            }
 2750|      1|            ParsedNodeKind::CaseRange(start, end, stmt) => {
 2751|      1|                self.collect_labels(*start);
 2752|      1|                self.collect_labels(*end);
 2753|      1|                self.collect_labels(*stmt);
 2754|      1|            }
 2755|      2|            ParsedNodeKind::Default(stmt) => {
 2756|      2|                self.collect_labels(*stmt);
 2757|      2|            }
 2758|    224|            ParsedNodeKind::ExpressionStatement(Some(e)) => {
 2759|    224|                self.collect_labels(*e);
 2760|    224|            }
 2761|    282|            ParsedNodeKind::Return(Some(e)) => {
 2762|    282|                self.collect_labels(*e);
 2763|    282|            }
 2764|      3|            ParsedNodeKind::GnuStatementExpression(stmt, _) => {
 2765|      3|                self.collect_labels(*stmt);
 2766|      3|            }
 2767|    163|            ParsedNodeKind::BinaryOp(_, lhs, rhs) => {
 2768|    163|                self.collect_labels(*lhs);
 2769|    163|                self.collect_labels(*rhs);
 2770|    163|            }
 2771|     69|            ParsedNodeKind::UnaryOp(_, operand) => {
 2772|     69|                self.collect_labels(*operand);
 2773|     69|            }
 2774|     95|            ParsedNodeKind::FunctionCall(callee, args) => {
 2775|     95|                self.collect_labels(*callee);
 2776|    247|                for arg in args {
                                  ^152
 2777|    152|                    self.collect_labels(*arg);
 2778|    152|                }
 2779|       |            }
 2780|      6|            ParsedNodeKind::TernaryOp(cond, then_branch, else_branch) => {
 2781|      6|                self.collect_labels(*cond);
 2782|      6|                self.collect_labels(*then_branch);
 2783|      6|                self.collect_labels(*else_branch);
 2784|      6|            }
 2785|    119|            ParsedNodeKind::Assignment(_, lhs, rhs) => {
 2786|    119|                self.collect_labels(*lhs);
 2787|    119|                self.collect_labels(*rhs);
 2788|    119|            }
 2789|     22|            ParsedNodeKind::Cast(_, expr) => {
 2790|     22|                self.collect_labels(*expr);
 2791|     22|            }
 2792|     47|            ParsedNodeKind::IndexAccess(base, index) => {
 2793|     47|                self.collect_labels(*base);
 2794|     47|                self.collect_labels(*index);
 2795|     47|            }
 2796|    132|            ParsedNodeKind::MemberAccess(base, _, _) => {
 2797|    132|                self.collect_labels(*base);
 2798|    132|            }
 2799|     17|            ParsedNodeKind::PostIncrement(operand) | ParsedNodeKind::PostDecrement(operand) => {
                                                        ^12                                      ^5
 2800|     17|                self.collect_labels(*operand);
 2801|     17|            }
 2802|     33|            ParsedNodeKind::SizeOfExpr(expr) => {
 2803|     33|                self.collect_labels(*expr);
 2804|     33|            }
 2805|    339|            ParsedNodeKind::Declaration(decl) => {
 2806|    691|                for init in &decl.init_declarators {
                                  ^352
 2807|    352|                    if let Some(e) = init.initializer {
                                              ^200
 2808|    200|                        self.collect_labels(e);
 2809|    200|                    }
                                  ^152
 2810|       |                }
 2811|       |            }
 2812|      6|            ParsedNodeKind::CompoundLiteral(_, init) => {
 2813|      6|                self.collect_labels(*init);
 2814|      6|            }
 2815|     37|            ParsedNodeKind::InitializerList(inits) => {
 2816|    108|                for init in inits {
                                  ^71
 2817|     71|                    self.collect_labels(init.initializer);
 2818|     95|                    for d in &init.designation {
                                      ^24
 2819|     24|                        match d {
 2820|     12|                            ParsedDesignator::ArrayIndex(idx) => self.collect_labels(*idx),
 2821|      0|                            ParsedDesignator::GnuArrayRange(s, e) => {
 2822|      0|                                self.collect_labels(*s);
 2823|      0|                                self.collect_labels(*e);
 2824|      0|                            }
 2825|     12|                            _ => {}
 2826|       |                        }
 2827|       |                    }
 2828|       |                }
 2829|       |            }
 2830|     32|            ParsedNodeKind::GenericSelection(control, assocs) => {
 2831|     32|                self.collect_labels(*control);
 2832|     97|                for a in assocs {
                                  ^65
 2833|     65|                    self.collect_labels(a.result_expr);
 2834|     65|                }
 2835|       |            }
 2836|      7|            ParsedNodeKind::BuiltinVaArg(_, expr) => {
 2837|      7|                self.collect_labels(*expr);
 2838|      7|            }
 2839|     11|            ParsedNodeKind::BuiltinOffsetof(_, expr) => {
 2840|     11|                self.collect_labels(*expr);
 2841|     11|            }
 2842|      4|            ParsedNodeKind::BuiltinVaStart(ap, last) => {
 2843|      4|                self.collect_labels(*ap);
 2844|      4|                self.collect_labels(*last);
 2845|      4|            }
 2846|      2|            ParsedNodeKind::BuiltinVaEnd(ap) => {
 2847|      2|                self.collect_labels(*ap);
 2848|      2|            }
 2849|      0|            ParsedNodeKind::BuiltinVaCopy(dst, src) => {
 2850|      0|                self.collect_labels(*dst);
 2851|      0|                self.collect_labels(*src);
 2852|      0|            }
 2853|     13|            ParsedNodeKind::AtomicOp(_, args) => {
 2854|     55|                for arg in args {
                                  ^42
 2855|     42|                    self.collect_labels(*arg);
 2856|     42|                }
 2857|       |            }
 2858|  1.47k|            _ => {}
 2859|       |        }
 2860|  3.64k|    }
 2861|       |
 2862|     20|    fn deduce_array_size_full(&self, init_node: NodeRef, element_type: TypeRef) -> Option<usize> {
 2863|     20|        match self.ast.get_kind(init_node) {
 2864|     11|            NodeKind::InitializerList(list) => {
 2865|       |                // Special case: array of character type initialized by { "string" }
 2866|     11|                if list.init_len > 0 {
 2867|     11|                    let first_item_ref = list.init_start;
 2868|     11|                    if let NodeKind::InitializerItem(item) = self.ast.get_kind(first_item_ref)
 2869|     11|                        && item.designator_len == 0
 2870|     10|                        && let NodeKind::Literal(literal::Literal::String(s)) = self.ast.get_kind(item.initializer)
                                                                                        ^4
 2871|       |                    {
 2872|      4|                        let parsed = crate::semantic::literal_utils::parse_string_literal(*s);
 2873|      4|                        let string_elem_type = match parsed.builtin_type {
 2874|      1|                            BuiltinType::Char => self.registry.type_char,
 2875|      1|                            BuiltinType::Int => self.registry.type_int,
 2876|      1|                            BuiltinType::UShort => self.registry.type_short_unsigned,
 2877|      1|                            BuiltinType::UInt => self.registry.type_int_unsigned,
 2878|      0|                            _ => self.registry.type_char,
 2879|       |                        };
 2880|       |
 2881|      4|                        if self.registry.is_compatible(
 2882|      4|                            QualType::unqualified(element_type),
 2883|      4|                            QualType::unqualified(string_elem_type),
 2884|       |                        ) {
 2885|      4|                            return Some(parsed.size);
 2886|      0|                        }
 2887|      7|                    }
 2888|      0|                }
 2889|       |
 2890|      7|                let mut max_index: i64 = -1;
 2891|      7|                let mut current_index: i64 = 0;
 2892|      7|                let eval = |e| const_eval::eval_const_expr(&self.const_ctx(), e);
                                             ^3                          ^3                 ^3
 2893|       |
 2894|     17|                for item_ref in list.init_start.range(list.init_len) {
                                              ^7              ^7    ^7
 2895|     17|                    let NodeKind::InitializerItem(init) = self.ast.get_kind(item_ref) else {
 2896|      0|                        continue;
 2897|       |                    };
 2898|       |
 2899|     17|                    if init.designator_len > 0 {
 2900|      3|                        match self.ast.get_kind(init.designator_start) {
 2901|      3|                            NodeKind::Designator(Designator::ArrayIndex(idx)) => {
 2902|      3|                                current_index = eval(*idx)?;
                                                                        ^0
 2903|       |                            }
 2904|      0|                            NodeKind::Designator(Designator::GnuArrayRange(start, end)) => {
 2905|      0|                                let (s_v, e_v) = (eval(*start)?, eval(*end)?);
 2906|      0|                                if s_v > e_v {
 2907|      0|                                    return None;
 2908|      0|                                }
 2909|      0|                                current_index = e_v;
 2910|       |                            }
 2911|      0|                            _ => return None,
 2912|       |                        }
 2913|     14|                    }
 2914|       |
 2915|     17|                    max_index = max_index.max(current_index);
 2916|     17|                    current_index += 1;
 2917|       |                }
 2918|       |
 2919|      7|                Some((max_index + 1) as usize)
 2920|       |            }
 2921|      9|            NodeKind::Literal(literal::Literal::String(s)) => {
 2922|      9|                let parsed = crate::semantic::literal_utils::parse_string_literal(*s);
 2923|      9|                Some(parsed.size)
 2924|       |            }
 2925|      0|            _ => None,
 2926|       |        }
 2927|     20|    }
 2928|       |}
 2929|       |/// Extracts the bit-field width from a declarator if it exists.
 2930|    190|fn extract_bit_field_width<'a>(
 2931|    190|    declarator: &'a ParsedDeclarator,
 2932|    190|    ctx: &mut LowerCtx,
 2933|    190|) -> (Option<u16>, &'a ParsedDeclarator) {
 2934|    190|    let ParsedDeclarator::BitField(base, expr_ref) = declarator else {
                                                 ^13   ^13
 2935|    177|        return (None, declarator);
 2936|       |    };
 2937|       |
 2938|     13|    let width_expr = ctx.visit_expression(*expr_ref);
 2939|     13|    let span = ctx.ast.get_span(width_expr);
 2940|       |
 2941|     13|    let width = match const_eval::eval_const_expr(&ctx.const_ctx(), width_expr) {
 2942|     12|        Some(val) if (0..=65535).contains(&val) => Some(val as u16),
 2943|       |        Some(_) => {
 2944|      0|            ctx.report_error(SemanticError::InvalidBitfieldWidth { span });
 2945|      0|            None
 2946|       |        }
 2947|       |        None => {
 2948|      1|            ctx.report_error(SemanticError::NonConstantBitfieldWidth { span });
 2949|      1|            None
 2950|       |        }
 2951|       |    };
 2952|       |
 2953|     13|    (width, base)
 2954|    190|}
 2955|       |
 2956|       |/// Common logic for lowering struct members, used by both TypeSpecifier::Record lowering
 2957|       |/// and Declarator::AnonymousRecord handling.
 2958|    119|fn visit_struct_members(members: &[ParsedDeclarationData], ctx: &mut LowerCtx, span: SourceSpan) -> Vec<StructMember> {
 2959|    119|    let mut struct_members = Vec::new();
 2960|       |
 2961|    308|    for decl in members {
                      ^189
 2962|    189|        let spec_info = visit_decl_specifiers(&decl.specifiers, ctx, span);
 2963|       |
 2964|       |        // Check for illegal storage classes
 2965|    189|        if spec_info.storage.is_some() {
 2966|      0|            ctx.report_error(SemanticError::ConflictingStorageClasses { span });
 2967|    189|        }
 2968|       |
 2969|       |        // Handle anonymous struct/union members (C11 6.7.2.1p13)
 2970|    189|        if decl.init_declarators.is_empty() {
 2971|     12|            if let Some(type_ref) = spec_info.base_type {
 2972|     12|                let type_ref = ctx.merge_qualifiers_with_check(type_ref, spec_info.qualifiers, span);
 2973|     12|                if type_ref.is_record() {
 2974|     12|                    let is_anonymous = matches!(
                                                     ^0
 2975|     12|                        &ctx.registry.get(type_ref.ty()).kind,
 2976|       |                        TypeKind::Record { tag: None, .. }
 2977|       |                    );
 2978|       |
 2979|     12|                    if is_anonymous {
 2980|     12|                        struct_members.push(StructMember {
 2981|     12|                            member_type: type_ref,
 2982|     12|                            alignment: spec_info.alignment,
 2983|     12|                            span,
 2984|     12|                            ..Default::default()
 2985|     12|                        });
 2986|     12|                    }
                                  ^0
 2987|      0|                }
 2988|      0|            }
 2989|     12|            continue;
 2990|    177|        }
 2991|       |
 2992|    367|        for init_declarator in &decl.init_declarators {
                          ^190
 2993|    190|            let (bit_field_size, base_declarator) = extract_bit_field_width(&init_declarator.declarator, ctx);
 2994|       |
 2995|    190|            if bit_field_size.is_some() && spec_info.alignment.is_some() {
                                                         ^12                 ^12
 2996|      1|                ctx.report_error(SemanticError::AlignmentNotAllowed {
 2997|      1|                    context: "bit-field".to_string(),
 2998|      1|                    span: init_declarator.span,
 2999|      1|                });
 3000|    189|            }
 3001|       |
 3002|    190|            let member_name = extract_name(base_declarator);
 3003|       |
 3004|    190|            let member_type = {
 3005|    190|                let base = spec_info
 3006|    190|                    .base_type
 3007|    190|                    .unwrap_or_else(|| QualType::unqualified(ctx.registry.type_int));
                                                     ^0                    ^0
 3008|    190|                let qualified_base = ctx.merge_qualifiers_with_check(base, spec_info.qualifiers, init_declarator.span);
 3009|    190|                apply_declarator(
 3010|    190|                    qualified_base,
 3011|    190|                    base_declarator,
 3012|    190|                    ctx,
 3013|    190|                    init_declarator.span,
 3014|    190|                    &spec_info,
 3015|    190|                    DeclaratorContext { in_parameter: false },
 3016|       |                )
 3017|       |            };
 3018|       |
 3019|       |            // Validate bit-field
 3020|    190|            if let Some(width) = bit_field_size {
                                      ^12
 3021|     12|                if !member_type.is_integer() {
 3022|      1|                    ctx.report_error(SemanticError::InvalidBitfieldType {
 3023|      1|                        ty: ctx.registry.display_qual_type(member_type),
 3024|      1|                        span: init_declarator.span,
 3025|      1|                    });
 3026|     11|                } else if let Ok(layout) = ctx.registry.ensure_layout(member_type.ty()) {
 3027|     11|                    let type_width = layout.size * 8;
 3028|     11|                    if width > type_width {
 3029|      1|                        ctx.report_error(SemanticError::BitfieldWidthExceedsType {
 3030|      1|                            width,
 3031|      1|                            type_width,
 3032|      1|                            span: init_declarator.span,
 3033|      1|                        });
 3034|     10|                    }
 3035|      0|                }
 3036|       |
 3037|     12|                if width == 0 && member_name.is_some() {
                                               ^3          ^3
 3038|      2|                    ctx.report_error(SemanticError::NamedZeroWidthBitfield {
 3039|      2|                        span: init_declarator.span,
 3040|      2|                    });
 3041|     10|                }
 3042|    178|            }
 3043|       |
 3044|    190|            if bit_field_size.is_none()
 3045|    178|                && let Ok(layout) = ctx.registry.ensure_layout(member_type.ty())
                                        ^173
 3046|    173|                && let Some(req_align) = spec_info.alignment
                                          ^4
 3047|       |            {
 3048|      4|                let natural_align = layout.alignment as u32;
 3049|      4|                if req_align < natural_align {
 3050|      0|                    ctx.report_error(SemanticError::AlignmentTooLoose {
 3051|      0|                        requested: req_align,
 3052|      0|                        natural: natural_align,
 3053|      0|                        span: init_declarator.span,
 3054|      0|                    });
 3055|      4|                }
 3056|    186|            }
 3057|       |
 3058|    190|            struct_members.push(StructMember {
 3059|    190|                name: member_name,
 3060|    190|                member_type,
 3061|    190|                bit_field_size,
 3062|    190|                alignment: spec_info.alignment,
 3063|    190|                span: init_declarator.span,
 3064|    190|            });
 3065|       |        }
 3066|       |    }
 3067|    119|    struct_members
 3068|    119|}

/app/src/semantic/symbol_table.rs:
    1|       |//! Symbol table management and scope handling.
    2|       |//!
    3|       |//! This module provides the core data structures and operations for managing
    4|       |//! symbols and scopes during semantic analysis. It maintains a hierarchical
    5|       |//! scope structure and provides efficient symbol lookup and storage.
    6|       |
    7|       |use hashbrown::HashMap;
    8|       |use std::num::NonZeroU32;
    9|       |use std::sync::Arc;
   10|       |
   11|       |use log::debug;
   12|       |use thiserror::Error;
   13|       |
   14|       |use crate::{
   15|       |    ast::*,
   16|       |    semantic::{QualType, StructMember, TypeRef},
   17|       |};
   18|       |
   19|       |pub type SymbolRef = NonZeroU32;
   20|       |
   21|       |/// Represents the definition state of a symbol entry.
   22|       |#[derive(Debug, Clone, Copy, PartialEq, Eq)]
   23|       |pub enum DefinitionState {
   24|       |    Tentative,    // int x;
   25|       |    Defined,      // int x = ...;
   26|       |    DeclaredOnly, // extern int x;
   27|       |}
   28|       |
   29|       |/// Represents a resolved symbol entry from the symbol table.
   30|       |/// This structure is typically populated during the semantic analysis phase.
   31|       |/// Symbol are stored in a separate Vec<Symbol> with SymbolRef references.
   32|       |/// invariant:
   33|       |/// - Variable / Typedef / Function: type_info is meaningful
   34|       |/// - EnumConstant: type_info = int (unqualified)
   35|       |/// - Label / RecordTag / EnumTag: type_info = TypeKind::Error
   36|       |#[derive(Debug, Clone)]
   37|       |pub struct Symbol {
   38|       |    pub name: NameId,
   39|       |    pub kind: SymbolKind, // e.g., Variable, Function, Typedef
   40|       |    pub type_info: QualType,
   41|       |    pub scope_id: ScopeId, // Reference to the scope where it's defined
   42|       |    pub def_span: SourceSpan,
   43|       |    pub def_state: DefinitionState,
   44|       |    pub is_completed: bool,
   45|       |}
   46|       |
   47|       |impl Symbol {
   48|     63|    pub(crate) fn is_const(&self) -> bool {
   49|     63|        self.type_info.is_const()
   50|     63|    }
   51|       |
   52|     53|    pub(crate) fn has_linkage(&self) -> bool {
   53|     53|        match &self.kind {
   54|     21|            SymbolKind::Function { .. } => true,
   55|     27|            SymbolKind::Variable { is_global, storage, .. } => *is_global || *storage == Some(StorageClass::Extern),
                                                                                           ^10
   56|      5|            _ => false,
   57|       |        }
   58|     53|    }
   59|       |}
   60|       |
   61|       |/// Defines the kind of symbol.
   62|       |#[derive(Debug, Clone)]
   63|       |pub enum SymbolKind {
   64|       |    Variable {
   65|       |        is_global: bool,
   66|       |        storage: Option<StorageClass>,
   67|       |        // Initializer might be an AST node or a constant value
   68|       |        initializer: Option<NodeRef>,
   69|       |        alignment: Option<u32>, // Max alignment in bytes
   70|       |    },
   71|       |    Function {
   72|       |        storage: Option<StorageClass>,
   73|       |    },
   74|       |    Typedef {
   75|       |        aliased_type: QualType,
   76|       |    },
   77|       |    EnumConstant {
   78|       |        value: i64, // Resolved constant value
   79|       |    },
   80|       |    Label,
   81|       |    Record {
   82|       |        is_complete: bool,
   83|       |        members: Arc<[StructMember]>,
   84|       |    },
   85|       |    EnumTag {
   86|       |        is_complete: bool,
   87|       |    },
   88|       |    // Add other symbol kinds as needed (e.g., Macro, BlockScope)
   89|       |}
   90|       |
   91|       |/// Symbol table error types
   92|       |#[derive(Debug, Error)]
   93|       |pub enum SymbolTableError {
   94|       |    #[error("Invalid redefinition: symbol '{name}' cannot be redefined")]
   95|       |    InvalidRedefinition { name: NameId, existing: SymbolRef },
   96|       |}
   97|       |
   98|       |use serde::Serialize;
   99|       |
  100|       |/// Scope ID for efficient scope references
  101|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize)]
  102|       |pub struct ScopeId(NonZeroU32);
  103|       |
  104|       |impl ScopeId {
  105|       |    pub const GLOBAL: Self = Self(NonZeroU32::new(1).unwrap());
  106|       |
  107|    411|    pub(crate) fn new(id: u32) -> Option<Self> {
  108|    411|        NonZeroU32::new(id).map(Self)
  109|    411|    }
  110|       |
  111|  7.95k|    pub(crate) fn get(self) -> u32 {
  112|  7.95k|        self.0.get()
  113|  7.95k|    }
  114|       |}
  115|       |
  116|       |/// Symbol namespaces in C
  117|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
  118|       |pub enum Namespace {
  119|       |    Ordinary, // Variables, functions, typedefs, enum constants
  120|       |    Tag,      // Struct, union, and enum tags
  121|       |    Label,    // Goto labels
  122|       |}
  123|       |
  124|       |/// Scope information
  125|       |#[derive(Debug, Default)]
  126|       |pub struct Scope {
  127|       |    pub parent: Option<ScopeId>,
  128|       |    pub symbols: HashMap<NameId, SymbolRef>, // Ordinary identifiers
  129|       |    pub tags: HashMap<NameId, SymbolRef>,    // Struct/union/enum tags
  130|       |    pub labels: HashMap<NameId, SymbolRef>,  // Goto labels
  131|       |    pub level: u32,
  132|       |}
  133|       |
  134|       |/// Symbol table using flattened storage
  135|       |#[derive(Debug)]
  136|       |pub struct SymbolTable {
  137|       |    pub entries: Vec<Symbol>,
  138|       |    pub scopes: Vec<Scope>,
  139|       |    current_scope_id: ScopeId,
  140|       |    next_scope_id: u32,
  141|       |}
  142|       |
  143|       |impl SymbolTable {
  144|    534|    pub(crate) fn new() -> Self {
  145|    534|        let mut table = SymbolTable {
  146|    534|            entries: Vec::new(),
  147|    534|            scopes: Vec::new(),
  148|    534|            current_scope_id: ScopeId::GLOBAL,
  149|    534|            next_scope_id: 2, // Start after GLOBAL
  150|    534|        };
  151|       |
  152|       |        // Initialize global scope
  153|    534|        table.scopes.push(Scope::default());
  154|       |
  155|    534|        table
  156|    534|    }
  157|       |
  158|    411|    pub(crate) fn push_scope(&mut self) -> ScopeId {
  159|    411|        let new_scope_id = ScopeId::new(self.next_scope_id).unwrap();
  160|    411|        self.next_scope_id += 1;
  161|       |
  162|    411|        let new_scope = Scope {
  163|    411|            parent: Some(self.current_scope_id),
  164|    411|            level: self.scopes[self.current_scope_id.get() as usize - 1].level + 1,
  165|    411|            ..Default::default()
  166|    411|        };
  167|       |
  168|    411|        self.scopes.push(new_scope);
  169|    411|        self.current_scope_id = new_scope_id;
  170|    411|        debug!(
  171|      0|            "SymbolTable: Pushed new scope. New current_scope_id: {}",
  172|      0|            self.current_scope_id.get()
  173|       |        );
  174|    411|        new_scope_id
  175|    411|    }
  176|       |
  177|    411|    pub(crate) fn pop_scope(&mut self) -> Option<ScopeId> {
  178|    411|        let current_scope_id_before_pop = self.current_scope_id;
  179|    411|        let current_scope = &self.scopes[current_scope_id_before_pop.get() as usize - 1];
  180|    411|        if let Some(parent) = current_scope.parent {
  181|    411|            self.current_scope_id = parent;
  182|    411|            debug!(
  183|      0|                "SymbolTable: Popped scope. Old current_scope_id: {}, New current_scope_id: {}",
  184|      0|                current_scope_id_before_pop.get(),
  185|      0|                self.current_scope_id.get()
  186|       |            );
  187|    411|            Some(parent)
  188|       |        } else {
  189|      0|            debug!("SymbolTable: Attempted to pop global scope. No change.");
  190|      0|            None
  191|       |        }
  192|    411|    }
  193|       |
  194|  1.12k|    pub(crate) fn current_scope(&self) -> ScopeId {
  195|  1.12k|        self.current_scope_id
  196|  1.12k|    }
  197|       |
  198|  1.31k|    pub(crate) fn set_current_scope(&mut self, scope_id: ScopeId) {
  199|  1.31k|        self.current_scope_id = scope_id;
  200|  1.31k|        debug!("SymbolTable: Set current_scope_id to {}", self.current_scope_id.get());
                             ^0                                         ^0                    ^0
  201|  1.31k|    }
  202|       |
  203|  5.08k|    pub(crate) fn get_scope(&self, scope_id: ScopeId) -> &Scope {
  204|  5.08k|        &self.scopes[scope_id.get() as usize - 1]
  205|  5.08k|    }
  206|       |
  207|  2.05k|    pub(crate) fn get_scope_mut(&mut self, scope_id: ScopeId) -> &mut Scope {
  208|  2.05k|        &mut self.scopes[scope_id.get() as usize - 1]
  209|  2.05k|    }
  210|       |
  211|  1.90k|    pub(crate) fn add_symbol(&mut self, name: NameId, entry: Symbol) -> SymbolRef {
  212|  1.90k|        let entry_ref = self.push_symbol(entry);
  213|  1.90k|        let current_scope = self.get_scope_mut(self.current_scope_id);
  214|  1.90k|        current_scope.symbols.insert(name, entry_ref);
  215|  1.90k|        entry_ref
  216|  1.90k|    }
  217|       |
  218|    148|    pub(crate) fn add_symbol_in_namespace(&mut self, name: NameId, entry: Symbol, ns: Namespace) -> SymbolRef {
  219|    148|        let entry_ref = self.push_symbol(entry);
  220|    148|        let current_scope = self.get_scope_mut(self.current_scope_id);
  221|    148|        match ns {
  222|      0|            Namespace::Ordinary => current_scope.symbols.insert(name, entry_ref),
  223|    130|            Namespace::Tag => current_scope.tags.insert(name, entry_ref),
  224|     18|            Namespace::Label => current_scope.labels.insert(name, entry_ref),
  225|       |        };
  226|    148|        entry_ref
  227|    148|    }
  228|       |
  229|  2.66k|    pub(crate) fn lookup_symbol(&self, name: NameId) -> Option<(SymbolRef, ScopeId)> {
  230|  2.66k|        self.lookup(name, self.current_scope_id, Namespace::Ordinary)
  231|  2.66k|    }
  232|       |
  233|    357|    pub(crate) fn lookup_tag(&self, name: NameId) -> Option<(SymbolRef, ScopeId)> {
  234|    357|        self.lookup(name, self.current_scope_id, Namespace::Tag)
  235|    357|    }
  236|       |
  237|  3.34k|    pub(crate) fn lookup(&self, name: NameId, start_scope: ScopeId, ns: Namespace) -> Option<(SymbolRef, ScopeId)> {
  238|  3.34k|        let mut scope_id = start_scope;
  239|       |        loop {
  240|  4.10k|            let scope = self.get_scope(scope_id);
  241|  4.10k|            let result = match ns {
  242|  3.65k|                Namespace::Ordinary => scope.symbols.get(&name),
  243|    447|                Namespace::Tag => scope.tags.get(&name),
  244|      6|                Namespace::Label => scope.labels.get(&name),
  245|       |            };
  246|  4.10k|            if let Some(&entry_ref) = result {
                                       ^1.78k
  247|  1.78k|                return Some((entry_ref, scope_id));
  248|  2.32k|            }
  249|  2.32k|            if let Some(parent) = scope.parent {
                                      ^765
  250|    765|                scope_id = parent;
  251|    765|            } else {
  252|  1.56k|                break;
  253|       |            }
  254|       |        }
  255|  1.56k|        None
  256|  3.34k|    }
  257|       |
  258|       |    /// find a symbol in exact scope without looking to parent scope if not exist
  259|    765|    pub(crate) fn fetch(&self, name: NameId, scope_id: ScopeId, ns: Namespace) -> Option<SymbolRef> {
  260|    765|        let scope = self.get_scope(scope_id);
  261|    765|        match ns {
  262|    765|            Namespace::Ordinary => scope.symbols.get(&name).copied(),
  263|      0|            Namespace::Tag => scope.tags.get(&name).copied(),
  264|      0|            Namespace::Label => scope.labels.get(&name).copied(),
  265|       |        }
  266|    765|    }
  267|       |
  268|  2.05k|    fn push_symbol(&mut self, entry: Symbol) -> SymbolRef {
  269|  2.05k|        let index = self.entries.len() as u32 + 1;
  270|  2.05k|        self.entries.push(entry);
  271|  2.05k|        SymbolRef::new(index).expect("SymbolEntryRef overflow")
  272|  2.05k|    }
  273|       |
  274|  4.52k|    pub(crate) fn get_symbol(&self, index: SymbolRef) -> &Symbol {
  275|  4.52k|        &self.entries[(index.get() - 1) as usize]
  276|  4.52k|    }
  277|       |
  278|    179|    pub(crate) fn get_symbol_mut(&mut self, index: SymbolRef) -> &mut Symbol {
  279|    179|        &mut self.entries[(index.get() - 1) as usize]
  280|    179|    }
  281|       |
  282|       |    /// Define a new variable in the current scope.
  283|       |    /// Handles global variable merging and local variable insertion.
  284|  1.41k|    pub(crate) fn define_variable(
  285|  1.41k|        &mut self,
  286|  1.41k|        name: NameId,
  287|  1.41k|        ty: QualType,
  288|  1.41k|        storage: Option<StorageClass>,
  289|  1.41k|        initializer: Option<NodeRef>,
  290|  1.41k|        alignment: Option<u32>,
  291|  1.41k|        span: SourceSpan,
  292|  1.41k|    ) -> Result<SymbolRef, SymbolTableError> {
  293|  1.41k|        let is_global = self.current_scope_id == ScopeId::GLOBAL;
  294|       |
  295|  1.41k|        let def_state = if initializer.is_some() {
  296|  1.04k|            DefinitionState::Defined
  297|    369|        } else if storage == Some(StorageClass::Extern) {
  298|     15|            DefinitionState::DeclaredOnly
  299|       |        } else {
  300|    354|            DefinitionState::Tentative
  301|       |        };
  302|       |
  303|  1.41k|        let symbol_entry = Symbol {
  304|  1.41k|            name,
  305|  1.41k|            kind: SymbolKind::Variable {
  306|  1.41k|                is_global,
  307|  1.41k|                storage,
  308|  1.41k|                initializer,
  309|  1.41k|                alignment,
  310|  1.41k|            },
  311|  1.41k|            type_info: ty,
  312|  1.41k|            scope_id: self.current_scope_id,
  313|  1.41k|            def_span: span,
  314|  1.41k|            def_state,
  315|  1.41k|            is_completed: true,
  316|  1.41k|        };
  317|       |
  318|  1.41k|        if is_global {
  319|    234|            self.merge_global_symbol(name, symbol_entry)
  320|       |        } else {
  321|  1.18k|            Ok(self.add_symbol(name, symbol_entry))
  322|       |        }
  323|  1.41k|    }
  324|       |
  325|       |    /// Define a new function in the current scope.
  326|       |    /// Handles global function merging (declarations/definitions).
  327|    452|    pub(crate) fn define_function(
  328|    452|        &mut self,
  329|    452|        name: NameId,
  330|    452|        ty: TypeRef,
  331|    452|        storage: Option<StorageClass>,
  332|    452|        is_definition: bool,
  333|    452|        span: SourceSpan,
  334|    452|    ) -> Result<SymbolRef, SymbolTableError> {
  335|       |        // Function declarations are "DeclaredOnly" by default, or "Defined" if it's a function definition
  336|    452|        let def_state = if is_definition {
  337|    373|            DefinitionState::Defined
  338|       |        } else {
  339|     79|            DefinitionState::DeclaredOnly
  340|       |        };
  341|       |
  342|    452|        let symbol_entry = Symbol {
  343|    452|            name,
  344|    452|            kind: SymbolKind::Function { storage },
  345|    452|            type_info: QualType::unqualified(ty),
  346|    452|            scope_id: self.current_scope_id,
  347|    452|            def_span: span,
  348|    452|            def_state,
  349|    452|            is_completed: true,
  350|    452|        };
  351|       |
  352|    452|        if self.current_scope_id == ScopeId::GLOBAL {
  353|    452|            self.merge_global_symbol(name, symbol_entry)
  354|       |        } else {
  355|      0|            Ok(self.add_symbol(name, symbol_entry))
  356|       |        }
  357|    452|    }
  358|       |
  359|       |    /// Define a typedef in the current scope.
  360|     48|    pub(crate) fn define_typedef(
  361|     48|        &mut self,
  362|     48|        name: NameId,
  363|     48|        ty: QualType,
  364|     48|        span: SourceSpan,
  365|     48|    ) -> Result<SymbolRef, SymbolTableError> {
  366|     48|        let symbol_entry = Symbol {
  367|     48|            name,
  368|     48|            kind: SymbolKind::Typedef { aliased_type: ty },
  369|     48|            type_info: ty,
  370|     48|            scope_id: self.current_scope_id,
  371|     48|            def_span: span,
  372|     48|            def_state: DefinitionState::Defined,
  373|     48|            is_completed: true,
  374|     48|        };
  375|       |
  376|       |        // Check for redefinition in the SAME scope
  377|     48|        if let Some(existing_ref) = self.fetch(name, self.current_scope_id, Namespace::Ordinary) {
                                  ^3
  378|      3|            return Err(SymbolTableError::InvalidRedefinition {
  379|      3|                name,
  380|      3|                existing: existing_ref,
  381|      3|            });
  382|     45|        }
  383|       |
  384|     45|        Ok(self.add_symbol(name, symbol_entry))
  385|     48|    }
  386|       |
  387|       |    /// Define an enum constant in the current scope.
  388|     31|    pub(crate) fn define_enum_constant(
  389|     31|        &mut self,
  390|     31|        name: NameId,
  391|     31|        value: i64,
  392|     31|        ty: TypeRef,
  393|     31|        span: SourceSpan,
  394|     31|    ) -> Result<SymbolRef, SymbolTableError> {
  395|     31|        let symbol_entry = Symbol {
  396|     31|            name,
  397|     31|            kind: SymbolKind::EnumConstant { value },
  398|     31|            type_info: QualType::unqualified(ty),
  399|     31|            scope_id: self.current_scope_id,
  400|     31|            def_span: span,
  401|     31|            def_state: DefinitionState::Defined,
  402|     31|            is_completed: true,
  403|     31|        };
  404|       |
  405|     31|        if let Some(existing_ref) = self.fetch(name, self.current_scope_id, Namespace::Ordinary) {
                                  ^1
  406|      1|            return Err(SymbolTableError::InvalidRedefinition {
  407|      1|                name,
  408|      1|                existing: existing_ref,
  409|      1|            });
  410|     30|        }
  411|       |
  412|     30|        Ok(self.add_symbol(name, symbol_entry))
  413|     31|    }
  414|       |
  415|       |    /// Define a record (struct/union) tag in the current scope.
  416|    115|    pub(crate) fn define_record(
  417|    115|        &mut self,
  418|    115|        name: NameId,
  419|    115|        ty: TypeRef,
  420|    115|        is_complete: bool,
  421|    115|        span: SourceSpan,
  422|    115|    ) -> SymbolRef {
  423|    115|        let symbol_entry = Symbol {
  424|    115|            name,
  425|    115|            kind: SymbolKind::Record {
  426|    115|                is_complete,
  427|    115|                members: Arc::from([]),
  428|    115|            },
  429|    115|            type_info: QualType::unqualified(ty),
  430|    115|            scope_id: self.current_scope_id,
  431|    115|            def_span: span,
  432|    115|            def_state: DefinitionState::Defined,
  433|    115|            is_completed: false,
  434|    115|        };
  435|    115|        self.add_symbol_in_namespace(name, symbol_entry, Namespace::Tag)
  436|    115|    }
  437|       |
  438|       |    /// Define an enum tag in the current scope.
  439|     15|    pub(crate) fn define_enum(&mut self, name: NameId, ty: TypeRef, span: SourceSpan) -> SymbolRef {
  440|     15|        let symbol_entry = Symbol {
  441|     15|            name,
  442|     15|            kind: SymbolKind::EnumTag { is_complete: false },
  443|     15|            type_info: QualType::unqualified(ty),
  444|     15|            scope_id: self.current_scope_id,
  445|     15|            def_span: span,
  446|     15|            def_state: DefinitionState::Defined,
  447|     15|            is_completed: false,
  448|     15|        };
  449|     15|        self.add_symbol_in_namespace(name, symbol_entry, Namespace::Tag)
  450|     15|    }
  451|       |
  452|       |    /// Define a label in the current scope.
  453|     18|    pub(crate) fn define_label(
  454|     18|        &mut self,
  455|     18|        name: NameId,
  456|     18|        ty: TypeRef,
  457|     18|        span: SourceSpan,
  458|     18|    ) -> Result<SymbolRef, SymbolTableError> {
  459|     18|        let symbol_entry = Symbol {
  460|     18|            name,
  461|     18|            kind: SymbolKind::Label,
  462|     18|            type_info: QualType::unqualified(ty),
  463|     18|            scope_id: self.current_scope_id,
  464|     18|            def_span: span,
  465|     18|            def_state: DefinitionState::Defined,
  466|     18|            is_completed: true,
  467|     18|        };
  468|     18|        Ok(self.add_symbol_in_namespace(name, symbol_entry, Namespace::Label))
  469|     18|    }
  470|       |
  471|       |    /// Lookup a label in the current scope.
  472|      6|    pub(crate) fn lookup_label(&self, name: NameId) -> Option<(SymbolRef, ScopeId)> {
  473|      6|        self.lookup(name, self.current_scope_id, Namespace::Label)
  474|      6|    }
  475|       |
  476|       |    /// Merge a new symbol entry with an existing one in the global scope.
  477|       |    /// This implements C11 6.9.2 for handling tentative definitions, extern declarations, and actual definitions.
  478|    686|    fn merge_global_symbol(&mut self, name: NameId, mut new_entry: Symbol) -> Result<SymbolRef, SymbolTableError> {
  479|    686|        let global_scope = ScopeId::GLOBAL;
  480|       |
  481|       |        // Check if symbol already exists in global scope
  482|    686|        if let Some(existing_ref) = self.fetch(name, global_scope, Namespace::Ordinary) {
                                  ^36
  483|     36|            let existing = self.get_symbol_mut(existing_ref);
  484|       |
  485|       |            // Verify kinds match
  486|     36|            match (&existing.kind, &new_entry.kind) {
  487|     13|                (SymbolKind::Variable { .. }, SymbolKind::Variable { .. }) => {}
  488|     21|                (SymbolKind::Function { .. }, SymbolKind::Function { .. }) => {}
  489|       |                _ => {
  490|       |                    // Mismatched kinds
  491|      2|                    debug!("Symbol '{}' redefinition: different kinds", name);
                                         ^0
  492|      2|                    return Err(SymbolTableError::InvalidRedefinition {
  493|      2|                        name,
  494|      2|                        existing: existing_ref,
  495|      2|                    });
  496|       |                }
  497|       |            }
  498|       |
  499|       |            // Check alignment compatibility (Variables only)
  500|       |            if let SymbolKind::Variable {
  501|     13|                alignment: new_align, ..
  502|     34|            } = &new_entry.kind
  503|       |                && let SymbolKind::Variable {
  504|     13|                    alignment: existing_align,
  505|       |                    ..
  506|     13|                } = &existing.kind
  507|       |            {
  508|     13|                match (existing_align, new_align) {
  509|      0|                    (Some(a), Some(b)) if a != b => {
  510|      0|                        return Err(SymbolTableError::InvalidRedefinition {
  511|      0|                            name,
  512|      0|                            existing: existing_ref,
  513|      0|                        });
  514|       |                    }
  515|      0|                    (None, Some(b)) => {
  516|       |                        // Inherit alignment from new declaration
  517|      0|                        if let SymbolKind::Variable { alignment, .. } = &mut existing.kind {
  518|      0|                            *alignment = Some(*b);
  519|      0|                        }
  520|       |                    }
  521|     13|                    _ => {}
  522|       |                }
  523|     21|            }
  524|       |
  525|       |            // Apply C11 merging rules
  526|     34|            match (existing.def_state, new_entry.def_state) {
  527|       |                (DefinitionState::Defined, DefinitionState::Defined) => {
  528|       |                    // Multiple actual definitions - error
  529|      2|                    debug!("Multiple definitions of '{}'", name);
                                         ^0
  530|      2|                    return Err(SymbolTableError::InvalidRedefinition {
  531|      2|                        name,
  532|      2|                        existing: existing_ref,
  533|      2|                    });
  534|       |                }
  535|       |
  536|       |                (DefinitionState::Defined, _) => {
  537|       |                    // Already defined, ignore new declaration/tentative definition
  538|      1|                    debug!("Ignoring redundant declaration for already-defined '{}'", name);
                                         ^0
  539|       |                }
  540|       |
  541|       |                (_, DefinitionState::Defined) => {
  542|       |                    // Upgrade to defined
  543|     14|                    debug!("Upgrading to defined for '{}'", name);
                                         ^0
  544|     14|                    existing.def_state = DefinitionState::Defined;
  545|     14|                    if let SymbolKind::Variable { initializer, .. } = &mut new_entry.kind
                                                                ^1
  546|       |                        && let SymbolKind::Variable {
  547|      1|                            initializer: existing_init,
  548|       |                            ..
  549|      1|                        } = &mut existing.kind
  550|      1|                    {
  551|      1|                        *existing_init = *initializer;
  552|     13|                    }
  553|       |                }
  554|       |
  555|       |                (DefinitionState::Tentative, DefinitionState::Tentative)
  556|       |                | (DefinitionState::Tentative, DefinitionState::DeclaredOnly)
  557|       |                | (DefinitionState::DeclaredOnly, DefinitionState::DeclaredOnly) => {
  558|       |                    // No change to def_state
  559|     15|                    debug!("Merging similar or weaker definition for '{}'", name);
                                         ^0
  560|       |                }
  561|       |
  562|       |                (DefinitionState::DeclaredOnly, DefinitionState::Tentative) => {
  563|       |                    // Upgrade to tentative
  564|      2|                    debug!("Upgrading extern declaration to tentative for '{}'", name);
                                         ^0
  565|      2|                    existing.def_state = DefinitionState::Tentative;
  566|       |                }
  567|       |            }
  568|       |
  569|     32|            Ok(existing_ref)
  570|       |        } else {
  571|       |            // Symbol doesn't exist, add it
  572|    650|            debug!(
  573|      0|                "Adding new global symbol '{}' with def_state {:?}",
  574|       |                name, new_entry.def_state
  575|       |            );
  576|    650|            Ok(self.add_symbol(name, new_entry))
  577|       |        }
  578|    686|    }
  579|       |}

/app/src/semantic/type_registry.rs:
    1|       |//! Type Registry
    2|       |//!
    3|       |//! Arena + canonicalization layer for semantic types.
    4|       |//! All TypeRef creation and mutation MUST go through this context.
    5|       |
    6|       |use std::borrow::Cow;
    7|       |use std::sync::Arc;
    8|       |
    9|       |use crate::source_manager::SourceSpan;
   10|       |use crate::{ast::NameId, diagnostic::SemanticError, semantic::QualType};
   11|       |use hashbrown::{HashMap, HashSet};
   12|       |use smallvec::SmallVec;
   13|       |use target_lexicon::{PointerWidth, Triple};
   14|       |
   15|       |use super::types::TypeClass;
   16|       |use super::types::{FieldLayout, LayoutKind};
   17|       |use super::{
   18|       |    ArraySizeType, BuiltinType, EnumConstant, FunctionParameter, StructMember, Type, TypeKind, TypeLayout,
   19|       |    TypeQualifiers, TypeRef,
   20|       |};
   21|       |
   22|       |/// Central arena & factory for semantic types.
   23|       |///
   24|       |/// Invariants:
   25|       |/// - All TypeRef come from this context
   26|       |/// - Types are never removed
   27|       |/// - Canonical types are reused when possible
   28|       |pub struct TypeRegistry {
   29|       |    pub target_triple: Triple,
   30|       |
   31|       |    // Index 0 is dummy.
   32|       |    // Index 1..16 are builtins.
   33|       |    // Index 17+ are allocated types.
   34|       |    pub types: Vec<Type>,
   35|       |
   36|       |    // --- Canonicalization caches ---
   37|       |    pointer_cache: HashMap<QualType, TypeRef>,
   38|       |    array_cache: HashMap<(TypeRef, ArraySizeType), TypeRef>,
   39|       |    function_cache: HashMap<FnSigKey, TypeRef>,
   40|       |    complex_cache: HashMap<TypeRef, TypeRef>,
   41|       |
   42|       |    // --- Layout computation tracking ---
   43|       |    layout_in_progress: HashSet<TypeRef>,
   44|       |
   45|       |    // --- Common builtin types ---
   46|       |    pub type_void: TypeRef,
   47|       |    pub type_bool: TypeRef,
   48|       |    pub type_short: TypeRef,
   49|       |    pub type_short_unsigned: TypeRef,
   50|       |    pub type_int: TypeRef,
   51|       |    pub type_int_unsigned: TypeRef,
   52|       |    pub type_long: TypeRef,
   53|       |    pub type_long_unsigned: TypeRef,
   54|       |    pub type_long_long: TypeRef,
   55|       |    pub type_long_long_unsigned: TypeRef,
   56|       |    pub type_char: TypeRef,
   57|       |    pub type_schar: TypeRef,
   58|       |    pub type_char_unsigned: TypeRef,
   59|       |    pub type_float: TypeRef,
   60|       |    pub type_double: TypeRef,
   61|       |    pub type_long_double: TypeRef,
   62|       |    pub type_void_ptr: TypeRef,
   63|       |    pub type_signed: TypeRef,
   64|       |    pub type_valist: TypeRef,
   65|       |    pub type_complex_marker: TypeRef,
   66|       |    pub type_error: TypeRef,
   67|       |}
   68|       |
   69|       |impl Default for TypeRegistry {
   70|      0|    fn default() -> Self {
   71|      0|        Self::new(Triple::host())
   72|      0|    }
   73|       |}
   74|       |
   75|       |impl TypeRegistry {
   76|       |    /// Create a new TypeRegistry with builtin types initialized.
   77|    540|    pub(crate) fn new(target_triple: Triple) -> Self {
   78|    540|        let mut reg = TypeRegistry {
   79|    540|            target_triple,
   80|    540|            types: Vec::new(),
   81|    540|            pointer_cache: HashMap::new(),
   82|    540|            array_cache: HashMap::new(),
   83|    540|            function_cache: HashMap::new(),
   84|    540|            complex_cache: HashMap::new(),
   85|    540|            layout_in_progress: HashSet::new(),
   86|    540|
   87|    540|            // temporary placeholders - will be overwritten by create_builtin
   88|    540|            type_void: TypeRef::dummy(),
   89|    540|            type_bool: TypeRef::dummy(),
   90|    540|            type_int: TypeRef::dummy(),
   91|    540|            type_int_unsigned: TypeRef::dummy(),
   92|    540|            type_short: TypeRef::dummy(),
   93|    540|            type_long: TypeRef::dummy(),
   94|    540|            type_long_long: TypeRef::dummy(),
   95|    540|            type_char: TypeRef::dummy(),
   96|    540|            type_schar: TypeRef::dummy(),
   97|    540|            type_short_unsigned: TypeRef::dummy(),
   98|    540|            type_char_unsigned: TypeRef::dummy(),
   99|    540|            type_long_unsigned: TypeRef::dummy(),
  100|    540|            type_long_long_unsigned: TypeRef::dummy(),
  101|    540|            type_float: TypeRef::dummy(),
  102|    540|            type_double: TypeRef::dummy(),
  103|    540|            type_long_double: TypeRef::dummy(),
  104|    540|            type_void_ptr: TypeRef::dummy(),
  105|    540|            type_signed: TypeRef::dummy(),
  106|    540|            type_valist: TypeRef::dummy(),
  107|    540|            type_complex_marker: TypeRef::dummy(),
  108|    540|            type_error: TypeRef::dummy(),
  109|    540|        };
  110|       |
  111|       |        // Initialize dummy at index 0
  112|    540|        reg.types.push(Type::new(TypeKind::Error));
  113|       |
  114|    540|        reg.create_builtin();
  115|    540|        reg
  116|    540|    }
  117|       |
  118|    540|    fn create_builtin(&mut self) {
  119|       |        // Reset types to just dummy to ensure order
  120|    540|        self.types.truncate(1);
  121|       |
  122|       |        // Must match BuiltinType enum values 1..16 sequentially
  123|       |
  124|       |        // 1: Void
  125|    540|        self.type_void = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Void));
  126|       |
  127|       |        // 2: Bool
  128|    540|        self.type_bool = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Bool));
  129|       |
  130|       |        // 3: Char (signed)
  131|    540|        self.type_char = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Char));
  132|       |
  133|       |        // 4: SChar (explicit signed char)
  134|    540|        self.type_schar = self.alloc_builtin(TypeKind::Builtin(BuiltinType::SChar));
  135|       |
  136|       |        // 5: UChar
  137|    540|        self.type_char_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::UChar));
  138|       |
  139|       |        // 6: Short
  140|    540|        self.type_short = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Short));
  141|       |
  142|       |        // 7: UShort
  143|    540|        self.type_short_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::UShort));
  144|       |
  145|       |        // 8: Int
  146|    540|        self.type_int = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Int));
  147|       |
  148|       |        // 9: UInt
  149|    540|        self.type_int_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::UInt));
  150|       |
  151|       |        // 10: Long
  152|    540|        self.type_long = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Long));
  153|       |
  154|       |        // 11: ULong
  155|    540|        self.type_long_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::ULong));
  156|       |
  157|       |        // 12: LongLong
  158|    540|        self.type_long_long = self.alloc_builtin(TypeKind::Builtin(BuiltinType::LongLong));
  159|       |
  160|       |        // 13: ULongLong
  161|    540|        self.type_long_long_unsigned = self.alloc_builtin(TypeKind::Builtin(BuiltinType::ULongLong));
  162|       |
  163|       |        // 14: Float
  164|    540|        self.type_float = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Float));
  165|       |
  166|       |        // 15: Double
  167|    540|        self.type_double = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Double));
  168|       |
  169|       |        // 16: LongDouble
  170|    540|        self.type_long_double = self.alloc_builtin(TypeKind::Builtin(BuiltinType::LongDouble));
  171|       |
  172|       |        // 17: Signed (marker)
  173|    540|        self.type_signed = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Signed));
  174|       |
  175|       |        // 18: VaList
  176|    540|        self.type_valist = self.alloc_builtin(TypeKind::Builtin(BuiltinType::VaList));
  177|       |
  178|       |        // 19: Complex (marker)
  179|    540|        self.type_complex_marker = self.alloc_builtin(TypeKind::Builtin(BuiltinType::Complex));
  180|       |
  181|       |        // Pre-calculate void*
  182|    540|        self.type_void_ptr = self.pointer_to(QualType::unqualified(self.type_void));
  183|       |
  184|       |        // We can assert that the last allocated index was 18
  185|    540|        debug_assert_eq!(self.types.len() - 1, 19, "Builtin types allocation mismatch");
                                                                 ^0
  186|       |
  187|       |        // Compute layouts for all builtins immediately
  188|       |        // This prevents ICEs when code generation assumes builtins have layouts
  189|    540|        let builtins = [
  190|    540|            self.type_void,
  191|    540|            self.type_bool,
  192|    540|            self.type_char,
  193|    540|            self.type_schar,
  194|    540|            self.type_char_unsigned,
  195|    540|            self.type_short,
  196|    540|            self.type_short_unsigned,
  197|    540|            self.type_int,
  198|    540|            self.type_int_unsigned,
  199|    540|            self.type_long,
  200|    540|            self.type_long_unsigned,
  201|    540|            self.type_long_long,
  202|    540|            self.type_long_long_unsigned,
  203|    540|            self.type_float,
  204|    540|            self.type_double,
  205|    540|            self.type_long_double,
  206|    540|            self.type_signed,
  207|    540|            self.type_valist,
  208|    540|            self.type_complex_marker,
  209|    540|            self.type_void_ptr,
  210|    540|        ];
  211|       |
  212|  11.3k|        for &ty in &builtins {
                           ^10.8k
  213|  10.8k|            let _ = self.ensure_layout(ty);
  214|  10.8k|        }
  215|    540|    }
  216|       |
  217|  10.2k|    fn alloc_builtin(&mut self, kind: TypeKind) -> TypeRef {
  218|  10.2k|        let ty = Type::new(kind);
  219|  10.2k|        self.alloc(ty)
  220|  10.2k|    }
  221|       |
  222|     19|    pub(crate) fn get_builtin_type(&self, b: BuiltinType) -> TypeRef {
  223|     19|        match b {
  224|      1|            BuiltinType::Void => self.type_void,
  225|      1|            BuiltinType::Bool => self.type_bool,
  226|      1|            BuiltinType::Char => self.type_char,
  227|      1|            BuiltinType::SChar => self.type_schar,
  228|      1|            BuiltinType::UChar => self.type_char_unsigned,
  229|      1|            BuiltinType::Short => self.type_short,
  230|      1|            BuiltinType::UShort => self.type_short_unsigned,
  231|      1|            BuiltinType::Int => self.type_int,
  232|      1|            BuiltinType::UInt => self.type_int_unsigned,
  233|      1|            BuiltinType::Long => self.type_long,
  234|      1|            BuiltinType::ULong => self.type_long_unsigned,
  235|      1|            BuiltinType::LongLong => self.type_long_long,
  236|      1|            BuiltinType::ULongLong => self.type_long_long_unsigned,
  237|      1|            BuiltinType::Float => self.type_float,
  238|      1|            BuiltinType::Double => self.type_double,
  239|      1|            BuiltinType::LongDouble => self.type_long_double,
  240|      1|            BuiltinType::Signed => self.type_signed,
  241|      1|            BuiltinType::VaList => self.type_valist,
  242|      1|            BuiltinType::Complex => self.type_complex_marker,
  243|       |        }
  244|     19|    }
  245|       |
  246|       |    /// Allocate a new canonical type and return its TypeRef.
  247|  10.9k|    fn alloc(&mut self, ty: Type) -> TypeRef {
  248|  10.9k|        let idx = self.types.len() as u32;
  249|  10.9k|        self.types.push(ty);
  250|  10.9k|        let kind_ref = &self.types[idx as usize].kind;
  251|  10.9k|        let class = kind_ref.to_class();
  252|       |
  253|  10.9k|        TypeRef::new(idx, class, 0, 0).expect("TypeRef alloc failed")
  254|  10.9k|    }
  255|       |
  256|       |    /// Resolve a TypeRef to a Type.
  257|       |    /// Returns Cow because inline types are constructed on the fly.
  258|       |    #[inline]
  259|  15.3k|    pub(crate) fn get(&self, r: TypeRef) -> Cow<'_, Type> {
  260|  15.3k|        if r.is_inline_pointer() {
  261|       |            // Reconstruct Pointer Type
  262|       |            // We need to know the TypeRef of the pointee.
  263|    231|            let pointee = self.reconstruct_pointee(r);
  264|       |
  265|       |            // Pointer layout is always fixed
  266|    231|            let layout = TypeLayout {
  267|    231|                size: 8,
  268|    231|                alignment: 8,
  269|    231|                kind: LayoutKind::Scalar,
  270|    231|            };
  271|       |
  272|    231|            Cow::Owned(Type {
  273|    231|                kind: TypeKind::Pointer {
  274|    231|                    pointee: QualType::unqualified(pointee),
  275|    231|                },
  276|    231|                layout: Some(layout),
  277|    231|            })
  278|  15.1k|        } else if r.is_inline_array() {
  279|       |            // Reconstruct Array Type
  280|    337|            let element = self.reconstruct_element(r);
  281|    337|            let len = r.array_len().unwrap() as u64;
  282|       |
  283|    337|            Cow::Owned(Type {
  284|    337|                kind: TypeKind::Array {
  285|    337|                    element_type: element,
  286|    337|                    size: ArraySizeType::Constant(len as usize),
  287|    337|                },
  288|    337|                layout: None,
  289|    337|            })
  290|       |        } else {
  291|       |            // Registry type
  292|  14.7k|            Cow::Borrowed(&self.types[r.index()])
  293|       |        }
  294|  15.3k|    }
  295|       |
  296|       |    /// Helper to get the pointee type if the given type is a pointer.
  297|    127|    pub(crate) fn get_pointee(&self, ty: TypeRef) -> Option<QualType> {
  298|    127|        if ty.is_inline_pointer() {
  299|    112|            Some(QualType::unqualified(self.reconstruct_pointee(ty)))
  300|       |        } else {
  301|     15|            match &self.get(ty).kind {
  302|     14|                TypeKind::Pointer { pointee } => Some(*pointee),
  303|      1|                _ => None,
  304|       |            }
  305|       |        }
  306|    127|    }
  307|       |
  308|      1|    pub(crate) fn is_char_type(&self, ty: TypeRef) -> bool {
  309|      1|        self.get(ty).kind.builtin().is_some_and(|b| b.is_char())
  310|      1|    }
  311|       |
  312|       |    /// Helper to get the element type if the given type is an array.
  313|     66|    pub(crate) fn get_array_element(&self, ty: TypeRef) -> Option<TypeRef> {
  314|     66|        if ty.is_inline_array() {
  315|     65|            Some(self.reconstruct_element(ty))
  316|       |        } else {
  317|      1|            match &self.get(ty).kind {
  318|      1|                TypeKind::Array { element_type, .. } => Some(*element_type),
  319|      0|                _ => None,
  320|       |            }
  321|       |        }
  322|     66|    }
  323|       |
  324|       |    // Legacy support: mutable access only for completing records/enums
  325|       |    #[inline]
  326|    137|    fn get_mut(&mut self, r: TypeRef) -> &mut Type {
  327|       |        // Cannot mutate inline types
  328|    137|        if r.is_inline_pointer() || r.is_inline_array() {
  329|      0|            panic!("Cannot get_mut on inline type {:?}", r);
  330|    137|        }
  331|    137|        &mut self.types[r.index()]
  332|    137|    }
  333|       |
  334|    345|    fn reconstruct_pointee(&self, r: TypeRef) -> TypeRef {
  335|    345|        debug_assert!(r.is_inline_pointer());
  336|    345|        let depth = r.pointer_depth();
  337|    345|        if depth > 1 {
  338|       |            // Decrement depth
  339|      3|            TypeRef::new(r.base(), r.class(), depth - 1, 0).unwrap()
  340|       |        } else {
  341|       |            // Depth becomes 0. Class becomes Class of Base.
  342|       |            // Look up base in registry.
  343|    342|            let base_idx = r.base();
  344|    342|            let base_type = &self.types[base_idx as usize];
  345|    342|            let base_class = base_type.kind.to_class();
  346|    342|            TypeRef::new(base_idx, base_class, 0, 0).unwrap()
  347|       |        }
  348|    345|    }
  349|       |
  350|  1.17k|    fn reconstruct_element(&self, r: TypeRef) -> TypeRef {
  351|  1.17k|        debug_assert!(r.is_inline_array());
  352|       |        // Array becomes non-array (arr=0). Class becomes Class of Base.
  353|  1.17k|        let base_idx = r.base();
  354|  1.17k|        let base_type = &self.types[base_idx as usize];
  355|  1.17k|        let base_class = base_type.kind.to_class();
  356|  1.17k|        TypeRef::new(base_idx, base_class, 0, 0).unwrap()
  357|  1.17k|    }
  358|       |
  359|       |    // ============================================================
  360|       |    // Canonical type constructors
  361|       |    // ============================================================
  362|    843|    pub(crate) fn pointer_to(&mut self, base: QualType) -> TypeRef {
  363|       |        // Try inline if unqualified
  364|    843|        if base.qualifiers().is_empty() {
  365|    775|            let base_ty = base.ty();
  366|       |            // 1. If base is Inline Pointer (depth 1..2), we can increment depth (max 3).
  367|    775|            if base_ty.is_inline_pointer() {
  368|     11|                let depth = base_ty.pointer_depth();
  369|     11|                if depth < 3 {
  370|     10|                    return TypeRef::new(base_ty.base(), TypeClass::Pointer, depth + 1, 0).unwrap();
  371|      1|                }
  372|    764|            }
  373|       |
  374|       |            // 2. If base is Simple (Ptr=0, Arr=0), we can make Inline Pointer depth 1.
  375|    765|            if base_ty.pointer_depth() == 0 && base_ty.array_len().is_none() {
                                                             ^764                ^764
  376|    755|                return TypeRef::new(base_ty.base(), TypeClass::Pointer, 1, 0).unwrap();
  377|     10|            }
  378|     68|        }
  379|       |
  380|       |        // Fallback to Registry
  381|     78|        if let Some(&ptr) = self.pointer_cache.get(&base) {
                                   ^21
  382|     21|            return ptr;
  383|     57|        }
  384|       |
  385|     57|        let ptr = self.alloc(Type::new(TypeKind::Pointer { pointee: base }));
  386|     57|        self.pointer_cache.insert(base, ptr);
  387|     57|        ptr
  388|    843|    }
  389|       |
  390|    598|    pub(crate) fn array_of(&mut self, elem: TypeRef, size: ArraySizeType) -> TypeRef {
  391|       |        // Try inline
  392|    598|        if let ArraySizeType::Constant(len) = size
                                                     ^556
  393|    556|            && len <= 31
  394|    550|            && elem.pointer_depth() == 0
  395|    542|            && elem.array_len().is_none()
  396|       |        {
  397|       |            // Check if elem is Simple
  398|    533|            return TypeRef::new(elem.base(), TypeClass::Array, 0, len as u32).unwrap();
  399|     65|        }
  400|       |
  401|     65|        let key = (elem, size.clone());
  402|     65|        if let Some(&arr) = self.array_cache.get(&key) {
                                   ^8
  403|      8|            return arr;
  404|     57|        }
  405|       |
  406|     57|        let arr = self.alloc(Type::new(TypeKind::Array {
  407|     57|            element_type: elem,
  408|     57|            size,
  409|     57|        }));
  410|     57|        self.array_cache.insert(key, arr);
  411|     57|        arr
  412|    598|    }
  413|       |
  414|    472|    pub(crate) fn function_type(
  415|    472|        &mut self,
  416|    472|        return_type: TypeRef,
  417|    472|        params: Vec<FunctionParameter>,
  418|    472|        is_variadic: bool,
  419|    472|        is_noreturn: bool,
  420|    472|    ) -> TypeRef {
  421|       |        // Bolt : Collect into SmallVec to avoid heap allocation for the lookup key
  422|       |        // in the common case (<= 8 parameters).
  423|    472|        let key = FnSigKey {
  424|    472|            return_type,
  425|    472|            params: params.iter().map(|p| p.param_type).collect(),
  426|    472|            is_variadic,
  427|    472|            is_noreturn,
  428|       |        };
  429|       |
  430|    472|        if let Some(&f) = self.function_cache.get(&key) {
                                   ^35
  431|     35|            return f;
  432|    437|        }
  433|       |
  434|    437|        let f = self.alloc(Type::new(TypeKind::Function {
  435|    437|            return_type,
  436|    437|            parameters: Arc::from(params),
  437|    437|            is_variadic,
  438|    437|            is_noreturn,
  439|    437|        }));
  440|       |
  441|    437|        self.function_cache.insert(key, f);
  442|    437|        f
  443|    472|    }
  444|       |
  445|     78|    pub(crate) fn complex_type(&mut self, base_type: TypeRef) -> TypeRef {
  446|     78|        if let Some(&complex) = self.complex_cache.get(&base_type) {
                                   ^49
  447|     49|            return complex;
  448|     29|        }
  449|       |
  450|       |        // Complex is usually stored in registry.
  451|     29|        let complex = self.alloc(Type::new(TypeKind::Complex { base_type }));
  452|     29|        self.complex_cache.insert(base_type, complex);
  453|     29|        complex
  454|     78|    }
  455|       |
  456|       |    // ============================================================
  457|       |    // Record / enum handling
  458|       |    // ============================================================
  459|       |
  460|    136|    pub(crate) fn declare_record(&mut self, tag: Option<NameId>, is_union: bool) -> TypeRef {
  461|    136|        self.alloc(Type::new(TypeKind::Record {
  462|    136|            tag,
  463|    136|            members: Arc::from([]),
  464|    136|            is_complete: false,
  465|    136|            is_union,
  466|    136|        }))
  467|    136|    }
  468|       |
  469|    122|    pub(crate) fn complete_record(&mut self, record: TypeRef, members: Vec<StructMember>) {
  470|    122|        let ty = self.get_mut(record);
  471|    122|        match &mut ty.kind {
  472|       |            TypeKind::Record {
  473|    122|                is_complete,
  474|    122|                members: slot,
  475|       |                ..
  476|    122|            } => {
  477|    122|                *slot = Arc::from(members);
  478|    122|                *is_complete = true;
  479|    122|            }
  480|      0|            _ => unreachable!("complete_record on non-record"),
  481|       |        }
  482|    122|    }
  483|       |
  484|     16|    pub(crate) fn declare_enum(&mut self, tag: Option<NameId>, base_type: TypeRef) -> TypeRef {
  485|     16|        self.alloc(Type::new(TypeKind::Enum {
  486|     16|            tag,
  487|     16|            base_type,
  488|     16|            enumerators: Arc::from([]),
  489|     16|            is_complete: false,
  490|     16|        }))
  491|     16|    }
  492|       |
  493|     15|    pub(crate) fn complete_enum(&mut self, enum_ty: TypeRef, enumerators: Vec<EnumConstant>) {
  494|     15|        let ty = self.get_mut(enum_ty);
  495|     15|        match &mut ty.kind {
  496|       |            TypeKind::Enum {
  497|     15|                is_complete,
  498|     15|                enumerators: slot,
  499|       |                ..
  500|     15|            } => {
  501|     15|                *slot = Arc::from(enumerators);
  502|     15|                *is_complete = true;
  503|     15|            }
  504|      0|            _ => unreachable!("complete_enum on non-enum"),
  505|       |        }
  506|     15|    }
  507|       |
  508|       |    // ============================================================
  509|       |    // Layout
  510|       |    // ============================================================
  511|       |
  512|  2.07k|    pub(crate) fn get_layout(&self, ty: TypeRef) -> Cow<'_, TypeLayout> {
  513|  2.07k|        if ty.is_inline_pointer() {
  514|      6|            return Cow::Owned(TypeLayout {
  515|      6|                size: 8,
  516|      6|                alignment: 8,
  517|      6|                kind: LayoutKind::Scalar,
  518|      6|            });
  519|  2.07k|        }
  520|       |
  521|  2.07k|        if ty.is_inline_array() {
  522|    108|            let elem = self.reconstruct_element(ty);
  523|    108|            let elem_layout = self.get_layout(elem);
  524|    108|            let len = ty.array_len().unwrap() as u64;
  525|    108|            return Cow::Owned(TypeLayout {
  526|    108|                size: elem_layout.size * (len as u16), // Potential overflow if not careful, but C rules apply
  527|    108|                alignment: elem_layout.alignment,
  528|    108|                kind: LayoutKind::Array { element: elem, len },
  529|    108|            });
  530|  1.96k|        }
  531|       |
  532|  1.96k|        let idx = ty.index();
  533|  1.96k|        match self.types[idx].layout.as_ref() {
  534|  1.96k|            Some(x) => Cow::Borrowed(x),
  535|      0|            None => panic!("ICE: TypeRef {ty} layout not computed. make sure layout is computed in previous phase"),
  536|       |        }
  537|  2.07k|    }
  538|       |
  539|     96|    pub(crate) fn get_array_layout(&self, ty: TypeRef) -> (u16, u16, TypeRef, u64) {
  540|     96|        let layout = self.get_layout(ty);
  541|     96|        match layout.kind {
  542|     96|            LayoutKind::Array { element, len } => (layout.size, layout.alignment, element, len),
  543|      0|            _ => panic!("ICE: layout is not array"),
  544|       |        }
  545|     96|    }
  546|       |
  547|  15.5k|    pub(crate) fn ensure_layout(&mut self, ty: TypeRef) -> Result<Cow<'_, TypeLayout>, SemanticError> {
  548|  15.5k|        if ty.is_inline_pointer() {
  549|    635|            return Ok(Cow::Owned(TypeLayout {
  550|    635|                size: 8,
  551|    635|                alignment: 8,
  552|    635|                kind: LayoutKind::Scalar,
  553|    635|            }));
  554|  14.9k|        }
  555|       |
  556|  14.9k|        if ty.is_inline_array() {
  557|       |            // Recursive check
  558|    611|            let elem = self.reconstruct_element(ty);
  559|    611|            let elem_layout = self.ensure_layout(elem)?; // returns Cow
                              ^610                                  ^1
  560|    610|            let len = ty.array_len().unwrap() as u64;
  561|    610|            let size = (elem_layout.size as u64 * len) as u16;
  562|       |
  563|    610|            return Ok(Cow::Owned(TypeLayout {
  564|    610|                size,
  565|    610|                alignment: elem_layout.alignment,
  566|    610|                kind: LayoutKind::Array { element: elem, len },
  567|    610|            }));
  568|  14.3k|        }
  569|       |
  570|  14.3k|        let idx = ty.index();
  571|  14.3k|        if self.types[idx].layout.is_some() {
  572|  3.83k|            return Ok(Cow::Borrowed(self.types[idx].layout.as_ref().unwrap()));
  573|  10.5k|        }
  574|       |
  575|  10.5k|        let layout = self.compute_layout(ty)?;
                          ^10.4k                          ^31
  576|  10.4k|        self.types[idx].layout = Some(layout);
  577|       |
  578|  10.4k|        Ok(Cow::Borrowed(self.types[idx].layout.as_ref().unwrap()))
  579|  15.5k|    }
  580|       |
  581|  10.5k|    fn compute_layout(&mut self, ty: TypeRef) -> Result<TypeLayout, SemanticError> {
  582|  10.5k|        if self.layout_in_progress.contains(&ty) {
  583|      6|            return Err(SemanticError::RecursiveType { ty });
  584|  10.4k|        }
  585|       |
  586|       |        // We clone Kind to release borrow on self
  587|  10.4k|        let type_kind = self.get(ty).kind.clone();
  588|       |
  589|  10.4k|        self.layout_in_progress.insert(ty);
  590|       |
  591|  10.4k|        let layout = match type_kind {
                          ^10.4k
  592|  10.2k|            TypeKind::Builtin(b) => match b {
  593|    540|                BuiltinType::Void => TypeLayout {
  594|    540|                    size: 0,
  595|    540|                    alignment: 1,
  596|    540|                    kind: LayoutKind::Scalar,
  597|    540|                },
  598|  2.16k|                BuiltinType::Bool | BuiltinType::Char | BuiltinType::SChar | BuiltinType::UChar => TypeLayout {
  599|  2.16k|                    size: 1,
  600|  2.16k|                    alignment: 1,
  601|  2.16k|                    kind: LayoutKind::Scalar,
  602|  2.16k|                },
  603|  1.08k|                BuiltinType::Short | BuiltinType::UShort => TypeLayout {
  604|  1.08k|                    size: 2,
  605|  1.08k|                    alignment: 2,
  606|  1.08k|                    kind: LayoutKind::Scalar,
  607|  1.08k|                },
  608|  1.62k|                BuiltinType::Int | BuiltinType::UInt | BuiltinType::Float => TypeLayout {
  609|  1.62k|                    size: 4,
  610|  1.62k|                    alignment: 4,
  611|  1.62k|                    kind: LayoutKind::Scalar,
  612|  1.62k|                },
  613|       |                BuiltinType::Long | BuiltinType::ULong => {
  614|       |                    // long is usually pointer width
  615|  1.08k|                    let size = match self.target_triple.pointer_width() {
  616|      0|                        Ok(PointerWidth::U16) => 2,
  617|      0|                        Ok(PointerWidth::U32) => 4,
  618|  1.08k|                        Ok(PointerWidth::U64) => 8,
  619|      0|                        Err(_) => 8, // Default to 64-bit if unknown
  620|       |                    };
  621|  1.08k|                    TypeLayout {
  622|  1.08k|                        size,
  623|  1.08k|                        alignment: size,
  624|  1.08k|                        kind: LayoutKind::Scalar,
  625|  1.08k|                    }
  626|       |                }
  627|  1.62k|                BuiltinType::LongLong | BuiltinType::ULongLong | BuiltinType::Double => TypeLayout {
  628|  1.62k|                    size: 8,
  629|  1.62k|                    alignment: 8,
  630|  1.62k|                    kind: LayoutKind::Scalar,
  631|  1.62k|                },
  632|       |                BuiltinType::LongDouble => {
  633|       |                    // On x86_64, long double is typically 80-bit (10 bytes) but padded to 16 bytes for alignment.
  634|       |                    // We use 16 bytes to match the System V ABI size.
  635|    540|                    let size = 16;
  636|    540|                    TypeLayout {
  637|    540|                        size,
  638|    540|                        alignment: size,
  639|    540|                        kind: LayoutKind::Scalar,
  640|    540|                    }
  641|       |                }
  642|    540|                BuiltinType::Signed => TypeLayout {
  643|    540|                    size: 4,
  644|    540|                    alignment: 4,
  645|    540|                    kind: LayoutKind::Scalar,
  646|    540|                },
  647|    540|                BuiltinType::VaList => TypeLayout {
  648|    540|                    size: 24,
  649|    540|                    alignment: 8,
  650|    540|                    kind: LayoutKind::Record {
  651|    540|                        fields: Arc::from([
  652|    540|                            FieldLayout { offset: 0 },
  653|    540|                            FieldLayout { offset: 4 },
  654|    540|                            FieldLayout { offset: 8 },
  655|    540|                            FieldLayout { offset: 16 },
  656|    540|                        ]),
  657|    540|                        is_union: false,
  658|    540|                    },
  659|    540|                },
  660|    540|                BuiltinType::Complex => TypeLayout {
  661|    540|                    size: 0,
  662|    540|                    alignment: 1,
  663|    540|                    kind: LayoutKind::Scalar,
  664|    540|                },
  665|       |            },
  666|       |
  667|       |            TypeKind::Pointer { .. } => {
  668|     42|                let size = match self.target_triple.pointer_width() {
  669|      0|                    Ok(PointerWidth::U16) => 2,
  670|      0|                    Ok(PointerWidth::U32) => 4,
  671|     42|                    Ok(PointerWidth::U64) => 8,
  672|      0|                    Err(_) => 8,
  673|       |                };
  674|     42|                TypeLayout {
  675|     42|                    size,
  676|     42|                    alignment: size,
  677|     42|                    kind: LayoutKind::Scalar,
  678|     42|                }
  679|       |            }
  680|       |
  681|     26|            TypeKind::Complex { base_type } => {
  682|     26|                let base_layout = self.ensure_layout(base_type)?;
                                                                             ^0
  683|     26|                TypeLayout {
  684|     26|                    size: base_layout.size * 2,
  685|     26|                    alignment: base_layout.alignment,
  686|     26|                    kind: LayoutKind::Scalar,
  687|     26|                }
  688|       |            }
  689|       |
  690|     28|            TypeKind::Array { element_type, size } => match size {
  691|     11|                ArraySizeType::Constant(len) => {
  692|     11|                    let element_layout = self.ensure_layout(element_type)?;
                                                                                       ^0
  693|     11|                    let total_size = element_layout.size as u64 * len as u64;
  694|     11|                    TypeLayout {
  695|     11|                        size: total_size as u16,
  696|     11|                        alignment: element_layout.alignment,
  697|     11|                        kind: LayoutKind::Array {
  698|     11|                            element: element_type,
  699|     11|                            len: len as u64,
  700|     11|                        },
  701|     11|                    }
  702|       |                }
  703|       |                _ => {
  704|     17|                    return Err(SemanticError::UnsupportedFeature {
  705|     17|                        feature: "incomplete/VLA array layout".to_string(),
  706|     17|                        span: SourceSpan::dummy(),
  707|     17|                    });
  708|       |                }
  709|       |            },
  710|       |
  711|      0|            TypeKind::Function { .. } => TypeLayout {
  712|      0|                size: 0,
  713|      0|                alignment: 1,
  714|      0|                kind: LayoutKind::Scalar,
  715|      0|            },
  716|       |
  717|       |            TypeKind::Record {
  718|    126|                members,
  719|    126|                is_complete,
  720|    126|                is_union,
  721|       |                ..
  722|       |            } => {
  723|    126|                if !is_complete {
  724|       |                    // This is the correct error when sizeof is used on an incomplete type.
  725|      5|                    return Err(SemanticError::SizeOfIncompleteType {
  726|      5|                        ty,
  727|      5|                        // The span from the caller (e.g., the sizeof expression) is used,
  728|      5|                        // so a dummy span here is acceptable.
  729|      5|                        span: SourceSpan::dummy(),
  730|      5|                    });
  731|    121|                }
  732|    121|                self.compute_record_layout(&members, is_union)?
                                                                            ^3
  733|       |            }
  734|       |
  735|       |            TypeKind::Enum {
  736|     15|                base_type, is_complete, ..
  737|       |            } => {
  738|     15|                if !is_complete {
  739|      0|                    return Err(SemanticError::UnsupportedFeature {
  740|      0|                        feature: "incomplete enum type layout".to_string(),
  741|      0|                        span: SourceSpan::dummy(),
  742|      0|                    });
  743|     15|                }
  744|     15|                self.ensure_layout(base_type)?.into_owned()
                                                           ^0
  745|       |            }
  746|       |
  747|       |            TypeKind::Error => {
  748|      0|                return Err(SemanticError::UnsupportedFeature {
  749|      0|                    feature: "error layout".to_string(),
  750|      0|                    span: SourceSpan::dummy(),
  751|      0|                });
  752|       |            }
  753|       |        };
  754|       |
  755|  10.4k|        self.layout_in_progress.remove(&ty);
  756|  10.4k|        Ok(layout)
  757|  10.5k|    }
  758|       |
  759|    121|    fn compute_record_layout(&mut self, members: &[StructMember], is_union: bool) -> Result<TypeLayout, SemanticError> {
  760|    121|        let mut max_align = 1;
  761|    121|        let mut current_size = 0;
  762|    121|        let mut field_layouts = Vec::with_capacity(members.len());
  763|       |        // For C11 6.7.2.1p18 flexible array check:
  764|       |        // "the last element of a structure with more than one named member may have an incomplete array type"
  765|       |        // But incomplete array types are NOT allowed in unions.
  766|       |        // We will check validity as we iterate.
  767|       |        // Note: The count of members might include anonymous struct/union members which are technically members.
  768|       |
  769|    121|        let member_count = members.len();
  770|       |
  771|    204|        for (i, member) in members.iter().enumerate() {
                                         ^121    ^121   ^121
  772|    204|            let member_ty = member.member_type.ty();
  773|       |
  774|       |            // Special handling for flexible array member (FAM)
  775|       |            // Need to check if it is incomplete array
  776|       |            // We can't use is_complete because that recurses. We check TypeKind directly.
  777|    204|            let is_incomplete_or_vla_array = if member_ty.is_inline_array() {
  778|     11|                false // inline array always has len
  779|       |            } else {
  780|    189|                matches!(
  781|    193|                    self.get(member_ty).kind,
  782|       |                    TypeKind::Array {
  783|       |                        size: ArraySizeType::Incomplete | ArraySizeType::Variable(_),
  784|       |                        ..
  785|       |                    }
  786|       |                )
  787|       |            };
  788|       |
  789|    204|            if is_incomplete_or_vla_array {
  790|      4|                if is_union {
  791|       |                    // Incomplete or VLA types not allowed in union
  792|      1|                    return Err(SemanticError::UnsupportedFeature {
  793|      1|                        feature: "incomplete/VLA array in union".to_string(),
  794|      1|                        span: member.span,
  795|      1|                    });
  796|      3|                }
  797|       |
  798|       |                // Must be last member
  799|      3|                if i != member_count - 1 {
  800|      1|                    return Err(SemanticError::FlexibleArrayNotLast { span: member.span });
  801|      2|                }
  802|       |
  803|       |                // Must have at least one other named member.
  804|       |                // Or rather, "structure with more than one named member".
  805|       |                // If this is the only member, it's invalid.
  806|      2|                if member_count < 2 {
  807|      1|                    return Err(SemanticError::FlexibleArrayInEmptyStruct { span: member.span });
  808|      1|                }
  809|       |
  810|       |                // If valid FAM:
  811|       |                // Size of structure is as if FAM was omitted.
  812|       |                // But we must respect its alignment for the struct's alignment.
  813|       |                // We need to get the element type to find alignment.
  814|      1|                let elem_ty = match &self.get(member_ty).kind {
  815|      1|                    TypeKind::Array { element_type, .. } => *element_type,
  816|      0|                    _ => unreachable!(),
  817|       |                };
  818|      1|                let elem_layout = self.ensure_layout(elem_ty)?;
                                                                           ^0
  819|       |
  820|      1|                max_align = max_align.max(elem_layout.alignment);
  821|       |
  822|       |                // FAM has size 0 for layout purposes of the struct size,
  823|       |                // but its offset is where it would start.
  824|       |                // The standard says: "size of the structure is as if the flexible array member were omitted"
  825|       |                // This means current_size stays as is (after padding for alignment of FAM? No, omitted means omitted).
  826|       |                // "except that it may have more trailing padding than the omission would imply"
  827|       |                // Usually this is interpreted as: sizeof(struct) = max(sizeof(struct_without_fam), offsetof(fam)).
  828|       |                // Or simply: layout the FAM, but don't increment current_size by its size (which is unknown/0).
  829|       |                // But we might need to add padding to current_size to reach FAM alignment?
  830|       |                // "as if the flexible array member were omitted" implies we don't even add padding for it?
  831|       |                // BUT "except that it may have more trailing padding".
  832|       |                // Most compilers align the end of the struct to the alignment of the FAM.
  833|       |
  834|       |                // Let's compute offset.
  835|      1|                let offset = (current_size + elem_layout.alignment - 1) & !(elem_layout.alignment - 1);
  836|      1|                field_layouts.push(FieldLayout { offset });
  837|       |
  838|       |                // We do NOT update current_size with FAM size (which is effectively 0 or variable).
  839|       |                // But we might update current_size to offset?
  840|       |                // GCC: sizeof(struct { int x; int y[]; }) == 4.
  841|       |                //      sizeof(struct { char c; int y[]; }) == 4 (aligned to 4).
  842|       |                // So we do align current_size.
  843|      1|                current_size = offset;
  844|       |
  845|      1|                continue;
  846|    200|            }
  847|       |
  848|    200|            let layout = self.ensure_layout(member_ty)?;
                                                                    ^0
  849|    200|            let mut member_align = layout.alignment;
  850|    200|            if let Some(req_align) = member.alignment {
                                      ^5
  851|      5|                member_align = member_align.max(req_align as u16);
  852|    195|            }
  853|    200|            max_align = max_align.max(member_align);
  854|       |
  855|    200|            if is_union {
  856|     15|                current_size = current_size.max(layout.size);
  857|     15|                field_layouts.push(FieldLayout { offset: 0 });
  858|    185|            } else {
  859|    185|                // Align current_size to member's alignment to find its offset
  860|    185|                let offset = (current_size + member_align - 1) & !(member_align - 1);
  861|    185|                field_layouts.push(FieldLayout { offset });
  862|    185|                current_size = offset + layout.size;
  863|    185|            }
  864|       |        }
  865|       |
  866|       |        // Final size is padded to the record's max alignment
  867|    118|        let final_size = (current_size + max_align - 1) & !(max_align - 1);
  868|       |
  869|    118|        Ok(TypeLayout {
  870|    118|            size: final_size,
  871|    118|            alignment: max_align,
  872|    118|            kind: LayoutKind::Record {
  873|    118|                fields: Arc::from(field_layouts),
  874|    118|                is_union,
  875|    118|            },
  876|    118|        })
  877|    121|    }
  878|       |
  879|    318|    pub(crate) fn decay(&mut self, qt: QualType, ptr_qualifiers: TypeQualifiers) -> QualType {
  880|    318|        let kind = self.get(qt.ty()).kind.clone();
  881|    318|        match kind {
  882|     86|            TypeKind::Array { element_type, .. } => {
  883|       |                // Correct logic: Array of T decays to Pointer to T.
  884|       |                // Qualifiers on Array apply to the element in the resulting pointer type.
  885|     86|                let elem_qt = QualType::new(element_type, qt.qualifiers());
  886|     86|                let ptr = self.pointer_to(elem_qt);
  887|       |                // Apply the extracted pointer qualifiers (e.g. from static/const inside [])
  888|     86|                QualType::new(ptr, ptr_qualifiers)
  889|       |            }
  890|       |            TypeKind::Function { .. } => {
  891|     10|                let ptr = self.pointer_to(qt);
  892|     10|                QualType::new(ptr, ptr_qualifiers)
  893|       |            }
  894|    222|            _ => qt,
  895|       |        }
  896|    318|    }
  897|       |
  898|     76|    pub(crate) fn strip_all(&self, qt: QualType) -> QualType {
  899|     76|        QualType::unqualified(qt.ty())
  900|     76|    }
  901|       |
  902|  3.54k|    pub(crate) fn merge_qualifiers(&self, base: QualType, add: TypeQualifiers) -> QualType {
  903|  3.54k|        QualType::new(base.ty(), base.qualifiers() | add)
  904|  3.54k|    }
  905|       |
  906|    104|    pub(crate) fn is_compatible(&self, a: QualType, b: QualType) -> bool {
  907|    104|        if a == b {
  908|     57|            return true;
  909|     47|        }
  910|       |
  911|     47|        if a.qualifiers() != b.qualifiers() {
  912|     19|            return false;
  913|     28|        }
  914|       |
  915|     28|        let ty_a_ref = a.ty();
  916|     28|        let ty_b_ref = b.ty();
  917|       |
  918|     28|        if ty_a_ref == ty_b_ref {
  919|      0|            return true;
  920|     28|        }
  921|       |
  922|     28|        let kind_a = self.get(ty_a_ref).kind.clone();
  923|     28|        let kind_b = self.get(ty_b_ref).kind.clone();
  924|       |
  925|     28|        match (kind_a, kind_b) {
  926|       |            (
  927|       |                TypeKind::Array {
  928|      0|                    element_type: elem_a,
  929|      0|                    size: size_a,
  930|       |                },
  931|       |                TypeKind::Array {
  932|      0|                    element_type: elem_b,
  933|      0|                    size: size_b,
  934|       |                },
  935|       |            ) => {
  936|      0|                if !self.is_compatible(QualType::unqualified(elem_a), QualType::unqualified(elem_b)) {
  937|      0|                    return false;
  938|      0|                }
  939|      0|                match (size_a, size_b) {
  940|      0|                    (ArraySizeType::Incomplete, _) => true,
  941|      0|                    (_, ArraySizeType::Incomplete) => true,
  942|      0|                    (ArraySizeType::Constant(sa), ArraySizeType::Constant(sb)) => sa == sb,
  943|      0|                    (ArraySizeType::Star, _) => true,
  944|      0|                    (_, ArraySizeType::Star) => true,
  945|      0|                    _ => false,
  946|       |                }
  947|       |            }
  948|       |            (
  949|       |                TypeKind::Function {
  950|      0|                    return_type: ret_a,
  951|      0|                    parameters: params_a,
  952|      0|                    is_variadic: var_a,
  953|       |                    ..
  954|       |                },
  955|       |                TypeKind::Function {
  956|      0|                    return_type: ret_b,
  957|      0|                    parameters: params_b,
  958|      0|                    is_variadic: var_b,
  959|       |                    ..
  960|       |                },
  961|       |            ) => {
  962|      0|                if var_a != var_b {
  963|      0|                    return false;
  964|      0|                }
  965|      0|                if !self.is_compatible(QualType::unqualified(ret_a), QualType::unqualified(ret_b)) {
  966|      0|                    return false;
  967|      0|                }
  968|      0|                if params_a.len() != params_b.len() {
  969|      0|                    return false;
  970|      0|                }
  971|      0|                for (p_a, p_b) in params_a.iter().zip(params_b.iter()) {
  972|       |                    // Ignore top-level qualifiers on parameters
  973|      0|                    let type_a = QualType::unqualified(p_a.param_type.ty());
  974|      0|                    let type_b = QualType::unqualified(p_b.param_type.ty());
  975|      0|                    if !self.is_compatible(type_a, type_b) {
  976|      0|                        return false;
  977|      0|                    }
  978|       |                }
  979|      0|                true
  980|       |            }
  981|      6|            (TypeKind::Pointer { pointee: p_a }, TypeKind::Pointer { pointee: p_b }) => self.is_compatible(p_a, p_b),
  982|     22|            _ => false,
  983|       |        }
  984|    104|    }
  985|       |
  986|     47|    pub(crate) fn composite_type(&mut self, a: QualType, b: QualType) -> Option<QualType> {
  987|     47|        if a.qualifiers() != b.qualifiers() {
  988|      1|            return None;
  989|     46|        }
  990|       |
  991|     46|        if a.ty() == b.ty() {
  992|     36|            return Some(a);
  993|     10|        }
  994|       |
  995|     10|        let kind_a = self.get(a.ty()).kind.clone();
  996|     10|        let kind_b = self.get(b.ty()).kind.clone();
  997|       |
  998|     10|        match (kind_a, kind_b) {
  999|       |            (
 1000|       |                TypeKind::Array {
 1001|      4|                    element_type: elem_a,
 1002|      4|                    size: size_a,
 1003|       |                },
 1004|       |                TypeKind::Array {
 1005|      4|                    element_type: elem_b,
 1006|      4|                    size: size_b,
 1007|       |                },
 1008|       |            ) => {
 1009|      4|                let composite_elem =
 1010|      4|                    self.composite_type(QualType::unqualified(elem_a), QualType::unqualified(elem_b))?;
                                                                                                                   ^0
 1011|      4|                let composite_size = match (size_a, size_b) {
                                  ^3
 1012|      2|                    (ArraySizeType::Incomplete, s) => s,
 1013|      1|                    (s, ArraySizeType::Incomplete) => s,
 1014|      1|                    (ArraySizeType::Constant(sa), ArraySizeType::Constant(sb)) if sa == sb => {
                                                           ^0                           ^0             ^0
 1015|      0|                        ArraySizeType::Constant(sa)
 1016|       |                    }
 1017|      0|                    (ArraySizeType::Star, s) => s,
 1018|      0|                    (s, ArraySizeType::Star) => s,
 1019|      1|                    _ => return None,
 1020|       |                };
 1021|      3|                let res_ty = self.array_of(composite_elem.ty(), composite_size);
 1022|      3|                Some(QualType::new(res_ty, a.qualifiers()))
 1023|       |            }
 1024|       |            (
 1025|       |                TypeKind::Function {
 1026|      4|                    return_type: ret_a,
 1027|      4|                    parameters: params_a,
 1028|      4|                    is_variadic: var_a,
 1029|      4|                    is_noreturn: noreturn_a,
 1030|       |                },
 1031|       |                TypeKind::Function {
 1032|      4|                    return_type: ret_b,
 1033|      4|                    parameters: params_b,
 1034|      4|                    is_variadic: var_b,
 1035|      4|                    is_noreturn: noreturn_b,
 1036|       |                },
 1037|       |            ) => {
 1038|      4|                if var_a != var_b {
 1039|      0|                    return None;
 1040|      4|                }
 1041|      4|                let composite_ret = self.composite_type(QualType::unqualified(ret_a), QualType::unqualified(ret_b))?;
                                                                                                                                 ^0
 1042|      4|                if params_a.len() != params_b.len() {
 1043|      0|                    return None;
 1044|      4|                }
 1045|      4|                let mut composite_params = Vec::with_capacity(params_a.len());
 1046|      4|                for (p_a, p_b) in params_a.iter().zip(params_b.iter()) {
                                   ^3   ^3
 1047|       |                    // C11 6.7.6.3p15: each parameter declared with qualified type is taken as
 1048|       |                    // having the unqualified version of its declared type.
 1049|      3|                    let type_a = QualType::unqualified(p_a.param_type.ty());
 1050|      3|                    let type_b = QualType::unqualified(p_b.param_type.ty());
 1051|      3|                    let cp = self.composite_type(type_a, type_b)?;
                                      ^1                                      ^2
 1052|       |
 1053|      1|                    composite_params.push(FunctionParameter {
 1054|      1|                        param_type: cp,
 1055|      1|                        name: p_b.name.or(p_a.name),
 1056|      1|                        storage: p_b.storage.or(p_a.storage),
 1057|      1|                    });
 1058|       |                }
 1059|      2|                let res_ty = self.function_type(composite_ret.ty(), composite_params, var_a, noreturn_a || noreturn_b);
                                                                                                                         ^1
 1060|      2|                Some(QualType::new(res_ty, a.qualifiers()))
 1061|       |            }
 1062|      1|            (TypeKind::Pointer { pointee: p_a }, TypeKind::Pointer { pointee: p_b }) => {
 1063|      1|                let composite_pointee = self.composite_type(p_a, p_b)?;
                                  ^0
 1064|      0|                let res_ty = self.pointer_to(composite_pointee);
 1065|      0|                Some(QualType::new(res_ty, a.qualifiers()))
 1066|       |            }
 1067|       |            _ => {
 1068|      1|                if self.is_compatible(a, b) {
 1069|      0|                    Some(a)
 1070|       |                } else {
 1071|      1|                    None
 1072|       |                }
 1073|       |            }
 1074|       |        }
 1075|     47|    }
 1076|       |
 1077|    830|    pub(crate) fn is_complete(&self, ty: TypeRef) -> bool {
 1078|    830|        if ty.is_inline_pointer() {
 1079|     88|            return true;
 1080|    742|        }
 1081|    742|        if ty.is_inline_array() {
 1082|       |            // Array is complete if element is complete
 1083|       |            // But strict C says array valid if element type is complete (except local VLA which is complete at runtime allocation point?)
 1084|       |            // Here we just check element kind.
 1085|     55|            let elem = self.reconstruct_element(ty);
 1086|     55|            return self.is_complete(elem);
 1087|    687|        }
 1088|       |
 1089|    687|        let kind = &self.types[ty.index()].kind;
 1090|    513|        match kind {
 1091|     79|            TypeKind::Record { is_complete, .. } => *is_complete,
 1092|      4|            TypeKind::Enum { is_complete, .. } => *is_complete,
 1093|     15|            TypeKind::Array { element_type, size } => {
 1094|     15|                if let ArraySizeType::Incomplete = size {
 1095|      5|                    return false;
 1096|     10|                }
 1097|     10|                self.is_complete(*element_type)
 1098|       |            }
 1099|      8|            TypeKind::Builtin(BuiltinType::Void) => false,
 1100|    581|            _ => true, // Scalars are always complete
 1101|       |        }
 1102|    830|    }
 1103|       |
 1104|    126|    pub(crate) fn is_const_recursive(&self, qt: QualType) -> bool {
 1105|    126|        if qt.is_const() {
 1106|      8|            return true;
 1107|    118|        }
 1108|       |
 1109|    118|        let ty_ref = qt.ty();
 1110|    118|        if ty_ref.is_record()
 1111|      3|            && let TypeKind::Record { members, is_union, .. } = &self.get(ty_ref).kind
 1112|       |        {
 1113|      3|            if *is_union {
 1114|       |                // For unions, the entire union is not "const" just because one member is.
 1115|       |                // Only the specific const member access is restricted, handled in check_lvalue.
 1116|      0|                return false;
 1117|      3|            }
 1118|       |
 1119|      3|            for member in members.iter() {
 1120|       |                // Pointers are only const if the pointer itself is const,
 1121|       |                // not if the pointee is const.
 1122|       |                // Arrays and nested structs incur recursive constness if they contain const elements/members.
 1123|      3|                if !member.member_type.is_pointer() && self.is_const_recursive(member.member_type) {
 1124|      0|                    return true;
 1125|      3|                }
 1126|       |            }
 1127|    115|        }
 1128|    118|        false
 1129|    126|    }
 1130|       |
 1131|     93|    pub(crate) fn display_qual_type(&self, qt: QualType) -> String {
 1132|     93|        let quals = qt.qualifiers();
 1133|     93|        let ty_str = self.display_type(qt.ty());
 1134|     93|        if quals.is_empty() {
 1135|     43|            ty_str
 1136|       |        } else {
 1137|     50|            format!("{} {}", quals, ty_str)
 1138|       |        }
 1139|     93|    }
 1140|       |
 1141|    155|    pub(crate) fn display_type(&self, ty: TypeRef) -> String {
 1142|    155|        if ty.is_inline_pointer() {
 1143|      2|            let pointee = self.reconstruct_pointee(ty);
 1144|      2|            return format!("{}*", self.display_type(pointee));
 1145|    153|        }
 1146|       |
 1147|    153|        if ty.is_inline_array() {
 1148|      2|            let elem = self.reconstruct_element(ty);
 1149|      2|            let len = ty.array_len().unwrap();
 1150|      2|            return format!("{}[{}]", self.display_type(elem), len);
 1151|    151|        }
 1152|       |
 1153|    151|        let type_kind = &self.types[ty.index()].kind;
 1154|    151|        match type_kind {
 1155|    131|            TypeKind::Builtin(b) => match b {
 1156|      5|                BuiltinType::Void => "void".to_string(),
 1157|      1|                BuiltinType::Bool => "_Bool".to_string(),
 1158|      2|                BuiltinType::Char => "char".to_string(),
 1159|      3|                BuiltinType::SChar => "signed char".to_string(),
 1160|      3|                BuiltinType::UChar => "unsigned char".to_string(),
 1161|      9|                BuiltinType::Short => "short".to_string(),
 1162|      7|                BuiltinType::UShort => "unsigned short".to_string(),
 1163|     16|                BuiltinType::Int => "int".to_string(),
 1164|      4|                BuiltinType::UInt => "unsigned int".to_string(),
 1165|      9|                BuiltinType::Long => "long".to_string(),
 1166|     11|                BuiltinType::ULong => "unsigned long".to_string(),
 1167|     13|                BuiltinType::LongLong => "long long".to_string(),
 1168|      9|                BuiltinType::ULongLong => "unsigned long long".to_string(),
 1169|     19|                BuiltinType::Float => "float".to_string(),
 1170|     11|                BuiltinType::Double => "double".to_string(),
 1171|      6|                BuiltinType::LongDouble => "long double".to_string(),
 1172|      1|                BuiltinType::Signed => "signed".to_string(),
 1173|      1|                BuiltinType::VaList => "__builtin_va_list".to_string(),
 1174|      1|                BuiltinType::Complex => "_Complex (marker)".to_string(),
 1175|       |            },
 1176|      9|            TypeKind::Complex { base_type } => format!("_Complex {}", self.display_type(*base_type)),
 1177|      0|            TypeKind::Pointer { pointee } => format!("{}*", self.display_qual_type(*pointee)),
 1178|      4|            TypeKind::Array { element_type, size } => {
 1179|      4|                let elem_str = self.display_type(*element_type);
 1180|      4|                match size {
 1181|      0|                    ArraySizeType::Constant(len) => format!("{}[{}]", elem_str, len),
 1182|      0|                    ArraySizeType::Variable(_) => format!("{}[*]", elem_str), // Using * for VLA for now or expr?
 1183|      4|                    ArraySizeType::Incomplete => format!("{}[]", elem_str),
 1184|      0|                    ArraySizeType::Star => format!("{}[*]", elem_str),
 1185|       |                }
 1186|       |            }
 1187|       |            TypeKind::Function {
 1188|      0|                return_type,
 1189|      0|                parameters,
 1190|      0|                is_variadic,
 1191|       |                ..
 1192|       |            } => {
 1193|      0|                let ret_str = self.display_type(*return_type);
 1194|      0|                let params_str = parameters
 1195|      0|                    .iter()
 1196|      0|                    .map(|p| self.display_qual_type(p.param_type))
 1197|      0|                    .collect::<Vec<_>>()
 1198|      0|                    .join(", ");
 1199|      0|                let var_str = if *is_variadic { ", ..." } else { "" };
 1200|      0|                format!("{}({}{})", ret_str, params_str, var_str)
 1201|       |            }
 1202|      7|            TypeKind::Record { tag, is_union, .. } => {
 1203|      7|                let kind_str = if *is_union { "union" } else { "struct" };
                                                            ^0
 1204|      7|                if let Some(tag_name) = tag {
 1205|      7|                    format!("{} {}", kind_str, tag_name)
 1206|       |                } else {
 1207|      0|                    format!("{} (anonymous)", kind_str)
 1208|       |                }
 1209|       |            }
 1210|      0|            TypeKind::Enum { tag, .. } => {
 1211|      0|                if let Some(tag_name) = tag {
 1212|      0|                    format!("enum {}", tag_name)
 1213|       |                } else {
 1214|      0|                    "enum (anonymous)".to_string()
 1215|       |                }
 1216|       |            }
 1217|      0|            TypeKind::Error => "<error>".to_string(),
 1218|       |        }
 1219|    155|    }
 1220|       |}
 1221|       |
 1222|       |// ================================================================
 1223|       |// Helper types
 1224|       |// ================================================================
 1225|       |
 1226|       |/// Key for canonicalizing function types.
 1227|       |/// Bolt : Uses SmallVec to avoid heap allocations during function type lookups.
 1228|       |/// Most C functions have <= 8 parameters, allowing the key to remain on the stack.
 1229|       |#[derive(Debug, Clone, PartialEq, Eq, Hash)]
 1230|       |struct FnSigKey {
 1231|       |    return_type: TypeRef,
 1232|       |    params: SmallVec<[QualType; 8]>,
 1233|       |    is_variadic: bool,
 1234|       |    is_noreturn: bool,
 1235|       |}

/app/src/semantic/types.rs:
    1|       |//! Type system representation and utilities.
    2|       |//!
    3|       |//! This module defines the semantic type system used during analysis,
    4|       |//! distinct from the syntactic TypeSpecifier constructs used in parsing.
    5|       |
    6|       |use std::sync::Arc;
    7|       |use std::{fmt::Display, num::NonZeroU32};
    8|       |
    9|       |use bitflags::bitflags;
   10|       |use serde::Serialize;
   11|       |
   12|       |use crate::ast::{NameId, NodeRef, SourceSpan, StorageClass};
   13|       |
   14|       |/// Type representation (for semantic analysis)
   15|       |/// This is a canonical type, distinct from TypeSpecifier which is a syntax construct.
   16|       |/// Types are stored in a separate Vec<Type> with TypeRef references.
   17|       |/// invariant:
   18|       |/// - layout == None for incomplete types
   19|       |/// - layout is computed according to C abstract machine rules
   20|       |/// - layout may differ from MIR layout
   21|       |
   22|       |#[derive(Debug, Clone)]
   23|       |pub struct Type {
   24|       |    pub kind: TypeKind,
   25|       |    pub layout: Option<TypeLayout>,
   26|       |}
   27|       |
   28|       |#[derive(Debug, Clone)]
   29|       |pub struct TypeLayout {
   30|       |    pub size: u16,
   31|       |    pub alignment: u16,
   32|       |    pub kind: LayoutKind,
   33|       |}
   34|       |
   35|       |#[derive(Debug, Clone)]
   36|       |pub enum LayoutKind {
   37|       |    Scalar,
   38|       |    Array { element: TypeRef, len: u64 },
   39|       |    Record { fields: Arc<[FieldLayout]>, is_union: bool },
   40|       |}
   41|       |
   42|       |#[derive(Debug, Clone)]
   43|       |pub struct FieldLayout {
   44|       |    pub offset: u16,
   45|       |}
   46|       |
   47|       |impl Type {
   48|       |    /// Create a new type with default qualifiers
   49|       |    /// can only be called by TypeRegistry
   50|  11.5k|    pub(crate) fn new(kind: TypeKind) -> Self {
   51|  11.5k|        Type { kind, layout: None }
   52|  11.5k|    }
   53|       |
   54|    187|    pub(crate) fn flatten_members(&self, registry: &super::TypeRegistry, flat_members: &mut Vec<StructMember>) {
   55|    187|        if let TypeKind::Record { members, .. } = &self.kind {
   56|    380|            for member in members.iter().cloned() {
                                        ^187           ^187
   57|    380|                if member.name.is_none() {
   58|     44|                    let inner_type = registry.get(member.member_type.ty());
   59|     44|                    inner_type.flatten_members(registry, flat_members);
   60|    336|                } else {
   61|    336|                    flat_members.push(member);
   62|    336|                }
   63|       |            }
   64|      0|        }
   65|    187|    }
   66|       |
   67|    100|    pub(crate) fn flatten_members_with_layouts(
   68|    100|        &self,
   69|    100|        registry: &super::TypeRegistry,
   70|    100|        flat_members: &mut Vec<StructMember>,
   71|    100|        flat_offsets: &mut Vec<u16>,
   72|    100|        base_offset: u16,
   73|    100|    ) {
   74|       |        #[allow(clippy::collapsible_if)]
   75|    100|        if let TypeKind::Record { members, .. } = &self.kind {
   76|       |            if let Some(TypeLayout {
   77|    100|                kind: LayoutKind::Record { fields, .. },
   78|       |                ..
   79|    100|            }) = &self.layout
   80|       |            {
   81|    191|                for (i, member) in members.iter().enumerate() {
                                                 ^100           ^100
   82|    191|                    let offset = base_offset + fields[i].offset;
   83|    191|                    if member.name.is_none() {
   84|     13|                        let inner_type = registry.get(member.member_type.ty());
   85|     13|                        inner_type.flatten_members_with_layouts(registry, flat_members, flat_offsets, offset);
   86|    178|                    } else {
   87|    178|                        flat_members.push(*member);
   88|    178|                        flat_offsets.push(offset);
   89|    178|                    }
   90|       |                }
   91|      0|            }
   92|      0|        }
   93|    100|    }
   94|       |
   95|     44|    pub(crate) fn is_union(&self) -> bool {
   96|     44|        matches!(self.kind, TypeKind::Record { is_union: true, .. })
                      ^3
   97|     44|    }
   98|       |
   99|      0|    pub(crate) fn is_record_empty(&self) -> bool {
  100|      0|        if let TypeKind::Record { members, .. } = &self.kind {
  101|      0|            members.is_empty()
  102|       |        } else {
  103|      0|            false
  104|       |        }
  105|      0|    }
  106|       |}
  107|       |
  108|       |#[repr(u8)]
  109|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
  110|       |pub enum TypeClass {
  111|       |    Builtin = 0,
  112|       |    Pointer = 1,
  113|       |    Array = 2,
  114|       |    Function = 3,
  115|       |    Record = 4,
  116|       |    Enum = 5,
  117|       |    Typedef = 6,
  118|       |    Complex = 7,
  119|       |}
  120|       |
  121|       |impl TypeClass {
  122|  84.7k|    pub(crate) fn from_u32(v: u32) -> Self {
  123|  84.7k|        match v {
  124|  68.5k|            0 => Self::Builtin,
  125|  3.67k|            1 => Self::Pointer,
  126|  4.33k|            2 => Self::Array,
  127|  2.09k|            3 => Self::Function,
  128|  4.60k|            4 => Self::Record,
  129|    190|            5 => Self::Enum,
  130|      0|            6 => Self::Typedef,
  131|  1.32k|            7 => Self::Complex,
  132|      0|            _ => unreachable!("Invalid TypeClass value: {}", v),
  133|       |        }
  134|  84.7k|    }
  135|       |}
  136|       |
  137|       |#[repr(u8)]
  138|       |#[derive(Clone, Copy, Debug, PartialEq, Eq)]
  139|       |pub enum BuiltinType {
  140|       |    Void = 1,
  141|       |    Bool = 2,
  142|       |    Char = 3,
  143|       |    SChar = 4,
  144|       |    UChar = 5,
  145|       |    Short = 6,
  146|       |    UShort = 7,
  147|       |    Int = 8,
  148|       |    UInt = 9,
  149|       |    Long = 10,
  150|       |    ULong = 11,
  151|       |    LongLong = 12,
  152|       |    ULongLong = 13,
  153|       |    Float = 14,
  154|       |    Double = 15,
  155|       |    LongDouble = 16,
  156|       |    Signed = 17,
  157|       |    VaList = 18,
  158|       |    Complex = 19,
  159|       |}
  160|       |
  161|       |impl BuiltinType {
  162|  3.33k|    pub(crate) fn from_u32(v: u32) -> Option<Self> {
  163|  3.33k|        match v {
  164|     16|            1 => Some(Self::Void),
  165|     14|            2 => Some(Self::Bool),
  166|     18|            3 => Some(Self::Char),
  167|      8|            4 => Some(Self::SChar),
  168|     73|            5 => Some(Self::UChar),
  169|     15|            6 => Some(Self::Short),
  170|      8|            7 => Some(Self::UShort),
  171|  2.50k|            8 => Some(Self::Int),
  172|     10|            9 => Some(Self::UInt),
  173|     42|            10 => Some(Self::Long),
  174|    268|            11 => Some(Self::ULong),
  175|    119|            12 => Some(Self::LongLong),
  176|      5|            13 => Some(Self::ULongLong),
  177|     65|            14 => Some(Self::Float),
  178|    129|            15 => Some(Self::Double),
  179|     40|            16 => Some(Self::LongDouble),
  180|      0|            17 => Some(Self::Signed),
  181|      0|            18 => Some(Self::VaList),
  182|      0|            19 => Some(Self::Complex),
  183|      0|            _ => None,
  184|       |        }
  185|  3.33k|    }
  186|       |
  187|  2.49k|    pub(crate) fn is_integer(self) -> bool {
  188|    106|        matches!(
  189|  2.49k|            self,
  190|       |            Self::Bool
  191|       |                | Self::Char
  192|       |                | Self::SChar
  193|       |                | Self::UChar
  194|       |                | Self::Short
  195|       |                | Self::UShort
  196|       |                | Self::Int
  197|       |                | Self::UInt
  198|       |                | Self::Long
  199|       |                | Self::ULong
  200|       |                | Self::LongLong
  201|       |                | Self::ULongLong
  202|       |                | Self::Signed // signed int
  203|       |        )
  204|  2.49k|    }
  205|       |
  206|      1|    pub(crate) fn is_char(self) -> bool {
  207|      1|        matches!(self, Self::Char | Self::SChar | Self::UChar)
                      ^0
  208|      1|    }
  209|       |
  210|    386|    pub(crate) fn is_floating(self) -> bool {
  211|    386|        matches!(self, Self::Float | Self::Double | Self::LongDouble)
                      ^315
  212|    386|    }
  213|       |
  214|     70|    pub(crate) fn is_signed(self) -> bool {
  215|     70|        match self {
  216|      0|            Self::Bool => false,
  217|      0|            Self::Char => true, // Assuming char is signed
  218|      0|            Self::SChar => true,
  219|      0|            Self::UChar => false,
  220|      0|            Self::Short => true,
  221|      0|            Self::UShort => false,
  222|     34|            Self::Int => true,
  223|      1|            Self::UInt => false,
  224|      3|            Self::Long => true,
  225|     29|            Self::ULong => false,
  226|      3|            Self::LongLong => true,
  227|      0|            Self::ULongLong => false,
  228|      0|            Self::Signed => true,
  229|      0|            _ => false,
  230|       |        }
  231|     70|    }
  232|       |
  233|  1.54k|    pub(crate) fn rank(self) -> u8 {
  234|  1.54k|        match self {
  235|      0|            Self::Bool => 1,
  236|     41|            Self::Char | Self::SChar | Self::UChar => 2,
  237|      5|            Self::Short | Self::UShort => 3,
  238|  1.34k|            Self::Int | Self::UInt | Self::Signed => 4,
  239|    148|            Self::Long | Self::ULong => 5,
  240|     12|            Self::LongLong | Self::ULongLong => 6,
  241|      0|            _ => 0,
  242|       |        }
  243|  1.54k|    }
  244|       |}
  245|       |
  246|       |/// Opaque reference to a canonical type.
  247|       |/// Internally index + 1 (NonZeroU32 for niche optimization).
  248|       |#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, Serialize)]
  249|       |#[repr(transparent)]
  250|       |pub struct TypeRef(NonZeroU32);
  251|       |
  252|       |impl TypeRef {
  253|       |    // Layout:
  254|       |    // bit  0..=17  (18 bit)  BASE INDEX
  255|       |    // bit 18..=20  (3 bit)   TYPE CLASS
  256|       |    // bit 21..=22  (2 bit)   POINTER DEPTH (0..3)
  257|       |    // bit 23..=27  (5 bit)   ARRAY LEN INLINE (0..31)
  258|       |
  259|       |    const BASE_BITS: u32 = 18;
  260|       |    const CLASS_BITS: u32 = 3;
  261|       |    const PTR_BITS: u32 = 2;
  262|       |    const ARR_BITS: u32 = 5;
  263|       |
  264|       |    const BASE_SHIFT: u32 = 0;
  265|       |    const CLASS_SHIFT: u32 = Self::BASE_BITS;
  266|       |    const PTR_SHIFT: u32 = Self::CLASS_SHIFT + Self::CLASS_BITS;
  267|       |    const ARR_SHIFT: u32 = Self::PTR_SHIFT + Self::PTR_BITS;
  268|       |
  269|       |    const BASE_MASK: u32 = (1 << Self::BASE_BITS) - 1;
  270|       |    const CLASS_MASK: u32 = (1 << Self::CLASS_BITS) - 1;
  271|       |    const PTR_MASK: u32 = (1 << Self::PTR_BITS) - 1;
  272|       |    const ARR_MASK: u32 = (1 << Self::ARR_BITS) - 1;
  273|       |
  274|       |    #[inline]
  275|  13.8k|    pub(crate) fn new(base_index: u32, class: TypeClass, ptr_depth: u8, arr_len: u32) -> Option<Self> {
  276|  13.8k|        if base_index == 0 || base_index > Self::BASE_MASK {
  277|      0|            return None; // Base index must be non-zero and fit in 18 bits
  278|  13.8k|        }
  279|  13.8k|        if ptr_depth as u32 > Self::PTR_MASK {
  280|      1|            return None;
  281|  13.8k|        }
  282|  13.8k|        if arr_len > Self::ARR_MASK {
  283|      1|            return None;
  284|  13.8k|        }
  285|       |
  286|       |        // Validate combinations
  287|  13.8k|        match class {
  288|       |            TypeClass::Builtin => {
  289|  11.6k|                if ptr_depth != 0 || arr_len != 0 {
                                                   ^11.6k
  290|      1|                    return None;
  291|  11.6k|                }
  292|       |            }
  293|       |            TypeClass::Pointer => {
  294|    828|                if arr_len != 0 {
  295|      1|                    return None;
  296|    827|                }
  297|       |                // Pointer depth 0 means "Registry Pointer" (valid)
  298|       |                // Pointer depth 1..3 means "Inline Pointer" (valid)
  299|       |            }
  300|       |            TypeClass::Array => {
  301|       |                // Array len 0 means "Registry Array" (valid)
  302|       |                // Array len 1..31 means "Inline Array" (valid)
  303|    602|                if ptr_depth != 0 {
  304|      1|                    return None;
  305|    601|                }
  306|       |            }
  307|       |            TypeClass::Function | TypeClass::Record | TypeClass::Enum | TypeClass::Typedef | TypeClass::Complex => {
  308|    733|                if ptr_depth != 0 || arr_len != 0 {
  309|      0|                    return None;
  310|    733|                }
  311|       |            }
  312|       |        }
  313|       |
  314|  13.8k|        let mut raw = 0u32;
  315|  13.8k|        raw |= base_index & Self::BASE_MASK;
  316|  13.8k|        raw |= (class as u32) << Self::CLASS_SHIFT;
  317|  13.8k|        raw |= (ptr_depth as u32) << Self::PTR_SHIFT;
  318|  13.8k|        raw |= (arr_len) << Self::ARR_SHIFT;
  319|       |
  320|  13.8k|        NonZeroU32::new(raw).map(TypeRef)
  321|  13.8k|    }
  322|       |
  323|       |    // Unsafe constructor for internal use / tests
  324|       |    #[inline]
  325|  47.1k|    pub(crate) unsafe fn from_raw_unchecked(n: u32) -> Self {
  326|  47.1k|        unsafe { TypeRef(NonZeroU32::new_unchecked(n)) }
  327|  47.1k|    }
  328|       |
  329|       |    /// Create a dummy TypeRef (value 1) for initialization placeholders.
  330|       |    /// This is safe because 1 is a valid NonZeroU32, though the TypeRef might not be valid in the registry yet.
  331|       |    #[inline]
  332|  11.3k|    pub(crate) fn dummy() -> Self {
  333|  11.3k|        unsafe { Self::from_raw_unchecked(1) }
  334|  11.3k|    }
  335|       |
  336|       |    #[inline]
  337|    121|    pub(crate) fn get(self) -> u32 {
  338|    121|        self.raw()
  339|    121|    }
  340|       |
  341|       |    #[inline]
  342|  38.2k|    pub(crate) fn base(self) -> u32 {
  343|  38.2k|        (self.0.get() >> Self::BASE_SHIFT) & Self::BASE_MASK
  344|  38.2k|    }
  345|       |
  346|       |    #[inline]
  347|  84.7k|    pub(crate) fn class(self) -> TypeClass {
  348|  84.7k|        TypeClass::from_u32((self.0.get() >> Self::CLASS_SHIFT) & Self::CLASS_MASK)
  349|  84.7k|    }
  350|       |
  351|       |    #[inline]
  352|  3.41k|    pub(crate) fn pointer_depth(self) -> u8 {
  353|  3.41k|        ((self.0.get() >> Self::PTR_SHIFT) & Self::PTR_MASK) as u8
  354|  3.41k|    }
  355|       |
  356|       |    #[inline]
  357|  4.96k|    pub(crate) fn array_len(self) -> Option<u32> {
  358|  4.96k|        let val = (self.0.get() >> Self::ARR_SHIFT) & Self::ARR_MASK;
  359|  4.96k|        if val == 0 { None } else { Some(val) }
                                    ^1.51k        ^3.44k
  360|  4.96k|    }
  361|       |
  362|       |    #[inline]
  363|  3.98k|    pub(crate) fn is_builtin(self) -> bool {
  364|  3.98k|        self.class() == TypeClass::Builtin
  365|  3.98k|    }
  366|       |
  367|       |    #[inline]
  368|  2.66k|    pub(crate) fn is_pointer(self) -> bool {
  369|  2.66k|        self.class() == TypeClass::Pointer
  370|  2.66k|    }
  371|       |
  372|       |    #[inline]
  373|    894|    pub(crate) fn is_array(self) -> bool {
  374|    894|        self.class() == TypeClass::Array
  375|    894|    }
  376|       |
  377|       |    #[inline]
  378|  1.67k|    pub(crate) fn is_function(self) -> bool {
  379|  1.67k|        self.class() == TypeClass::Function
  380|  1.67k|    }
  381|       |
  382|       |    #[inline]
  383|    690|    pub(crate) fn is_record(self) -> bool {
  384|    690|        self.class() == TypeClass::Record
  385|    690|    }
  386|       |
  387|       |    #[inline]
  388|  2.87k|    pub(crate) fn is_enum(self) -> bool {
  389|  2.87k|        self.class() == TypeClass::Enum
  390|  2.87k|    }
  391|       |
  392|       |    #[inline]
  393|  1.92k|    pub(crate) fn is_complex(self) -> bool {
  394|  1.92k|        self.class() == TypeClass::Complex
  395|  1.92k|    }
  396|       |
  397|       |    // --- Helpers for inline/registry check ---
  398|       |
  399|       |    #[inline]
  400|  35.4k|    pub(crate) fn is_inline_pointer(self) -> bool {
  401|  35.4k|        self.class() == TypeClass::Pointer && self.pointer_depth() != 0
                                                            ^1.70k
  402|  35.4k|    }
  403|       |
  404|       |    #[inline]
  405|  34.6k|    pub(crate) fn is_inline_array(self) -> bool {
  406|  34.6k|        self.class() == TypeClass::Array && self.array_len().is_some()
                                                          ^2.56k           ^2.56k
  407|  34.6k|    }
  408|       |    // --- Legacy/Compat helpers ---
  409|       |
  410|       |    #[inline]
  411|  3.94k|    pub(crate) fn builtin(self) -> Option<BuiltinType> {
  412|  3.94k|        if self.is_builtin() {
  413|  3.33k|            BuiltinType::from_u32(self.base())
  414|       |        } else {
  415|    611|            None
  416|       |        }
  417|  3.94k|    }
  418|       |
  419|       |    #[inline]
  420|  22.8k|    pub(crate) fn raw(self) -> u32 {
  421|  22.8k|        self.0.get()
  422|  22.8k|    }
  423|       |
  424|       |    #[inline]
  425|  32.0k|    pub(crate) fn index(self) -> usize {
  426|       |        // Compatibility: returns base as index.
  427|       |        // For inline types, this returns the index of the base type.
  428|       |        // For registry types, this returns the registry index.
  429|  32.0k|        self.base() as usize
  430|  32.0k|    }
  431|       |
  432|       |    #[inline]
  433|    272|    pub(crate) fn is_void(self) -> bool {
  434|    272|        matches!(self.builtin(), Some(BuiltinType::Void))
                      ^266
  435|    272|    }
  436|       |
  437|       |    #[inline]
  438|  2.05k|    pub(crate) fn is_integer(self) -> bool {
  439|  2.05k|        self.is_enum() || self.builtin().is_some_and(|b| b.is_integer())
                                        ^2.04k^2.04k    ^2.04k          ^1.73k^1.73k
  440|  2.05k|    }
  441|       |
  442|       |    #[inline]
  443|    704|    pub(crate) fn is_floating(self) -> bool {
  444|    704|        self.is_complex() || self.builtin().is_some_and(|b| b.is_floating())
                                           ^604 ^604      ^604            ^384^384
  445|    704|    }
  446|       |
  447|       |    #[inline]
  448|  1.93k|    pub(crate) fn is_arithmetic(self) -> bool {
  449|  1.93k|        self.is_integer() || self.is_floating()
                                           ^375 ^375
  450|  1.93k|    }
  451|       |
  452|       |    #[inline]
  453|     37|    pub(crate) fn is_real(self) -> bool {
  454|     37|        self.is_integer() || self.builtin().is_some_and(|b| b.is_floating())
                                           ^3   ^3        ^3              ^2^2
  455|     37|    }
  456|       |
  457|       |    #[inline]
  458|    131|    pub(crate) fn is_scalar(self) -> bool {
  459|    131|        self.is_arithmetic() || self.is_pointer()
                                              ^54  ^54
  460|    131|    }
  461|       |}
  462|       |
  463|       |impl Display for TypeRef {
  464|     42|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  465|     42|        if self.is_builtin() {
  466|     19|            write!(f, "{:?}", self.builtin().unwrap())
  467|       |        } else {
  468|     23|            write!(
  469|     23|                f,
  470|     23|                "TypeRef(base={}, class={:?}, ptr={}, arr={:?})",
  471|     23|                self.base(),
  472|     23|                self.class(),
  473|     23|                self.pointer_depth(),
  474|     23|                self.array_len()
  475|       |            )
  476|       |        }
  477|     42|    }
  478|       |}
  479|       |
  480|       |#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, Serialize)]
  481|       |#[repr(transparent)]
  482|       |pub struct QualType(u32);
  483|       |
  484|       |impl Default for QualType {
  485|     12|    fn default() -> Self {
  486|       |        // Use raw value 1 (which maps to TypeRef(1)) as default to avoid NonZeroU32(0) UB
  487|     12|        QualType(1)
  488|     12|    }
  489|       |}
  490|       |
  491|       |// bits  0..=27   TypeRef (28 bit)
  492|       |// bits 28..=31   qualifiers (4 bit)
  493|       |
  494|       |impl QualType {
  495|       |    const QUAL_BITS: u32 = 4;
  496|       |    const QUAL_SHIFT: u32 = 28;
  497|       |    const TY_MASK: u32 = (1 << Self::QUAL_SHIFT) - 1;
  498|       |
  499|       |    #[inline]
  500|  11.3k|    pub(crate) fn new(ty: TypeRef, quals: TypeQualifiers) -> Self {
  501|  11.3k|        debug_assert!(quals.bits() < (1 << Self::QUAL_BITS));
  502|  11.3k|        debug_assert!(ty.raw() <= Self::TY_MASK);
  503|       |
  504|  11.3k|        QualType((ty.raw() & Self::TY_MASK) | ((quals.bits() as u32) << Self::QUAL_SHIFT))
  505|  11.3k|    }
  506|       |
  507|       |    #[inline]
  508|  6.99k|    pub(crate) fn unqualified(ty: TypeRef) -> Self {
  509|  6.99k|        Self::new(ty, TypeQualifiers::empty())
  510|  6.99k|    }
  511|       |
  512|       |    #[inline]
  513|  35.7k|    pub(crate) fn ty(self) -> TypeRef {
  514|  35.7k|        unsafe { TypeRef::from_raw_unchecked(self.0 & Self::TY_MASK) }
  515|  35.7k|    }
  516|       |
  517|       |    #[inline]
  518|  6.45k|    pub(crate) fn qualifiers(self) -> TypeQualifiers {
  519|  6.45k|        TypeQualifiers::from_bits_truncate((self.0 >> Self::QUAL_SHIFT) as u8)
  520|  6.45k|    }
  521|       |
  522|       |    #[inline]
  523|    200|    pub(crate) fn is_const(self) -> bool {
  524|    200|        self.qualifiers().contains(TypeQualifiers::CONST)
  525|    200|    }
  526|       |
  527|       |    #[inline]
  528|  2.60k|    pub(crate) fn is_pointer(self) -> bool {
  529|  2.60k|        self.ty().is_pointer()
  530|  2.60k|    }
  531|       |    #[inline]
  532|    891|    pub(crate) fn is_array(self) -> bool {
  533|    891|        self.ty().is_array()
  534|    891|    }
  535|       |    #[inline]
  536|  1.55k|    pub(crate) fn is_function(self) -> bool {
  537|  1.55k|        self.ty().is_function()
  538|  1.55k|    }
  539|       |    #[inline]
  540|    153|    pub(crate) fn is_record(self) -> bool {
  541|    153|        self.ty().is_record()
  542|    153|    }
  543|       |    #[inline]
  544|     88|    pub(crate) fn is_complex(self) -> bool {
  545|     88|        self.ty().is_complex()
  546|     88|    }
  547|       |    #[inline]
  548|    272|    pub(crate) fn is_void(self) -> bool {
  549|    272|        self.ty().is_void()
  550|    272|    }
  551|       |    #[inline]
  552|     84|    pub(crate) fn is_integer(self) -> bool {
  553|     84|        self.ty().is_integer()
  554|     84|    }
  555|       |    #[inline]
  556|  1.80k|    pub(crate) fn is_arithmetic(self) -> bool {
  557|  1.80k|        self.ty().is_arithmetic()
  558|  1.80k|    }
  559|       |    #[inline]
  560|     37|    pub(crate) fn is_real(self) -> bool {
  561|     37|        self.ty().is_real()
  562|     37|    }
  563|       |    #[inline]
  564|    131|    pub(crate) fn is_scalar(self) -> bool {
  565|    131|        self.ty().is_scalar()
  566|    131|    }
  567|       |}
  568|       |
  569|       |impl Display for QualType {
  570|     27|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  571|     27|        let quals = self.qualifiers();
  572|     27|        if !quals.is_empty() {
  573|      0|            write!(f, "{} ", quals)?;
  574|     27|        }
  575|     27|        write!(f, "{}", self.ty())
  576|     27|    }
  577|       |}
  578|       |
  579|       |const _: () = assert!(std::mem::size_of::<QualType>() == 4);
  580|       |
  581|       |/// The kind of type
  582|       |#[derive(Debug, Clone, PartialEq, Default)]
  583|       |pub enum TypeKind {
  584|       |    Builtin(BuiltinType),
  585|       |    Complex {
  586|       |        base_type: TypeRef,
  587|       |    },
  588|       |    Pointer {
  589|       |        pointee: QualType,
  590|       |    },
  591|       |    Array {
  592|       |        element_type: TypeRef,
  593|       |        size: ArraySizeType,
  594|       |    },
  595|       |    Function {
  596|       |        return_type: TypeRef,
  597|       |        parameters: Arc<[FunctionParameter]>,
  598|       |        is_variadic: bool,
  599|       |        is_noreturn: bool,
  600|       |    },
  601|       |    Record {
  602|       |        tag: Option<NameId>,
  603|       |        members: Arc<[StructMember]>,
  604|       |        is_complete: bool,
  605|       |        is_union: bool,
  606|       |    },
  607|       |    Enum {
  608|       |        tag: Option<NameId>,
  609|       |        base_type: TypeRef,
  610|       |        enumerators: Arc<[EnumConstant]>,
  611|       |        is_complete: bool,
  612|       |    },
  613|       |    #[default]
  614|       |    Error,
  615|       |}
  616|       |
  617|       |impl TypeKind {
  618|      1|    pub(crate) fn builtin(&self) -> Option<BuiltinType> {
  619|      1|        match self {
  620|      1|            TypeKind::Builtin(b) => Some(*b),
  621|      0|            _ => None,
  622|       |        }
  623|      1|    }
  624|       |
  625|  12.5k|    pub(crate) fn to_class(&self) -> TypeClass {
  626|  12.5k|        match self {
  627|  11.6k|            TypeKind::Builtin(_) | TypeKind::Error => TypeClass::Builtin,
  628|     29|            TypeKind::Complex { .. } => TypeClass::Complex,
  629|     57|            TypeKind::Pointer { .. } => TypeClass::Pointer,
  630|     66|            TypeKind::Array { .. } => TypeClass::Array,
  631|    465|            TypeKind::Function { .. } => TypeClass::Function,
  632|    223|            TypeKind::Record { .. } => TypeClass::Record,
  633|     16|            TypeKind::Enum { .. } => TypeClass::Enum,
  634|       |        }
  635|  12.5k|    }
  636|       |}
  637|       |
  638|       |impl Display for TypeKind {
  639|     33|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  640|     33|        match self {
  641|     22|            TypeKind::Builtin(b) => match b {
  642|      3|                BuiltinType::Void => write!(f, "void"),
  643|      0|                BuiltinType::Bool => write!(f, "_Bool"),
  644|      1|                BuiltinType::Char => write!(f, "char"),
  645|      0|                BuiltinType::SChar => write!(f, "signed char"),
  646|      0|                BuiltinType::UChar => write!(f, "unsigned char"),
  647|      0|                BuiltinType::Short => write!(f, "short"),
  648|      0|                BuiltinType::UShort => write!(f, "unsigned short"),
  649|     15|                BuiltinType::Int => write!(f, "int"),
  650|      0|                BuiltinType::UInt => write!(f, "unsigned int"),
  651|      0|                BuiltinType::Long => write!(f, "long"),
  652|      0|                BuiltinType::ULong => write!(f, "unsigned long"),
  653|      0|                BuiltinType::LongLong => write!(f, "long long"),
  654|      0|                BuiltinType::ULongLong => write!(f, "unsigned long long"),
  655|      0|                BuiltinType::Float => write!(f, "float"),
  656|      3|                BuiltinType::Double => write!(f, "double"),
  657|      0|                BuiltinType::LongDouble => write!(f, "long double"),
  658|      0|                BuiltinType::Signed => write!(f, "signed"),
  659|      0|                BuiltinType::VaList => write!(f, "__builtin_va_list"),
  660|      0|                BuiltinType::Complex => write!(f, "_Complex (marker)"),
  661|       |            },
  662|      0|            TypeKind::Complex { .. } => write!(f, "_Complex"),
  663|      4|            TypeKind::Pointer { .. } => write!(f, "<pointer>"),
  664|      0|            TypeKind::Array { .. } => write!(f, "<array>"),
  665|      0|            TypeKind::Function { .. } => write!(f, "<function>"),
  666|      7|            TypeKind::Record { tag, is_union, .. } => {
  667|      7|                let kind_str = if *is_union { "union" } else { "struct" };
                                                            ^0
  668|      7|                if let Some(tag_name) = tag {
  669|      7|                    write!(f, "{} {}", kind_str, tag_name)
  670|       |                } else {
  671|      0|                    write!(f, "{} (anonymous)", kind_str)
  672|       |                }
  673|       |            }
  674|      0|            TypeKind::Enum { tag, .. } => {
  675|      0|                if let Some(tag_name) = tag {
  676|      0|                    write!(f, "enum {}", tag_name)
  677|       |                } else {
  678|      0|                    write!(f, "enum (anonymous)")
  679|       |                }
  680|       |            }
  681|      0|            TypeKind::Error => write!(f, "<error>"),
  682|       |        }
  683|     33|    }
  684|       |}
  685|       |
  686|       |/// Array size types
  687|       |#[derive(Debug, Clone, PartialEq, Eq, Hash)]
  688|       |pub enum ArraySizeType {
  689|       |    Constant(usize),
  690|       |    Variable(NodeRef),
  691|       |    Incomplete,
  692|       |    Star,
  693|       |}
  694|       |
  695|       |bitflags! {
  696|       |    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, Serialize, Default)]
  697|       |    pub struct TypeQualifiers: u8 {
  698|       |        const CONST = 1 << 0;
  699|       |        const VOLATILE = 1 << 1;
  700|       |        const RESTRICT = 1 << 2;
  701|       |        const ATOMIC = 1 << 3;
  702|       |    }
  703|       |}
  704|       |
  705|       |impl Display for TypeQualifiers {
  706|     50|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  707|     50|        if self.contains(TypeQualifiers::CONST) {
  708|      2|            write!(f, "const")?;
                                            ^0
  709|     48|        }
  710|     50|        if self.contains(TypeQualifiers::VOLATILE) {
  711|      0|            write!(f, "volatile")?;
  712|     50|        }
  713|     50|        if self.contains(TypeQualifiers::RESTRICT) {
  714|      0|            write!(f, "restrict")?;
  715|     50|        }
  716|     50|        if self.contains(TypeQualifiers::ATOMIC) {
  717|     48|            write!(f, "_Atomic")?;
                                              ^0
  718|      2|        }
  719|       |
  720|     50|        Ok(())
  721|     50|    }
  722|       |}
  723|       |
  724|       |#[derive(Debug, Clone, Copy, PartialEq)]
  725|       |pub struct FunctionParameter {
  726|       |    pub param_type: QualType,
  727|       |    pub name: Option<NameId>,
  728|       |    pub storage: Option<StorageClass>,
  729|       |}
  730|       |
  731|       |#[derive(Debug, Clone, Copy, PartialEq, Default)]
  732|       |pub struct StructMember {
  733|       |    pub name: Option<NameId>,
  734|       |    pub member_type: QualType,
  735|       |    pub bit_field_size: Option<u16>,
  736|       |    pub alignment: Option<u32>,
  737|       |    pub span: SourceSpan,
  738|       |}
  739|       |
  740|       |#[derive(Debug, Clone, Copy, PartialEq)]
  741|       |pub struct EnumConstant {
  742|       |    pub name: NameId,
  743|       |    pub value: i64,
  744|       |    pub span: SourceSpan,
  745|       |    pub init_expr: Option<NodeRef>,
  746|       |}

/app/src/source_manager.rs:
    1|       |use hashbrown::HashMap;
    2|       |use serde::Serialize;
    3|       |use std::sync::Arc;
    4|       |use std::{
    5|       |    cmp::Ordering,
    6|       |    num::NonZeroU32,
    7|       |    path::{Path, PathBuf},
    8|       |};
    9|       |
   10|       |/// Source ID for identifying source files
   11|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize)]
   12|       |pub struct SourceId(pub(crate) NonZeroU32);
   13|       |
   14|       |impl std::fmt::Display for SourceId {
   15|     42|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   16|     42|        write!(f, "SourceId({})", self.0)
   17|     42|    }
   18|       |}
   19|       |
   20|       |impl SourceId {
   21|       |    /// create a new SourceId from a u32. panics if id is zero.
   22|  73.4k|    pub(crate) fn new(id: u32) -> Self {
   23|  73.4k|        SourceId(NonZeroU32::new(id).expect("SourceId must be non-zero"))
   24|  73.4k|    }
   25|       |
   26|  33.1k|    pub(crate) fn to_u32(self) -> u32 {
   27|  33.1k|        self.0.get()
   28|  33.1k|    }
   29|       |}
   30|       |
   31|       |/// Source ID and byte offset.
   32|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize)]
   33|       |pub struct SourceLoc {
   34|       |    pub source_id: SourceId,
   35|       |    pub offset: u32,
   36|       |}
   37|       |
   38|       |impl Default for SourceLoc {
   39|      0|    fn default() -> Self {
   40|      0|        Self::builtin()
   41|      0|    }
   42|       |}
   43|       |
   44|       |impl SourceLoc {
   45|  71.6k|    pub(crate) fn new(source_id: SourceId, offset: u32) -> Self {
   46|  71.6k|        SourceLoc { source_id, offset }
   47|  71.6k|    }
   48|       |
   49|       |    /// built-in source location (SourceId = 1, offset = 0)
   50|  48.7k|    pub(crate) fn builtin() -> Self {
   51|  48.7k|        SourceLoc::new(SourceId::new(1), 0)
   52|  48.7k|    }
   53|       |
   54|  17.4k|    pub(crate) fn source_id(&self) -> SourceId {
   55|  17.4k|        self.source_id
   56|  17.4k|    }
   57|       |
   58|  16.8k|    pub(crate) fn offset(&self) -> u32 {
   59|  16.8k|        self.offset
   60|  16.8k|    }
   61|       |}
   62|       |
   63|       |impl std::fmt::Display for SourceLoc {
   64|      1|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
   65|      1|        write!(f, "SourceLoc(source_id={}, offset={})", self.source_id, self.offset)
   66|      1|    }
   67|       |}
   68|       |
   69|       |/// Represents a range in the source file.
   70|       |/// Packed representation (64 bits total):
   71|       |/// - Bits 0-23: Offset (24 bits) - Max 16 MiB
   72|       |/// - Bits 24-39: Length (16 bits) - Max 64 KiB
   73|       |/// - Bits 40-63: SourceId (24 bits) - Max ~16M files
   74|       |#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize)]
   75|       |pub struct SourceSpan(u64);
   76|       |
   77|       |impl Default for SourceSpan {
   78|    302|    fn default() -> Self {
   79|    302|        Self::empty()
   80|    302|    }
   81|       |}
   82|       |
   83|       |impl SourceSpan {
   84|       |    const OFFSET_BITS: u64 = 24;
   85|       |    const LENGTH_BITS: u64 = 16;
   86|       |    const SOURCE_ID_BITS: u64 = 24;
   87|       |
   88|       |    const OFFSET_MASK: u64 = (1 << Self::OFFSET_BITS) - 1;
   89|       |    const LENGTH_MASK: u64 = (1 << Self::LENGTH_BITS) - 1;
   90|       |    const SOURCE_ID_MASK: u64 = (1 << Self::SOURCE_ID_BITS) - 1;
   91|       |
   92|       |    const LENGTH_SHIFT: u64 = Self::OFFSET_BITS;
   93|       |    const SOURCE_ID_SHIFT: u64 = Self::OFFSET_BITS + Self::LENGTH_BITS;
   94|       |
   95|       |    const MAX_OFFSET: u32 = Self::OFFSET_MASK as u32;
   96|       |    const MAX_LENGTH: u32 = Self::LENGTH_MASK as u32;
   97|       |    const MAX_SOURCE_ID: u32 = Self::SOURCE_ID_MASK as u32;
   98|       |
   99|  12.6k|    pub(crate) fn new(start: SourceLoc, end: SourceLoc) -> Self {
  100|  12.6k|        if start.source_id != end.source_id {
  101|       |            // Panic removed: When start and end are in different files (e.g. usage of macro vs macro expansion),
  102|       |            // we cannot represent the span correctly in our packed format.
  103|       |            // Gracefully degrade to a zero-length span at the start location.
  104|     12|            return Self::new_with_length(start.source_id, start.offset, 0);
  105|  12.6k|        }
  106|       |
  107|  12.6k|        let length = end.offset.saturating_sub(start.offset);
  108|  12.6k|        Self::new_with_length(start.source_id, start.offset, length)
  109|  12.6k|    }
  110|       |
  111|  28.9k|    pub(crate) fn new_with_length(source_id: SourceId, offset: u32, length: u32) -> Self {
  112|  28.9k|        let id = source_id.to_u32();
  113|  28.9k|        assert!(id <= Self::MAX_SOURCE_ID, "SourceId exceeds 24-bit limit: {}", id);
                                                         ^0
  114|  28.9k|        assert!(
  115|  28.9k|            offset <= Self::MAX_OFFSET,
  116|      2|            "SourceSpan offset exceeds 16 MiB limit: {}",
  117|       |            offset
  118|       |        );
  119|       |
  120|  28.9k|        let len = length.min(Self::MAX_LENGTH);
  121|       |
  122|  28.9k|        Self((offset as u64) | ((len as u64) << Self::LENGTH_SHIFT) | ((id as u64) << Self::SOURCE_ID_SHIFT))
  123|  28.9k|    }
  124|       |
  125|  6.60k|    pub(crate) fn empty() -> Self {
  126|  6.60k|        Self::new(SourceLoc::builtin(), SourceLoc::builtin())
  127|  6.60k|    }
  128|       |
  129|     23|    pub(crate) fn dummy() -> Self {
  130|     23|        Self::empty()
  131|     23|    }
  132|       |
  133|  8.11k|    pub(crate) fn start(&self) -> SourceLoc {
  134|  8.11k|        let offset = (self.0 & Self::OFFSET_MASK) as u32;
  135|  8.11k|        SourceLoc {
  136|  8.11k|            source_id: self.source_id(),
  137|  8.11k|            offset,
  138|  8.11k|        }
  139|  8.11k|    }
  140|       |
  141|  7.33k|    pub(crate) fn end(&self) -> SourceLoc {
  142|  7.33k|        let offset = (self.0 & Self::OFFSET_MASK) as u32;
  143|  7.33k|        let length = ((self.0 >> Self::LENGTH_SHIFT) & Self::LENGTH_MASK) as u32;
  144|  7.33k|        SourceLoc {
  145|  7.33k|            source_id: self.source_id(),
  146|  7.33k|            offset: offset + length,
  147|  7.33k|        }
  148|  7.33k|    }
  149|       |
  150|  18.9k|    pub(crate) fn source_id(&self) -> SourceId {
  151|  18.9k|        let id = ((self.0 >> Self::SOURCE_ID_SHIFT) & Self::SOURCE_ID_MASK) as u32;
  152|  18.9k|        SourceId::new(id)
  153|  18.9k|    }
  154|       |
  155|      1|    pub(crate) fn is_source_id_builtin(&self) -> bool {
  156|      1|        self.source_id().to_u32() == 1
  157|      1|    }
  158|       |
  159|       |    /// Merge two source spans into a single span covering both
  160|  1.72k|    pub(crate) fn merge(self, other: SourceSpan) -> SourceSpan {
  161|  1.72k|        let id1 = self.source_id();
  162|  1.72k|        let id2 = other.source_id();
  163|       |
  164|  1.72k|        if id1 != id2 {
  165|      4|            return self;
  166|  1.72k|        }
  167|       |
  168|  1.72k|        let start1 = self.start().offset;
  169|  1.72k|        let end1 = self.end().offset;
  170|  1.72k|        let start2 = other.start().offset;
  171|  1.72k|        let end2 = other.end().offset;
  172|       |
  173|  1.72k|        let min_start = start1.min(start2);
  174|  1.72k|        let max_end = end1.max(end2);
  175|       |
  176|  1.72k|        let start_loc = SourceLoc::new(id1, min_start);
  177|  1.72k|        let end_loc = SourceLoc::new(id1, max_end);
  178|       |
  179|  1.72k|        Self::new(start_loc, end_loc)
  180|  1.72k|    }
  181|       |}
  182|       |
  183|       |impl std::fmt::Display for SourceSpan {
  184|     39|    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
  185|     39|        write!(
  186|     39|            f,
  187|     39|            "SourceSpan(source_id={}, start={}, end={})",
  188|     39|            self.source_id(),
  189|     39|            self.start().offset,
  190|     39|            self.end().offset
  191|       |        )
  192|     39|    }
  193|       |}
  194|       |
  195|       |/// Represents a single #line directive entry
  196|       |#[derive(Debug, Clone, PartialEq, Eq)]
  197|       |pub struct LineDirective {
  198|       |    pub physical_line: u32,
  199|       |    pub logical_line: u32,
  200|       |    pub logical_file: Option<String>,
  201|       |}
  202|       |
  203|       |impl LineDirective {
  204|    111|    pub(crate) fn new(physical_line: u32, logical_line: u32, logical_file: Option<String>) -> Self {
  205|    111|        LineDirective {
  206|    111|            physical_line,
  207|    111|            logical_line,
  208|    111|            logical_file,
  209|    111|        }
  210|    111|    }
  211|       |}
  212|       |
  213|       |impl Ord for LineDirective {
  214|      2|    fn cmp(&self, other: &Self) -> Ordering {
  215|      2|        self.physical_line.cmp(&other.physical_line)
  216|      2|    }
  217|       |}
  218|       |
  219|       |impl PartialOrd for LineDirective {
  220|      1|    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
  221|      1|        Some(self.cmp(other))
  222|      1|    }
  223|       |}
  224|       |
  225|       |/// Stores all #line directives for a single file, sorted by physical line
  226|       |#[derive(Debug, Clone, Default)]
  227|       |pub struct LineMap {
  228|       |    pub(crate) entries: Vec<LineDirective>,
  229|       |}
  230|       |
  231|       |impl LineMap {
  232|  5.69k|    pub(crate) fn new() -> Self {
  233|  5.69k|        LineMap { entries: Vec::new() }
  234|  5.69k|    }
  235|       |
  236|       |    /// Add a line directive entry. Must be added in sorted order by physical_line.
  237|    108|    pub(crate) fn add_entry(&mut self, entry: LineDirective) {
  238|       |        // Ensure monotonic addition
  239|    108|        if let Some(last) = self.entries.last() {
                                  ^100
  240|    100|            assert!(
  241|    100|                entry.physical_line >= last.physical_line,
  242|      0|                "Line directives must be added in sorted order"
  243|       |            );
  244|      8|        }
  245|    108|        self.entries.push(entry);
  246|    108|    }
  247|       |
  248|       |    /// Find the presumed location for a given physical line
  249|  1.01k|    pub(crate) fn presumed_location(&self, physical_line: u32) -> (u32, Option<&str>) {
  250|       |        // Binary search to find the last entry where physical_line <= target
  251|  8.00k|        let idx = self.entries.partition_point(|e| e.physical_line <= physical_line);
                          ^1.01k^1.01k       ^1.01k
  252|       |
  253|  1.01k|        if idx == 0 {
  254|       |            // No mapping, use physical line
  255|      7|            (physical_line, None)
  256|       |        } else {
  257|  1.00k|            let entry = &self.entries[idx - 1];
  258|  1.00k|            let logical_line = entry.logical_line + (physical_line - entry.physical_line);
  259|       |            // If entry has no logical file, it means no change from physical file
  260|  1.00k|            (logical_line, entry.logical_file.as_deref())
  261|       |        }
  262|  1.01k|    }
  263|       |}
  264|       |
  265|       |/// File information for tracking source files
  266|       |#[derive(Debug)]
  267|       |pub struct FileInfo {
  268|       |    pub file_id: SourceId,
  269|       |    pub path: PathBuf,
  270|       |    pub size: u32,
  271|       |    pub buffer_index: usize,            // Index into buffers Vec
  272|       |    pub line_starts: Vec<u32>,          // Line start offsets for efficient line lookup
  273|       |    pub line_map: LineMap,              // #line directive mappings
  274|       |    pub include_loc: Option<SourceLoc>, // Location where this file was included/expanded from
  275|       |}
  276|       |
  277|       |/// Manages source files and locations
  278|       |/// File size limit: 4 MiB per file (22-bit offset in SourceLoc)
  279|       |/// Maximum files: 1023 unique source files (10-bit file ID in SourceLoc)
  280|       |pub struct SourceManager {
  281|       |    buffers: Vec<Arc<[u8]>>,
  282|       |    file_infos: Vec<FileInfo>,
  283|       |    path_to_id: HashMap<PathBuf, SourceId>,
  284|       |    next_file_id: u32,
  285|       |}
  286|       |
  287|       |impl Default for SourceManager {
  288|    982|    fn default() -> Self {
  289|    982|        Self {
  290|    982|            buffers: Vec::new(),
  291|    982|            file_infos: Vec::new(),
  292|    982|            path_to_id: HashMap::new(),
  293|    982|            next_file_id: 2, // Start from 2, reserve 1 for built-ins
  294|    982|        }
  295|    982|    }
  296|       |}
  297|       |
  298|       |impl SourceManager {
  299|    982|    pub(crate) fn new() -> Self {
  300|    982|        Self::default()
  301|    982|    }
  302|       |
  303|       |    /// Add a file to the source manager from a file path
  304|       |    /// Since we only support UTF-8, we can read directly as bytes and assume validity
  305|     11|    pub(crate) fn add_file_from_path(
  306|     11|        &mut self,
  307|     11|        path: &std::path::Path,
  308|     11|        include_loc: Option<SourceLoc>,
  309|     11|    ) -> Result<SourceId, std::io::Error> {
  310|     11|        let buffer = std::fs::read(path)?;
                          ^10                         ^1
  311|     10|        let path_str = path.to_str().unwrap_or("<invalid-utf8>");
  312|     10|        Ok(self.add_buffer(buffer, path_str, include_loc))
  313|     11|    }
  314|       |
  315|       |    /// Add a buffer to the source manager with raw bytes (UTF-8 assumed)
  316|  5.59k|    pub(crate) fn add_buffer(&mut self, buffer: Vec<u8>, path: &str, include_loc: Option<SourceLoc>) -> SourceId {
  317|  5.59k|        let path_buf = PathBuf::from(path);
  318|       |        // Standard buffers get empty line_starts initially; they are calculated/set later if needed
  319|  5.59k|        self.add_file_entry(Arc::from(buffer), path_buf, Vec::new(), include_loc, true)
  320|  5.59k|    }
  321|       |
  322|       |    /// Add a virtual buffer for macro expansions (Level B support)
  323|       |    /// Virtual buffers contain expanded macro text with proper sequential locations
  324|     97|    pub(crate) fn add_virtual_buffer(
  325|     97|        &mut self,
  326|     97|        buffer: Vec<u8>,
  327|     97|        name: &str,
  328|     97|        include_loc: Option<SourceLoc>,
  329|     97|    ) -> SourceId {
  330|       |        // Calculate line starts for the virtual buffer immediately
  331|     97|        let mut line_starts = vec![0];
  332|  1.06k|        for (i, &byte) in buffer.iter().enumerate() {
                                        ^97           ^97
  333|  1.06k|            if byte == b'\n' {
  334|      3|                line_starts.push((i + 1) as u32);
  335|  1.05k|            }
  336|       |        }
  337|       |
  338|     97|        let path_buf = PathBuf::from(format!("<{}>", name));
  339|     97|        self.add_file_entry(Arc::from(buffer), path_buf, line_starts, include_loc, false)
  340|     97|    }
  341|       |
  342|       |    /// Helper to add a file entry and update maps
  343|  5.69k|    fn add_file_entry(
  344|  5.69k|        &mut self,
  345|  5.69k|        buffer: Arc<[u8]>,
  346|  5.69k|        path: PathBuf,
  347|  5.69k|        line_starts: Vec<u32>,
  348|  5.69k|        include_loc: Option<SourceLoc>,
  349|  5.69k|        is_real_file: bool,
  350|  5.69k|    ) -> SourceId {
  351|  5.69k|        let file_id = SourceId::new(self.next_file_id);
  352|  5.69k|        self.next_file_id += 1;
  353|       |
  354|  5.69k|        let size = buffer.len() as u32;
  355|  5.69k|        let buffer_index = self.buffers.len();
  356|  5.69k|        self.buffers.push(buffer);
  357|       |
  358|  5.69k|        if is_real_file {
  359|  5.59k|            // Only map path for real files (not virtual ones usually).
  360|  5.59k|            // This avoids unnecessary map insertions for short-lived virtual buffers.
  361|  5.59k|            self.path_to_id.insert(path.clone(), file_id);
  362|  5.59k|        }
                      ^97
  363|       |
  364|  5.69k|        let file_info = FileInfo {
  365|  5.69k|            file_id,
  366|  5.69k|            path,
  367|  5.69k|            size,
  368|  5.69k|            buffer_index,
  369|  5.69k|            line_starts,
  370|  5.69k|            line_map: LineMap::new(),
  371|  5.69k|            include_loc,
  372|  5.69k|        };
  373|       |
  374|  5.69k|        self.file_infos.push(file_info);
  375|       |
  376|  5.69k|        file_id
  377|  5.69k|    }
  378|       |
  379|       |    /// Get the buffer for a given source ID
  380|       |    /// Since SourceId is always valid (we panic if not found), we can use indexing
  381|       |    /// use get_source_text to get &str from SourceSpan instead if you need text
  382|    945|    pub(crate) fn get_buffer(&self, source_id: SourceId) -> &[u8] {
  383|    945|        let id = source_id.to_u32();
  384|    945|        if id < 2 {
  385|      0|            panic!("invalid source_id {source_id}");
  386|    945|        }
  387|    945|        let info = match self.file_infos.get(id as usize - 2) {
                          ^944
  388|    944|            Some(info) => info,
  389|      1|            None => panic!("invalid source_id {source_id}"),
  390|       |        };
  391|    944|        &self.buffers[info.buffer_index][..]
  392|    944|    }
  393|       |
  394|       |    /// Get the buffer for a given source ID, returning None if not found
  395|    155|    pub(crate) fn get_buffer_safe(&self, source_id: SourceId) -> Option<&[u8]> {
  396|    155|        let id = source_id.to_u32();
  397|    155|        if id < 2 {
  398|     10|            return None;
  399|    145|        }
  400|    145|        self.file_infos
  401|    145|            .get(id as usize - 2)
  402|    145|            .map(|info| &self.buffers[info.buffer_index][..])
  403|    155|    }
  404|       |
  405|       |    /// Get the buffer as an Arc for a given source ID.
  406|       |    /// This allows shared ownership without cloning the entire buffer.
  407|    952|    pub(crate) fn get_buffer_arc(&self, source_id: SourceId) -> Arc<[u8]> {
  408|    952|        let id = source_id.to_u32();
  409|    952|        if id < 2 {
  410|      0|            panic!("invalid source_id {source_id}");
  411|    952|        }
  412|    952|        let info = match self.file_infos.get(id as usize - 2) {
                          ^951
  413|    951|            Some(info) => info,
  414|      1|            None => panic!("invalid source_id {source_id}"),
  415|       |        };
  416|    951|        self.buffers[info.buffer_index].clone()
  417|    951|    }
  418|       |
  419|       |    /// Get file info for a given source ID
  420|    314|    pub(crate) fn get_file_info(&self, source_id: SourceId) -> Option<&FileInfo> {
  421|    314|        let id = source_id.to_u32();
  422|    314|        if id < 2 {
  423|     10|            return None;
  424|    304|        }
  425|    304|        self.file_infos.get(id as usize - 2)
  426|    314|    }
  427|       |
  428|       |    /// Get source ID for a given file path
  429|     56|    pub(crate) fn get_file_id(&self, path: &str) -> Option<SourceId> {
  430|     56|        self.path_to_id.get(Path::new(path)).copied()
  431|     56|    }
  432|       |
  433|       |    /// Get mutable access to the LineMap for a given source ID
  434|      3|    pub(crate) fn get_line_map_mut(&mut self, source_id: SourceId) -> Option<&mut LineMap> {
  435|      3|        let id = source_id.to_u32();
  436|      3|        if id < 2 {
  437|      0|            return None;
  438|      3|        }
  439|      3|        self.file_infos.get_mut(id as usize - 2).map(|fi| &mut fi.line_map)
  440|      3|    }
  441|       |
  442|       |    /// Set line starts for a given source ID
  443|    918|    pub(crate) fn set_line_starts(&mut self, source_id: SourceId, line_starts: Vec<u32>) {
  444|    918|        let id = source_id.to_u32();
  445|    918|        if id >= 2 {
  446|    918|            if let Some(file_info) = self.file_infos.get_mut(id as usize - 2) {
                                      ^917
  447|    917|                file_info.line_starts = line_starts;
  448|    917|            }
                          ^1
  449|      0|        }
  450|    918|    }
  451|       |
  452|       |    /// Calculate line starts for a given source ID
  453|    922|    pub(crate) fn calculate_line_starts(&mut self, source_id: SourceId) {
  454|    922|        let id = source_id.to_u32();
  455|    922|        if id >= 2 {
  456|    922|            if let Some(file_info) = self.file_infos.get_mut(id as usize - 2) {
                                      ^921
  457|    921|                let buffer = &self.buffers[file_info.buffer_index];
  458|    921|                let mut line_starts = vec![0]; // First line starts at offset 0
  459|       |
  460|  75.7k|                for (i, &byte) in buffer.iter().enumerate() {
                                                ^921          ^921
  461|  75.7k|                    if byte == b'\n' {
  462|  3.15k|                        line_starts.push((i + 1) as u32);
  463|  72.6k|                    }
  464|       |                }
  465|       |
  466|    921|                file_info.line_starts = line_starts;
  467|      1|            }
  468|      0|        }
  469|    922|    }
  470|       |
  471|       |    /// Get the source text for a given span
  472|       |    /// Since we only support UTF-8, we can assume the bytes are valid UTF-8
  473|       |    #[cfg(test)]
  474|      2|    pub(crate) fn get_source_text(&self, span: SourceSpan) -> &str {
  475|      2|        let buffer = self.get_buffer(span.source_id());
  476|      2|        let start = span.start().offset() as usize;
  477|      2|        let end = span.end().offset() as usize;
  478|       |
  479|      2|        if start <= end && end <= buffer.len() {
  480|      1|            unsafe { std::str::from_utf8_unchecked(&buffer[start..end]) }
  481|       |        } else {
  482|      1|            panic!("Invalid span range");
  483|       |        }
  484|      1|    }
  485|       |
  486|       |    /// Get line and column for a source location
  487|     20|    pub(crate) fn get_line_column(&self, loc: SourceLoc) -> Option<(u32, u32)> {
  488|     20|        let file_info = self.get_file_info(loc.source_id())?;
                          ^19                                            ^1
  489|     19|        let offset = loc.offset();
  490|       |
  491|     19|        let line_starts = &file_info.line_starts;
  492|     19|        if line_starts.is_empty() {
  493|       |            // If line_starts not calculated yet, assume single line starting at 0
  494|      1|            return Some((1, offset + 1));
  495|     18|        }
  496|       |
  497|       |        // Use partition_point which performs a binary search
  498|     59|        let idx = line_starts.partition_point(|&start| start <= offset);
                          ^18   ^18         ^18
  499|       |
  500|     18|        if idx == 0 {
  501|      1|            return Some((0, 1));
  502|     17|        }
  503|       |
  504|       |        // idx is the index of the first element GREATER than offset.
  505|       |        // The line index corresponds to the element immediately preceding usage.
  506|     17|        let line_idx = idx - 1;
  507|     17|        let line_start = line_starts[line_idx];
  508|     17|        let column = offset - line_start;
  509|       |
  510|     17|        Some((line_idx as u32 + 1, column + 1)) // 1-based indexing
  511|     20|    }
  512|       |
  513|       |    /// Get the presumed location (logical line and file) for a source location
  514|      7|    pub(crate) fn get_presumed_location(&self, loc: SourceLoc) -> Option<(u32, u32, Option<&str>)> {
  515|      7|        let file_info = self.get_file_info(loc.source_id())?;
                          ^6                                             ^1
  516|      6|        let (physical_line, column) = self.get_line_column(loc)?;
                                                                             ^0
  517|       |
  518|      6|        let (logical_line, logical_file) = file_info.line_map.presumed_location(physical_line);
  519|       |
  520|       |        // If no logical file specified, use the physical filename
  521|      6|        let filename = logical_file.or_else(|| file_info.path.to_str());
                                                             ^5             ^5
  522|       |
  523|      6|        Some((logical_line, column, filename))
  524|      7|    }
  525|       |}