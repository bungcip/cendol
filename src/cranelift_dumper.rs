//! Cranelift IR Dumper
//!
//! This module provides functionality to dump Cranelift IR in a human-readable format
//! to the console for debugging and analysis purposes.

use std::fmt::Write;

// Re-export Function type for easier access
use cranelift::codegen::ir::Function;

/// Configuration for Cranelift dump output
#[derive(Debug, Clone)]
pub struct CraneliftDumpConfig {
    pub include_header: bool,
    pub show_analysis: bool,
}

impl Default for CraneliftDumpConfig {
    fn default() -> Self {
        CraneliftDumpConfig {
            include_header: true,
            show_analysis: false,
        }
    }
}

/// Main Cranelift IR dumper that generates human-readable Cranelift output
pub struct CraneliftDumper<'a> {
    config: &'a CraneliftDumpConfig,
}

impl<'a> CraneliftDumper<'a> {
    /// Create a new Cranelift dumper
    pub fn new(config: &'a CraneliftDumpConfig) -> Self {
        Self { config }
    }

    /// Dump a Cranelift function to the console
    pub fn dump_function(&self, func: &Function) -> Result<String, std::fmt::Error> {
        let mut output = String::new();

        // Dump function header
        if self.config.include_header {
            writeln!(output, "; Cranelift IR Function")?;
            writeln!(output, "; Generated by Cendol C11 Compiler")?;
            writeln!(output)?;
        }

        // Use Cranelift's built-in display implementation
        writeln!(output, "{}", func)?;

        Ok(output)
    }

    /// Dump multiple Cranelift functions to the console
    pub fn dump_functions(&self, functions: Vec<(&str, Function)>) -> Result<String, std::fmt::Error> {
        let mut output = String::new();

        // Dump module header
        if self.config.include_header {
            writeln!(output, "; Cranelift IR Module")?;
            writeln!(output, "; Generated by Cendol C11 Compiler")?;
            writeln!(output)?;
        }

        // Dump each function
        for (name, func) in functions {
            writeln!(output, "; Function: {}", name)?;
            writeln!(output, "{}", func)?;
            writeln!(output)?;
        }

        Ok(output)
    }

    /// Dump a complete Cranelift context (including all functions)
    pub fn dump_context(&self, ctx: &cranelift::codegen::Context) -> Result<String, std::fmt::Error> {
        let mut output = String::new();

        // Dump function header
        if self.config.include_header {
            writeln!(output, "; Cranelift IR Context")?;
            writeln!(output, "; Generated by Cendol C11 Compiler")?;
            writeln!(output)?;
        }

        // Use Cranelift's built-in display implementation
        writeln!(output, "{}", &ctx.func)?;

        Ok(output)
    }

    /// Dump Cranelift IR with detailed analysis information
    pub fn dump_function_with_analysis(&self, func: &Function) -> Result<String, std::fmt::Error> {
        let mut output = String::new();

        // Dump the function itself
        self.dump_function(func)?;

        if self.config.show_analysis {
            // Add analysis information if requested
            writeln!(output)?;
            writeln!(output, "; Analysis Information")?;

            // Count basic blocks
            let num_blocks = func.layout.blocks().count();
            writeln!(output, "; Number of basic blocks: {}", num_blocks)?;

            // Count instructions
            let mut num_instructions = 0;
            for block in func.layout.blocks() {
                num_instructions += func.layout.block_insts(block).count();
            }
            writeln!(output, "; Number of instructions: {}", num_instructions)?;

            // List all variables
            let num_vars = func.dfg.num_values();
            writeln!(output, "; Number of variables: {}", num_vars)?;
        }

        Ok(output)
    }
}
