//! MIR (Mid-level Intermediate Representation) Dumper
//!
//! This module provides functionality to dump MIR in a human-readable format
//! following the C11 compiler's specific conventions:
//! - Local variables: %0, %1, %tmp3
//! - Global variables: @g_var
//! - Basic blocks: bb0, bb1
//! - Constants: const 42, const null
//! - Types: i8, i16, i32, i64, u8, u16, u32, u64, f32, f64, ptr<T>

use std::fmt::Write;

use crate::{
    driver::compiler::SemaOutput,
    mir::{
        BinaryOp, CallTarget, ConstValue, ConstValueId, Global, GlobalId, LocalId, MirBlock, MirBlockId, MirFunction,
        MirFunctionId, MirFunctionKind, MirStmt, MirType, Operand, Place, Rvalue, Terminator, TypeId, UnaryOp,
    },
};

/// Configuration for MIR dump output
#[derive(Debug, Clone)]
pub struct MirDumpConfig {
    pub include_header: bool,
}

impl Default for MirDumpConfig {
    fn default() -> Self {
        MirDumpConfig { include_header: true }
    }
}

/// Main MIR dumper that generates human-readable MIR output
pub struct MirDumper<'a> {
    sema_output: &'a SemaOutput,
    config: &'a MirDumpConfig,
}

impl<'a> MirDumper<'a> {
    /// Create a new MIR dumper
    pub fn new(sema_output: &'a SemaOutput, config: &'a MirDumpConfig) -> Self {
        Self { sema_output, config }
    }

    /// Generate the complete MIR dump
    pub fn generate_mir_dump(&self) -> Result<String, std::fmt::Error> {
        let mut output = String::new();

        // Dump module header
        if self.config.include_header {
            writeln!(output, "; MIR Dump for Module {}", self.sema_output.module.id.get())?;
            writeln!(output, "; Generated by Cendol C11 Compiler")?;
            writeln!(output)?;
        }

        // Dump type definitions
        self.dump_types(&mut output)?;
        writeln!(output)?;

        // Dump global variables first
        if !self.sema_output.module.globals.is_empty() {
            for &global_id in &self.sema_output.module.globals {
                if let Some(global) = self.sema_output.globals.get(&global_id) {
                    self.dump_global(&mut output, global)?;
                    writeln!(output)?;
                }
            }
            writeln!(output)?;
        }

        // Dump all functions
        for &func_id in &self.sema_output.module.functions {
            if let Some(func) = self.sema_output.functions.get(&func_id) {
                self.dump_function(&mut output, func)?;
                writeln!(output)?;
            }
        }

        Ok(output)
    }

    /// Dump a single function
    fn dump_function(&self, output: &mut String, func: &MirFunction) -> Result<(), std::fmt::Error> {
        // Function signature
        let return_type = self.type_to_string(func.return_type);
        let fn_keyword = match func.kind {
            MirFunctionKind::Extern => "extern fn",
            MirFunctionKind::Defined => "fn",
        };
        write!(output, "{} {}(", fn_keyword, func.name)?;

        // Dump parameters
        for (i, &param_id) in func.params.iter().enumerate() {
            if i > 0 {
                write!(output, ", ")?;
            }
            if let Some(param) = self.sema_output.locals.get(&param_id) {
                let param_type = self.type_to_string(param.type_id);
                let param_name = param.name.as_ref().map_or("%unnamed".to_string(), |s| s.to_string());
                write!(output, "%{}: {}", param_name, param_type)?;
            } else {
                write!(output, "%param{}: ?", param_id.get())?;
            }
        }

        write!(output, ") -> {}", return_type)?;

        // For extern functions, don't output any body
        if matches!(func.kind, MirFunctionKind::Extern) {
            writeln!(output)?;
            return Ok(());
        }

        writeln!(output)?;

        // Function body
        writeln!(output, "{{")?;

        // Dump locals section
        if func.locals.is_empty() == false {
            writeln!(output, "  locals {{")?;
            for &local_id in &func.locals {
                if let Some(local) = self.sema_output.locals.get(&local_id) {
                    let local_type = self.type_to_string(local.type_id);
                    let local_name = self.local_to_string(local_id);
                    writeln!(output, "    {}: {}", local_name, local_type)?;
                }
            }
            writeln!(output, "  }}")?;
        }

        // Dump basic blocks
        for &block_id in &func.blocks {
            if let Some(block) = self.sema_output.blocks.get(&block_id) {
                self.dump_block(output, block_id, block)?;
            }
        }

        writeln!(output, "}}")?;
        Ok(())
    }

    /// Dump all type definitions
    fn dump_types(&self, output: &mut String) -> Result<(), std::fmt::Error> {
        for (i, mir_type) in self.sema_output.module.types.iter().enumerate() {
            let type_id = TypeId::new((i + 1) as u32).unwrap();
            let type_str = self.type_to_string_with_id(type_id, mir_type);
            writeln!(output, "{}", type_str)?;
        }
        Ok(())
    }

    /// Convert MIR type to string representation with type ID
    fn type_to_string_with_id(&self, type_id: TypeId, mir_type: &MirType) -> String {
        let type_index = self.get_type_index_from_type_id(type_id);
        let type_name = format!("%t{}", type_index);

        match mir_type {
            MirType::Void => format!("type {} = void", type_name),
            MirType::Bool => format!("type {} = bool", type_name),
            MirType::Int { is_signed, width } => {
                let base_type = if *is_signed { "i" } else { "u" };
                format!("type {} = {}{}", type_name, base_type, width)
            }
            MirType::Float { width } => format!("type {} = f{}", type_name, width),
            MirType::Pointer { pointee } => {
                let pointee_index = self.get_type_index_from_type_id(*pointee);
                format!("type {} = ptr<%t{}>", type_name, pointee_index)
            }
            MirType::Array { element, size, .. } => {
                let elem_index = self.get_type_index_from_type_id(*element);
                format!("type {} = [{}]%t{}", type_name, size, elem_index)
            }
            MirType::Function { return_type, params } => {
                let ret_index = self.get_type_index_from_type_id(*return_type);
                let param_types: Vec<String> = params
                    .iter()
                    .map(|&p| {
                        let param_index = self.get_type_index_from_type_id(p);
                        format!("%t{}", param_index)
                    })
                    .collect();
                format!("type {} = fn({}) -> %t{}", type_name, param_types.join(", "), ret_index)
            }
            MirType::Record {
                name, fields, is_union, ..
            } => {
                let field_strs: Vec<String> = fields
                    .iter()
                    .map(|(fname, fid)| {
                        let field_index = self.get_type_index_from_type_id(*fid);
                        format!("{}: %t{}", fname, field_index)
                    })
                    .collect();
                let kind = if *is_union { "union" } else { "struct" };
                format!("type {} = {} {} {{ {} }}", type_name, kind, name, field_strs.join(", "))
            }
            MirType::Enum { name, variants } => {
                let variant_strs: Vec<String> = variants
                    .iter()
                    .map(|(vname, val)| format!("{} = {}", vname, val))
                    .collect();
                format!("type {} = enum {} {{ {} }}", type_name, name, variant_strs.join(", "))
            }
        }
    }

    /// Helper function to get type index from TypeId
    fn get_type_index_from_type_id(&self, type_id: TypeId) -> usize {
        // Find the index of this type in the module.types vector
        for (index, _mir_type) in self.sema_output.module.types.iter().enumerate() {
            // Create a temporary TypeId for comparison
            let temp_type_id = TypeId::new((index + 1) as u32).unwrap();
            if temp_type_id == type_id {
                return index;
            }
        }
        // Fallback: assume sequential mapping
        type_id.get() as usize - 1
    }

    /// Dump a global variable
    fn dump_global(&self, output: &mut String, global: &Global) -> Result<(), std::fmt::Error> {
        let global_type = self.type_to_string(global.type_id);
        write!(output, "global @{}: {}", global.name, global_type)?;

        if let Some(const_id) = global.initial_value {
            // Check if this global represents a string literal
            if let Some(string_repr) = self.try_format_as_string_literal(&global.name.to_string(), const_id) {
                write!(output, " = {}", string_repr)?;
            } else {
                write!(output, " = {}", self.const_to_string(const_id))?;
            }
        }

        Ok(())
    }

    /// Dump a basic block
    fn dump_block(&self, output: &mut String, block_id: MirBlockId, block: &MirBlock) -> Result<(), std::fmt::Error> {
        writeln!(output)?;
        writeln!(output, "  {}:", self.block_to_string(block_id))?;

        // Dump statements in the block
        for &stmt_id in &block.statements {
            if let Some(stmt) = self.sema_output.statements.get(&stmt_id) {
                write!(output, "    ")?;
                self.dump_statement(output, stmt)?;
                writeln!(output)?;
            }
        }

        // Dump terminator (MUST be explicit)
        write!(output, "    ")?;
        self.dump_terminator(output, &block.terminator)?;
        writeln!(output)?;

        Ok(())
    }

    /// Dump a statement
    fn dump_statement(&self, output: &mut String, stmt: &MirStmt) -> Result<(), std::fmt::Error> {
        match stmt {
            MirStmt::Assign(place, rvalue) => {
                write!(output, "{} = ", self.place_to_string(place))?;
                self.dump_rvalue(output, rvalue)?;
            }
            MirStmt::Store(operand, place) => {
                write!(output, "store ")?;
                self.dump_operand(output, operand)?;
                write!(output, ", {}", self.place_to_string(place))?;
            }
            MirStmt::Call(call_target, operands) => {
                write!(output, "call {}(", self.call_target_to_string(call_target))?;
                for (i, operand) in operands.iter().enumerate() {
                    if i > 0 {
                        write!(output, ", ")?;
                    }
                    self.dump_operand(output, operand)?;
                }
                write!(output, ")")?;
            }
            MirStmt::Alloc(place, type_id) => {
                write!(
                    output,
                    "{} = alloc {}",
                    self.place_to_string(place),
                    self.type_to_string(*type_id)
                )?;
            }
            MirStmt::Dealloc(operand) => {
                write!(output, "dealloc ")?;
                self.dump_operand(output, operand)?;
            }
        }
        Ok(())
    }

    /// Dump a terminator
    fn dump_terminator(&self, output: &mut String, terminator: &Terminator) -> Result<(), std::fmt::Error> {
        match terminator {
            Terminator::Goto(block_id) => {
                write!(output, "br {}", self.block_to_string(*block_id))?;
            }
            Terminator::If(cond, then_block, else_block) => {
                write!(
                    output,
                    "cond_br {}, {}, {}",
                    self.operand_to_string(cond),
                    self.block_to_string(*then_block),
                    self.block_to_string(*else_block)
                )?;
            }
            Terminator::Return(operand) => match operand {
                Some(op) => {
                    write!(output, "return ")?;
                    self.dump_operand(output, op)?;
                }
                None => {
                    write!(output, "return")?;
                }
            },
            Terminator::Unreachable => {
                write!(output, "unreachable")?;
            }
        }
        Ok(())
    }

    /// Convert MIR type to string representation
    fn type_to_string(&self, type_id: TypeId) -> String {
        if let Some(mir_type) = self.sema_output.types.get(&type_id) {
            let type_index = self.get_type_index_from_type_id(type_id);

            match mir_type {
                MirType::Void => "void".to_string(),
                MirType::Bool => "bool".to_string(),
                MirType::Int { is_signed, width } => {
                    format!("{}{}", if *is_signed { "i" } else { "u" }, width)
                }
                MirType::Float { width } => format!("f{}", width),
                MirType::Pointer { pointee } => {
                    let pointee_type = self.type_to_string(*pointee);
                    format!("ptr<{}>", pointee_type)
                }
                MirType::Array { element, size, .. } => {
                    let elem_type = self.type_to_string(*element);
                    format!("[{}]{}", size, elem_type)
                }
                MirType::Function { return_type, params } => {
                    let ret_type = self.type_to_string(*return_type);
                    let param_types: Vec<String> = params.iter().map(|&p| self.type_to_string(p)).collect();
                    format!("fn({}) -> {}", param_types.join(", "), ret_type)
                }
                MirType::Record { .. } => {
                    // For aggregate types, use the type ID to keep output concise
                    format!("%t{}", type_index)
                }
                MirType::Enum { name, variants } => {
                    let variant_strs: Vec<String> = variants
                        .iter()
                        .map(|(vname, val)| format!("{} = {}", vname, val))
                        .collect();
                    format!("enum {} {{ {} }}", name, variant_strs.join(", "))
                }
            }
        } else {
            format!("unknown_type_{}", type_id.get())
        }
    }

    /// Convert local ID to string representation
    fn local_to_string(&self, local_id: LocalId) -> String {
        let local = self.sema_output.locals.get(&local_id);
        let name = match local {
            Some(local) => {
                if let Some(name) = &local.name {
                    format!("{}", name)
                } else {
                    format!("{}", local.id.get())
                }
            }
            None => format!("{}", local_id.get()),
        };

        format!("%{}", name)
    }

    /// Convert global ID to string representation
    fn global_to_string(&self, global_id: GlobalId) -> String {
        if let Some(global) = self.sema_output.globals.get(&global_id) {
            format!("@{}", global.name)
        } else {
            format!("@global_{}", global_id.get())
        }
    }

    /// Convert block ID to string representation
    fn block_to_string(&self, block_id: MirBlockId) -> String {
        format!("bb{}", block_id.get())
    }

    /// Convert function ID to string representation
    fn function_to_string(&self, func_id: MirFunctionId) -> String {
        if let Some(func) = self.sema_output.functions.get(&func_id) {
            format!("{}", func.name)
        } else {
            format!("func_{}", func_id.get())
        }
    }

    /// Convert call target to string representation
    fn call_target_to_string(&self, call_target: &CallTarget) -> String {
        match call_target {
            CallTarget::Direct(func_id) => self.function_to_string(*func_id),
            CallTarget::Indirect(operand) => format!("*{}", self.operand_to_string(operand)),
        }
    }

    /// Try to format a constant as a string literal if applicable
    fn try_format_as_string_literal(&self, global_name: &str, const_id: ConstValueId) -> Option<String> {
        // Only format as string if the global name starts with .L.str (our anonymous string literals)
        if !global_name.starts_with(".L.str") {
            return None;
        }

        if let Some(const_value) = self.sema_output.constants.get(&const_id)
            && let ConstValue::ArrayLiteral(elements) = const_value
        {
            // Try to convert the array elements to a string
            let mut chars = Vec::new();
            for &element_id in elements {
                let element = self.sema_output.constants.get(&element_id).unwrap();
                if let ConstValue::Int(byte) = element {
                    if *byte == 0 {
                        // Null terminator - end of string
                        break;
                    } else if *byte >= 32 && *byte <= 126 {
                        // Printable ASCII character
                        chars.push(*byte as u8 as char);
                    } else {
                        // Non-printable character, not a simple string literal
                        return None;
                    }
                } else {
                    // Non-integer element, not a string
                    return None;
                }
            }

            if !chars.is_empty() {
                return Some(format!("const \"{}\"", chars.iter().collect::<String>()));
            }
        }

        None
    }

    /// Convert constant ID to string representation
    fn const_to_string(&self, const_id: ConstValueId) -> String {
        if let Some(const_value) = self.sema_output.constants.get(&const_id) {
            match const_value {
                ConstValue::Int(val) => format!("const {}", val),
                ConstValue::Float(val) => format!("const {}", val),
                ConstValue::Bool(val) => format!("const {}", val),
                ConstValue::Null => "const null".to_string(),
                ConstValue::Zero => "const zero".to_string(),
                ConstValue::StructLiteral(fields) => {
                    // Expand struct literal to show field contents
                    let field_strs: Vec<String> = fields
                        .iter()
                        .map(|(field_idx, field_const_id)| {
                            let field_const_str = self.const_to_string(*field_const_id);
                            format!("{}: {}", field_idx, field_const_str)
                        })
                        .collect();
                    format!("const struct_literal {{ {} }}", field_strs.join(", "))
                }
                ConstValue::ArrayLiteral(elements) => {
                    // Expand array literal to show element contents
                    let element_strs: Vec<String> = elements
                        .iter()
                        .map(|element_const_id| self.const_to_string(*element_const_id))
                        .collect();
                    format!("const array_literal [{}]", element_strs.join(", "))
                }
                ConstValue::GlobalAddress(global_id) => {
                    format!("const {}", self.global_to_string(*global_id))
                }
                &ConstValue::FunctionAddress(func_id) => {
                    format!("const {}", self.function_to_string(func_id))
                }
            }
        } else {
            format!("const unknown_{}", const_id.get())
        }
    }

    /// Convert place to string representation
    fn place_to_string(&self, place: &Place) -> String {
        match place {
            Place::Local(local_id) => self.local_to_string(*local_id),
            Place::Deref(operand) => format!("deref({})", self.operand_to_string(operand)),
            Place::Global(global_id) => self.global_to_string(*global_id),
            Place::StructField(base_place, field_idx) => {
                format!("{}.field_{}", self.place_to_string(base_place), field_idx)
            }
            Place::ArrayIndex(base_place, index) => {
                format!(
                    "{}[{}]",
                    self.place_to_string(base_place),
                    self.operand_to_string(index)
                )
            }
        }
    }

    /// Convert operand to string representation
    fn operand_to_string(&self, operand: &Operand) -> String {
        match operand {
            Operand::Copy(place) => self.place_to_string(place),
            Operand::Constant(const_id) => self.const_to_string(*const_id),
            Operand::AddressOf(place) => {
                format!("addr_of({})", self.place_to_string(place))
            }
            Operand::Cast(type_id, operand) => {
                format!(
                    "cast<{}>({})",
                    self.type_to_string(*type_id),
                    self.operand_to_string(operand)
                )
            }
        }
    }

    /// Dump an operand (for use in statements)
    fn dump_operand(&self, output: &mut String, operand: &Operand) -> Result<(), std::fmt::Error> {
        write!(output, "{}", self.operand_to_string(operand))?;
        Ok(())
    }

    /// Dump an rvalue (for use in assignments)
    fn dump_rvalue(&self, output: &mut String, rvalue: &Rvalue) -> Result<(), std::fmt::Error> {
        match rvalue {
            Rvalue::Use(operand) => {
                self.dump_operand(output, operand)?;
            }
            Rvalue::BinaryOp(op, left, right) => {
                write!(
                    output,
                    "{} {} {}",
                    self.operand_to_string(left),
                    self.binary_op_to_string(op),
                    self.operand_to_string(right)
                )?;
            }
            Rvalue::UnaryOp(op, operand) => {
                write!(
                    output,
                    "{} {}",
                    self.unary_op_to_string(op),
                    self.operand_to_string(operand)
                )?;
            }
            Rvalue::Cast(type_id, operand) => {
                write!(
                    output,
                    "cast<{}>({})",
                    self.type_to_string(*type_id),
                    self.operand_to_string(operand)
                )?;
            }
            Rvalue::PtrAdd(base, offset) => {
                write!(
                    output,
                    "ptradd({}, {})",
                    self.operand_to_string(base),
                    self.operand_to_string(offset)
                )?;
            }
            Rvalue::StructLiteral(_fields) => {
                write!(output, "struct_literal")?;
            }
            Rvalue::ArrayLiteral(_elements) => {
                write!(output, "array_literal")?;
            }
            Rvalue::Load(operand) => {
                write!(output, "load {}", self.operand_to_string(operand))?;
            }
            Rvalue::Call(call_target, operands) => {
                write!(output, "call {}(", self.call_target_to_string(call_target))?;
                for (i, operand) in operands.iter().enumerate() {
                    if i > 0 {
                        write!(output, ", ")?;
                    }
                    self.dump_operand(output, operand)?;
                }
                write!(output, ")")?;
            }
        }
        Ok(())
    }

    /// Convert binary operation to string representation
    fn binary_op_to_string(&self, op: &BinaryOp) -> String {
        match op {
            BinaryOp::Add => "+".to_string(),
            BinaryOp::Sub => "-".to_string(),
            BinaryOp::Mul => "*".to_string(),
            BinaryOp::Div => "/".to_string(),
            BinaryOp::Mod => "%".to_string(),
            BinaryOp::BitAnd => "&".to_string(),
            BinaryOp::BitOr => "|".to_string(),
            BinaryOp::BitXor => "^".to_string(),
            BinaryOp::LShift => "<<".to_string(),
            BinaryOp::RShift => ">>".to_string(),
            BinaryOp::Equal => "==".to_string(),
            BinaryOp::NotEqual => "!=".to_string(),
            BinaryOp::Less => "<".to_string(),
            BinaryOp::LessEqual => "<=".to_string(),
            BinaryOp::Greater => ">".to_string(),
            BinaryOp::GreaterEqual => ">=".to_string(),
            BinaryOp::LogicAnd => "&&".to_string(),
            BinaryOp::LogicOr => "||".to_string(),
            BinaryOp::Comma => ",".to_string(),
        }
    }

    /// Convert unary operation to string representation
    fn unary_op_to_string(&self, op: &UnaryOp) -> String {
        match op {
            UnaryOp::Neg => "-".to_string(),
            UnaryOp::Not => "!".to_string(),
            UnaryOp::AddrOf => "&".to_string(),
            UnaryOp::Deref => "*".to_string(),
        }
    }
}
