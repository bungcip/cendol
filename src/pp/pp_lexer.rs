use crate::source_manager::{SourceId, SourceLoc};
use symbol_table::GlobalSymbol as Symbol;

// Packed token flags for preprocessor tokens
bitflags::bitflags! {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
    pub struct PPTokenFlags: u8 {
        const LEADING_SPACE = 1 << 0;  // Token has leading whitespace
        const STARTS_PP_LINE = 1 << 1; // Token starts a preprocessing line
        const NEEDS_CLEANUP = 1 << 2;  // Token needs cleanup after expansion
        const MACRO_EXPANDED = 1 << 3; // Token was generated by macro expansion
    }
}

/// Token kinds for preprocessor tokens
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PPTokenKind {
    // Punctuation and operators
    Plus,
    Minus,
    Star,
    Slash,
    Percent, // + - * / %
    And,
    Or,
    Xor,
    Not,
    Tilde, // & | ^ ! ~
    Less,
    Greater,
    LessEqual,
    GreaterEqual,
    Equal,
    NotEqual, // < > <= >= == !=
    LeftShift,
    RightShift, // << >>
    Assign,
    PlusAssign,
    MinusAssign, // = += -=
    StarAssign,
    DivAssign,
    ModAssign, // *= /= %=
    AndAssign,
    OrAssign,
    XorAssign, // &= |= ^=
    LeftShiftAssign,
    RightShiftAssign, // <<= >>=
    Increment,
    Decrement, // ++ --
    Arrow,
    Dot, // -> .
    Question,
    Colon, // ? :
    Comma,
    Semicolon, // , ;
    LeftParen,
    RightParen, // ( )
    LeftBracket,
    RightBracket, // [ ]
    LeftBrace,
    RightBrace, // { }
    Ellipsis,   // ...
    LogicAnd,
    LogicOr, // && ||
    Hash,
    HashHash, // # ##
    // Literals and identifiers
    Identifier(Symbol),      // Interned identifier
    StringLiteral(Symbol),   // Interned string literal
    CharLiteral(u8, Symbol), // byte char value and raw text
    Number(Symbol),          // Raw numeric literal text for parser
    // Special
    Eof,
    Unknown,
}

/// Token structure for preprocessor tokens
#[derive(Clone, Copy, Debug)]
pub struct PPToken {
    pub kind: PPTokenKind,
    pub flags: PPTokenFlags,
    pub location: SourceLoc, // Contains file ID and byte offset
    pub length: u16,         // Maximum token length (64KB should be sufficient for any token)
}

impl PPToken {
    /// Create a PPToken with full control over all fields
    pub fn new(kind: PPTokenKind, flags: PPTokenFlags, location: SourceLoc, length: u16) -> Self {
        PPToken {
            kind,
            flags,
            location,
            length,
        }
    }

    /// Create a simple PPToken with empty flags and length 1 (most common case)
    pub fn simple(kind: PPTokenKind, location: SourceLoc) -> Self {
        PPToken::new(kind, PPTokenFlags::empty(), location, 1)
    }

    /// Create a PPToken with text-based length
    pub fn text(kind: PPTokenKind, flags: PPTokenFlags, location: SourceLoc, text: &str) -> Self {
        PPToken::new(kind, flags, location, text.len() as u16)
    }

    /// Create a PPToken with custom flags and length 1
    pub fn with_flags(kind: PPTokenKind, flags: PPTokenFlags, location: SourceLoc) -> Self {
        PPToken::new(kind, flags, location, 1)
    }

    /// Get the source range (file_id, start_offset, end_offset) for this token
    pub fn source_range(&self) -> (crate::source_manager::SourceId, u32, u32) {
        let start = self.location.offset();
        let end = start + self.length as u32;
        (self.location.source_id(), start, end)
    }

    /// Get the raw byte slice from the source buffer for this token
    pub fn get_raw_slice<'a>(&self, buffer: &'a [u8]) -> &'a [u8] {
        let start = self.location.offset() as usize;
        let end = start + self.length as usize;
        &buffer[start..end]
    }

    /// Get the text representation of the token
    pub fn get_text(&self) -> String {
        match &self.kind {
            PPTokenKind::Identifier(sym) => sym.as_str().to_string(),
            PPTokenKind::Number(sym) => sym.as_str().to_string(),
            PPTokenKind::StringLiteral(sym) => sym.as_str().to_string(),
            PPTokenKind::CharLiteral(_, sym) => sym.as_str().to_string(),
            PPTokenKind::LeftParen => "(".to_string(),
            PPTokenKind::RightParen => ")".to_string(),
            PPTokenKind::LeftBracket => "[".to_string(),
            PPTokenKind::RightBracket => "]".to_string(),
            PPTokenKind::LeftBrace => "{".to_string(),
            PPTokenKind::RightBrace => "}".to_string(),
            PPTokenKind::Plus => "+".to_string(),
            PPTokenKind::Minus => "-".to_string(),
            PPTokenKind::Star => "*".to_string(),
            PPTokenKind::Slash => "/".to_string(),
            PPTokenKind::Percent => "%".to_string(),
            PPTokenKind::And => "&".to_string(),
            PPTokenKind::Or => "|".to_string(),
            PPTokenKind::Xor => "^".to_string(),
            PPTokenKind::Not => "!".to_string(),
            PPTokenKind::Tilde => "~".to_string(),
            PPTokenKind::Less => "<".to_string(),
            PPTokenKind::Greater => ">".to_string(),
            PPTokenKind::LessEqual => "<=".to_string(),
            PPTokenKind::GreaterEqual => ">=".to_string(),
            PPTokenKind::Equal => "==".to_string(),
            PPTokenKind::NotEqual => "!=".to_string(),
            PPTokenKind::LeftShift => "<<".to_string(),
            PPTokenKind::RightShift => ">>".to_string(),
            PPTokenKind::Assign => "=".to_string(),
            PPTokenKind::PlusAssign => "+=".to_string(),
            PPTokenKind::MinusAssign => "-=".to_string(),
            PPTokenKind::StarAssign => "*=".to_string(),
            PPTokenKind::DivAssign => "/=".to_string(),
            PPTokenKind::ModAssign => "%=".to_string(),
            PPTokenKind::AndAssign => "&=".to_string(),
            PPTokenKind::OrAssign => "|=".to_string(),
            PPTokenKind::XorAssign => "^=".to_string(),
            PPTokenKind::LeftShiftAssign => "<<=".to_string(),
            PPTokenKind::RightShiftAssign => ">>=".to_string(),
            PPTokenKind::Increment => "++".to_string(),
            PPTokenKind::Decrement => "--".to_string(),
            PPTokenKind::Arrow => "->".to_string(),
            PPTokenKind::Dot => ".".to_string(),
            PPTokenKind::Question => "?".to_string(),
            PPTokenKind::Colon => ":".to_string(),
            PPTokenKind::Comma => ",".to_string(),
            PPTokenKind::Semicolon => ";".to_string(),
            PPTokenKind::Ellipsis => "...".to_string(),
            PPTokenKind::LogicAnd => "&&".to_string(),
            PPTokenKind::LogicOr => "||".to_string(),
            PPTokenKind::Hash => "#".to_string(),
            PPTokenKind::HashHash => "##".to_string(),
            PPTokenKind::Eof => "".to_string(),
            PPTokenKind::Unknown => "?".to_string(),
        }
    }
}

/// Manages lexing from different source buffers
pub struct PPLexer {
    pub source_id: SourceId,
    buffer: Vec<u8>,
    pub position: u32, // its okay to use u32 here since source files are limited to 4 MB
    line_starts: Vec<u32>,
    put_back_token: Option<PPToken>,
    pub line_offset: u32,
    pub filename_override: Option<String>,
    pub in_directive: bool,  // Whether we are lexing a directive name
    pub in_expression: bool, // Whether we are lexing a preprocessor expression
}

impl PPLexer {
    pub fn new(source_id: SourceId, buffer: Vec<u8>) -> Self {
        let line_starts = vec![0]; // First line starts at offset 0

        PPLexer {
            source_id,
            buffer,
            position: 0,
            line_starts,
            put_back_token: None,
            line_offset: 0,
            filename_override: None,
            in_directive: false,
            in_expression: false,
        }
    }

    /// Get the next character, handling line splicing transparently
    /// Line splicing: backslash followed by newline removes both characters
    pub fn next_char(&mut self) -> Option<u8> {
        if self.position as usize >= self.buffer.len() {
            return None;
        }

        let mut result = self.buffer[self.position as usize];
        self.position += 1;

        // Handle line splicing: backslash followed by newline or carriage return
        if result == b'\\' && (self.position as usize) < self.buffer.len() {
            let next = self.buffer[self.position as usize];
            if next == b'\n' || next == b'\r' {
                self.position += 1;
                if next == b'\r'
                    && (self.position as usize) < self.buffer.len()
                    && self.buffer[self.position as usize] == b'\n'
                {
                    self.position += 1;
                }
                // Update line starts - remove the newline from line tracking
                if self.line_starts.len() > 1 {
                    self.line_starts.pop();
                }
                // Get the character after the line ending for splicing
                if (self.position as usize) < self.buffer.len() {
                    result = self.buffer[self.position as usize];
                    self.position += 1;
                } else {
                    return None;
                }
            }
        }

        // Update line starts for regular newlines
        if result == b'\n' {
            self.line_starts.push(self.position);
        }

        Some(result)
    }

    /// Peek at the next character without consuming it, handling line splicing
    pub fn peek_char(&mut self) -> Option<u8> {
        let saved_position = self.position;
        let saved_line_starts = self.line_starts.clone();

        let result = self.next_char();

        // Restore state
        self.position = saved_position;
        self.line_starts = saved_line_starts;

        result
    }

    pub fn next_token(&mut self) -> Option<PPToken> {
        if let Some(token) = self.put_back_token.take() {
            return Some(token);
        }

        let saved_position = self.position;
        self.skip_whitespace_and_comments();
        let had_leading_space = self.position > saved_position;

        if self.position as usize >= self.buffer.len() {
            return None;
        }

        let flags = if had_leading_space {
            PPTokenFlags::LEADING_SPACE
        } else {
            PPTokenFlags::empty()
        };

        let start_pos = self.position;
        let ch = self.next_char().unwrap_or(b' ');

        match ch {
            b'a'..=b'z' | b'A'..=b'Z' | b'_' => {
                if ch == b'L' || ch == b'u' || ch == b'U' {
                    let next_ch = self.peek_char();
                    if next_ch == Some(b'"') {
                        Some(self.lex_string_literal(start_pos, ch, flags))
                    } else if next_ch == Some(b'\'') {
                        Some(self.lex_char_literal(start_pos, ch, flags))
                    } else {
                        Some(self.lex_identifier(start_pos, ch, flags))
                    }
                } else {
                    Some(self.lex_identifier(start_pos, ch, flags))
                }
            }
            b'0'..=b'9' => Some(self.lex_number(start_pos, ch, flags)),
            b'"' => Some(self.lex_string_literal(start_pos, ch, flags)),
            b'\'' => Some(self.lex_char_literal(start_pos, ch, flags)),
            b'#' => {
                let mut token_flags = flags;
                token_flags |= PPTokenFlags::STARTS_PP_LINE;
                let next_ch = self.peek_char();
                if next_ch == Some(b'#') {
                    self.next_char(); // consume the second #
                    Some(PPToken::new(
                        PPTokenKind::HashHash,
                        flags, // HashHash does not start a PP line
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::with_flags(
                        PPTokenKind::Hash,
                        token_flags,
                        SourceLoc::new(self.source_id, start_pos),
                    ))
                }
            }
            b'+' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'+') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::Increment,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::PlusAssign,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Plus,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'-' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'-') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::Decrement,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::MinusAssign,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else if next_ch == Some(b'>') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::Arrow,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Minus,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'*' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::StarAssign,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Star,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'/' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::DivAssign,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Slash,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'%' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::ModAssign,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Percent,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'=' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::Equal,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Assign,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'!' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::NotEqual,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Not,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'<' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'<') {
                    self.next_char();
                    let next_next_ch = self.peek_char();
                    if next_next_ch == Some(b'=') {
                        self.next_char();
                        Some(PPToken::new(
                            PPTokenKind::LeftShiftAssign,
                            flags,
                            SourceLoc::new(self.source_id, start_pos),
                            3,
                        ))
                    } else {
                        Some(PPToken::new(
                            PPTokenKind::LeftShift,
                            flags,
                            SourceLoc::new(self.source_id, start_pos),
                            2,
                        ))
                    }
                } else if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::LessEqual,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Less,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'>' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'>') {
                    self.next_char();
                    let next_next_ch = self.peek_char();
                    if next_next_ch == Some(b'=') {
                        self.next_char();
                        Some(PPToken::new(
                            PPTokenKind::RightShiftAssign,
                            flags,
                            SourceLoc::new(self.source_id, start_pos),
                            3,
                        ))
                    } else {
                        Some(PPToken::new(
                            PPTokenKind::RightShift,
                            flags,
                            SourceLoc::new(self.source_id, start_pos),
                            2,
                        ))
                    }
                } else if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::GreaterEqual,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Greater,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'&' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'&') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::LogicAnd,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::AndAssign,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::And,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'|' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'|') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::LogicOr,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::OrAssign,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Or,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'^' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                if next_ch == Some(b'=') {
                    self.next_char();
                    Some(PPToken::new(
                        PPTokenKind::XorAssign,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        2,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Xor,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'~' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::Tilde,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b'.' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                let next_ch = self.peek_char();
                let next_next_ch = self.peek_char();
                if next_ch == Some(b'.') && next_next_ch == Some(b'.') {
                    self.next_char(); // consume first '.'
                    self.next_char(); // consume second '.'
                    Some(PPToken::new(
                        PPTokenKind::Ellipsis,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        3,
                    ))
                } else {
                    Some(PPToken::new(
                        PPTokenKind::Dot,
                        flags,
                        SourceLoc::new(self.source_id, start_pos),
                        1,
                    ))
                }
            }
            b'?' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::Question,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b':' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::Colon,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b',' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::Comma,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b';' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::Semicolon,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b'(' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::LeftParen,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b')' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::RightParen,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b'[' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::LeftBracket,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b']' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::RightBracket,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b'{' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::LeftBrace,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            b'}' => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::RightBrace,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
            _ => {
                let flags = if had_leading_space {
                    PPTokenFlags::LEADING_SPACE
                } else {
                    PPTokenFlags::empty()
                };
                Some(PPToken::new(
                    PPTokenKind::Unknown,
                    flags,
                    SourceLoc::new(self.source_id, start_pos),
                    1,
                ))
            }
        }
    }

    fn skip_whitespace_and_comments(&mut self) {
        loop {
            // Skip whitespace, handling line splicing
            while let Some(ch) = self.peek_char() {
                if ch.is_ascii_whitespace() {
                    self.next_char();
                } else {
                    break;
                }
            }

            if self.position as usize >= self.buffer.len() {
                break;
            }

            // Check for comments by temporarily consuming
            let saved_position = self.position;
            let saved_line_starts = self.line_starts.clone();

            let ch1 = self.next_char();
            let ch2 = self.next_char();

            if ch1 == Some(b'/') && ch2 == Some(b'/') {
                // Line comment, skip to end of line
                while let Some(ch) = self.next_char() {
                    if ch == b'\n' {
                        break;
                    }
                }
                // Continue loop
            } else if ch1 == Some(b'/') && ch2 == Some(b'*') {
                // Block comment, skip to */
                while let Some(ch) = self.next_char() {
                    if ch == b'*' && self.peek_char() == Some(b'/') {
                        self.next_char(); // consume '/'
                        break;
                    }
                }
                // Continue loop
            } else {
                // Not a comment, restore position
                self.position = saved_position;
                self.line_starts = saved_line_starts;
                break;
            }
        }
    }

    fn lex_identifier(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
        // Use next_char() for consistency with line splicing
        let mut chars = vec![first_ch];
        while let Some(ch) = self.peek_char() {
            if ch.is_ascii_alphanumeric() || ch == b'_' {
                chars.push(self.next_char().unwrap());
            } else {
                break;
            }
        }

        let text = String::from_utf8(chars).unwrap();

        let symbol = Symbol::new(&text);
        let kind = PPTokenKind::Identifier(symbol);

        PPToken::text(
            kind,
            flags,
            SourceLoc::new(self.source_id, start_pos),
            &text,
        )
    }

    fn lex_number(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
        // Use next_char() for consistency with line splicing
        let mut chars = vec![first_ch];
        let mut seen_e = false;
        while let Some(ch) = self.peek_char() {
            if ch.is_ascii_digit() || ch == b'.' || ch.is_ascii_alphabetic() || ch == b'_' {
                chars.push(self.next_char().unwrap());
                if ch == b'e' || ch == b'E' {
                    seen_e = true;
                }
            } else if (ch == b'+' || ch == b'-') && seen_e {
                // Allow + or - after e/E for scientific notation
                chars.push(self.next_char().unwrap());
                seen_e = false; // Reset so we don't allow multiple +/- after e
            } else {
                break;
            }
        }

        let text = String::from_utf8(chars).unwrap();
        let symbol = Symbol::new(&text);

        PPToken::text(
            PPTokenKind::Number(symbol),
            flags,
            SourceLoc::new(self.source_id, start_pos),
            &text,
        )
    }

    fn lex_string_literal(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
        let has_prefix = first_ch == b'L' || first_ch == b'u' || first_ch == b'U';
        let mut chars = vec![first_ch];

        if has_prefix {
            // consume the "
            let quote = self.next_char().unwrap();
            chars.push(quote);
        }

        while let Some(ch) = self.next_char() {
            chars.push(ch);
            if ch == b'"' {
                break; // End of string literal
            } else if ch == b'\\' {
                // Handle escape sequences, including line splicing
                if let Some(next_ch) = self.next_char() {
                    chars.push(next_ch);
                    if next_ch == b'\n' {
                        // This is line splicing within a string - the newline is consumed as part of the escape
                        continue;
                    }
                }
            }
        }

        let text = String::from_utf8(chars).unwrap();
        let symbol = Symbol::new(&text);

        PPToken::text(
            PPTokenKind::StringLiteral(symbol),
            flags,
            SourceLoc::new(self.source_id, start_pos),
            &text,
        )
    }

    fn lex_char_literal(&mut self, start_pos: u32, first_ch: u8, flags: PPTokenFlags) -> PPToken {
        let has_prefix = first_ch == b'L' || first_ch == b'u' || first_ch == b'U';
        let mut chars = vec![first_ch];

        if has_prefix {
            // consume the '
            let quote = self.next_char().unwrap();
            chars.push(quote);
        }

        // now collect until closing '
        while let Some(ch) = self.next_char() {
            chars.push(ch);
            if ch == b'\'' {
                break; // End of char literal
            } else if ch == b'\\' {
                // Handle escape sequences
                if let Some(escaped) = self.next_char() {
                    chars.push(escaped);
                }
            }
        }

        // Parse character literal content
        let quote_start = if has_prefix { 1 } else { 0 };
        let content_start = quote_start + 1;
        let content_len = chars.len() - content_start - 1; // exclude closing '

        let codepoint = if content_len == 1 {
            chars[content_start]
        } else if content_len == 2 && chars[content_start] == b'\\' {
            // Handle escape sequences
            match chars[content_start + 1] {
                b'0' => 0,                     // null
                b'n' => 10,                    // newline
                b't' => 9,                     // tab
                b'r' => 13,                    // carriage return
                b'\\' => 92,                   // backslash
                b'\'' => 39,                   // single quote
                b'"' => 34,                    // double quote
                _ => chars[content_start + 1], // fallback to the escaped char
            }
        } else {
            0 // placeholder for complex cases (multibyte chars, etc.)
        };

        let text = String::from_utf8(chars).unwrap();
        let symbol = Symbol::new(&text);

        PPToken::new(
            PPTokenKind::CharLiteral(codepoint, symbol),
            flags,
            SourceLoc::new(self.source_id, start_pos),
            text.len() as u16,
        )
    }

    pub fn put_back(&mut self, token: PPToken) {
        self.put_back_token = Some(token);
    }

    pub fn get_line(&self, offset: u32) -> u32 {
        self.line_starts.partition_point(|&x| x <= offset) as u32 + self.line_offset
    }

    pub fn get_current_line(&self) -> u32 {
        self.line_starts.len() as u32 + self.line_offset
    }

    pub fn get_line_starts(&self) -> &Vec<u32> {
        &self.line_starts
    }
}
