use convert_case::{self, Case, Casing};
// use itertools::{self, };
use std::{env, fs, io::Write, path::PathBuf};

fn main() {
    let manifest_dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .ancestors()
        .nth(2)
        .expect("failed to locate project root")
        .to_path_buf();

    let builtins_path = manifest_dir.join("tools/generate_types/builtins.txt");
    let output_path = manifest_dir.join("src/generated_types.rs");

    println!("ðŸ“˜ Reading builtins from: {}", builtins_path.display());

    let content = fs::read_to_string(&builtins_path)
        .unwrap_or_else(|e| panic!("failed to read builtins.txt: {}", e));

    let mut lines = Vec::new();
    for line in content.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() || trimmed.starts_with("//") {
            continue;
        }

        let parts: Vec<&str> = trimmed.split("=>").collect();

        let name = parts[0].trim();
        let flags: Vec<String> = parts[1]
            .split('|')
            .map(str::trim)
            .map(str::to_string)
            .collect();

        lines.push((name, flags));
    }

    let mut output = String::new();
    output.push_str("// Auto-generated by tools/generate_types\n");
    output.push_str("// DO NOT EDIT MANUALLY\n\n");
    // output.push_str("use crate::types::TypeId;\n\n");

    generate_constant(&mut output, &lines);
    generate_builtins(&mut output, &lines);

    fs::create_dir_all(output_path.parent().unwrap()).unwrap();
    let mut file = fs::File::create(&output_path).unwrap();
    file.write_all(output.as_bytes()).unwrap();

    println!("âœ… Generated {}", output_path.display());
}

fn generate_constant(output: &mut String, lines: &Vec<(&str, Vec<String>)>) {
    output.push_str("impl TypeId {\n");

    for (i, (name, flags)) in lines.iter().enumerate() {
        let upper = name.to_ascii_uppercase();
        let flags: Vec<String> = flags.iter().map(|x| format!("TypeId::{x}")).collect();
        let flags = flags.join("|");

        output.push_str(&format!(
            "    pub const {upper}: TypeId = TypeId::from_parts({i}, {flags});\n",
        ));
    }

    // Generate pointer versions
    let mut next_index = lines.len();
    for (name, flags) in lines {
        let upper = name.to_ascii_uppercase();
        let flags: Vec<String> = flags.iter().map(|x| format!("TypeId::{x}")).collect();
        let flags = flags.join("|");
        output.push_str(&format!(
            "    pub const {upper}_PTR: TypeId = TypeId::from_parts({next_index}, {flags} | TypeId::FLAG_POINTER);\n",
        ));
        next_index += 1;
    }
    output.push_str("\n");
    output.push_str("}\n\n");
}

fn generate_builtins(output: &mut String, lines: &Vec<(&str, Vec<String>)>) {
    output.push_str("impl TypeTable {\n");

    // generate `new_with_builtins`
    output.push_str("    pub fn new_with_builtins() -> Self {\n");

    output.push_str("        let mut table = TypeTable {\n");
    output.push_str("            types: Vec::new(),\n");
    output.push_str("            map: HashMap::new(),\n");
    output.push_str("        };\n\n");


    output.push_str("        let push = |kind: TypeKind, tbl: &mut TypeTable| {\n");
    output.push_str("            let idx = tbl.types.len() as u16;\n");
    output.push_str("            tbl.map.insert(kind.clone(), idx);\n");
    output.push_str("            tbl.types.push(kind);\n");
    output.push_str("        };\n");

    // basic
    for (i, (name, flags)) in lines.iter().enumerate() {
        let title = name.to_case(Case::Title);
        let flags: Vec<String> = flags.iter().map(|x| format!("TypeId::{x}")).collect();
        // let flags = flags.join("|");
        output.push_str(&format!(
            "        push(TypeKind::{title}, &mut table); // {i}\n"
        ));
    }
    output.push_str("\n");

    // pointer
    let mut next_index = lines.len();
    for (i, (name, flags)) in lines.iter().enumerate() {
        let lower = name.to_case(Case::Lower);
        let flags: Vec<String> = flags.iter().map(|x| format!("TypeId::{x}")).collect();
        let flags = flags.join("|");
        output.push_str(&format!(
            "        let {lower}_id = TypeId::from_parts({i}, {flags});\n"
        ));
        output.push_str(&format!(
            "        push(TypeKind::Pointer({lower}_id), &mut table); // {next_index}\n"
        ));
        next_index += 1;
    }

    output.push_str("        table\n");
    output.push_str("    }\n");
    output.push_str("}\n");
}
